<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CUDA编程中的错误处理</title>
    <url>/2017/03/29/cuda-error-handle/</url>
    <content><![CDATA[<p>CUDA程序往往很难高度，特别是核函数出错时，甚至有些情况下核函数中内容访问错误时，运行程序之后系统返回的报错信息是<code>free() error</code>之类的错误，会严重误导错误查找过程。所以编写CUDA程序一定记得进行错误错误处理，多写几行代码，有可能省出很多的时间。假如自己的CUDA程序出现了各种奇葩、难以理解的错误，可以考虑加上错误处理，也许就柳岸花明了。<br>在<a href="http://notes.maxwi.com/2015/06/11/CUDA-study-notes/">CUDA学习笔记</a>最后的总结中刻意提到编写CUDA程序一定要做错误处理，但其中一直未提及如何进行错误处理，这里给补上。</p>
<span id="more"></span>

<p>CUDA编程中的错误处理实际上非常简单，错误处理相关的函数一共也只有4个：</p>
<ul>
<li><code>__host__ __device__ const char* cudaGetErrorName( cudaError_t error )</code> 接受一个错误码，返回错误名称</li>
<li><code>__host__ __device__ const char* cudaGetErrorString( cudaError_t error )</code> 接受一个错误码，返回错误描述</li>
<li><code>__host__ __device__ cudaError_t cudaGetLastError( void )</code> 返回上一次CUDA runtime调用时的错误码，并将CUDA错误码置为<code>cudaSuccess</code></li>
<li><code>__host__ __device__ cudaError_t cudaPeekAtLastError( void )</code> 与上面功能一样，但不会重置CUDA的错误信息<br>当核函数被调用或者CUDA API被调用时，通常都会返回一个错误码，如果返回的错误码为0，则表示该调用没有出错，即<code>cudaSuccess</code>（即错误名称），CUDA的错误码一共有82个（截止到2017.3.29），所有的错误码信息可以在这里查看<a href="http://docs.nvidia.com/cuda/cuda-runtime-api/group__CUDART__TYPES.html#group__CUDART__TYPES_1g3f51e3575c2178246db0a94a430e0038">cudaError</a>，其实就是个enum类型的数据。</li>
</ul>
<p>根据官方提代的4个错误处理函数，明显可以看出对于<code>cudaMemcpy</code>这类API调用函数，可以直接传递给<code>cudaGetErrorString</code>来进行错误检查，而核函数调用之后必然会更新CUDA Runtime的错误值，那么就可以在核函数调用之后调用<code>cudaGetLastError()</code>来进行核函数调用的错误检查。由于CPU与GPU程序时异步执行，所以为了避免获取到的核函数调用错误信息有误，应该在调用<code>cudaGetLastError()</code>这类函数之前使用<code>cudaDeviceSynchronize()</code>对CPU进行阻塞，以同步GPU与CPU的线程，保证核函数已经调用完成。<br>为了便于错误处理，通常会将错误处理写成函数，或者进行宏定义，不然每次获取到错误码之后，都还要去调用<code>cudaGetErrorString</code>来查看错误描述。<br>下面是我常用的一个错误处理宏定义，兼容C与C++，可以参考：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//API调用错误处理，可以接受CUDA的API函数调用作为参数</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CHECK_ERROR(<span class="keyword">error</span>) checkCudaError(<span class="keyword">error</span>, __FILE__, __LINE__)</span></span><br><span class="line"><span class="comment">//检查CUDA Runtime状态码，可以接受一个指定的提示信息</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CHECK_STATE(msg) checkCudaState(msg, __FILE__, __LINE__)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">checkCudaError</span><span class="params">(cudaError_t error, <span class="type">const</span> <span class="type">char</span> *file, <span class="type">const</span> <span class="type">int</span> line)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (error != cudaSuccess) &#123;</span><br><span class="line">      std::cerr &lt;&lt; <span class="string">&quot;CUDA CALL FAILED:&quot;</span> &lt;&lt; file &lt;&lt; <span class="string">&quot;( &quot;</span> &lt;&lt; line &lt;&lt; <span class="string">&quot;)- &quot;</span> &lt;&lt; <span class="built_in">cudaGetErrorString</span>(error) &lt;&lt; std::endl;</span><br><span class="line">      <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">checkCudaState</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *msg, <span class="type">const</span> <span class="type">char</span> *file, <span class="type">const</span> <span class="type">int</span> line)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   cudaError_t error = <span class="built_in">cudaGetLastError</span>();</span><br><span class="line">   <span class="keyword">if</span> (error != cudaSuccess) &#123;</span><br><span class="line">      std::cerr &lt;&lt; <span class="string">&quot;---&quot;</span> &lt;&lt; msg &lt;&lt; <span class="string">&quot; Error---&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">      std::cerr &lt;&lt; file &lt;&lt; <span class="string">&quot;( &quot;</span> &lt;&lt; line &lt;&lt; <span class="string">&quot;)- &quot;</span> &lt;&lt; <span class="built_in">cudaGetErrorString</span>(error) &lt;&lt; std::endl;</span><br><span class="line">      <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用举例，下面是从以前一个项目代码中抽出来的代码片断：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//统计用于GPU计算的时间</span><br><span class="line">cudaEvent_t start, stop;</span><br><span class="line">CHECK_ERROR(cudaEventCreate(&amp;start));</span><br><span class="line">CHECK_ERROR(cudaEventCreate(&amp;stop));</span><br><span class="line">CHECK_ERROR(cudaEventRecord(start, 0));</span><br><span class="line">CHECK_ERROR(cudaEventSynchronize(start));</span><br><span class="line"></span><br><span class="line">CHECK_ERROR(cudaMemcpy(dev_grid_in, grid_in, SIZE * sizeof(double), cudaMemcpyHostToDevice));</span><br><span class="line">CHECK_ERROR(cudaMemcpy(dev_grid_out, grid_out, SIZE * sizeof(double), cudaMemcpyHostToDevice));</span><br><span class="line"></span><br><span class="line">for (int i=0; i&lt;times; ++i) &#123;</span><br><span class="line">   kernel&lt;&lt;&lt;grids, blocks&gt;&gt;&gt;(dev_grid_in, dev_grid_out);</span><br><span class="line">   std::swap(dev_grid_in, dev_grid_out);</span><br><span class="line">&#125;</span><br><span class="line">cudaDeviceSynchronize();</span><br><span class="line"></span><br><span class="line">CHECK_STATE(&quot;kernel call&quot;);</span><br><span class="line"></span><br><span class="line">CHECK_ERROR(cudaMemcpy(grid_in, dev_grid_in, SIZE * sizeof(double), cudaMemcpyDeviceToHost));</span><br><span class="line"></span><br><span class="line">//计算统计的时间</span><br><span class="line">CHECK_ERROR(cudaEventRecord(stop, 0));</span><br><span class="line">CHECK_ERROR(cudaEventSynchronize(stop));</span><br><span class="line">float elapsedTime;</span><br><span class="line">CHECK_ERROR(cudaEventElapsedTime(&amp;elapsedTime, start, stop));</span><br></pre></td></tr></table></figure>
<p>上述代码片断的完整代码链接在<a href="https://github.com/blueyi/stencil_computation_sample/blob/master/7_point_stencil_jacobi3d_Optimize.cu">https://github.com/blueyi/stencil_computation_sample/blob/master/7_point_stencil_jacobi3d_Optimize.cu</a></p>
<p>参考：<br>1.<a href="http://docs.nvidia.com/cuda/cuda-runtime-api/group__CUDART__ERROR.html#group__CUDART__ERROR">http://docs.nvidia.com/cuda/cuda-runtime-api/group__CUDART__ERROR.html#group__CUDART__ERROR</a><br>2.<a href="https://devblogs.nvidia.com/parallelforall/how-query-device-properties-and-handle-errors-cuda-cc/">How to Query Device Properties and Handle Errors in CUDA C/C++</a><br>3.<a href="https://codeyarns.com/2011/03/02/how-to-do-error-checking-in-cuda/">How to do error checking in CUDA</a></p>
]]></content>
      <categories>
        <category>CUDA</category>
      </categories>
      <tags>
        <tag>CUDA</tag>
        <tag>Top</tag>
      </tags>
  </entry>
  <entry>
    <title>CUDA学习笔记</title>
    <url>/2015/06/11/CUDA-study-notes/</url>
    <content><![CDATA[<h2 id="关于-准备"><a href="#关于-准备" class="headerlink" title="关于|准备"></a>关于|准备</h2><p>本为内容来源于《CUDA by Example.An Introduction to General-Purpose GPU Programming》学习整理，网上中英文版都有，其源码以及本文测试源码在<a href="https://github.com/blueyi/cuda_example">github</a>。部分内容来源于CUDA官方文档<a href="http://docs.nvidia.com/cuda">http://docs.nvidia.com/cuda</a>以及其他网上相关资料，官方文档右上角的搜索不是非常好用，如果没有搜索到你所需要的关键字可以定位到所需文档后试试<code>ctrl+f</code>,例如<code>dim3</code>的概念。这里是一个中文版本的<a href="http://www.nvidia.cn/docs/IO/57399/NVIDIA_CUDA_Programming_Guide_2.0Final.pdf">NVIDIA_CUDA_Programming_Guide_2.0Final</a>。<br><strong>新人入坑看这里，系统学习强烈推荐直接看官方这份编程指南：<a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html">http://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html</a>，本文后期补充的大量内容都来自该指南。</strong><br><strong>看完指南再看官方的进阶文档，最佳实践指南：<a href="http://docs.nvidia.com/cuda/cuda-c-best-practices-guide/">http://docs.nvidia.com/cuda/cuda-c-best-practices-guide/</a>，这些看完你也就完全入门了，并且跟上了CUDA的最新技术发展。</strong></p>
<span id="more"></span>

<p>书上使用的是C语言，为了顺便练习下C++且本文主要是为了以后自己查询所用，所以可能会有混用<code>C/C++</code>的情况，如果你不慎看到本文且发现了有问题的地方请及时与我联系，在以后的学习过程中我也会逐渐更正。</p>
<p><strong>特别推荐偶然间在网上找到的纽约大学的<code>CUDA</code>课程，地址在<a href="http://cs.nyu.edu/courses/spring12/CSCI-GA.3033-012/">Graphics Processing Units (GPUs): Architecture and Programming</a>。该页面底部也推荐了一些其他非常好的GPU相关的编程网站。</strong></p>
<p>本文没有介绍Windows下环境安装等相关的内容，因为<code>NVIDIA</code>基本上干好了一切，这应该就是商业公司的好处。<a href="https://developer.nvidia.com/cuda-zone">CUDA ZONE</a>上你可以找到所有<code>CUDA</code>环境及官方相关资料。<code>windows</code>下直接下载官方<code>CUDA Toolkit</code>安装即可，<code>Linux</code>下建议安装配置好<code>Nvida</code>显卡驱动且确定驱动正常运行后直接下载官方对应二进制包安装即可，这里建议安装个<code>snapper</code>并在你不确定是否能够完美配置好环境的情况下创建个快照，方便回滚。如果只是学习简单实例，且开发的文件较少并且熟悉<code>vim</code>,可以考虑使用<code>nvcc+vim</code>，不需要启动庞大的<code>VS</code>，当然<code>VS</code>也足够好用。以下是我用的<code>vim</code>针对<code>CUDA</code>的绑定，<code>Ctrl + F8</code>或<code>F8</code>一键编译并运行，其中<code>Ctrl + F8</code>会默认将CUDA官方示例中的头文件加入编译时的头文件查找路径中，方便编译官方示例，如果不是编译官方示例，直接使用<code>F8</code>即可。添加<code>--ptxas-options=-v</code>编译选项是为了在编译时输出核函数所使用的<code>register</code>和<code>shared memory</code>，方便自己根据需要调整block尺寸。</p>
<p>Linux下双显卡配置，可以参见：<a href="http://notes.maxwi.com/2017/02/26/ubuntu-cuda8-env-set/">http://notes.maxwi.com/2017/02/26/ubuntu-cuda8-env-set/</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;-- For CUDA development setting --</span></span><br><span class="line"><span class="string">&quot;</span> Ctrl + F8 compile, <span class="built_in">link</span> and execute .cu file with Samples header file</span><br><span class="line">map &lt;C-F8&gt; :call Nvcc_S() &lt;CR&gt;</span><br><span class="line">imap &lt;C-F8&gt; &lt;ESC&gt; :call Nvcc_S() &lt;CR&gt;</span><br><span class="line"><span class="string">&quot; F8 compile, link and execute .cu file without Samples header file</span></span><br><span class="line"><span class="string">map &lt;F8&gt; :call Nvcc() &lt;CR&gt;</span></span><br><span class="line"><span class="string">imap &lt;F8&gt; &lt;ESC&gt; :call Nvcc() &lt;CR&gt;</span></span><br><span class="line"><span class="string">&quot;</span>将CUDA Samples中的头文件加入编译路径</span><br><span class="line">func! Nvcc_S()</span><br><span class="line">    exe <span class="string">&quot;:ccl&quot;</span></span><br><span class="line">    exe <span class="string">&quot;:update&quot;</span></span><br><span class="line">    <span class="keyword">if</span> g:iswindows</span><br><span class="line">        exe <span class="string">&#x27;:!nvcc --ptxas-options=-v % -I &quot;C:\ProgramData\NVIDIA Corporation\CUDA Samples\v7.5\common\inc&quot; -o %&lt;.exe&#x27;</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        exe <span class="string">&#x27;:!nvcc --ptxas-options=-v % -I &quot;/usr/local/cuda-8.0/samples/common/inc&quot; -o %&lt;.o&#x27;</span></span><br><span class="line">    endif</span><br><span class="line">    <span class="keyword">if</span> v:shell_error == 0</span><br><span class="line">        <span class="keyword">if</span> g:iswindows</span><br><span class="line">            exe <span class="string">&quot;:!%&lt;.exe&quot;</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            exe <span class="string">&quot;:!./%&lt;.o&quot;</span></span><br><span class="line">        endif</span><br><span class="line">    endif</span><br><span class="line">endfunc</span><br><span class="line"></span><br><span class="line">func! Nvcc()</span><br><span class="line">    exe <span class="string">&quot;:ccl&quot;</span></span><br><span class="line">    exe <span class="string">&quot;:update&quot;</span></span><br><span class="line">    <span class="keyword">if</span> g:iswindows</span><br><span class="line">        exe <span class="string">&#x27;:!nvcc --ptxas-options=-v % -o %&lt;.exe&#x27;</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        exe <span class="string">&#x27;:!nvcc --ptxas-options=-v % -o %&lt;.o&#x27;</span></span><br><span class="line">    endif</span><br><span class="line">    <span class="keyword">if</span> v:shell_error == 0</span><br><span class="line">        <span class="keyword">if</span> g:iswindows</span><br><span class="line">            exe <span class="string">&quot;:!%&lt;.exe&quot;</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            exe <span class="string">&quot;:!./%&lt;.o&quot;</span></span><br><span class="line">        endif</span><br><span class="line">    endif</span><br><span class="line">endfunc</span><br></pre></td></tr></table></figure>

<h2 id="CUDA-C-简介及基本概念"><a href="#CUDA-C-简介及基本概念" class="headerlink" title="CUDA C++简介及基本概念"></a>CUDA C++简介及基本概念</h2><p><img data-src="GPU.jpg" alt="GPU结构概览"><br>硬件层面上CUDA架构中的GPU计算单元由很多的SM（Stream Multiprocess）组成，而每个SM又由多个CUDA Core（对应于single process）组成。这跟CUDA编程中的线程（thread）、线程块（block）、线程格（grid）并无直接的一一对应关系，CUDA编程中为了便于线程的调度和管理采用多维的方式来组织线程。</p>
<p>2.1 CPU中执行的代码称为主机代码，GPU中执行的代码称为设备代码,在GPU设备上执行的函数通常称为核函数（kernel）。一个程序中可以包含多个核函数。</p>
<p>2.2 通过<code>__global__ type func()</code>来声明可以从主机上调用并在设备上运行的代码，通过<code>__device__ type func()</code>来声明只能从其他<code>__device__</code>函数或者从<code>__global__</code>函数调用而需要在设备上执行的代码，也就是说其声明的函数只能在GPU上调用。<code>CUDA</code>中的并行化即是指这个核函数在程序启动后可以由多个线程同时来执行这个核函数一次。</p>
<p>2.3 通过<code>func&lt;&lt;&lt;N,1&gt;&gt;&gt;()</code>来调用需要在GPU中执行的代码。其中参数N表示设备在执行该函数时使用的并行线程块数量，参数1表示<code>CUDA</code>运行时在每个线程块中创建的线程数量。</p>
<p>2.4 GPU的大致使用流程总结如下：</p>
<ul>
<li>1.使用关键定<code>__global__</code>声明核函数，eg: <code>__global__ void kernel(int a, int b, int *c);</code></li>
<li>2.定义需要在GPU中使用的所有数据指针，eg: <code>int *dev_a;</code></li>
<li>3.然后通过<code>cudaMalloc</code>为所有需要设备内存的数据指针分配设备内存，注意<code>cudaMalloc()</code>分配的是<code>global memory</code>,也就是全局内存。eg: <code>cudaMalloc((void**)&amp;dev_a, sizeof(int));</code></li>
<li>4.通过<code>cudaMemcpy</code>将GPU代码中需要使用到的主机数据复制到GPU，eg: <code>cudaMemcpy(dev_b, b, N*sizeof(b), cudaMemcpyHostToDevice);</code></li>
<li>5.调用GPU核函数，eg: <code>kernel&lt;&lt;&lt;1,1&gt;&gt;&gt;(1, 2, dev_b);</code></li>
<li>6.调用后将需要在主机中使用的数据通过<code>cudaMemcpy</code>从设备内存复制到主机内存中使用，eg: <code>cudaMemcpy(b, dev_b,sizeof(int), cudaMemcpyDeviceToHost);</code></li>
<li>7.最后调用<code>cudaFree</code>释放在GPU中分配的内存，eg: <code>cudaFree(dev_a);</code></li>
</ul>
<p>举例如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">__global__ <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> *b, <span class="type">int</span> *c)</span> <span class="comment">//声明需要在GPU中执行的核函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	*c = a + *b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> b, c;</span><br><span class="line">	b = <span class="number">3</span>;</span><br><span class="line">	<span class="type">int</span> *dev_b, *dev_c; <span class="comment">//声明GPU需要使用到的指针</span></span><br><span class="line">	<span class="built_in">cudaMalloc</span>((<span class="type">void</span> **)&amp;dev_b, <span class="built_in">sizeof</span>(<span class="type">int</span>)); <span class="comment">//在GPU内存中为dev_b分配内存</span></span><br><span class="line">	<span class="built_in">cudaMalloc</span>((<span class="type">void</span> **)&amp;dev_c, <span class="built_in">sizeof</span>(<span class="type">int</span>)); <span class="comment">//在GPU内存中为dev_c分配内存</span></span><br><span class="line">	<span class="built_in">cudaMemcpy</span>(dev_b, &amp;b, <span class="built_in">sizeof</span>(<span class="type">int</span>), cudaMemcpyHostToDevice); <span class="comment">//将核函数需要的数据复制到设备内存</span></span><br><span class="line">	add&lt;&lt;&lt;<span class="number">1</span>,<span class="number">1</span>&gt;&gt;&gt;(<span class="number">2</span>, dev_b, dev_c); <span class="comment">//调用核函数</span></span><br><span class="line">	<span class="built_in">cudaMemcpy</span>(&amp;c, dev_c, <span class="built_in">sizeof</span>(<span class="type">int</span>), cudaMemcpyDeviceToHost); <span class="comment">//将计算结果dev_c中的数据从设备内存复制到主机内存</span></span><br><span class="line">	std::cout &lt;&lt; <span class="number">2</span> &lt;&lt; <span class="string">&quot; + &quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; c &lt;&lt; std::endl;</span><br><span class="line">	<span class="built_in">cudaFree</span>(dev_b); <span class="comment">//释放设备内存</span></span><br><span class="line">	<span class="built_in">cudaFree</span>(dev_c);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>这里特别强调，如果你发现本文中带有中文注释的示例无法通过编译，请手动设置源代码文件格式为<code>utf-8 with bomb</code>, <code>vim</code>设置方法为<code>:set bomb</code>,查看当前文件是否带<code>bomb</code>用<code>:set bomb?</code>,<code>EmEditor</code>另存时选择<code>UTF-8 with signature</code>,其他编辑器类似。当然VS通常默认应该是带<code>bomb</code>，否则请认真检查。这个问题花了我一下午尝试，怀疑是<code>nvcc</code>的兼容问题或者BUG，因为在<code>linux</code>下无论是带不带bomb，都能正常编译，但在windows下如果带有中文注释必须带bomb，或者将每一行带中文注释的行前后各放置一个空行。</strong></p>
<p>2.5 <code>cudaDeviceProp</code>结构体中包含了当前<code>CUDA</code>设备的几乎所有属性，可以通过<code>cudaGetDeviceCount(&amp;count)</code>查询当前计算机中<code>CUDA</code>设备数量，使用<code>cudaGetDevice(&amp;dev)</code>获取当前使用的设备ID，设备ID从0开始编号。使用<code>cudaGetDeviceProperties(&amp;prop, i)</code>函数来获取ID为i的<code>CUDA</code>设备的属性。使用<code>cudaChooseDevice(&amp;dev, &amp;prop)</code>可以获取符合<code>prop</code>要求的设备ID到<code>dev</code>，使用<code>cudaSetDevice(dev)</code>可以设置使用ID为dev的对应设备。有关设备属性的具体内容及用法参见<a href="http://docs.nvidia.com/cuda/cuda-runtime-api/group__CUDART__DEVICE.html#group__CUDART__DEVICE_1gf61f9ae0fe2d93b5b968756684a49460">http://docs.nvidia.com/cuda</a>。<br><strong>补充：可以使用NVIDIA官方Toolkit自带的工具<code>nvidia-smi</code>来查询GPU信息，功能强大,该工具默认安装路径为<code>C:\Program Files\NVIDIA Corporation\NVSMI\nvidia-smi.exe</code>，详情查看官方DOC。也可以在通过指定环境变量<code>CUDA_VISIBLE_DEVICES</code>来设置对于系统程序CUDA设备的可见性</strong></p>
<p>2.6 设备指针使用限制：</p>
<ul>
<li>可以将<code>cudaMalloc()</code>分配的指针传递给在设备上执行的函数。</li>
<li>可以在设备代码中使用<code>cudaMalloc()</code>分配的指针进行内存读/写操作。</li>
<li>可以将<code>cudaMalloc()</code>分配的指针传递给在主机上执行的函数。</li>
<li>不能在主机代码中使用<code>cudaMalloc()</code>分配的指针进行内存读/写操作。</li>
<li>总之，主机代码只能访问主机内存，设备代码只能访问设备内存。</li>
</ul>
<h2 id="CUDA-C并行编程的一维线程管理"><a href="#CUDA-C并行编程的一维线程管理" class="headerlink" title="CUDA C并行编程的一维线程管理"></a>CUDA C并行编程的一维线程管理</h2><p>3.1 <code>CUDA</code>使用线程格管理线程，线程格可以是一维的线程块集合，也可以是二维的线程块集合。核函数的每个副本都可以通过内置变量<code>blockIdx</code>来判断哪个线程块正在执行它，即确定线程块的索引。也可以通过<code>gridDim</code>来获得线程格中所包含的线程块的数量,通过<code>blockDim</code>可以获得线程块中所包含的线程的数量。<br>对于一个一维的线程格来说，不需要特别定义，可以直接使用<code>blockIdx.x</code>来获取当前线程块的索引，此时对应的核函数调用为<code>kernel&lt;&lt;&lt;N, 1&gt;&gt;&gt;();</code>即启动N个线程块；或者使用<code>threadIdx.x</code>来获取当前线程块中线程的索引，此时对应的核函数调用为<code>kernel&lt;&lt;&lt;1, N&gt;&gt;&gt;();</code>即启动一个线程块，该线程块启动N个线程。</p>
<p>3.2 GPU利用一维线程格进行矢量求和的例子:<br>所有的<code>tid</code>都是为了确定输入数组中的一个全局偏移，用于确定当前执行该核函数的线程应该计算数组中哪个元素的值,所以它必须要包含在它之前所有线程的索引值。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">10000</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">__global__ <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> *b, <span class="type">int</span> *c)</span>	<span class="comment">//定义GPU函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> tid = blockIdx.x;			<span class="comment">//计算该线程块的索引值</span></span><br><span class="line"><span class="comment">//  int tid = threadIdx.x;			//计算该线程的索引处值</span></span><br><span class="line">    <span class="keyword">if</span> (tid &lt; N)  <span class="comment">//与并行线程块数N对应,此处通过if防止由于执行的线程数量超过N个时内存访问越界</span></span><br><span class="line">        c[tid] = a[tid] + b[tid];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a[N], b[N], c[N];			<span class="comment">//在堆上分配主机数据空间</span></span><br><span class="line">    <span class="type">int</span> *dev_a, *dev_b, *dev_c;			<span class="comment">//设备内存指针</span></span><br><span class="line">    <span class="built_in">cudaMalloc</span>((<span class="type">void</span>**)&amp;dev_a, N*<span class="built_in">sizeof</span>(<span class="type">int</span>));	<span class="comment">//在GPU上为数据分配设备内存</span></span><br><span class="line">    <span class="built_in">cudaMalloc</span>((<span class="type">void</span>**)&amp;dev_b, N*<span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="built_in">cudaMalloc</span>((<span class="type">void</span>**)&amp;dev_c, N*<span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++)			<span class="comment">//在cpu上为数组赋值，可参照设备代码add修改为GPU上的代码</span></span><br><span class="line">    &#123;</span><br><span class="line">        a[i] = -i;</span><br><span class="line">	b[i] = i * i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cudaMemcpy</span>(dev_a, a, N*<span class="built_in">sizeof</span>(<span class="type">int</span>), cudaMemcpyHostToDevice);   <span class="comment">//将主机上的数组复制到GPU内存中</span></span><br><span class="line">    <span class="built_in">cudaMemcpy</span>(dev_b, b, N*<span class="built_in">sizeof</span>(<span class="type">int</span>), cudaMemcpyHostToDevice);</span><br><span class="line"></span><br><span class="line">    add&lt;&lt;&lt;N, <span class="number">1</span>&gt;&gt;&gt;(dev_a, dev_b, dev_c);		<span class="comment">//调用设备函数,将启动N个线程块</span></span><br><span class="line"><span class="comment">//  add&lt;&lt;&lt;1, N&gt;&gt;&gt;(dev_a, dev_b, dev_c);		//调用设备函数,只启动一个线程块，该线程块将启动N个线程</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cudaMemcpy</span>(c, dev_c, N*<span class="built_in">sizeof</span>(<span class="type">int</span>), cudaMemcpyDeviceToHost);   <span class="comment">//将计算后的GPU内存中的数据复制到主机内存，以便主机代码访问</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">	std::cout &lt;&lt; i &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; a[i] &lt;&lt; <span class="string">&quot; + &quot;</span> &lt;&lt; b[i] &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; c[i] &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cudaFree</span>(dev_a);    <span class="comment">//释放GPU内存</span></span><br><span class="line">    <span class="built_in">cudaFree</span>(dev_b);</span><br><span class="line">    <span class="built_in">cudaFree</span>(dev_c);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="线程协作-共享内存"><a href="#线程协作-共享内存" class="headerlink" title="线程协作|共享内存"></a>线程协作|共享内存</h2><p>4.1 硬件对线程块数量及线程块中包含的线程数量都有限制，具体限制可以通过CUDA API内置的结构体设备属性<code>cudaDeviceProp</code>查询。</p>
<p>4.2 线程格表示当前运行的线程块集合，线程格可以是二维，对应的内置变量<code>gridDim.x</code>中保存了线程格中每一维中的线程块数量；线程块表示当前运行的线程集合，线程块可以是三维的，对应的<code>blockDim.x</code>中保存了当前运行的线程块中每一维的线程数量。</p>
<p>4.3 当需要多个线程块并且每个线程块又包含多个线程时，索引计算方法为：<code>int tid = threadIdx.x + blockIdx.x * blockDim.x;</code>，其中索引tid相当于一个以线程块为行，线程为列的二维集合中某格所在的索引值。所以<code>threadIdx.x</code>表示当前线程所在线程块中某行的索引，<code>blockIdx.x</code>表示线程块索引，<code>blockDim.x</code>表示每个线程块中的线程数量。<code>gridDim.x</code>表示当前线程格中线程块的数量，线程格其实就是当前正在运行的线程块集合。如下图所示:<br><img data-src="tid.jpg" alt="一维线程格中线程索引对应关系"></p>
<p><img data-src="threads_organization.jpg" alt="CUDA线程组织形式"></p>
<p>4.4 在确定启动线程块的数量时记得考虑避免出现启动0个线程块的情况。例如若要每个线程块启动128个线程，假如我们总共需要启动N个并行线程，那么对应的线程块数量应为<code>N/128</code>。这样将导致当<code>N &lt; 128</code>时我们启动的线程块数量将为0，所以应该修改线程块数量为<code>(N+127)/128</code>，即计算大于或等于N的128的最小整数倍，同时不需要调用<code>ceil()</code>函数。</p>
<p>4.5 由于<code>gridDim.x</code>中存放了当前线程格中线程块的数量，<code>blockDim.x</code>中存放了当前线程块中线程的数量，所以<code>blockDim.x * gridDim.x</code>表示线程格中正在运行的线程块总数。</p>
<p>4.6 举例说明同时启动多个线程块及多个线程计算上述矢量求和的例子：<br>此处只给出核函数并说明函数调用。 </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">10000</span>;</span><br><span class="line"><span class="comment">/*N可以设置为任意编译器以及GPU内存限制下可以支持的数字，</span></span><br><span class="line"><span class="comment">因为我们可以限制线程和线程块数量，而让每个线程进行多次迭代*/</span></span><br><span class="line"><span class="comment">//核函数</span></span><br><span class="line"><span class="function">__global__ <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> *b, <span class="type">int</span> *c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> tid = threadIdx.x + blockIdx.x * blockDim.x;  <span class="comment">//当前线程中线程的起始索引</span></span><br><span class="line">    <span class="keyword">while</span> (tid &lt; N)  <span class="comment">//使用一个线程进行多次计算</span></span><br><span class="line">    &#123;</span><br><span class="line">	c[tid] = a[tid] + b[tid];</span><br><span class="line">	tid += blockDim.x * gridDim.x;  </span><br><span class="line"><span class="comment">/*计算完成一次之后需要递增的步长为当前线程格中正在运行的线程数量。</span></span><br><span class="line"><span class="comment">因为每个线程的起始索引都如上所示，即至少以一个线程块中的线程数量为单位递增，</span></span><br><span class="line"><span class="comment">所以当前在运行的总的线程数量应为每个线程块中包含的线程总数乘以线程格中的线程块总数。*/</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//核函数调用</span></span><br><span class="line">add&lt;&lt;&lt;<span class="number">128</span>, <span class="number">128</span>&gt;&gt;&gt;(dev_a, dev_b, dev_c); <span class="comment">//线程块和线程的数量可以设置为硬件限制内的任何数值。</span></span><br></pre></td></tr></table></figure>

<p>4.7 使用数据类型<code>dim3</code>可以定义多维block以及thread。例如可以定义一个N<em>N的二维线程块，每个线程块中含有M</em>M的线程，方法为  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dim3 block(N, N);  //默认第三维为1</span><br><span class="line">dim3 thread(M, M);</span><br><span class="line">kernel&lt;&lt;&lt;block, thread&gt;&gt;&gt;(type args);</span><br></pre></td></tr></table></figure>
<p>针对上面的普通数组加法的程序，可以修改核函数为  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">__global__ void add(int *a, int *b, int *c)</span><br><span class="line">&#123;</span><br><span class="line">   int x = threadIdx.x + blockIdx.x * blockDim.x;</span><br><span class="line">   int y = threadIdx.y + blockIdx.y * blockDim.y;</span><br><span class="line">   int tid = x + y * blockDim.x * gridDim.x;</span><br><span class="line">   while (tid &lt; N)</span><br><span class="line">   &#123;</span><br><span class="line">      c[tid] = a[tid] + b[tid];</span><br><span class="line">      tid += blockDim.x * gridDim.x * blockDim.y * gridDim.y;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4.8 以下为书上的一个实现1024x1024大小波纹动画效果的代码，将每个线程对应于一个像素，具体内容见注释。  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;cuda.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;book.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;cpu_anim.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> DIM = <span class="number">1024</span>; <span class="comment">//定义像素大小</span></span><br><span class="line"></span><br><span class="line"><span class="function">__global__ <span class="type">void</span> <span class="title">kernel</span><span class="params">( <span class="type">unsigned</span> <span class="type">char</span> *ptr, <span class="type">int</span> ticks )</span> </span>&#123;</span><br><span class="line">    <span class="comment">// map from threadIdx/BlockIdx to pixel position</span></span><br><span class="line">    <span class="type">int</span> x = threadIdx.x + blockIdx.x * blockDim.x;    </span><br><span class="line"><span class="comment">/*当前线程所在x轴坐标位置,注意每一个像素对应一个线程，如果定义每一个线程块包含16x16大小的</span></span><br><span class="line"><span class="comment">    线程数组，那么一共就需要DIM/16 x DIM/16个线程块。*/</span></span><br><span class="line">    <span class="type">int</span> y = threadIdx.y + blockIdx.y * blockDim.y;</span><br><span class="line">    <span class="type">int</span> offset = x + y * blockDim.x * gridDim.x;      </span><br><span class="line"><span class="comment">/*偏移量的计算与上图&quot;线程索引对应关系&quot;的计算方式一样。</span></span><br><span class="line"><span class="comment">只是此处偏移量是指位图的每个像素且每一个单元格对应一个线程块。*/</span></span><br><span class="line">    <span class="comment">// now calculate the value at that position</span></span><br><span class="line">    <span class="type">float</span> fx = x - DIM/<span class="number">2</span>;</span><br><span class="line">    <span class="type">float</span> fy = y - DIM/<span class="number">2</span>;</span><br><span class="line">    <span class="type">float</span> d = <span class="built_in">sqrtf</span>( fx * fx + fy * fy );</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> grey = (<span class="type">unsigned</span> <span class="type">char</span>)(<span class="number">128.0f</span> + <span class="number">127.0f</span> * <span class="built_in">cos</span>(d/<span class="number">10.0f</span> - ticks/<span class="number">7.0f</span>)/(d/<span class="number">10.0f</span> + <span class="number">1.0f</span>));    </span><br><span class="line">    ptr[offset*<span class="number">4</span> + <span class="number">0</span>] = grey;</span><br><span class="line">    ptr[offset*<span class="number">4</span> + <span class="number">1</span>] = grey;</span><br><span class="line">    ptr[offset*<span class="number">4</span> + <span class="number">2</span>] = grey;</span><br><span class="line">    ptr[offset*<span class="number">4</span> + <span class="number">3</span>] = <span class="number">255</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">DataBlock</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>   *dev_bitmap;</span><br><span class="line">    CPUAnimBitmap  *bitmap;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">generate_frame</span><span class="params">( DataBlock *d, <span class="type">int</span> ticks )</span> </span>&#123;</span><br><span class="line">    <span class="function">dim3    <span class="title">blocks</span><span class="params">(DIM/<span class="number">16</span>,DIM/<span class="number">16</span>)</span></span>;    <span class="comment">//定义一个二维线程块，默认第三维为1，关于dim3类型参见官网DOC。</span></span><br><span class="line">    <span class="function">dim3    <span class="title">threads</span><span class="params">(<span class="number">16</span>,<span class="number">16</span>)</span></span>;           <span class="comment">//定义每个线程块中包含的线程数为16x16。</span></span><br><span class="line">    kernel&lt;&lt;&lt;blocks,threads&gt;&gt;&gt;( d-&gt;dev_bitmap, ticks );</span><br><span class="line"></span><br><span class="line">    <span class="built_in">HANDLE_ERROR</span>( <span class="built_in">cudaMemcpy</span>( d-&gt;bitmap-&gt;<span class="built_in">get_ptr</span>(), d-&gt;dev_bitmap, d-&gt;bitmap-&gt;<span class="built_in">image_size</span>(), cudaMemcpyDeviceToHost ) );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// clean up memory allocated on the GPU</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cleanup</span><span class="params">( DataBlock *d )</span> </span>&#123;</span><br><span class="line">    <span class="built_in">HANDLE_ERROR</span>( <span class="built_in">cudaFree</span>( d-&gt;dev_bitmap ) ); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">( <span class="type">void</span> )</span> </span>&#123;</span><br><span class="line">    DataBlock   data;</span><br><span class="line">    <span class="function">CPUAnimBitmap  <span class="title">bitmap</span><span class="params">( DIM, DIM, &amp;data )</span></span>;</span><br><span class="line">    data.bitmap = &amp;bitmap;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">HANDLE_ERROR</span>( <span class="built_in">cudaMalloc</span>( (<span class="type">void</span>**)&amp;data.dev_bitmap, bitmap.<span class="built_in">image_size</span>() ) );</span><br><span class="line"></span><br><span class="line">    bitmap.<span class="built_in">anim_and_exit</span>( (<span class="built_in">void</span> (*)(<span class="type">void</span>*,<span class="type">int</span>))generate_frame, (<span class="built_in">void</span> (*)(<span class="type">void</span>*))cleanup );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4.9 共享内存： <code>CUDA</code>可以在声明时通过<code>__shared__</code>关键字,使变量驻留在共享内存中。共享内存中的变量可以被同一线程块中的线程所共享，所以可以通过共享内存来实现同一线程块中的线程之间进行通信，且共享内存位于物理GPU上，其访问延迟要远远低于普通缓冲区。使用方法即是将<code>__shared__</code>添加到变量声明中。  </p>
<p>4.10 <code>CUDA</code>可以使用线程同步机制<code>__syncthreads();</code>对线程块中的线程进行同步。该函数可以确保同一线程块中的所有线程在执行完该语句之前的所有语句之后才会执行其下一条语句。使用<code>__syncthreads();</code>时一定要时刻记住避免由于线程发散所引起的线程永久等待问题。线程发散是指由于某种判断导致某些线程需要执行一些指令，而其他线程不需要执行这条指令的情况。例如：<code>if (threadIdx.x % 2) myvar = threadIdx.x;</code>这将导致奇数线程需要执行，而偶数线程不需要执行。但在这个时候如果将<code>__syncthreads();</code>函数放在<code>if</code>语句中，就必然会导致有些线程需要执行到<code>__syncthreads();</code>的情况，此时当奇数线程执行到这里时它需要等待其他线程也执行到该语句，但由于<code>if</code>语句的判断，会导致它永远等不到偶数线程来执行<code>__syncthreads();</code>函数，这样就会引起处理器挂起的情况。</p>
<p>4.11 时刻记得<code>CUDA</code>是使用GPU进行并行计算，所有线程格所组织的线程块中的所有线程都在同时执行同一个核函数。在对共享内存写入时要记得确保所有线程都已经执行完成，避免发生竞态条件。竞态条件是指对于共享内存中的数据，有可能线程A和线程B会同时对该共享数据进行操作，那么，在这种情况下代码的执行结果将是不确定的。CUDA中避免同一个线程块中线程访问shared memory出现竞态条件的方法是使用<code>__syncthreads()</code>在读取shared memory的值之前进行线程同步。</p>
<p>4.12 关于书上点积运算的例子中在求和归约运算时需要使用<code>__syncthreads();</code>的解释，详细看下图以及4.13中实例分析，注意当前该线程块中的所有线程都在运行这个核函数，且每个线程块都会有其自己的一个共享内存区域，只有同一个线程块中的线程之间才能共享该线程块的共享内存。<br><img data-src="syncthreads.jpg" alt="线程协作"><br>由于所有线程同时并行运行所以并不一定线程0就先计算，但对应关系一定是这样，且通过与<code>i</code>比较来筛选出索引小于<code>i</code>的线程进行计算。每次循环线程数减半，直到最后所有的值都加到cache[0]中</p>
<p>4.13 <code>threadIdx.x</code>是个内置变量，存储了当前线程所在线程块中的索引，也就是说它是核函数中唯一能表征当前时刻该核函数正在被哪个线程所执行，且该变量是个常量。它的值是相对于线程块的，在同一个线程块中其值是唯一的，每个线程块都会存在对应值相等的<code>threadIdx.x</code>。将其与线程块和线程格结合起来便能确定出一个唯一的线程索引。</p>
<p>4.14 点积运算实例的详细说明，其中用到了一些之前没有用过的方法，程序还有很多可以改善的地方：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> min(a,b) (a&lt;b?a:b)  <span class="comment">//用于确定线程格中线程块的数量</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">33</span> * <span class="number">1024</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> threadsPerBlock = <span class="number">256</span>;  <span class="comment">/*N应尽量为线程块中线程数的整数倍，以确保刚好每个线程都在参与计算，</span></span><br><span class="line"><span class="comment">又由于后面需要使用归约运算求和，所以其必须为2的指数。*/</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> blocksPerGrid = <span class="built_in">min</span>(<span class="number">32</span>, (N+threadsPerBlock<span class="number">-1</span>)/threadsPerBlock);  </span><br><span class="line"><span class="comment">/*为了性能要求确保每个线程格中的线程块数量不超过32。</span></span><br><span class="line"><span class="comment">当线程块过多时会导致产生过多的线程使GPU非常繁忙而CPU却有空闲。其实此处明显其值为32*/</span></span><br><span class="line"></span><br><span class="line"><span class="function">__global__ <span class="type">void</span> <span class="title">dot</span><span class="params">(<span class="type">float</span> *a, <span class="type">float</span> *b, <span class="type">float</span> *c)</span>  <span class="comment">//a,b为输入数据，c为计算结果</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//在共享内存为每个线程块声明一个cache数组用于存放每个线程计算的结果</span></span><br><span class="line">    __shared__ <span class="type">float</span> cache[threadsPerBlock];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过线程块索引和线程索引计算出输入数组中的全局偏移，也就是确定当前该线程该去计算哪个数组的元素了。</span></span><br><span class="line">    <span class="type">int</span> tid = threadIdx.x + blockIdx.x * blockDim.x;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*cache的大小刚好就是线程块中所包含的线程数量，所以cache中的</span></span><br><span class="line"><span class="comment">    每个元素刚好可以与线程一一对应，threadIdx.x就是当前执行该核函数的线程所在线程块中的索引*/</span></span><br><span class="line">    <span class="type">int</span> cacheIndex = threadIdx.x;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*由于一个线程有可能执行多次求积的运算，所以可以用它临时存放该线程所计算的积，</span></span><br><span class="line"><span class="comment">    最后再将该线程计算的所有积累加存入共享内存中的数组cache*/</span></span><br><span class="line">    <span class="type">float</span> temp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (tid &lt; N)</span><br><span class="line">    &#123;</span><br><span class="line">        temp += a[tid] * b[tid];</span><br><span class="line">        tid += blockDim.x * gridDim.x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*在该线程计算完成之后将其计算过的所有积的累加和存入数组。</span></span><br><span class="line"><span class="comment">    此处应该可以将前面声明的cacheIndex省略，而直接使用threadIdx.x作为数组索引。*/</span></span><br><span class="line">    cache[cacheIndex] = temp;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对线程块中的线程进行同步，确保所有线程都已经将其计算的值存入了共享内存中</span></span><br><span class="line">    __syncthreads();</span><br><span class="line">    <span class="comment">/*也就是说到此为止所有的积都已经计算完了，下面想办法将它们累加起来就可以。</span></span><br><span class="line"><span class="comment">    当前的情况为一共有32个线程块，而每个线程块中都有一个大小为256的cache数组，</span></span><br><span class="line"><span class="comment">    也就是说有32 x 256个值需要累加。当然可以直接使用一个线程对它们进行一一迭代32 x 256次，</span></span><br><span class="line"><span class="comment">    既然使用了GPU必然有更好的方法，那就是归约，归约的目的是对一个输入数组执行某种计算，</span></span><br><span class="line"><span class="comment">    然后产生一个更小的结果数组，类似于算法中的归并策略。此处使用并行的方法来执行归约计算，</span></span><br><span class="line"><span class="comment">    即每个线程块中前1/2的线程将cache[]中的对应于其索引的元素的值与cache[]中后面1/2的值进行累加，</span></span><br><span class="line"><span class="comment">    然后依次循环为前1/2的1/2线程执行同样的操作，所以前面要求threadsPerBlock必须为2的指数，具体参见3.11图。*/</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i = blockDim.x / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span> (i != <span class="number">0</span>)  <span class="comment">//直到所有值都加到了cache[0]中</span></span><br><span class="line">    &#123;</span><br><span class="line">	<span class="comment">//防止索引越界,由于无法确定哪个线程先计算，所以也同时相当于挑选那些索引在i之前的线程进行计算。</span></span><br><span class="line">	<span class="keyword">if</span> (cacheIndex &lt; i)</span><br><span class="line">	&#123;</span><br><span class="line">            cache[cacheIndex] += cache[cacheIndex + i];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//确保所有对共享内存的写操作都完成了，注意不能将它放入if中，以免发生处理器挂起的情况</span></span><br><span class="line">        __syncthreads();</span><br><span class="line"></span><br><span class="line">        i /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//至此每一个线程块中线程的计算结果都放入了其对应共享内存的cache[0]中</span></span><br><span class="line">    <span class="comment">/*使用线程索引为0的线程将计算结果存入结果数组c中，当然可以使用任意一个线程完成这个工作，</span></span><br><span class="line"><span class="comment">    也可以不加个条件判断而让所有线程同时执行这个操作，但这将增加很多额外的通信量。*/</span></span><br><span class="line">    <span class="keyword">if</span> (cacheIndex == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">	c[blockIdx.x] = cache[<span class="number">0</span>];  <span class="comment">//每个线程块都有一个cache[]数组</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*至此乘积的计算结果被分成了32份放入了数组c中，然后使用CPU进行累加就可以了。</span></span><br><span class="line"><span class="comment">    不使用GPU的多线程是因为计算量太小，如果使用GPU的话会导致很多线程处于空闲状态，浪费资源。*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">float</span> *a, *b, *partial_c;  </span><br><span class="line">    <span class="comment">/*注意此处并没有直接声明为数组，而是声明的指针。因为malloc分配的空间是在堆上，</span></span><br><span class="line"><span class="comment">    直接声明为数组时分配的内存却是在栈上。虽然对于栈的操作效率更高，但堆上可以分配的空间更大，</span></span><br><span class="line"><span class="comment">    堆上分配的内存记得要手动释放*/</span></span><br><span class="line">    pass;  <span class="comment">//省略</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>更多关于共享内存的内容参见官方DOC: <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#shared-memory">http://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#shared-memory</a></p>
<h2 id="常量内存-事件"><a href="#常量内存-事件" class="headerlink" title="常量内存|事件"></a>常量内存|事件</h2><p>5.1 <code>CUDA</code>使用关键字<code>__constant__</code>声明常量内存中的变量，常量内存只读，但效率高且可以节约内存带宽,所以常量内存适合存放需要大量只读调用的常量数据。声明常量内存时必须指定数组大小，eg: <code>__constant__ type arr[15];</code>。<code>cudaMalloc()</code>分配的为全局内存，即设备内存。</p>
<p>5.2 将数据从主机内存复制到GPU上的常量内存需要使用<code>cudaMemcpyToSymbol()</code>函数，eg: <code>cudaMemcpyToSymbol(tar, src, size);</code>不需要指定方向。</p>
<p>5.3 <code>CUDA</code>架构中，线程束是指一个包含32个线程的集合(高版本的指令集支持指定线程束数量及重新排列线程束中线程的顺序)，同一个线程束中的线程会以“步调一致(Lockstep)”的形式执行,即在程序中的每一行，线程束中的每个线程都将在不同的数据上执行相同的指令，有点类似SIMD。半线程束即指线程束的一半，也就是16个线程。</p>
<p>5.4 常量内存具有两个特点：</p>
<ul>
<li>对常量内存的单次操作可以广播到其他邻近的15个线程中，也就是每次操作常量内存就相当于半线程束在同时操作常量内存，所以这将节约15次读取操作。</li>
<li>常量内存的数据将被缓存起来，因此对相同地址的连续读操作将不会产生额外的内存消耗。</li>
</ul>
<p>5.5 常量内存是一把双刃剑因为当半线程束需要访问常量内存中的不同数据时，这16次不同的读取操作会被串行化，而如果是从全局内存中读取，则会以并行方式同时进行。</p>
<p>5.6 <code>CUDA</code>使用事件来测量性能，事件本质上是GPU时间戳，由于可能会执行一些异步函数调用，所以在读取时间记录之前必须使用<code>cudaEventSynchronize()</code>函数对事件进行同步。<code>CUDA</code>事件是直接在GPU上实现的，所以它不能用于同时包含设备代码和主机代码的混合代码。eg:  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cudaEvent_t start, stop;  <span class="comment">//声明两个事件时间变量</span></span><br><span class="line"><span class="built_in">cudaEventCreate</span>(&amp;start);  <span class="comment">//创建起始事件</span></span><br><span class="line"><span class="built_in">cudaEventCreate</span>(&amp;stop);  <span class="comment">//创建结束事件</span></span><br><span class="line"><span class="built_in">cudaEventRecord</span>(start, <span class="number">0</span>); <span class="comment">//记录开始事件时间</span></span><br><span class="line"><span class="comment">//在GPU上执行一些工作</span></span><br><span class="line"><span class="built_in">cudaEventRecord</span>(stop, <span class="number">0</span>); <span class="comment">//记录结束事件时间</span></span><br><span class="line"><span class="built_in">cudaEventSynchronize</span>(stop); <span class="comment">//同步结束事件，确保所有对stop事件的操作已经完成</span></span><br><span class="line"><span class="type">float</span> elapsedTime;  <span class="comment">//用于存放事件所使用的时间</span></span><br><span class="line"><span class="built_in">cudaEventElapsedTime</span>(&amp;elapsedTime, start, stop);  <span class="comment">//计算两个事件之间所经历的时间,单位为毫秒</span></span><br><span class="line">std::cout &lt;&lt; elapsedTime;  <span class="comment">//输出时间</span></span><br><span class="line"><span class="built_in">cudaEventDestroy</span>(start);  <span class="comment">//销毁事件，相当于释放资源</span></span><br><span class="line"><span class="built_in">cudaEventDestroy</span>(stop);  </span><br></pre></td></tr></table></figure>

<h2 id="纹理内存和表面-Texture-and-Surface-Memory"><a href="#纹理内存和表面-Texture-and-Surface-Memory" class="headerlink" title="纹理内存和表面(Texture and Surface Memory)"></a>纹理内存和表面(Texture and Surface Memory)</h2><h3 id="Texture-Memory"><a href="#Texture-Memory" class="headerlink" title="Texture Memory"></a>Texture Memory</h3><p>6.1 纹理内存是CUDA中的另一种只读内存，同样缓存在芯片上，在特定的模式中可以提高性能并减少内存通信量，因为虽然他的分配实际也是在global memory，但它有cache，只有当cache没有命中时才会去访问device memory。它的特点是其专门用于那些在访问模式中存在大量空间局部性的图形应用程序而设计。这里的空间局部性是指某个线程读取的位置可能与邻近线程读取的位置“非常接近”，这些位置不一定要像常量内存那样都是连续的而是指可以前后左右相邻。所以纹理内存非常适合用于图像的处理。纹理内存也可以被layered，称为<code>Layered Textures</code></p>
<p>6.2 CUDA中有2种不同的方式来存取纹理内存和surface内存：</p>
<ul>
<li>纹理引用API（texture reference API），该API支持所有设备，也就是本文原来介绍的方式。该方式的纹理引用创建在编译期，所以需要在创建时指定大小。</li>
<li>纹理对象API（texture object API），该API只支持计算能力3.x以上的设备。纹理对象的创建发生在运行时。</li>
</ul>
<h4 id="Texture-Object-API"><a href="#Texture-Object-API" class="headerlink" title="Texture Object API"></a>Texture Object API</h4><p>该方式使用纹理内存的过程主要分为4步：1）分配device memory，2）通过device memory创建纹理对象，3）访问纹理内存，4）销毁纹理对象并释放device内存。<br>Texture对象使用函数<code>cudaCreateTextureObject()</code>从源描述结构体<code>cudaResourceDesc</code>创建，并通过texture描述结构体<code>cudaTextureDesc</code>指定texture对象的参数。该函数的原型：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">__host__ cudaError_t <span class="title">cudaCreateTextureObject</span> <span class="params">( cudaTextureObject_t* pTexObject, <span class="type">const</span> cudaResourceDesc* pResDesc, <span class="type">const</span> cudaTextureDesc* pTexDesc, <span class="type">const</span> cudaResourceViewDesc* pResViewDesc )</span></span></span><br></pre></td></tr></table></figure>
<p>其中<code>cudaResourceDesc</code>中可以用于指定device memory内存地址，以及相应的内存类型。当用于二维图像时，通常可以将<code>cudaResourceDesc::resType</code>设置为<code>cudaResourceTypePitch2D</code>，然后设置其相应的宽高等，下面是一个实例中对于YUV图像处理时使用纹理内存的<code>cudaResourceDesc</code>的初始化方法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> hhSrc = nSrcHeight * <span class="number">3</span> / <span class="number">2</span>;  <span class="comment">// nSrcHeight为原图像的高</span></span><br><span class="line"></span><br><span class="line">cudaResourceDesc resDesc = &#123;&#125;;</span><br><span class="line">resDesc.resType = cudaResourceTypePitch2D;</span><br><span class="line">resDesc.res.pitch2D.devPtr = dpSrc;  <span class="comment">// dpSrc为device memory中的设备内存指针</span></span><br><span class="line">resDesc.res.pitch2D.desc = <span class="built_in">cudaCreateChannelDesc</span>&lt;<span class="type">uint8_t</span>&gt;();</span><br><span class="line">resDesc.res.pitch2D.width = nSrcWidth;</span><br><span class="line">resDesc.res.pitch2D.height = hhSrc * nBatchSize;</span><br><span class="line">resDesc.res.pitch2D.pitchInBytes = nSrcPitch;</span><br></pre></td></tr></table></figure>
<p>关于该函数的详细描述可以看这里：<a href="http://docs.nvidia.com/cuda/cuda-runtime-api/group__CUDART__TEXTURE__OBJECT.html">http://docs.nvidia.com/cuda/cuda-runtime-api/group__CUDART__TEXTURE__OBJECT.html</a><br>NV官方一个示例的完整代码及注释如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Simple transformation kernel</span></span><br><span class="line"><span class="function">__global__ <span class="type">void</span> <span class="title">transformKernel</span><span class="params">(<span class="type">float</span>* output,</span></span></span><br><span class="line"><span class="params"><span class="function">                                cudaTextureObject_t texObj,</span></span></span><br><span class="line"><span class="params"><span class="function">                                <span class="type">int</span> width, <span class="type">int</span> height,</span></span></span><br><span class="line"><span class="params"><span class="function">                                <span class="type">float</span> theta)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Calculate normalized texture coordinates</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> x = blockIdx.x * blockDim.x + threadIdx.x;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> y = blockIdx.y * blockDim.y + threadIdx.y;</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> u = x / (<span class="type">float</span>)width;</span><br><span class="line">    <span class="type">float</span> v = y / (<span class="type">float</span>)height;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Transform coordinates</span></span><br><span class="line">    u -= <span class="number">0.5f</span>;</span><br><span class="line">    v -= <span class="number">0.5f</span>;</span><br><span class="line">    <span class="type">float</span> tu = u * <span class="built_in">cosf</span>(theta) - v * <span class="built_in">sinf</span>(theta) + <span class="number">0.5f</span>;</span><br><span class="line">    <span class="type">float</span> tv = v * <span class="built_in">cosf</span>(theta) + u * <span class="built_in">sinf</span>(theta) + <span class="number">0.5f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取纹理内存到global memory</span></span><br><span class="line">    output[y * width + x] = <span class="built_in">tex2D</span>&lt;<span class="type">float</span>&gt;(texObj, tu, tv);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Host code</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 在device memory中分配CUDA array</span></span><br><span class="line">    cudaChannelFormatDesc channelDesc =</span><br><span class="line">               <span class="built_in">cudaCreateChannelDesc</span>(<span class="number">32</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">                                     cudaChannelFormatKindFloat);</span><br><span class="line">    cudaArray* cuArray;</span><br><span class="line">    <span class="built_in">cudaMallocArray</span>(&amp;cuArray, &amp;channelDesc, width, height);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将主机上位于h_data中的数据拷贝到设备内存上的cuda array中</span></span><br><span class="line">    <span class="built_in">cudaMemcpyToArray</span>(cuArray, <span class="number">0</span>, <span class="number">0</span>, h_data, size,</span><br><span class="line">                      cudaMemcpyHostToDevice);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化texture的device内存源描述信息并指定device memory地址</span></span><br><span class="line">    <span class="comment">// 这里是使用的cuda array</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">cudaResourceDesc</span> resDesc;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;resDesc, <span class="number">0</span>, <span class="built_in">sizeof</span>(resDesc));</span><br><span class="line">    resDesc.resType = cudaResourceTypeArray;</span><br><span class="line">    resDesc.res.array.array = cuArray;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指定texture的参数信息</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">cudaTextureDesc</span> texDesc;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;texDesc, <span class="number">0</span>, <span class="built_in">sizeof</span>(texDesc));</span><br><span class="line">    texDesc.addressMode[<span class="number">0</span>]   = cudaAddressModeWrap;</span><br><span class="line">    texDesc.addressMode[<span class="number">1</span>]   = cudaAddressModeWrap;</span><br><span class="line">    texDesc.filterMode       = cudaFilterModeLinear;</span><br><span class="line">    texDesc.readMode         = cudaReadModeElementType;</span><br><span class="line">    texDesc.normalizedCoords = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建texture对象</span></span><br><span class="line">    cudaTextureObject_t texObj = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cudaCreateTextureObject</span>(&amp;texObj, &amp;resDesc, &amp;texDesc, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配变换结果所需要的device memory</span></span><br><span class="line">    <span class="type">float</span>* output;</span><br><span class="line">    <span class="built_in">cudaMalloc</span>(&amp;output, width * height * <span class="built_in">sizeof</span>(<span class="type">float</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Invoke kernel</span></span><br><span class="line">    <span class="function">dim3 <span class="title">dimBlock</span><span class="params">(<span class="number">16</span>, <span class="number">16</span>)</span></span>;</span><br><span class="line">    <span class="function">dim3 <span class="title">dimGrid</span><span class="params">((width  + dimBlock.x - <span class="number">1</span>) / dimBlock.x,</span></span></span><br><span class="line"><span class="params"><span class="function">                 (height + dimBlock.y - <span class="number">1</span>) / dimBlock.y)</span></span>;</span><br><span class="line">    transformKernel&lt;&lt;&lt;dimGrid, dimBlock&gt;&gt;&gt;(output,</span><br><span class="line">                                           texObj, width, height,</span><br><span class="line">                                           angle);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁纹理对象</span></span><br><span class="line">    <span class="built_in">cudaDestroyTextureObject</span>(texObj);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放显存</span></span><br><span class="line">    <span class="built_in">cudaFreeArray</span>(cuArray);</span><br><span class="line">    <span class="built_in">cudaFree</span>(output);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Texture-Reference-API"><a href="#Texture-Reference-API" class="headerlink" title="Texture Reference API"></a>Texture Reference API</h4><p>注意该模式下的texture引用变量只能为全局变量，不支持通过参数的形式传递为局部变量。<br>该方式下的纹理内存使用主要分为4个步骤：1）device memory分配，2）创建texture，并与分配的显存绑定，3）读取纹理内存，4）解绑并释放分配的显存。<br>创建texture的模板原型如下，其中<code>Type</code>和<code>ReadMode</code>两个为可选参数，具体作用参考官方文档。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">texture&lt;DataType, Type, ReadMode&gt; texRef;</span><br></pre></td></tr></table></figure>
<p>此处为一维纹理内存使用过程举例：<br>显存绑定：首先需要将输入的数据声明为<code>texture</code>类型的引用,eg: <code>texture&lt;float&gt; texIn;</code>表示声明一个<code>float</code>类型的纹理引用，引用名为<code>texIn</code>，纹理引用必须声明为文件作用域内的全局变量。注意这里仅仅是声明了一个引用，并没有分配内存空间。然后就需要使用<code>cudaBindTexture()</code>函数将引用变量绑定到内存缓冲区，此处的内存缓冲区依然需要使用<code>cudaMalloc()</code>来分配，<code>cudaBindTexture()</code>做的工作有将指定的缓冲区作为纹理内存来使用以及将纹理引用作为纹理的“名字”。<br>读取：纹理内存分配完成之后就可以使用了，纹理内存的读取不能像数组那样直接使用下标引用,而是使用内置函数<code>text1Dfetch(cudaTextureObject_t texObj, int x)</code>进行读取，<code>texObj</code>表示纹理对象，<code>x</code>表示整型纹理坐标，其实就是用全局偏移<code>offset</code>来指定的方向。<br>释放：使用内置函数<code>cudaUnbindTexture()</code>解除与纹理的绑定然后再释放内存即可。<br>eg:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">texture&lt;<span class="type">float</span>&gt; texIn;  <span class="comment">//声明一个float类型的纹理引用</span></span><br><span class="line"><span class="built_in">cudaMalloc</span>((<span class="type">void</span>**)&amp;date.dev_inSrc, imageSize);  <span class="comment">//分配一块打算作为纹理内存的空间</span></span><br><span class="line"><span class="built_in">cudaBindTexture</span>(<span class="literal">NULL</span>, texIn, date.dev_inSrc, imageSize);  <span class="comment">//将纹理引用与内存空间绑定并希望将指定的空间作为纹理内存使用</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> x = threadIdx.x + blockIdx.x * blockDim.x;</span><br><span class="line"><span class="type">int</span> y = threadIdx.y + blockIdx.y * blockDim.y;</span><br><span class="line"><span class="type">int</span> offset = x + y * blockDim.x * gridDim.x;</span><br><span class="line"><span class="type">int</span> top = offset - DIM;  <span class="comment">//定义需要处理的当前像素位置的上方的元素位置(DIM X DIM大小的画布),默认坐标(x, y)为中心数据</span></span><br><span class="line"><span class="type">float</span> t;  <span class="comment">//用于存放从纹理内存中读取的值</span></span><br><span class="line">t = <span class="built_in">text1Dfetch</span>(texIn, top);  <span class="comment">//读取纹理内存中的数据到t中</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cudaUnbindTexture</span>(texIn);  <span class="comment">//解除绑定</span></span><br><span class="line"><span class="built_in">cudaFree</span>(d-&gt;dev_inSrc);  </span><br></pre></td></tr></table></figure>

<p>声明的纹理引用可以在使用完之后解绑定，然后再将其与其他内存空间进行绑定，<code>cudaBindTexture()</code>的函数原型为</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cudaBindTexture</span> ( <span class="type">size_t</span>* offset, <span class="type">const</span> textureReference* texref, <span class="type">const</span> <span class="type">void</span>* devPtr, <span class="type">const</span> cudaChannelFormatDesc* desc, <span class="type">size_t</span> size = UINT_MAX )</span><br></pre></td></tr></table></figure>

<p>官方文档建议使用二维的纹理内存。Read more at: <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#texture-memory">http://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#texture-memory</a><br>NV官方与上面texture对象的方式使用纹理内存一样功能的一个示例：  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建全局的texture引用</span></span><br><span class="line">texture&lt;<span class="type">float</span>, cudaTextureType2D, cudaReadModeElementType&gt; texRef;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Simple transformation kernel</span></span><br><span class="line"><span class="function">__global__ <span class="type">void</span> <span class="title">transformKernel</span><span class="params">(<span class="type">float</span>* output,</span></span></span><br><span class="line"><span class="params"><span class="function">                                <span class="type">int</span> width, <span class="type">int</span> height,</span></span></span><br><span class="line"><span class="params"><span class="function">                                <span class="type">float</span> theta)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Calculate normalized texture coordinates</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> x = blockIdx.x * blockDim.x + threadIdx.x;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> y = blockIdx.y * blockDim.y + threadIdx.y;</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> u = x / (<span class="type">float</span>)width;</span><br><span class="line">    <span class="type">float</span> v = y / (<span class="type">float</span>)height;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Transform coordinates</span></span><br><span class="line">    u -= <span class="number">0.5f</span>;</span><br><span class="line">    v -= <span class="number">0.5f</span>;</span><br><span class="line">    <span class="type">float</span> tu = u * <span class="built_in">cosf</span>(theta) - v * <span class="built_in">sinf</span>(theta) + <span class="number">0.5f</span>;</span><br><span class="line">    <span class="type">float</span> tv = v * <span class="built_in">cosf</span>(theta) + u * <span class="built_in">sinf</span>(theta) + <span class="number">0.5f</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read from texture and write to global memory</span></span><br><span class="line">    output[y * width + x] = <span class="built_in">tex2D</span>(texRef, tu, tv);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Host code</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 在device memory中分配CUDA array</span></span><br><span class="line">    cudaChannelFormatDesc channelDesc =</span><br><span class="line">               <span class="built_in">cudaCreateChannelDesc</span>(<span class="number">32</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">                                     cudaChannelFormatKindFloat);</span><br><span class="line">    cudaArray* cuArray;</span><br><span class="line">    <span class="built_in">cudaMallocArray</span>(&amp;cuArray, &amp;channelDesc, width, height);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将主机上位于h_data中的数据拷贝到设备内存上的cuda array中</span></span><br><span class="line">    <span class="built_in">cudaMemcpyToArray</span>(cuArray, <span class="number">0</span>, <span class="number">0</span>, h_data, size,</span><br><span class="line">                      cudaMemcpyHostToDevice);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置texture引用的参数</span></span><br><span class="line">    texRef.addressMode[<span class="number">0</span>] = cudaAddressModeWrap;</span><br><span class="line">    texRef.addressMode[<span class="number">1</span>] = cudaAddressModeWrap;</span><br><span class="line">    texRef.filterMode     = cudaFilterModeLinear;</span><br><span class="line">    texRef.normalized     = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定刚才创建cuArray到纹理引用</span></span><br><span class="line">    <span class="built_in">cudaBindTextureToArray</span>(texRef, cuArray, channelDesc);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配变换结果所需要的device memory</span></span><br><span class="line">    <span class="type">float</span>* output;</span><br><span class="line">    <span class="built_in">cudaMalloc</span>(&amp;output, width * height * <span class="built_in">sizeof</span>(<span class="type">float</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Invoke kernel</span></span><br><span class="line">    <span class="function">dim3 <span class="title">dimBlock</span><span class="params">(<span class="number">16</span>, <span class="number">16</span>)</span></span>;</span><br><span class="line">    <span class="function">dim3 <span class="title">dimGrid</span><span class="params">((width  + dimBlock.x - <span class="number">1</span>) / dimBlock.x,</span></span></span><br><span class="line"><span class="params"><span class="function">                 (height + dimBlock.y - <span class="number">1</span>) / dimBlock.y)</span></span>;</span><br><span class="line">    transformKernel&lt;&lt;&lt;dimGrid, dimBlock&gt;&gt;&gt;(output, width, height,</span><br><span class="line">                                           angle);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放device memory</span></span><br><span class="line">    <span class="built_in">cudaFreeArray</span>(cuArray);</span><br><span class="line">    <span class="built_in">cudaFree</span>(output);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>6.3 二维纹理内存，由于此处是在处理<code>DIM x DIM</code>大小的图像问题，所以这里使用二维纹理内存更加合适，官方也建议尽量使用二维纹理内存。首先要清楚这里处理热传递问题有点类似<code>5-point stencil</code>的问题，即以坐标(x, y)为中心，然后对其上下左右的数据进行调用，刚好也是个二维平面。二维纹理内存的使用同样需要一维中的三大步。只是内置函数变化一下，而且不需要再使用全局偏移来定义位置，因为内存刚好也是二维的。eg:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">texture&lt;<span class="type">float</span>, <span class="number">2</span>&gt; texIn;  <span class="comment">//声明一个float类型的二维纹理内存引用</span></span><br><span class="line"><span class="built_in">cudaMalloc</span>((<span class="type">void</span>**)&amp;date.dev_inSrc, imageSize);  <span class="comment">//分配一块打算作为纹理内存的空间</span></span><br><span class="line"><span class="comment">//将二维纹理引用与内存空间绑定并希望将指定的空间作为纹理内存使用</span></span><br><span class="line"><span class="built_in">cudaBindTexture2D</span>(<span class="literal">NULL</span>, texIn, date.dev_inSrc, desc, DIM, DIM, DIM * <span class="built_in">sizeof</span>(<span class="type">float</span>)); </span><br><span class="line"></span><br><span class="line"><span class="type">int</span> x = threadIdx.x + blockIdx.x * blockDim.x;</span><br><span class="line"><span class="type">int</span> y = threadIdx.y + blockIdx.y * blockDim.y;</span><br><span class="line"><span class="type">int</span> offset = x + y * blockDim.x * gridDim.x;</span><br><span class="line"><span class="type">float</span> t;  <span class="comment">//用于存放从纹理内存中读取的值</span></span><br><span class="line">t = <span class="built_in">text2D</span>(texIn, x, y<span class="number">-1</span>);  <span class="comment">//读取二维纹理内存中的数据到t中，注意(x, y)为中心，它上面的元素自然就是(x, y-1)</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cudaUnbindTexture</span>(texIn);  <span class="comment">//解除绑定</span></span><br><span class="line"><span class="built_in">cudaFree</span>(d-&gt;dev_inSrc);  </span><br></pre></td></tr></table></figure>
<p>关于纹理内存使用的官方DOC：<a href="http://docs.nvidia.com/cuda/cuda-driver-api/group__CUDA__TEXREF.html#axzz3ggCvFftU">http://docs.nvidia.com/cuda/cuda-driver-api/group__CUDA__TEXREF.html#axzz3ggCvFftU</a></p>
<p>6.4 纹理内存选择一维还是二维应根据具体情况而定，哪个<code>coding</code>起来更方便就选择哪个，其对基本没有区别。</p>
<h3 id="Surface-Memory"><a href="#Surface-Memory" class="headerlink" title="Surface Memory"></a>Surface Memory</h3><p>Surface Memory的使用与纹理非常像，以后用到了再了解吧，官方使用文档在此<a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#surface-memory">http://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#surface-memory</a></p>
<h2 id="图形互操作性"><a href="#图形互操作性" class="headerlink" title="图形互操作性"></a>图形互操作性</h2><p>7.1 主要介绍<code>CUDA</code>可以执行通用计算将以前需要依赖CPU进行的图像渲染工作由GPU实现。这样的好处是首先GPU的并行性使得速度通常会更高，另一方面可以使CPU空闲出来做其他工作。这里主要介绍了<code>CUDA</code>与<code>OpenGL</code>的图形互操作，以及<code>CUDA C</code>核函数与<code>OpenGL</code>渲染函数之间共享数据。所以用到了大量<code>OpenGL</code>的知识，而且也主要是为了实现由GPU进行界面渲染，以后有需要再补充。</p>
<h2 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h2><p>8.1 计算功能集就是<code>Compute Capability</code>表示<code>NVIDIA GPU</code>所能支持的最高指令集版本。可以通过<code>cudaDeviceProp prop</code>结构体的<code>prop.major</code>和<code>prop.minor</code>来查看，我的机器上是<code>5.0</code>，由于计算功能集是向下兼容的，所以高版本支持所有低版本的指令操作。</p>
<p>8.2 可以通过为<code>nvcc</code>指定参数来告诉编译器所需要的最小计算功能集。例如你编写的程序中用到了3.5版本的某个新指令，而该指令在3.5以下版本中没有，那么可以在编译时加上参数<code>-arch=sm_35</code>，这样做的另一个好处是可以让编译器使用高版本的编译优化。eg: <code>nvcc test.cu -o test -arch=sm_11</code></p>
<p>8.3 原子操作是指由于某些操作的执行过程不能分解为更小的部分，而必须连续的不能被其他线程所中断地执行，我们将满足这种条件限制的操作称为原子操作。例如<code>x++;</code>，即是执行三个步骤：读取x-修改x-写入x，这三个过程一旦被打断，有可能最终获取一个不正确的x，所以就必须确保这三个过程是一个整体的操作。由于GPU线程的并行性导致这种情况很容易存在。</p>
<p>8.4 <code>CUDA</code>中可以使用<code>cudaMemset()</code>函数在GPU上为某块内存指定初始值，类似与<code>C/C++</code>中的<code>memset()</code>，但其返回值为错误码。<code>memset()</code>函数原型为说明：<code>void *memset(void *s, char ch, unsigned n);</code> 将s所指向的某一块内存中的每个字节的内容全部设置为ch指定的ASCII值,块的大小由第三个参数指定,这个函数通常为新申请的内存做初始化工作。</p>
<p>8.5 注意书上在验证GPU计算的直方图与CPU计算的直方图是否一样时巧妙地使用了逆序的方式计算。具体方法就是在GPU计算完直方图之后将计算结果复制回主机内存中。由于GPU计算直方图时字节流中一共有256个元素，设定含有256个元素的数组，字节流中的内容作为数组下标，然后对数组元素进行递增，最终遍历完这些字节之后数组中肯定就保存了各个字节的个数。现在反过来遍历所有数组并对数组元素进行递减，数组下标依然为字节流的内容，当所有字节遍历完是数组的所有元素应该为0，否则GPU计算肯定有问题。eg:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;SIZE；i++)</span><br><span class="line">    histo[buffer[i]]--;  <span class="comment">//histo存放直方图数据，buffer为字节流，SIZE为总字节数</span></span><br><span class="line"><span class="comment">//若GPU计算正确，此时histo中的所有元素应该为0</span></span><br></pre></td></tr></table></figure>
<p>8.6 实现原子操作的内置函数是<code>atomicAdd(addr, y)</code>，该函数将生成一个原子操作序列，这个操作序列包括读取地址<code>addr</code>处的值，将<code>y</code>增加到这个值，以及将结果保存回原地址<code>addr</code>。eg:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#defie SIZE (100*1024*1024)</span></span><br><span class="line"><span class="function">__global__ <span class="type">void</span> <span class="title">histo_kernel</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *buffer, <span class="type">long</span> size, <span class="type">unsigned</span> <span class="type">int</span> *histo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = threadIdx.x + blockIdx.x * blockDim.x;</span><br><span class="line">    <span class="type">int</span> stride = blockDim.x * gridDim.x;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; size)</span><br><span class="line">    &#123;</span><br><span class="line">	<span class="built_in">atomicAdd</span>(&amp;(histo[buffer[i]]), <span class="number">1</span>);  </span><br><span class="line">	<span class="comment">/*核函数调用将启动256个线程，每个线程的初始值都是0到线程数量减1之间，然后对其进行偏移，偏移</span></span><br><span class="line"><span class="comment">	量为已启动线程的总数，直到遍历完所有字节流。所以buffer[i]一定可以遍历完所以字节流，且其值为0到255之间，</span></span><br><span class="line"><span class="comment">	因为一个字节8位*/</span></span><br><span class="line">	i += stride;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个核函数效率非常低，因为这将启动数千个线程同时在全局内存中进行原子操作，而且是操作一个只有256个元素的数组，当数千个个线程尝试访问少量的内存位置时，必将发生大量的线程竞争。为了确保递增操作的原子性，对相同内存位置的操作都将被硬件串行化，极大降低并行带来的性能提升。改进方法就是使用共享内存，因为共享内存中是线程块中的线程之间竞争。</p>
<p>8.7 由于共享内存只能由同一个线程块中的线程之间进行访问，而此例中一个线程块中只有256个线程，而结果数据刚好是256个元素。所以当使用共享内存存储直方图结果时将只有256个线程在256个地址上发生竞争。具体的实现方式是分两个阶段，第一个阶段是每个线程块将计算的它所处理数据的直方图结果保存到一个临时数组，此时线程块之间的操作都是相互独立的，因为它们只能操作自己的那块共享内存。第二个阶段是使用原子操作将每个线程块中的结果保存到全局内存中，因为每个线程都可以访问全局内存。eg:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#defie SIZE (100*1024*1024)</span></span><br><span class="line"><span class="function">__global__ <span class="type">void</span> <span class="title">histo_kernel</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *buffer, <span class="type">long</span> size, <span class="type">unsigned</span> <span class="type">int</span> *histo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __shared__ <span class="type">unsigned</span> <span class="type">int</span> temp[<span class="number">256</span>];</span><br><span class="line">    temp[threadIdx.x] = <span class="number">0</span>;  <span class="comment">//利用每个线程将temp初值设置为0</span></span><br><span class="line">    __syncthreads();  <span class="comment">//由于操作共享内存，所以同步线程以确保所以写入操作完成</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i = threadIdx.x + blockIdx.x * blockDim.x;</span><br><span class="line">    <span class="type">int</span> stride = blockDim.x * gridDim.x;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; size)</span><br><span class="line">    &#123;</span><br><span class="line">	<span class="built_in">atomicAdd</span>(&amp;(temp[buffer[i]]), <span class="number">1</span>);  </span><br><span class="line">	<span class="comment">/*核函数调用将启动256个线程，每个线程的初始值都是0到线程数量减1之间，然后对其进行偏移，偏移</span></span><br><span class="line"><span class="comment">	量为已启动线程的总数，直到遍历完所有字节流。所以buffer[i]一定可以遍历完所以字节流，且其值为0到255之间，</span></span><br><span class="line"><span class="comment">	因为一个字节8位*/</span></span><br><span class="line">	i += stride;</span><br><span class="line">    &#125;</span><br><span class="line">    __syncthreads();  <span class="comment">//每次对共享内存的写入操作之后都要进行线程同步</span></span><br><span class="line">    <span class="built_in">atomicAdd</span>(&amp;(histo[threadIdx.x]), temp[threadIdx.x]);  </span><br><span class="line">    <span class="comment">//利用每个线程将其计算的直方图数据通过全局内存的原子操作增加到最终结果中。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>8.8 原子操作很简单，只是将需要进行原子操作的运算使用相应的原子操作函数实现即可，但一定要注意由于线程竞争引起的性能降低问题。更多原子操作参见官方DOC: <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#axzz3ggCvFftU">http://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#axzz3ggCvFftU</a></p>
<h2 id="页锁定主机内存-CUDA流"><a href="#页锁定主机内存-CUDA流" class="headerlink" title="页锁定主机内存|CUDA流"></a>页锁定主机内存|CUDA流</h2><p>9.1 以上所有讨论的GPU并行计算都是在进行数据并行性计算，即使用多个线程在大量的数据上执行同一个任务。另一种并行性即CPU中多线程应用程序的任务并行性，即并行地执行两个或多个不同的任务，如同一个程序下载的同时播放音乐。</p>
<p>9.2 页锁定主机内存是指通过<code>CUDA</code>的<code>cudaHostAlloc()</code>函数来在主机上分配一块页锁定的主机内存，也就是固定在物理内存上的主机内存。通过<code>malloc()</code>函数分配的内存为标准的可分页的(Pagable)主机内存，也就是说这段内存有可能被操作系统通过内存分配技术交换到磁盘上，例如<code>windows</code>上的虚拟内存文件<code>pagefile.sys</code>，<code>windows8</code>上的<code>swapfile.sys</code>以及<code>linux</code>系统中的<code>swap</code>分区。所以被转移到分页文件上的内存在一定程度上会降低程序性能。如果使用页锁定主机内存则可以避免这个问题，从而获得2倍以上的性能提升。但过多的使用页锁定主机内存会影响操作系统性能，导致系统更快地耗尽内存。</p>
<p>9.3 页锁定内存的使用与普通内存使用一样，需要先使用<code>cudaHostAlloc()</code>分配页锁定内存，然后使用<code>cudaFreeHost()</code>释放使用过的页锁定内存。eg:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> *a;</span><br><span class="line"><span class="built_in">cudaHostAlloc</span>((<span class="type">void</span>**)&amp;a, size * <span class="built_in">sizeof</span>(*a), cudaHostAllocDefault);  </span><br><span class="line"><span class="comment">//some operation</span></span><br><span class="line"><span class="built_in">cudaFreeHost</span>(a);</span><br></pre></td></tr></table></figure>
<p>更多关于页锁定内存的内容参见官方DOC: <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#page-locked-host-memory">http://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#page-locked-host-memory</a></p>
<p>9.4 <code>CUDA</code>流表示一个GPU操作队列，并且该队列中的操作将以指定的顺序指行。可以在流中添加一些操作，例如核函数启动，内存复制，以及事件的启动和结束等，将这些操作添加的流的顺序就是它们的执行顺序。</p>
<p>9.5 <code>CUDA</code>单个流的使用：首先可以通过设备属性中的<code>deviceOverlap</code>字段确定设备是否支持重叠(Device Overlap)功能,支持重叠功能的设备能够在执行核函数的同时在设备与主机之间执行复制操作。使用流之前需要使用<code>cudaStream_t</code>定义流，使用<code>cudaStreamCreate()</code>函数创建流，在异步内存复制以及核函数调用中使用流，然后需要使用<code>cudaStreamSynchronize()</code>函数对指定的流在GPU与主机之间进行同步，以告诉主机在继续执行之前要首先等待GPU执行完成。最后需要在退出程序之前使用<code>cudaStreamDestory()</code>函数销毁对GPU操作进行排队的流。eg:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N (1024*1024)	<span class="comment">//将需要处理的总数据分成20份，每份大小为N</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FULL_DATA_SIZE (N*20)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化流</span></span><br><span class="line">cudaStream_t stream;</span><br><span class="line"><span class="built_in">cudaStreamCreate</span>(&amp;stream);</span><br><span class="line"></span><br><span class="line"><span class="comment">//为了简化代码只声明输入数据a，输出数据对应为c</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> *host_a, *dev_a;</span><br><span class="line"><span class="built_in">cudaMalloc</span>((<span class="type">void</span>**)&amp;dev_a, N * <span class="built_in">sizeof</span>(<span class="type">int</span>));  <span class="comment">//在GPU上分配占需要处理的总数据量1/20的空间</span></span><br><span class="line"><span class="built_in">cudaHostAlloc</span>((<span class="type">void</span>**)&amp;host_a, FULL_DATA_SIZE * <span class="built_in">sizeof</span>(<span class="type">int</span>), cudaHostAllocDefault);  <span class="comment">//在主机页锁内存上分配总数据量的空间</span></span><br><span class="line"><span class="comment">//此处对数组填充</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//通过循环20次将总的数据分成20个小数据块以异步方式复制到GPU进行处理</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;FULL_DATA_SIZE; i+=N)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cudaMemcpyAsync</span>(dev_a, host_a+i, N * <span class="built_in">sizeof</span>(<span class="type">int</span>), cudaMemcpyHostToDevice, stream); <span class="comment">//将数据从主机页锁内存复制到设备内存</span></span><br><span class="line">   kernel&lt;&lt;&lt;N/<span class="number">256</span>, <span class="number">256</span>, <span class="number">0</span>, stream&gt;&gt;&gt;(dev_a, dev_c);  <span class="comment">//指定流的函数调用</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cudaMemcpyAsync</span>(host_c+i, dev_c, N * <span class="built_in">sizeof</span>(<span class="type">int</span>), cudaMemcpyDeviceToHost, stream); <span class="comment">//将处理完的数据复制回页锁内存</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>9.6 <code>cudaMemcpy()</code>是以同步方式执行，即当函数返回时复制操作已经完成，并且输出缓冲区中已经包含了复制进去的数据。而<code>cudaMemcpyAsync()</code>是以异步方式执行，即调用函数时只是放置一个请求，表示在这个流队列中执行一次内存复制操作，告诉GPU在它执行完前面的工作之后开始执行这个工作，所以无法保证当函数返回时复制操作是否已经启动。但可以确定复制操作肯定会在下一个被放入流的操作执行之前执行，例如上例中的核函数调用也在这个流中，那么核函数调用之前肯定会先执行完复制操作。任何被传递给<code>cudaMemcpyAsync()</code>的主机内存指针都必须已经通过<code>cudaHostAlloc()</code>分配好内存。</p>
<p>9.7 为了确保GPU流队列中的操作都已经在主机继续执行之前执行完成，必须使用<code>cudaStreamSynchronize(&amp;stream)</code>来同步指定的流。此处的同步是批让GPU与主机同步，以免CPU开始执行下一条需要用到GPU正在处理的数据指令时GPU却还没有执行完。</p>
<p>9.8 使用多个<code>CUDA</code>流：首先确保GPU支持重叠功能，然后开始调度流即可。需要注意的是使用两个流处理的数据量将是使用单个流的两倍，而且由于硬件中并没有流，而是包含一个或者多个引擎来执行内存复制操作，以及一个引擎来执行核函数，这些引擎也会以队列的形式执行，它们在安排队列执行时有可能出现阻塞的情况，从而导致多个流并不一定会加速程序执行。</p>
<p>9.9 将操作放入流队列的顺序将影响程序性能，应该采用宽度优化方式或者轮流加入流而非深度优先方式将操作放入队列，也就是说应该将两个流中的复制以及核函数调用的操作交替的放入流中以避免由于第0个流复制其结果数据之前必须执行核函数而导致此时内存复制引擎阻塞的情况。根据官方说明将流应用好了可以使程序性能获得近2倍的提升。</p>
<p>更多关于流的内存参见官方DOC: <a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#streams">http://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#streams</a>  </p>
<h2 id="零拷贝内存-可移动的固定内存"><a href="#零拷贝内存-可移动的固定内存" class="headerlink" title="零拷贝内存|可移动的固定内存"></a>零拷贝内存|可移动的固定内存</h2><p>10.1 零拷贝内存是指通过给<code>cudaHostAlloc()</code>函数传递<code>cudaHostAllocMapped</code>参数来在主机内存上分配一块GPU可以直接访问的页锁定内存(或称固定内存)，由于其不需要由主机复制到GPU所以称为零拷贝内存。</p>
<p>10.2 零拷贝内存在使用前应该通过设备属性中的字段<code>canMapHostMemory</code>来判断设备是否支持映射主机内存。如果支持那么还需要通过函数<code>cudaSetDeviceFlags()</code>将<code>CUDA</code>运行时设定为能分配零拷贝内存的状态。eg: <code>cudaSetDeviceFlags(cudaDeviceMapHost);</code></p>
<p>10.3 零拷贝内存的分配与页锁定内存类似，只是在分配时可以通过指定额外的标志<code>cudaHostAllocWriteCombined</code>参数将内存分配为“合并式写入”来提高GPU读取内存时的性能，但是当CPU也需要读取这块内存时，效率会低很多，所以要提前考虑应用程序可能的访问模式来决定是否使用这个参数。eg: <code>cudaHostAlloc((void**)&amp;a, size*sizeof(float), cudaHostAllocWriteCombined | cudaHostAllocMapped);</code></p>
<p>10.4 由于GPU的虚拟内存空间地址映射与CPU不同，而<code>cudaHostAlloc()</code>返回的是CPU上的指针，所以需要调用<code>cudaHostGetDevicePointer()</code>函数来获得这块内存在GPU上的指针。然后就可以将这个指针直接传递给核函数了。eg: <code>cudaHostGetDevicePointer(&amp;dev_a, a, 0);</code></p>
<p>10.5 由于核函数在执行期间，零拷贝内存中的内容是未定义的，CPU无法确定GPU在其上的执行是否完成，所以还需要在核函数调用完成之后调用<code>cudaThreadSynchronize()</code>函数来将CPU与GPU进行同步。该函数的调用不需要指定参数。</p>
<p>10.6 最后就是释放分配的内存，零拷贝内存是通过<code>cudaHostAlloc()</code>分配，所以释放与页锁定内存一样使用<code>cudaFreeHost()</code>即可。</p>
<p>10.7 零拷贝内存的性能提升: 对于独立GPU通常可能无效，对于集成GPU由于GPU与CPU共享系统内存，所以通常可以获得性能提升。但即使是集成GPU零拷贝内存也只有当输入内存和输出内存都只被使用一次时零拷贝内存才能带来性能提升。由于GPU不会缓存零拷贝内存中的内容，所以当需要多次读取内存时，使用零拷贝内存将得不偿失，远不如一开始就直接将数据复制到GPU。而且使用零拷贝内存也同样会固定地占用系统物理内存，最终导致系统性能降低。</p>
<p>10.8 可以通过<code>integrated</code>字段来判断GPU是集成的还是独立的。</p>
<p>10.9 页锁定内存(固定内存)只是对划分他的线程来说这些内存是页锁定的，如果要在线程之间共享指向这块内存的指针，那么其他的线程将把这块内存视为标准的、可分页的内存。这种情况将导致以下两种副作用：1).其他线程在这块内存上执行<code>cudaMemcpy()</code>操作时将按照标准的可分页的内存速率事执行复制操作，这种速率仅为最高传输速率的50%左右。2).当线程试图将<code>cudaMemcpyAsync()</code>调用放入CUDA流队列时将失败，因为该函数需要使用固定内存。</p>
<p>10.10 可以在分配内存时指定标志位<code>cudaHostAllocPortable</code>来将内存指定为可移动的，也就是说在其他线程来看，这块内存都是固定内存。该标志还可以与<code>cudaHostAllocWriteCombined</code>和<code>cudaHostAllocMapped</code>一起使用来将内存分配为可移动的、零拷贝的以及合并式写入等的任意组合。eg: <code>cudaHostAlloc((void**)&amp;a, N*sizeof(float), cudaHostAllocWriteCombined | cudaHostAllocMapped | cudaHostAllocPortable);</code>，记得在分配页锁定内存之前首先要调用<code>cudaSetDevice(device_id);</code>和<code>cudaSetDeviceFlags(cudaDeviceMapHost);</code>来将<code>CUDA</code>运行时设定为可以映射的。同样使用零拷贝内存时需要使用<code>cudaHostGetDevicePointer(&amp;dev_a, a, 0);</code>来获得主机内存的有效设备指针。</p>
<h2 id="多GPU系统上的CUDA-C"><a href="#多GPU系统上的CUDA-C" class="headerlink" title="多GPU系统上的CUDA C"></a>多GPU系统上的CUDA C</h2><p>使用多个GPU只需要使用多个CPU线程即可，即在CPU线程中指定GPU设备ID，让每个CPU线程管理一个GPU设备，然后对计算数据进行根据GPU性能进行划分。</p>
<h2 id="总结与补充"><a href="#总结与补充" class="headerlink" title="总结与补充"></a>总结与补充</h2><h3 id="CUDA的所有内存总结"><a href="#CUDA的所有内存总结" class="headerlink" title="CUDA的所有内存总结"></a><code>CUDA</code>的所有内存总结</h3><p><img data-src="cuda_memories.jpg" alt="CUDA硬件内存访问权限及特性"></p>
<p>图中没有涉及页锁定主机内存(<code>Page-Locked Host Memory</code>)或者固定内存(<code>Pinned Memory</code>)、可移动的固定内存(<code>Portable Pinned Memory</code>)以及零拷贝内存(<code>Zero-Copy Memory</code>)，因为这些内存都是通过映射主机内存而实现的，它们不在<code>CUDA</code>硬件中。</p>
<ul>
<li>全局内存(global memory)空间最大也就是<code>DRAM</code>，主要用于设备与主机之间进行数据通信，其存取延迟较高，所以不适合频繁读写。使用<code>cudaMalloc()</code>分配的就是全局内存。解决其高延迟的方法: 将数据分块然后使用<code>shared-memory</code>、当执行当前数据时预取下一个数据到寄存器中等。</li>
</ul>
<p><strong>对于2D/3D内存建议使用<code>cudaMallocPitch()/cudaMalloc3D()</code></strong><br>为了获取到更好的性能，官方建议使用这2个函数用于分配2D和3D的显存，详见：<br><a href="http://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory">http://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#device-memory</a></p>
<h3 id="CUDA中变量声明总结"><a href="#CUDA中变量声明总结" class="headerlink" title="CUDA中变量声明总结"></a><code>CUDA</code>中变量声明总结</h3><p><img data-src="cuda_memories_usage.jpg" alt="CUDA内存定义方式及生命周期和作用域"><br>其中生命周期为<code>kernel</code>的必须在<code>kernel</code>函数中声明且仅仅在这个核函数中是有效的，生命周期为<code>Application</code>的变量必须在任何函数外部声明。注意不属于任何函数，且声明于全局内存和常量内存中的变量可以被主机访问，常量内存在大小被限制为<code>64KB</code>。</p>
<ul>
<li>所有设备代码中声明的自动变量(即不加额外前缀的变量)，通常都分配在寄存器上，但有些情况下有可能会将其放在局部内存中。</li>
</ul>
<h3 id="CUDA线程的总结"><a href="#CUDA线程的总结" class="headerlink" title="CUDA线程的总结"></a><code>CUDA</code>线程的总结</h3><ul>
<li>同一个线程格中的所有线程执行同一个核函数，也就是说一个线程格只能对应一个核函数</li>
<li>线程格可以以一维、二维、三维数组的方式组织线程块(gridDim.x, gridDim.y, gridDim.z)</li>
<li>每个线程块可以以一维、二维、三维的数组方式组织线程(blockDim.x, blockDim.y, and blockDim.z)</li>
<li>核函数一经调用，它的维数将无法再改变</li>
<li>同一个线程格中的所有线程块具有相同的维度</li>
<li>一个线程块中可以包含的最大线程总数为1024(不同的硬件不一定一样)。也就是说当使用多维线程块来组织线程时各维总乘积必须在这个每个线程块中最大线程总数之内，例如我的机器使用属性输出结果为“  Maximum number of threads per block:1024, Max dimension size of a thread block (x,y,z): (1024, 1024, 64)”，并不是说我可以定义的三维线程块<code>dim3 blocks(x, y, z);</code>中的<code>x,y,z</code>可以取的最大值分别为<code>1024, 1024, 64</code>，而是<code>x*y*z &lt;= 1024</code>。线程格如何有限制也是如此，只是线程格维度较大。(ps:当时这里我理解错了，检查一个下午无解，直到后来添加了错误处理才发现，所以一定要写上错误处理)</li>
<li>线程块一旦指派给某个流处理器(SM=streaming multiprocessor)，则该线程块中的所有线程必须全部在这个SM中执行。也就是说同一个线程块中的所有线程将在同一个SM中执行。</li>
<li>指派给SM的线程块中的线程以线程束(warp)的形式组织。线程束就是SM中的线程队列单元即SM的最小组成单元，线程束中的线程ID是连续递增的。一般一个线程束中只有32个线程。</li>
<li>线程束的执行速度与该线程束中执行最慢的线程一样，因为线程束中的所有线程“步调一致”地执行。</li>
<li>对于线程来说我们需要关注硬件限制的如下参数: <code>threads/SM</code>, <code>blocks/SM</code>, <code>threads/block</code>, <code>threads/warp</code></li>
<li>同一个SM中的线程共享资源，所以为了性能最大化，通常应该优化线程中的资源占用，以保证我们的SM中的线程全部可以启动（因为当前资源不够时，CUDA会以wrap为单位来减少每个SM中的线程启动数量）。我们可以同时并行执行的线程数量也就是SM的总数乘以每个SM中可以执行的最大线程数，当我们需要启动的总线程数超过这个数字时，CUDA实际上会将需要启动的block组成队列，以block为单位来调度执行这些线程。而我们的核函数定义中实际上可以启动的线程总数除了受官方CUDA定义中的限制之外，主要还是受到我们的核函数对资源占用的限制。</li>
</ul>
<p><strong>关于deviceQuery给出的数据</strong><br>下面是我当前显卡<code>GTX1080</code>的输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CUDA Device Query (Runtime API) version (CUDART static linking)</span><br><span class="line"></span><br><span class="line">Detected 1 CUDA Capable device(s)</span><br><span class="line"></span><br><span class="line">Device 0: &quot;GeForce GTX 1080&quot;</span><br><span class="line">  CUDA Driver Version / Runtime Version          9.1 / 9.0</span><br><span class="line">  CUDA Capability Major/Minor version number:    6.1</span><br><span class="line">  Total amount of global memory:                 8192 MBytes (8589934592 bytes)</span><br><span class="line">  (20) Multiprocessors, (128) CUDA Cores/MP:     2560 CUDA Cores</span><br><span class="line">  GPU Max Clock rate:                            1734 MHz (1.73 GHz)</span><br><span class="line">  Memory Clock rate:                             5005 Mhz</span><br><span class="line">  Memory Bus Width:                              256-bit</span><br><span class="line">  L2 Cache Size:                                 2097152 bytes</span><br><span class="line">  Maximum Texture Dimension Size (x,y,z)         1D=(131072), 2D=(131072, 65536), 3D=(16384, 16384, 16384)</span><br><span class="line">  Maximum Layered 1D Texture Size, (num) layers  1D=(32768), 2048 layers</span><br><span class="line">  Maximum Layered 2D Texture Size, (num) layers  2D=(32768, 32768), 2048 layers</span><br><span class="line">  Total amount of constant memory:               65536 bytes</span><br><span class="line">  Total amount of shared memory per block:       49152 bytes</span><br><span class="line">  Total number of registers available per block: 65536</span><br><span class="line">  Warp size:                                     32</span><br><span class="line">  Maximum number of threads per multiprocessor:  2048</span><br><span class="line">  Maximum number of threads per block:           1024</span><br><span class="line">  Max dimension size of a thread block (x,y,z): (1024, 1024, 64)</span><br><span class="line">  Max dimension size of a grid size    (x,y,z): (2147483647, 65535, 65535)</span><br><span class="line">  Maximum memory pitch:                          2147483647 bytes</span><br><span class="line">  Texture alignment:                             512 bytes</span><br><span class="line">  Concurrent copy and kernel execution:          Yes with 2 copy engine(s)</span><br><span class="line">  Run time limit on kernels:                     Yes</span><br><span class="line">  Integrated GPU sharing Host Memory:            No</span><br><span class="line">  Support host page-locked memory mapping:       Yes</span><br><span class="line">  Alignment requirement for Surfaces:            Yes</span><br><span class="line">  Device has ECC support:                        Disabled</span><br><span class="line">  CUDA Device Driver Mode (TCC or WDDM):         WDDM (Windows Display Driver Model)</span><br><span class="line">  Device supports Unified Addressing (UVA):      Yes</span><br><span class="line">  Supports Cooperative Kernel Launch:            No</span><br><span class="line">  Supports MultiDevice Co-op Kernel Launch:      No</span><br><span class="line">  Device PCI Domain ID / Bus ID / location ID:   0 / 1 / 0</span><br><span class="line">  Compute Mode:</span><br><span class="line">     &lt; Default (multiple host threads can use ::cudaSetDevice() with device simultaneously) &gt;</span><br><span class="line"></span><br><span class="line">deviceQuery, CUDA Driver = CUDART, CUDA Driver Version = 9.1, CUDA Runtime Version = 9.0, NumDevs = 1</span><br></pre></td></tr></table></figure>

<p>上面的数据可以看到我的显卡上20个SM，每个SM最多可以有有2048个线程（Maximum number of threads per multiprocessor:  2048），那我的显卡一次最大可执行的并发线程数量即<code>20 * 2048 = 40960</code>，从上面的数据中也可以看出我的显卡每个SM中最多可以包含2048个线程，那么也就最少可以包含2个block，因为一个block最多可以有1024个线程，一个wrap是32个线程，那一个SM就可以有64个wrap。<br>欢迎参考这里<a href="https://stackoverflow.com/questions/2392250/understanding-cuda-grid-dimensions-block-dimensions-and-threads-organization-s">Understanding CUDA grid dimensions, block dimensions and threads organization</a></p>
<h3 id="CUDA中函数声明与调用总结"><a href="#CUDA中函数声明与调用总结" class="headerlink" title="CUDA中函数声明与调用总结"></a><code>CUDA</code>中函数声明与调用总结</h3><table>
<thead>
<tr>
<th>声明方式</th>
<th>执行硬件</th>
<th>调用者</th>
</tr>
</thead>
<tbody><tr>
<td><code>__device__ type DeviceFunc()</code></td>
<td>device</td>
<td>device</td>
</tr>
<tr>
<td><code>__global__ void KernelFunc()</code></td>
<td>device</td>
<td>Host</td>
</tr>
<tr>
<td><code>__host__ type HostFunc()</code></td>
<td>Host</td>
<td>Host</td>
</tr>
</tbody></table>
<ul>
<li>核函数返回值必须是<code>void</code></li>
<li><code>__device__</code>和<code>__host__</code>可以同时使用，单独使用<code>__host__</code>与不使用任何前缀直接声明是一样的</li>
<li>在编译认为合适的情况下会默认将所有<code>__device__</code>函数编译为<code>inline</code>的内联函数，使用<code>__noinline__</code>可以提示编译器在可能的情况下不进行设备函数的内联化，但此时函数体必须与声明在同一个文件。使用<code>__forceinline__</code>能够强制编译器将函数内联化。  </li>
<li><code>__global__</code>声明的核函数可以增加两个额外的参数用于指定动态分配的共享内存大小和流<code>kernel&lt;&lt;&lt;&gt;&gt;&gt;(Dg, Db, Ns, S);</code>。其中<code>Dg</code>就是类型为<code>dim3</code>的线程格大小和维数，也就是启动<code>Dg.x * Dg.y * Dg.z</code>个线程块，注意你机器的限制；<code>Db</code>为<code>dim3</code>类型的线程块大小和维数，也就是每个线程块启动<code>Db.x * Db.y * Db.z</code>个线程，这个参数注意最后一维大小通常较小，例如我的机器是64。<code>Ns</code>是<code>size_t</code>类型，用于指定每个线程块除了静态分配的<code>shared-memory</code>之外动态分配的<code>shared-memory</code>大小,单位<code>byte</code>，这部分动态内存将用于任何使用<code>__shared__</code>声明的外部数组变量，也就是说可以在核函数内部使用<code>extern</code>关键字声明一个不指定大小的数组，然后在调用核函数时通过<code>Ns</code>参数指定大小，注意数组应该为一维，<code>Ns</code>不指定时默认为0；<code>S</code>类型为<code>cudaStream_t</code>，用于指定关联的流，不指定时默认值为0。</li>
</ul>
<h3 id="CUDA中所有需要同步的操作"><a href="#CUDA中所有需要同步的操作" class="headerlink" title="CUDA中所有需要同步的操作"></a><code>CUDA</code>中所有需要同步的操作</h3><ul>
<li><code>__syncthreads();</code> 无需指定参数，只能有核函数调用，对同一个块中的所有线程进行同步，确保所有线程在执行完该语句之前的所有语句之后才会一起开始执行下一条语句。特别是当使用<code>shared-memory</code>时，要使用一个同步来保证对共享内存的写操作都已经完成。<strong>注意要避免出现线程发散的情况</strong>。</li>
<li><code>cudaEventSynchronize(stop);</code> 指定需要同步的事件，由主机调用。用于CPU同步事件，确保在CPU执行该语句下一条语句之前所有对事件的操作都已经完成。<strong>该语句只能用于同步仅含有GPU代码的事件。</strong></li>
<li><code>cudaStreamSynchronize(&amp;stream)</code> 指定需要同步的流，由主机调用。用于对指定的流在CPU和GPU之间进行同步，以确保在CPU继续执行之前，GPU流队列中的所有操作都已经完成。</li>
<li><code>cudaDeviceSynchronize()</code>或者这个老函数<code>cudaThreadSynchronize();</code>(该函数官方文档提示不建议使用,未来会被前面的新函数取代)： 无需指定参数，由主机调用。用于调用核函数之后在GPU与CPU之间同步线程，阻塞当前CPU的执行，以确保CPU继续执行之前核函数所有需要处理的任务处理完毕。<strong>特别是在使用零拷贝内存是使用其确保GPU对主机内存的读写已经完成。</strong></li>
<li>所有的同步操作都是阻塞行为，由于GPU是异步执行，也就是说主机调用设备代码后就会立即开始继续执行自己的主机代码，所以需要这些阻塞行为。当不需要额外的同步操作时，额外的同步函数调用必然会降低一定的性能。而复制(<code>cudaMemcpy</code>)等没有明确提出需要进行同步的操作，<code>CUDA</code>都会有隐式同步。</li>
</ul>
<h3 id="关于性能"><a href="#关于性能" class="headerlink" title="关于性能"></a>关于性能</h3><ul>
<li>As we program GPUs we need to pay attention to several performance bottlenecks:<br>  – Branch diversion<br>  – Global memory latency<br>  – Global memory bandwidth<br>  – Limited resources</li>
<li>We have several techniques in our arsenal to enhance performance<br>  – Try to make threads in the same warp follow the same control flow<br>  – Tiling<br>  – Coalescing<br>  – Loop unrolling<br>  – Increase thread granularity<br>  – Trade one resource for another</li>
<li>Pay attention to interaction among techniques</li>
</ul>
<p><strong>首先学习下面的“线程块尺寸确定”文章中的分析，然后根据自己的问题，结合Nvidia Visual Profiler的分析对核函数进行调优</strong></p>
<h3 id="线程块尺寸的确定"><a href="#线程块尺寸的确定" class="headerlink" title="线程块尺寸的确定"></a>线程块尺寸的确定</h3><p>由于线程块尺寸对性能有着非常大的影响，同时还要受到Register、Shared-Memory的限制，所以单独分析在以下链接中<br><a href="http://notes.maxwi.com/2015/08/12/Determine-block-size/">Streaming MultiProcessor、Register、Shared-Memory对线程块尺寸的影响</a></p>
<h3 id="CUDA调试"><a href="#CUDA调试" class="headerlink" title="CUDA调试"></a>CUDA调试</h3><p>官方Nsight使用方法<br><strong>需要注意VS编译选项中要正确添加显卡CodeGeneration选项（对应于选项-arch=sm_62），例如GTX1080的为compute_62,sm_62;否则VS下使用Nsight无法命中断点，</strong></p>
<h3 id="CUDA中的几个重要宏"><a href="#CUDA中的几个重要宏" class="headerlink" title="CUDA中的几个重要宏"></a>CUDA中的几个重要宏</h3><p><code>__CUDACC__</code>：用于区分当前代码是否是由NVCC编译（#ifdef）、还是其他编译器，该宏如果未定义会导致cudaOccupancyMaxPotentialBlockSize等函数无法使用<br><code>__CUDA_ARCH__</code>：用于区分当前代码是在device侧编译（#ifdef）还是host侧编译</p>
<h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h3><ol>
<li>核函数无法启动。通常可以会因为是内存访问越界或者使用到了你的硬件不支持的属性。可以通过调试查看启动失败的原因。然后对照错误提示去官方<code>API</code>中搜索，或者这里<a href="http://www.cs.cmu.edu/afs/cs/academic/class/15668-s11/www/cuda-doc/html/group__CUDART__TYPES_g3f51e3575c2178246db0a94a430e0038.html#g3f51e3575c2178246db0a94a430e0038">http://www.cs.cmu.edu/afs/cs/academic/class/15668-s11/www/cuda-doc/html/group__CUDART__TYPES_g3f51e3575c2178246db0a94a430e0038.html#g3f51e3575c2178246db0a94a430e0038</a></li>
</ol>
]]></content>
      <categories>
        <category>CUDA</category>
      </categories>
      <tags>
        <tag>CUDA</tag>
        <tag>Notes</tag>
        <tag>Top</tag>
      </tags>
  </entry>
  <entry>
    <title>C++静态绑定与动态绑定</title>
    <url>/2016/08/19/static-dynamic-binding/</url>
    <content><![CDATA[<p>首先明确C++中引用或指针的动态类型（dynamic type）与静态类型（static type）可以不同是C++支持多态性（polymorphism）的根本所在。<br>四个概念：</p>
<ul>
<li>静态类型：就是对象声明时采用的类型，一旦确定就无法更改，编译期已经确定 </li>
<li>动态类型：通常是指一个指针或引用在调用时所指向的类型，可以理解为赋值号右侧对象的类型（当然采用直接赋值就是括号中的对象的类型），可以在运行时更改，在运行期决定</li>
<li>静态绑定（static binding）：又名前期绑定（early binding），绑定的是对象的静态类型，发生在编译期，即程序编译完成后就已经确定</li>
<li>动态绑定（dynamic binding）：又名后期绑定（late binding），绑定的是对象的动态类型，发生在运行期，即在运行期由当前的动态类型决定所需要调用的函数或属性</li>
</ul>
<span id="more"></span>

<p>可以简单理解为，通常我们定义的非虚函数都是静态绑定，即静态类型与动态类型都指同一种类型，在编译期就已经确定，那么运行时调用的函数也就是相应类型对象的函数。<br>而虚函数可以发生动态绑定，即在运行时，根据指针或引用所指对象的类型来决定调用相应的虚函数。如当定义父类的指针，指向派生类的对象时，该指针的动态类型与静态类型就不一致,<br>动态类型即派生类，静态类型为父类，那么在使用此指针在运行时调用虚函数时会首先调用动态类型对象（即派生类对象）的虚函数，如果动态类型中没有重写（override）该虚函数，<br>则调用的还是基类中的虚函数。<br>举例说明：<br>所有的讲解都是注释中，请认真阅读每一句注释</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">void</span>)</span>  <span class="comment">//普通的非虚函数，只能静态绑定</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;A::func&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">vfunc1</span><span class="params">()</span>   <span class="comment">//虚函数，可以在运行时，根据动态类型不同而发生动态绑定</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;A::vfunc1&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">vfunc2</span><span class="params">(<span class="type">int</span> i = <span class="number">2</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;A::vfunc2: &quot;</span> &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;B::func&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">vfunc1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;B::vfunc1&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">vfunc2</span><span class="params">(<span class="type">int</span> i = <span class="number">5</span>)</span>  <span class="comment">//注意B改变了继承而来的虚函数的默认参数</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;B::vfunc2: &quot;</span> &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">public</span> B &#123;  <span class="comment">//注意C继承自B而不是A</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    B* pb = <span class="keyword">new</span> <span class="built_in">B</span>();  <span class="comment">//pb的静态类型即是它声明的类型B，动态类型是它指向的类型B，即动态类型与静态类型一致</span></span><br><span class="line">    C* pc = <span class="keyword">new</span> <span class="built_in">C</span>(); <span class="comment">//pc的静态类型与动态类型一致</span></span><br><span class="line">    A* pa = pc;   <span class="comment">//pa的静态类型是A，动态类型是C</span></span><br><span class="line">    pa = pb; <span class="comment">//将pa的动态类型改为B</span></span><br><span class="line">    B *pbnull = <span class="literal">nullptr</span>;  <span class="comment">//定义B指向空指针，它将在编译期发生静态绑定</span></span><br><span class="line">    pa-&gt;<span class="built_in">func</span>();  <span class="comment">//A::func，虽然pa的静态类型与动态类型不一样，但func是不是虚函数，只有在通过指针或引用调用虚函数时，才会有运行时发生动态绑定，即pa优先调用其动态类型中的虚函数，所以此时pa只能调用它自己的func</span></span><br><span class="line">    pa-&gt;<span class="built_in">vfunc1</span>(); <span class="comment">//B::vfunc1，此时pa发生了动态绑定，即调用它动态类型B的虚函数vfunc1</span></span><br><span class="line">    pb-&gt;<span class="built_in">func</span>(); <span class="comment">//B::func，pb的func将隐藏继承自A中的函数func，所有非虚函数的调用都由静态类型决定，即编译期就已经确定了</span></span><br><span class="line">    pb-&gt;<span class="built_in">vfunc2</span>(); <span class="comment">//B::vfunc2:5，pb正常通过静态绑定调用自己的函数vfunc2</span></span><br><span class="line">    pa-&gt;<span class="built_in">vfunc2</span>(); <span class="comment">//B::vfunc2:2，发现pa此时动态绑定调用的是类型B的成员函数，但形参去是A自己的形参，因为C++为了执行效率，缺省参数值都是静态绑定的，所以永远不要重新定义一个继承而来的virtual函数的缺省参数值</span></span><br><span class="line">    pc-&gt;<span class="built_in">func</span>(); <span class="comment">//B::func，pc正常的静态绑定，调用继承自B的函数func</span></span><br><span class="line">    pa = pc;  <span class="comment">//将pa的动态类型改为pc</span></span><br><span class="line">    pa-&gt;<span class="built_in">vfunc1</span>();  <span class="comment">//B::vfunc1，此时pa实际上发生了动态绑定，被动态绑定到pc，将调用其动态类型C中的虚函数，但由于C中没有重写继承自B的虚函数，所以只能调用其父类B中的虚函数，注意不是A中的</span></span><br><span class="line">    pbnull-&gt;<span class="built_in">func</span>();  <span class="comment">//B::func，虽然pbnull此时指向的是空指针，但其静态绑定是在编译期确定的，也就是说编译完成之后，pbnull就已经存在pbnull-&gt;func()的调用了。</span></span><br><span class="line">    <span class="comment">// pbnull-&gt;vfunc1(); //编译没有问题，但将发生运行时错误，linux下运行报错为Segmentation fault。因为在运行时发生动态绑定时，pbnull是指向空指针的，显然空指针不属于任何类型，pbnull也就无法正常绑定。之所以编译器无法检查到这类问题应该就是动态导致用户可以随时将pbnull绑定到一个其派生类的对象上</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//释放动态内存</span></span><br><span class="line">    <span class="keyword">delete</span> pb;</span><br><span class="line">    <span class="keyword">delete</span> pc;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的注释中已经讲解的非常清楚了，最后两句指向空指针的类对象也可以调用其静态绑定的函数需要特别注意，这是一种极不推荐的做法</p>
<p><strong>注意</strong></p>
<ul>
<li>永远不要重新定义继承而来的非虚函数，这样的函数由对象声明时的静太类型确定，没有多态性，将给程序留下不可预知的隐患</li>
<li>永远不要重新定义一个继承而来的虚函数的缺省参数值，因为缺省参数值都是静态绑定的。</li>
<li>接口基类不应该有非虚函数，即全部使用纯虚函数</li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>Top</tag>
        <tag>CPP</tag>
        <tag>C++拾遗</tag>
      </tags>
  </entry>
  <entry>
    <title>实例验证C/C++源代码变成程序的过程</title>
    <url>/2016/06/05/source-to-program/</url>
    <content><![CDATA[<p>本来只是为了从底层了解下堆和栈的区别，以及heap和free-store的区别，结果便引出了从源代码编译开始，直到可执行程序如何加载到内存，以及C/C++内存布局的问题，这里做个总结，主要参考<a href="http://www.gahcep.com/cpp-internals-memory-layout/">C++ Internals :: Memory Layout</a><br>本文所使用的环境：   </p>
<ul>
<li>Ubuntu-14.04 x64 kernel 4.2.0-36-generic</li>
<li>GCC version 4.8.4   </li>
</ul>
<p>需要使用的其他工具：   </p>
<ul>
<li>c++filt – Demangle C++ and Java symbols.详情可以自行查看man手册   </li>
</ul>
<p>C++编译器通常进行以下4个步骤将源代码编译为可执行程序：   </p>
<ul>
<li>预处理器的预处理阶段，替换#开头的内容   </li>
<li>编译器编译阶段，将预处理后的源程序处理成汇编源程序   </li>
<li>汇编器的汇编阶段，将汇编源程序汇编为可重定位的目标二进制程序   </li>
<li>连接器将可生定位的目标程序连接成为可执行的二进制目标程序   </li>
</ul>
<p>以下面这段代码的编译链接过程举例：   </p>
<span id="more"></span>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> PI</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PI 3.1415926</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">float</span> pi = PI;</span><br><span class="line"></span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; numbers &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> n : numbers)</span><br><span class="line">        std::cout &lt;&lt; n * n &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="预处理阶段"><a href="#预处理阶段" class="headerlink" title="预处理阶段"></a>预处理阶段</h2><p>命令：<code>g++ -std=c++11 -E main.cpp &gt; main.ii</code><br>-E参数可以让gcc只对源代码进行预处理，并将预处理之后的代码输出的标准输出中。默认情况下gcc会将预处理之后的代码命名为后缀<code>.ii</code><br>该阶段预处理器会处理以<code>#</code>开头的命令（如#include，#define，#if等），处理之后的输出文件就完全是个纯C++源文件，不再包含预处理命令，当该处理过程将根据#if，#ifdef，#ifndef，#endif来确定是否需要时行相应的处理。其中#include命令中包含的头文件会被替换成相应的文件内容，但通常只是声明，实现部分可能依然在源文件中，但会以特殊标记标出，以便编译器可以找到相应的实现。对于#define定义的宏命令，会直接进行相应内容的替换。<br>由于上例中包含有头文件vector和iostream，这两个头文件中包含有大量声明和实现，所以经过预处理之后会生成一个很大的输出文件，下面以下较简单的例子举例说明：<br><em>t.cpp</em></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> PI</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PI 3.1415926</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> a33 = <span class="number">33</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">float</span> pi = PI * <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> b44 = a33;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>经过预处理之后的文件为<br><em>t.ii</em></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"># <span class="number">1</span> <span class="string">&quot;const_folding.cpp&quot;</span></span><br><span class="line"># <span class="number">1</span> <span class="string">&quot;&lt;built-in&gt;&quot;</span></span><br><span class="line"># <span class="number">1</span> <span class="string">&quot;&lt;command-line&gt;&quot;</span></span><br><span class="line"># <span class="number">1</span> <span class="string">&quot;/usr/include/stdc-predef.h&quot;</span> <span class="number">1</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"># <span class="number">1</span> <span class="string">&quot;&lt;command-line&gt;&quot;</span> <span class="number">2</span></span><br><span class="line"># <span class="number">1</span> <span class="string">&quot;const_folding.cpp&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> a33 = <span class="number">33</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">float</span> pi = <span class="number">3.1415926</span> * <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> b44 = a33;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意上述代码有我额外定义了const的变量，发现在预编译阶段const变量并没有变化，也就是说网上很多人说的常量折叠其实并不是发生在预编译阶段，而是在编译阶段，编译器会将const定义的常量，字符常量表达式（如上面的3.1415926 * 2）替换为结果值<br>从输出代码中可以看出预处理器除了进行了宏替换之外，还增加一些形如：   </p>
<blockquote>
<p><code># linenum filename flags</code>      //注意行号是指相应filename的文件中的行   </p>
</blockquote>
<p>的代码，根据<a href="https://gcc.gnu.org/onlinedocs/cpp/Preprocessor-Output.html">GCC官方文档</a>最后的flags可以包含1、2、3、4，当包含多个时，以空格隔开，具体各自的意思，文档中都有详细说明。   </p>
<h2 id="编译阶段"><a href="#编译阶段" class="headerlink" title="编译阶段"></a>编译阶段</h2><p>编译阶段，编译器使用预处理器的输出文件生成汇编源文件，注意只是汇编源代码，也就是此时的文件还只是文本文件。使用命令：<code>g++ -std=c++11 -S main.ii</code>，<code>-S</code>参数表示GCC只生成汇编源代码，而不进行汇编。默认情况下生成的文件后缀为<code>.s</code>，对于上述代码生成的汇编源码的前17行如下，当然整个文件有1586行。<br><em>main.s</em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">	.file	&quot;main.cpp&quot;</span><br><span class="line">	.section	.rodata</span><br><span class="line">	.type	_ZStL19piecewise_construct, @object</span><br><span class="line">	.size	_ZStL19piecewise_construct, 1</span><br><span class="line">_ZStL19piecewise_construct:</span><br><span class="line">	.zero	1</span><br><span class="line">	.local	_ZStL8__ioinit</span><br><span class="line">	.comm	_ZStL8__ioinit,1,1</span><br><span class="line">	.text</span><br><span class="line">	.globl	main</span><br><span class="line">	.type	main, @function</span><br><span class="line">main:</span><br><span class="line">.LFB1554:</span><br><span class="line">	.cfi_startproc</span><br><span class="line">	.cfi_personality 0x3,__gxx_personality_v0</span><br><span class="line">	.cfi_lsda 0x3,.LLSDA1554</span><br><span class="line">	pushq	%rbp</span><br><span class="line">//.......</span><br></pre></td></tr></table></figure>
<p>由于编译器为了支持C++的函数重载，所以引用了<code>name mangling</code>机制，也就是相当于给所有函数名一个新的名字以区分不同的重载函数，可以使用GNU的<code>c++filt</code>工具来对原汇编源码unmangle name即可得到原名称，命令为<code>cat main.s | c++filt &gt; main_unmangled.s</code>，unmangle之后的部分代码如下：   </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">	.file	&quot;main.cpp&quot;</span><br><span class="line">	.section	.rodata</span><br><span class="line">	.type	std::piecewise_construct, @object</span><br><span class="line">	.size	std::piecewise_construct, 1</span><br><span class="line">std::piecewise_construct:</span><br><span class="line">	.zero	1</span><br><span class="line">	.local	std::__ioinit</span><br><span class="line">	.comm	std::__ioinit,1,1</span><br><span class="line">	.text</span><br><span class="line">	.globl	main</span><br><span class="line">	.type	main, @function</span><br><span class="line">main:</span><br><span class="line">.LFB1554:</span><br><span class="line">	.cfi_startproc</span><br><span class="line">	.cfi_personality 0x3,__gxx_personality_v0</span><br><span class="line">	.cfi_lsda 0x3,.LLSDA1554</span><br><span class="line">	pushq	%rbp</span><br></pre></td></tr></table></figure>

<h2 id="汇编阶段"><a href="#汇编阶段" class="headerlink" title="汇编阶段"></a>汇编阶段</h2><p>汇编阶段使用汇编器将汇编源代码汇编为可重定位的目标程序（relocatable object program），该阶段生成的文件为二进制文件，它的字节码是机器语言指令而不是字符。命令为<code>g++ -std=c++11 -c main.s</code>。<code>-c</code>参数表示只编译而不进行链接，默认输出文件为源程序名加后缀<code>.o</code>。注意汇编的输入文件必须是原汇编文件，而不能是unmangle name之后的文件。可重定位的目标程序相当于是编译器与链接器之间的桥梁，正是由于该中间结果的出现，使得不同的编程语言产生的含有符号表(symbols)和重定位表<code>relocations</code>的目标程序可以被链接器链接到一起成为可执行的目标程序。   </p>
<h2 id="链接阶段"><a href="#链接阶段" class="headerlink" title="链接阶段"></a>链接阶段</h2><p>以下未明天说“可执行”的目标文件是都是指可重定位的目标文件，符号=<code>symbols</code>，重定位=<code>relocations</code><br>该阶段使用链接器将目标文件链接到一个可执行文件或共享库中，该可执行文件将可以由操作系统或者加载器加载到内存中执行。命令为<code>g++ -std=c++11 -o main main.o</code>，如果不指定<code>-o</code>参数，则默认为输出文件名为<code>a.out</code><br>该阶段的实质是链接器通过符号（<code>symbols</code>）和重定位（<code>relocations</code>）将多个可重定位的目标程序中相应的节（section）合并到一个二进制文件中。此处如何合并就要涉及到内存布局的问题，参见<a href="">C++内存布局</a><br>关于symbols和relocations的详细介绍：   </p>
<h3 id="symbols"><a href="#symbols" class="headerlink" title="symbols"></a>symbols</h3><p>详情查看<a href="https://en.wikipedia.org/wiki/Linker_(computing)">Wikipedia</a><br>通常情况下可重定位的目标文件中包含三种类型的symbols（其实也是ELF格式的三种类型）:   </p>
<ul>
<li>已经定义的”external” symbols，该符号允许被其他模块调用   </li>
<li>未定义的”external” symbols，该符号引用在其他模块中已经定义的符号。   </li>
<li>局部符号，在目标文件中内部使用以便方便进行重定位。<br>例如一个C++源码编译生成的可重定位的目标程序中，每个函数、全局变量、静态变量都会有一个symbol与之对应，这些就是已经定义的symbols。定义在不同文件中symbols就是未定义的symbols。在链接期间，链接器会给每个symbol指定一个地址，并会通过查找同名的已经定义的symbol来解决所有未定义的symbol。根据该symbol是局部或全局、已初始化或未初始化、变量还是常量，链接器会将它们放在可执行的目标程序文件中的不同节（sections）。   </li>
</ul>
<h3 id="relocation"><a href="#relocation" class="headerlink" title="relocation"></a>relocation</h3><p>详情查看<a href="https://en.wikipedia.org/wiki/Relocation_(computing)">Wikipedia</a><br>重定位是指一个过程，该过程将为程序中不同部分指定载入地址并调整程序中的代码和数据以将其映射到指定的地址。<br>与重定位过程紧密相关的有重定位表（relocation tables）和一些包含额外信息的特定的节（sections），例如其中一个section就是<code>.rela.text</code>，该节与重定位可执行目标文件中的<code>.text</code>节有关。深入了解相关问题可以参见<code>ELF</code>文件格式。<br>每一个<code>.o</code>文件都有一个重定位表（relocation table），该表给出了每一个需要被链接器更新的符号symbol，以及该如何更新的信息。   </p>
<p>可以通过<code>g++ -std=c++11 -o main main.cpp</code>一次性编译并生成可执行的目标程序，如果希望一个命令编译并链接生成可执行程序的同时保留上面四个步骤中的临时文件，可以通过添加<code>--save-temps</code>参数，如<code>g++ -std=c++11 --save-temps -o main main.cpp</code>。<br>以图说话：<br><img data-src="compile_cpp.png" alt=""></p>
<p>关于可重定位的目标文件与可执行文件的实质区别，以及内存布局，section(节)与segment（段）的区别，详见<a href="http://notes.maxwi.com/2016/06/11/cpp-memory-layout/">实例分析C++内存布局</a>   </p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>Top</tag>
        <tag>CPP</tag>
      </tags>
  </entry>
  <entry>
    <title>实例分析C++内存布局</title>
    <url>/2016/06/11/cpp-memory-layout/</url>
    <content><![CDATA[<p>本文所使用的环境：</p>
<ul>
<li>Ubuntu-14.04 x64 kernel 4.2.0-36-generic</li>
<li>GCC version 4.8.4   </li>
</ul>
<p>需要用到的工具（都是系统自带的，以下是man的基本信息，详细信息可以直接查看man手册）：   </p>
<ul>
<li>size - list section sizes and total size.可以列出section大小和总的大小，能够用于粗略估计，但不适合深度研究section大小   </li>
<li>readelf - Displays information about ELF files.显示ELF文件的信息，readelf非常强大，能够显示出ELF非常多的信息   </li>
<li>objdump - display information from object files. 显示object文件的信息，也就是目标文件，功能与readelf类似，但没有readelf强大，有些readelf可以显示的信息，它无法显示   </li>
</ul>
<p>如果对编译过程不甚了解，可以参看这里<a href="/2016/06/05/source-to-program/">实例验证C/C++源代码如何变成程序的过程</a>   </p>
<span id="more"></span>

<h1 id="关于ELF"><a href="#关于ELF" class="headerlink" title="关于ELF"></a>关于ELF</h1><p>关于内存布局，首先需要了解ELF（Executable and Linkable Format）文件，因为ELF文件格式即是可执行文件通用格式，几乎所有UNIX系统的可执行文件都是采用ELF格式，ELF将被加载器（loader）载入到内存中被操作系统执行，所以ELF中指定了可执行程序的内存布局，ELF格式有三种不同的类型：   </p>
<ul>
<li>可重定位的目标文件（relocatable或object file），也就是编译之后用于链接的文件   </li>
<li>可执行文件（Executable），链接之后可以直接运行的文件   </li>
<li>共享库（Shared Object，或Shared Library）<br>具体一个ELF文件是哪种类型由ELF文件中的ELF Header、Section Header Table和Program Header Table指定。详情可以参考清华大学的一个课件<a href="http://learn.tsinghua.edu.cn/kejian/data/77130/138627/html-chunk/ch18s05.html">ELF文件</a>和Wikipedia上的<a href="https://en.wikipedia.org/wiki/Executable_and_Linkable_Format">Executable and Linkable Format</a><br>或者参见·<a href="http://man7.org/linux/man-pages/man5/elf.5.html">elf-man</a>，当然自己<code>man elf</code>也是一样的。<br>下面两个图ELF文件的布局：   </li>
</ul>
<p><img data-src="elf-layout.png" alt="ELF layout"> <img data-src="elfoverview.png" alt="ELF Overview"></p>
<h1 id="sections和segments的区别"><a href="#sections和segments的区别" class="headerlink" title="sections和segments的区别"></a>sections和segments的区别</h1><p>从上图中可以清楚的看到与可链接的(linkable)对应的是sections，与可执行的（executable）对应的是segments。ELF格式文件提供了两个视角，如后面的图中所示，左边是从链接器的视角来看ELF文件，右边是从加载器的视角来看ELF文件（左右是相对的，在前面图中则是相反中），链接器把ELF文件看成是Section的集合，sections中包含了链接和重定位的所有重要信息，可重定位的ELF中任意一个字节都最多对应一个section，也可以有一些不属于任何一个section的孤立字节。而加载器（loader）则把ELF文件看成是Segment的集合，segments中包含了可执行文件或共享库需要被加载到内存中的必要信息，每个segment中可以由一个或多个section组成，每个segment都有一个长度和一组与之关联的权限（如read、write、execute），一个进程只有在权限允许且在segment中的偏移长度在segment指定的长度之内，才能正常引用segment，否则将会出现segmentation fault的异常，关于segments的解释可以参看Wikipedia的<a href="https://en.wikipedia.org/wiki/Memory_segmentation">Memory segmentation</a>。<br>简单分析一下ELF文件各部分的信息，引用自上面提到的清华的一个课件。   </p>
<blockquote>
<p>开头的ELF Header描述了体系结构和操作系统等基本信息，并指出Section Header Table和Program Header Table在文件中的什么位置，Program Header Table在链接过程中用不到，所以是可有可无的，Section Header Table中保存了所有Section的描述信息，通过Section Header Table可以找到每个Section在文件中的位置。右边是从加载器的视角来看ELF文件，开头是ELF Header，Program Header Table中保存了所有Segment的描述信息，Section Header Table在加载过程中用不到，所以是可有可无的。从上图可以看出，一个Segment由一个或多个Section组成，这些Section加载到内存时具有相同的访问权限。有些Section只对链接器有意义，在运行时用不到，也不需要加载到内存，那么就不属于任何Segment。注意Section Header Table和Program Header Table并不是一定要位于文件的开头和结尾，其位置由ELF Header指出，上图这么画只是为了清晰   </p>
</blockquote>
<blockquote>
<p>目标文件需要链接器做进一步处理，所以一定有Section Header Table；可执行文件需要加载运行，所以一定有Program Header Table；而共享库既要加载运行，又要在加载时做动态链接，所以既有Section Header Table又有Program Header Table。   </p>
</blockquote>
<p>这样就区别出了ELF文件的三种类型。<br>链接器是如何将可重定位的目标程序中的sections映射到可执行目标程序中的segments，详情可以参见<a href="http://www.airs.com/blog/archives/45">Airs上的Linkers</a>，总结来说：<br>链接器从输入的可重定位的目标程序中读取section，然后根据访问权限将所有可载入的section对应地写入到可执行文件中的segments中。也就是说segments可以直接与内存相映射（终于扯出了内存布局），而setcion则是根据访问权限与segment映射，通常情况下所有的只读setcions被映射到一个segment中，而所有的可写sections被映射到其他segment。    </p>
<h1 id="查看ELF文件信息"><a href="#查看ELF文件信息" class="headerlink" title="查看ELF文件信息"></a>查看ELF文件信息</h1><p>下图是使用readelf工具读出的<a href="/2016/06/05/source-to-program/">实例验证C/C++源代码如何变成程序的过程</a>中<code>main.cpp</code>生成的可重定位的目标程序和可执行的目标程序的一部分输出，readelf命令是<code>readelf -a main.o</code>   </p>
<p><img data-src="REL_EXEC.jpg" alt="REL_EXEC"><br>使用vimdiff进行的比对，从图的ELF Header中可以清楚地看到前面一个ELF类型是可重定位的文件（REL），而后面一个是可执行的文件（EXEC）。通过ELF的魔数（Magic）可以看出这个ELF是64位，字节序为小端格式（后面将进行验证），更多关于ELF魔数可以参见<a href="https://en.wikipedia.org/wiki/Executable_and_Linkable_Format">Wikipedia</a>，或下图：<br><img data-src="magic_number.jpeg" alt="ELF魔数"><br>通过上图中的Section Headers部分信息可以看出链接之前的可重定位的目标文件中的section地址段全是0，因为这些加载地址要在链接时才会添加，所以可执行的文件中该地址都存在（当然这个地址是虚拟地址，需要根据程序运行时的实际地址进行偏移）。   </p>
<p>通过命令<code>readelf --segments &lt;input&gt;</code>命令可以查看Section到Segment的映射，由于可重定位的目标文件中并不存在segments，上面也说了可执行的目标文件有program header进行标识，所以该命令作用于<code>main.o</code>（可重定位的目标文件）时会提示”There are no program headers in this file.”。对于<code>main</code>（可执行的目标程序）输出如下，最下面标出了Section到Segment的映射。   </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Elf file type is EXEC (Executable file)</span><br><span class="line">Entry point 0x400970</span><br><span class="line">There are 9 program headers, starting at offset 64</span><br><span class="line"></span><br><span class="line">Program Headers:</span><br><span class="line">  Type           Offset             VirtAddr           PhysAddr</span><br><span class="line">                 FileSiz            MemSiz              Flags  Align</span><br><span class="line">  PHDR           0x0000000000000040 0x0000000000400040 0x0000000000400040</span><br><span class="line">                 0x00000000000001f8 0x00000000000001f8  R E    8</span><br><span class="line">  INTERP         0x0000000000000238 0x0000000000400238 0x0000000000400238</span><br><span class="line">                 0x000000000000001c 0x000000000000001c  R      1</span><br><span class="line">      [Requesting program interpreter: /lib64/ld-linux-x86-64.so.2]</span><br><span class="line">  LOAD           0x0000000000000000 0x0000000000400000 0x0000000000400000</span><br><span class="line">                 0x0000000000001dc9 0x0000000000001dc9  R E    200000</span><br><span class="line">  LOAD           0x0000000000001de8 0x0000000000601de8 0x0000000000601de8</span><br><span class="line">                 0x00000000000002b0 0x00000000000003d0  RW     200000</span><br><span class="line">  DYNAMIC        0x0000000000001e08 0x0000000000601e08 0x0000000000601e08</span><br><span class="line">                 0x00000000000001f0 0x00000000000001f0  RW     8</span><br><span class="line">  NOTE           0x0000000000000254 0x0000000000400254 0x0000000000400254</span><br><span class="line">                 0x0000000000000044 0x0000000000000044  R      4</span><br><span class="line">  GNU_EH_FRAME   0x000000000000147c 0x000000000040147c 0x000000000040147c</span><br><span class="line">                 0x00000000000001bc 0x00000000000001bc  R      4</span><br><span class="line">  GNU_STACK      0x0000000000000000 0x0000000000000000 0x0000000000000000</span><br><span class="line">                 0x0000000000000000 0x0000000000000000  RW     10</span><br><span class="line">  GNU_RELRO      0x0000000000001de8 0x0000000000601de8 0x0000000000601de8</span><br><span class="line">                 0x0000000000000218 0x0000000000000218  R      1</span><br><span class="line"></span><br><span class="line"> Section to Segment mapping:</span><br><span class="line">  Segment Sections...</span><br><span class="line">   00     </span><br><span class="line">   01     .interp </span><br><span class="line">   02     .interp .note.ABI-tag .note.gnu.build-id .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_r .rela.dyn .rela.plt .init .plt .text .fini .rodata .eh_frame_hdr .eh_frame .gcc_except_table </span><br><span class="line">   03     .init_array .fini_array .jcr .dynamic .got .got.plt .data .bss </span><br><span class="line">   04     .dynamic </span><br><span class="line">   05     .note.ABI-tag .note.gnu.build-id </span><br><span class="line">   06     .eh_frame_hdr </span><br><span class="line">   07     </span><br><span class="line">   08     .init_array .fini_array .jcr .dynamic .got </span><br></pre></td></tr></table></figure>
<p>当然可以使用<code>readelf --sections &lt;input&gt;</code>命令读取所有的sections。   </p>
<h1 id="Segments分析"><a href="#Segments分析" class="headerlink" title="Segments分析"></a>Segments分析</h1><p>上面已经说了ELF中的Segments对应的就是内存的布局，所以这里要先来分析Segments。<br>Segments主要包含以下几个部分   </p>
<h2 id="text-segment"><a href="#text-segment" class="headerlink" title=".text segment"></a>.text segment</h2><p>它是固定大小的只读segment<br>text segment也称代码段（segment），它包含了编译器和汇编器提供的可执行指令。   </p>
<h2 id="data-segment"><a href="#data-segment" class="headerlink" title=".data segment"></a>.data segment</h2><p>它是固定大小的可读写segment<br>data segment也称为<strong>已初始化</strong>（initialized）的数据段（segment），它包含已初始化的：</p>
<ul>
<li>全局变量，包括全局静态变量   </li>
<li>局部静态变量（即static声明的变量）   </li>
</ul>
<p>该segment的大小由源代码中相应变量所占用的大小决定，这些变量的值可以在运行时改变。   </p>
<h2 id="rdata-rodata-segment"><a href="#rdata-rodata-segment" class="headerlink" title=".rdata/.rodata segment"></a>.rdata/.rodata segment</h2><p>它是一段只读的segment<br>该segment存储静态的无名数据以及const修饰的常量，例如字符串常量，const修饰的变量。   </p>
<h2 id="bss-segment"><a href="#bss-segment" class="headerlink" title=".bss segment"></a>.bss segment</h2><p>它是可读写的segment，与.data segment相邻<br>BSS segment也称为未初始化的数据段，包含全局或静态未初始化的变量，该部分数据中的值会在程序启动时直接初始为0，BSS是Block Started by Symbol的简写。   </p>
<h2 id="堆（head）和栈（stack）"><a href="#堆（head）和栈（stack）" class="headerlink" title="堆（head）和栈（stack）"></a>堆（head）和栈（stack）</h2><p>堆和栈是每个程序都有的内存区域，详情可以参见<a href="https://en.wikipedia.org/wiki/Data_segment">Data segment</a>   </p>
<h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p>维基百科上的解释，堆起始于.bss和.data segments之后，从该处朝着地址空间变大的方向增长。堆通过malloc、realloc、free来管理，具体这三个函数的实现，在linux下有可能是使用brk/sbrk来实现，当然也有可能是通过mmap从虚拟内存的非连续内存中获取后给进程的虚拟地址空间的（brk/sbrk/mmap都是linux下管理内存的函数）。堆被同一个进程的所有线程、共享库以及动态加载的模块共享。<br>关于heap和free store的区别，SOF上也有强烈的争论，Herb Sutter在<a href="http://www.gotw.ca/gotw/009.htm">Memory Management - Part I</a>中详细说明了内存管理时的几个内存区域的区别，他认为heap和free store是不同的，一个是C语言下的，一个是C++下的。而Bjarne Stroustrup的说法我觉得应该更合适，在这里<a href="http://zamanbakshifirst.blogspot.com/search/label/heap">C++ : Free-store versus Heap</a>，为了避免可能无法打开该链接，将全文引在下面：   </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C++ : Free-store versus Heap</span><br><span class="line"></span><br><span class="line">What&#x27;s the difference between the heap and the free-store? The C++ Programming Language keeps on referring them interchangeably. There was as huge cry over this issue in C/C++ programmer&#x27;s community in Orkut. I had to shoot a mail to Dr. Bjarne Stroustrup. Here&#x27;s our conversation:</span><br><span class="line"></span><br><span class="line">My Mail:</span><br><span class="line"></span><br><span class="line">Dear Mr Stroustrup,</span><br><span class="line"></span><br><span class="line">Sorry to disturb you again. You have mentioned several times in the TC++PL that &#x27;new&#x27; allocates memory from the &#x27;free store (or heap)&#x27;. There has been a huge cry on the C++ community at Orkut (that I am moderating) as to whether free-store is the same as heap. The argument given against is that Mr Herb Sutter has mentioned that the free-store is different from the heap:</span><br><span class="line"></span><br><span class="line">http://www.gotw.ca/gotw/009.htm</span><br><span class="line"></span><br><span class="line">and that global &#x27;new&#x27; has nothing to do with the heap.</span><br><span class="line"></span><br><span class="line">So, if so, why has TC++PL used &#x27;free store (or heap)&#x27; instead of mentioning the use of &#x27;heap&#x27; separately.</span><br><span class="line"></span><br><span class="line">Waiting anxiously for the response.</span><br><span class="line"></span><br><span class="line">Regards,</span><br><span class="line">Zaman Bakshi</span><br><span class="line"></span><br><span class="line">His Reply:</span><br><span class="line"></span><br><span class="line">Note that Herb says: &quot;Note about Heap vs. Free Store: We distinguish between &quot;heap&quot; and &quot;free store&quot; because the draft deliberately leaves unspecified the question of whether these two areas are related. For example, when memory is deallocated via operator delete, 18.4.1.1 states:&quot;</span><br><span class="line"></span><br><span class="line">In other word, the &quot;free store&quot; vs &quot;heap&quot; distinction is Herb&#x27;s attempt to distinguish malloc() allocation from new allocation.</span><br><span class="line"></span><br><span class="line">&gt;</span><br><span class="line">&gt; So, if so, why has TC++PL used &#x27;free store (or heap)&#x27; instead of</span><br><span class="line">&gt; mentioning the use of &#x27;heap&#x27; separately.</span><br><span class="line"></span><br><span class="line">Because even though it is undefined from where new and malloc() get their memory, they typically get them from exactly the same place. It is common for new and malloc() to allocate and free storage from the same part of the computer&#x27;s memory. In that case, &quot;free store&quot; and &quot;heap&quot; are synonyms. I consistently use &quot;free store&quot; and &quot;heap&quot; is not a defined term in the C++ standard (outside the heap standard library algorithms, which are unrelated to new and malloc()). In relation to new, &quot;heap&quot; is simply a word someone uses (typically as a synonym to &quot;free store&quot;) - usually because they come from a different language background.</span><br><span class="line"></span><br><span class="line">My Reply:</span><br><span class="line"></span><br><span class="line">Thank you Mr. Stroustrup, I had inferred the same thing (about using free store as general -- or better, synonym -- term) and had explained the community. But, I had been requested to reconfirm.</span><br><span class="line"></span><br><span class="line">With warm regards,</span><br><span class="line">Zaman Bakshi</span><br></pre></td></tr></table></figure>
<h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>首先栈是先进后出的数据结构，其位于内存的高地址空间中。<br>自动变量存储在栈上，包括函数中定义的变量（也就是{}中的变量，但不包括static，上面说了static存储在data段）。函数调用时的参数也会被压入发起调用的进程栈中。   </p>
<p>下图可以形象地表示内存布局<br><img data-src="linuxFlexibleAddressSpaceLayout.png" alt="">   </p>
<p>以下这段程序的内存布局图来自<a href="http://www.cs.uleth.ca/~holzmann/C/system/memorylayout.pdf">pdf</a>   </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="type">int</span> a;  </span><br><span class="line">    <span class="type">int</span> b[<span class="number">3</span>];  </span><br><span class="line">    <span class="comment">/* no other auto variable */</span>  </span><br><span class="line">    ... </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">func</span>(<span class="number">72</span>,<span class="number">73</span>);  </span><br><span class="line">    ...  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码内存布局分析<br><img data-src="mem_layout_complex.png" alt=""></p>
<h2 id="关于堆和栈的增长方向"><a href="#关于堆和栈的增长方向" class="headerlink" title="关于堆和栈的增长方向"></a>关于堆和栈的增长方向</h2><p>从上面的图以及无数的解释中我们可以明显知到堆是沿低地址向高地址增长（低地址指较小的址，高地址指较大的地址，通常所说的向上增长就是指向高地址增长），而栈是沿高地址向低地址增加，栈和堆共用一块内存空间，当然它们有可能会出现重叠的情况。<br>内存中将这两部分称为堆和栈是因为它们的表现类似于数据结构中的堆（heap）和栈（stack）。很多童鞋，例如我想尝试验证堆和栈的增长方式，简单地在函数内定义几个自动变量，再使用malloc或者new创建几个变量，然后来输出地址比较，这种方法是行不通的，因为存在栈帧的问题。所谓栈帧就是每个函数在每次的调用过程中都会对应一个栈帧，栈帧中保存了该函数在调用过程中所需要的所有信息，包括返回地址、局部变量等。所以两个不同的函数调用时的局部变量将保存在不同的栈帧中，所以函数调用者栈帧中的信息必然比被调用者先入栈，如果被调用函数的局部变量地址比调用者的大，则栈肯定是沿低地址向高地址增长，即向上增长，反之则是向下增长。<br>使用下面这段代码分别在windows及linux下来验证栈的增长方向、栈帧内栈的增长方向以及malloc与new分配的空间是否是在同一块内存中：   </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//func2调用func1的参数，first必将比second先入栈</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">(<span class="type">int</span> *first)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> second = <span class="number">0</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;&amp;fir: &quot;</span> &lt;&lt; first &lt;&lt; std::endl</span><br><span class="line">              &lt;&lt; <span class="string">&quot;&amp;sec: &quot;</span> &lt;&lt; &amp;second &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当func1调用func2时，func1的返回地址及局部变量都将压入一个栈帧中</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> first = <span class="number">0</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;******stack direction******&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">func2</span>(&amp;first);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在一个栈帧内，局部变量的地址可以由编译器决定，输出一个栈帧内堆和栈的地址</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//在栈内定义4个变量</span></span><br><span class="line">    <span class="type">int</span> t1 = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> t2 = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> t3 = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> t4 = <span class="number">0</span>;</span><br><span class="line">    std::cout &lt;&lt; std::endl &lt;&lt; <span class="string">&quot;*******stack*****&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; &amp;t1 &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; &amp;t2 &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; &amp;t3 &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; &amp;t4 &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">//在堆内使用new定义4个变量</span></span><br><span class="line">    <span class="type">int</span> *n5 = <span class="keyword">new</span> <span class="type">int</span>;</span><br><span class="line">    <span class="type">int</span> *n6 = <span class="keyword">new</span> <span class="type">int</span>;</span><br><span class="line">    <span class="type">int</span> *n7 = <span class="keyword">new</span> <span class="type">int</span>;</span><br><span class="line">    <span class="type">int</span> *n8 = <span class="keyword">new</span> <span class="type">int</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;*******heap: new allocate*****&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; n5 &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; n6 &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; n7 &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; n8 &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">//在堆内使用malloc定义4个变量</span></span><br><span class="line">    <span class="type">int</span> *m5 = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="type">int</span> *m6 = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="type">int</span> *m7 = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="type">int</span> *m8 = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;*******heap: malloc allocate*****&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; m5 &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; m6 &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; m7 &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; m8 &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">//释放动态内存</span></span><br><span class="line">    <span class="keyword">delete</span> n5;</span><br><span class="line">    <span class="keyword">delete</span> n6;</span><br><span class="line">    <span class="keyword">delete</span> n7;</span><br><span class="line">    <span class="keyword">delete</span> n8;</span><br><span class="line">    <span class="built_in">free</span>(m5);</span><br><span class="line">    <span class="built_in">free</span>(m6);</span><br><span class="line">    <span class="built_in">free</span>(m7);</span><br><span class="line">    <span class="built_in">free</span>(m8);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">func1</span>();</span><br><span class="line">    <span class="built_in">func</span>();</span><br><span class="line">    <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是在Windows 7 x64系统下使用GCC 5.1.0 x64编译运行的结果：   </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:\Windows\system32\cmd.exe /c (mem.exe)</span><br><span class="line">******stack direction******</span><br><span class="line">&amp;fir: 0x22fe1c</span><br><span class="line">&amp;sec: 0x22fddc</span><br><span class="line"></span><br><span class="line">*******stack*****</span><br><span class="line">0x22fddc</span><br><span class="line">0x22fdd8</span><br><span class="line">0x22fdd4</span><br><span class="line">0x22fdd0</span><br><span class="line">*******heap: new allocate*****</span><br><span class="line">0x8f7b00</span><br><span class="line">0x8f7b20</span><br><span class="line">0x788ab0</span><br><span class="line">0x788ac0</span><br><span class="line">*******heap: malloc allocate*****</span><br><span class="line">0x788ad0</span><br><span class="line">0x788ae0</span><br><span class="line">0x788af0</span><br><span class="line">0x788b00</span><br></pre></td></tr></table></figure>
<p>这是在Ubuntu-14.10 x64系统下使用GCC 4.8.4 x64编译运行的结果：   </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">******stack direction******</span><br><span class="line">&amp;fir: 0x7ffdf88d276c</span><br><span class="line">&amp;sec: 0x7ffdf88d274c</span><br><span class="line"></span><br><span class="line">*******stack*****</span><br><span class="line">0x7ffdf88d2720</span><br><span class="line">0x7ffdf88d2724</span><br><span class="line">0x7ffdf88d2728</span><br><span class="line">0x7ffdf88d272c</span><br><span class="line">*******heap: new allocate*****</span><br><span class="line">0x753010</span><br><span class="line">0x753030</span><br><span class="line">0x753050</span><br><span class="line">0x753070</span><br><span class="line">*******heap: malloc allocate*****</span><br><span class="line">0x753090</span><br><span class="line">0x7530b0</span><br><span class="line">0x7530d0</span><br><span class="line">0x7530f0</span><br></pre></td></tr></table></figure>
<p>从以上结果可以清楚的看到不管是在windows下还是在linux下，first的地址都比second的地址大，也就是说先入栈的地址比后入栈的地址大，所以栈是向下增长。<br>而在一个栈帧内，即stack部分的输出结果可以看出windows下地址是减小的，而linux下地址却是增大，不管是由于编译器的问题还是系统的分配问题，或者都有可能（至少此处的例子编译器一样，虽然版本不同），所以在一个栈帧内并无法判断栈的增长方向。<br>而根据堆的输出结果可以看出不管是windows下还是linux下，地址都是变大的，也就是向上增长，从windows下的输出可以看出堆分配的内存有可能不连续，而不管是在windows下还是linux下都没有显示出new和malloc分配的内存不是在同一个内存区域上，而且据说new就是使用malloc进行实现的。<br>之所以要设计堆和栈两种不同的内存管理方式，根据函数的调用来说显然是栈的存在的非常有必要的，考虑到逻辑与数据的分享堆和栈也同样的非常有必要的。<br>总结堆和栈的区别：   </p>
<ol>
<li>分配方式不同，栈用于存储定义的自动变量、函数的返回地址、函数的参数等，由系统自动分配，而堆需要使用malloc、realloc或new手动分配   </li>
<li>回收方式不同，栈在函数调用结束或程序运行完成时由系统自动释放，而堆需要使用delete或free来手动释放，当然在程序运行结束后也有可能OS会自动回收   </li>
<li>增长方向不同，栈由高地址向低地址增长，而堆则是由低地址向高地址增长   </li>
<li>大小限制不同，栈可申请的空间通常在编译时由操作系统确定，程序运行之前就已经确定大小，且通常较小，而堆则可在运行时扩展，大小受限于系统剩余的虚拟内存   </li>
<li>申请效率不同，栈由系统自动分配通常效率较高，堆由于在分配和释放时需要由系统维护一个空闲内存地址的链表，容易产生碎片化的内存，在申请时，系统首先需要从空闲内存地址链表中查询空闲内存地址，找到后返回给程序并从该链表中删除，所以速度较慢。   </li>
<li>堆内存只能通过指针使用，而栈可以通过变量名   </li>
<li>栈的使用不会引起内存碎片化，但在堆上进行大量的分配和释放有可能造成内存碎片化   </li>
<li>失败后的结果不同，当分配的栈太大或者死循环，或者递归的太深时会引起栈溢出（stack overflow）。而在申请堆时，请求的内存太大会引起内存分配失败。   </li>
<li>网上有人说存取效率不同，栈的存取更快，堆较慢。这个应该根据不同的系统实现可能并不一定。   </li>
</ol>
<p>关于堆和栈的区别也可以看SOF上的高票<a href="http://stackoverflow.com/questions/79923/what-and-where-are-the-stack-and-heap">SOF</a>   </p>
<h1 id="实例分析"><a href="#实例分析" class="headerlink" title="实例分析"></a>实例分析</h1><p>从以下代码开始：   </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>查看它的section大小：   </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">blueyi@vm:~/cpp/b$ g++ --save-temps -o main main.cpp</span><br><span class="line">blueyi@vm:~/cpp/b$ size main.o </span><br><span class="line">   text	   data	    bss	    dec	    hex	filename</span><br><span class="line">     67	      0	      0	     67	     43	main.o</span><br></pre></td></tr></table></figure>
<p>因为没有定义任何变量，所以.data和.bss都是0，现在将程序修改为如下所示：   </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//未初始化的全局变量会存储在.bss中</span></span><br><span class="line"><span class="type">int</span> global_uninitialized;</span><br><span class="line"><span class="comment">//已初始化的全局变量会被存储在.data section中</span></span><br><span class="line"><span class="type">float</span> global_ini = <span class="number">3.1415</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//未初始化的静态变量也会存放在.bss section中</span></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> static_uninitialized;</span><br><span class="line">    <span class="comment">//已初始化的静态变量会被放在.data section中</span></span><br><span class="line">    <span class="type">static</span> <span class="type">char</span> ch_ini = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>查看section大小：   </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">blueyi@vm:~/cpp/b$ g++ --save-temps -o main main.cpp</span><br><span class="line">blueyi@vm:~/cpp/b$ size main.o </span><br><span class="line">   text	   data	    bss	    dec	    hex	filename</span><br><span class="line">     67	      5	      8	     80	     50	main.o</span><br></pre></td></tr></table></figure>
<p>现在.data section大小变成了5，刚好是一个已初始化的全局float占用的4个字节加上局部已初始化的静态char所占用的字节，而.bss section的大小刚好是两个int占用的字节8，它们分别来自全局未初始化的global_uninitialized和局部静态未初始化的static_uninitialized。   </p>
<p>对可执行程序执行反汇编并查看.data中的内容如下：   </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">blueyi@vm:~/cpp/b$ objdump -CS -s -j .data main</span><br><span class="line"></span><br><span class="line">main:     file format elf64-x86-64</span><br><span class="line"></span><br><span class="line">Contents of section .data:</span><br><span class="line"> 601028 00000000 00000000 00000000 00000000  ................</span><br><span class="line"> 601038 560e4940 61                          V.I@a           </span><br><span class="line"></span><br><span class="line">Disassembly of section .data:</span><br><span class="line"></span><br><span class="line">0000000000601028 &lt;__data_start&gt;:</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">0000000000601030 &lt;__dso_handle&gt;:</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">0000000000601038 &lt;global_ini&gt;:</span><br><span class="line">  601038:	56 0e 49 40                                         V.I@</span><br><span class="line"></span><br><span class="line">000000000060103c &lt;main::ch_ini&gt;:</span><br><span class="line">  60103c:	61                                                  a</span><br></pre></td></tr></table></figure>
<p>可以清楚地看到.data中有<code>&lt;global_ini&gt;</code>和<code>&lt;main::ch_ini&gt;</code>，它们正是我们的两个变量global_ini和ch_ini。   </p>
<p>反汇编并查看.bss中的内容如下：   </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">blueyi@vm:~/cpp/b$ objdump -CS -s -j .bss main</span><br><span class="line"></span><br><span class="line">main:     file format elf64-x86-64</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Disassembly of section .bss:</span><br><span class="line"></span><br><span class="line">0000000000601040 &lt;completed.6973&gt;:</span><br><span class="line">  601040:	00 00 00 00                                         ....</span><br><span class="line"></span><br><span class="line">0000000000601044 &lt;global_uninitialized&gt;:</span><br><span class="line">  601044:	00 00 00 00                                         ....</span><br><span class="line"></span><br><span class="line">0000000000601048 &lt;main::static_uninitialized&gt;:</span><br><span class="line">	...</span><br></pre></td></tr></table></figure>
<p>同样可以看到与我们源代码中对应的<code>&lt;global_uninitialized&gt;</code>和<code>&lt;main::static_uninitialized&gt;</code>   </p>
<p>通过反汇编查看.rodata中的数据如下：   </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">blueyi@vm:~/cpp/b$ objdump -CS -s -j .rodata main</span><br><span class="line"></span><br><span class="line">main:     file format elf64-x86-64</span><br><span class="line"></span><br><span class="line">Contents of section .rodata:</span><br><span class="line"> 400580 01000200                             ....            </span><br><span class="line"></span><br><span class="line">Disassembly of section .rodata:</span><br><span class="line"></span><br><span class="line">0000000000400580 &lt;_IO_stdin_used&gt;:</span><br><span class="line">  400580:	01 00 02 00                                         ....</span><br></pre></td></tr></table></figure>
<p>与之前.data的输出结果类比可以看出.rodata中并没有数据，因为我们的程序中没有定义需要存储在.rodata section中的数据。<br>将程序修改为如下：   </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//未初始化的全局变量会存储在.bss中</span></span><br><span class="line"><span class="type">int</span> global_uninitialized;</span><br><span class="line"><span class="comment">//已初始化的全局变量会被存储在.data section中</span></span><br><span class="line"><span class="type">float</span> global_ini = <span class="number">3.1415</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//const 修饰的变量相当于常量，会被存放在.rodata中</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX = <span class="number">100</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MIN = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//未初始化的静态变量也会存放在.bss section中</span></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> static_uninitialized;</span><br><span class="line">    <span class="comment">//已初始化的静态变量会被放在.data section中</span></span><br><span class="line">    <span class="type">static</span> <span class="type">char</span> ch_ini = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//const 修饰的变量相当于常量，会被存放在.rodata中</span></span><br><span class="line">    <span class="type">const</span> <span class="type">float</span> pi = <span class="number">3.14</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *str = <span class="string">&quot;maxwi.com&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再来查看sections大小，以及反汇编之后.rodata的内容：   </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">blueyi@vm:~/cpp/b$ g++ --save-temps -o main main.cpp</span><br><span class="line">blueyi@vm:~/cpp/b$ size main.o</span><br><span class="line">   text	   data	    bss	    dec	    hex	filename</span><br><span class="line">    108	      5	      8	    121	     79	main.o</span><br><span class="line">blueyi@vm:~/cpp/b$ objdump -CS -s -j .rodata main</span><br><span class="line"></span><br><span class="line">main:     file format elf64-x86-64</span><br><span class="line"></span><br><span class="line">Contents of section .rodata:</span><br><span class="line"> 400590 01000200 6d617877 692e636f 6d000000  ....maxwi.com...</span><br><span class="line"> 4005a0 64000000 0a000000 c3f54840           d.........H@    </span><br><span class="line"></span><br><span class="line">Disassembly of section .rodata:</span><br><span class="line"></span><br><span class="line">0000000000400590 &lt;_IO_stdin_used&gt;:</span><br><span class="line">  400590:	01 00 02 00 6d 61 78 77 69 2e 63 6f 6d 00 00 00     ....maxwi.com...</span><br><span class="line"></span><br><span class="line">00000000004005a0 &lt;MAX&gt;:</span><br><span class="line">  4005a0:	64 00 00 00                                         d...</span><br><span class="line"></span><br><span class="line">00000000004005a4 &lt;MIN&gt;:</span><br><span class="line">  4005a4:	0a 00 00 00 c3 f5 48 40                             ......H@</span><br></pre></td></tr></table></figure>
<p>从输出中可以看出.data和.bss的大小没有增加，而从.rodata section的输出出我们看到了程序中定义的全局const变量对应的内容<code>&lt;MAX&gt;</code>和<code>&lt;MIN&gt;</code>，但没有main函数中的pi和*str，仔细查看输出内容发现<code>&lt;_IO_stdin_used&gt;</code>的后面正是<code>maxwi.com</code>的十六进制ASCII码，紧接在<code>&lt;MIN&gt;</code>后面的是3.14的内容。</p>
<p>C++变量的内存布局中主要有.data、.bss、.rodata、heap和stack五个部分。.text属于ELF，用于存放源代码指令。      </p>
<h1 id="关于字节序的大端和小端"><a href="#关于字节序的大端和小端" class="headerlink" title="关于字节序的大端和小端"></a>关于字节序的大端和小端</h1><p>大端（Big-Endian）和小端（Little-Endian）是指字节在内存中的存储顺序：   </p>
<ul>
<li>小端（Little-Endian）就是低位字节排放在内存的低地址端，高位字节排放在内存的高地址端。</li>
<li>大端（Big-Endian）就是高位字节排放在内存的低地址端，低位字节排放在内存的高地址端。<br>下图应该很能说明问题：<br><img data-src="endian_diagram.png" alt=""><br>与之相关的两个关键词：   </li>
<li>MSB:MoST Significant Bit ——- 最高有效位   </li>
<li>LSB:Least Significant Bit ——- 最低有效位   </li>
</ul>
<p>下面用代码来验证本机是大端还是小端，都知道可以通过定义一个值为1的int型变量，然后将其强制转换为char，由于int占4个字节，而char只占1个字节，所以对于char来说就存在低位有效还是高位有效。默认情况下对于一个元素来说它在内存中存储是由低地址到高地址，例如一个int占4个字节，第二个字节在内存中的地址会比第一个字节大，依此类推，下面的程序中会验证。这样如果是最低位有效，即LSB，也就是与之对应的小端，反之就是MSB，与之对应的就是大端。参见<a href="https://en.wikipedia.org/wiki/Endianness">Endianness-Wikipedia</a>和<a href="http://www.bogotobogo.com/Embedded/Little_endian_big_endian_htons_htonl.php">Embedded Systems programming: Little Endian/Big Endian &amp; TCP Sockets - 2016</a><br>说再多也没用，”Talk is cheap. Show me the code.“   </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//单独一个元素在内存中的存储是从低地址到高地址   </span></span><br><span class="line"><span class="comment">//下面验证   </span></span><br><span class="line"><span class="comment">//使用整型转判断</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">int_address</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">12345</span>;  <span class="comment">//0x00003039</span></span><br><span class="line">    <span class="type">char</span> *p = (<span class="type">char</span>*)(&amp;a);</span><br><span class="line">    <span class="keyword">for</span> (std::<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; <span class="built_in">sizeof</span>(a); ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%p\t0x%.2x\n&quot;</span>, p + i, *(p + i));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据整型转char保留低位来判断</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">is_big_end_pointer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (*((<span class="type">char</span>*)&amp;p) == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据共用体来判断</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">is_big_end_union</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="type">char</span> ch;</span><br><span class="line">    &#125; endn;</span><br><span class="line">    endn.i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (endn.ch == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;address increase direction&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">int_address</span>();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;**pointer**&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">is_big_end_pointer</span>())</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;big endian&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;little endian&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;**union**&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">is_big_end_union</span>())</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;big endian&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;little endian&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Windows下的输出结果如下：   </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:\Windows\system32\cmd.exe /c (big_and_littel_endian.exe)</span><br><span class="line">address increase direction</span><br><span class="line">000000000022fe0c        0x39</span><br><span class="line">000000000022fe0d        0x30</span><br><span class="line">000000000022fe0e        0x00</span><br><span class="line">000000000022fe0f        0x00</span><br><span class="line"></span><br><span class="line">**pointer**</span><br><span class="line">little endian</span><br><span class="line"></span><br><span class="line">**union**</span><br><span class="line">little endian</span><br></pre></td></tr></table></figure>
<p>Linux下的输出结果如下：   </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">address increase direction</span><br><span class="line">0x7ffd9b54628c      0x39</span><br><span class="line">0x7ffd9b54628d      0x30</span><br><span class="line">0x7ffd9b54628e      0x00</span><br><span class="line">0x7ffd9b54628f      0x00</span><br><span class="line"></span><br><span class="line">**pointer**</span><br><span class="line">little endian</span><br><span class="line"></span><br><span class="line">**union**</span><br><span class="line">little endian</span><br></pre></td></tr></table></figure>
<p>显然，我机器的内存存储模式是小端格式，其他根据int_address()函数即能看出来单个元素在内存中的存储方向，同样可以清楚的看到低位存储在低地址，高位存储在高地址，即小端模式。<br><strong>关于字节序的一些知识</strong></p>
<ul>
<li>采用小端模式的处理器包括：PDP-11、VAX、Intel系列微处理器和一些网络通信设备； 采用大端模式的处理器包括：IBM3700系列、PDP-10、Mortolora微处理器系列和绝大多数的RISC处理器 所以通常我们自己的机器多数都是小端字节序。</li>
<li>网络字节序是确定的，网络字节序定义为大端模式，所以两台主机之间通过TCP/IP协议进行通信的时候，在向对方发送报文前，都需要调用相应的函数把自己的主机序（Little-Endian）模式的报文转换成网络序（Big-Endian）模式；同样，在接收到对方的报文信息后，都需要将报文（网络序）转换成主机序（Little-Endian）。</li>
</ul>
<h1 id="register"><a href="#register" class="headerlink" title="register"></a>register</h1><p>最后提一下register定义的寄存器变量，显然上述没有提到寄存器这个存储区，因为寄存器是CPU的存储单元，寄存器可以直接访问而不需要通过总线，所以速度较快。早期的编程环境，特别是较老硬件下的C语言编程通常会考虑将使用比较频繁的变量定义为register，以加快访问速度，但现在的C++编译器通常会忽略掉register，而是采用自己的优化策略。register在C和C++中的用法也有点区别：<br>在c++中：</p>
<ol>
<li>register 关键字无法在全局中定义变量，否则会被提示为不正确的存储类。</li>
<li>register 关键字在局部作用域中声明时，可以用 &amp; 操作符取地址，一旦使用了取地址操作符，被定义的变量会强制存放在内存中。<br>在c中:</li>
<li>register 关键字可以在全局中定义变量，当对其变量使用 &amp; 操作符时，只是警告“有坏的存储类”。</li>
<li>register 关键字可以在局部作用域中声明，但这样就无法对其使用 &amp; 操作符。否则编译不通过。</li>
</ol>
<h1 id="常量折叠"><a href="#常量折叠" class="headerlink" title="常量折叠"></a>常量折叠</h1><p>注意.rdata区，这是一段只读的数据区，该区域存储的常量数据通常会在编译阶段用于替换程序中相应的常量类型的变量（也就是所谓的常量折叠）<br>常量折叠发生在编译阶段，而不是预编译阶段，预编译阶段只是对宏定义这类进行替换（如#define、#include等定义），可以参考：<a href="http://notes.maxwi.com/2016/06/05/source-to-program/"> 实例验证C/C++源代码变成程序的过程 </a><br>而编译阶段的常量折叠是一种编译优化技术，会使用常量值来替换常量表达式，如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> i = <span class="number">2</span> * <span class="number">3</span> * <span class="number">6</span>;</span><br><span class="line"><span class="type">int</span> ca = a;</span><br></pre></td></tr></table></figure>
<p>编译完成之后实际上相当于：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//a被存储在.rodata区中</span></span><br><span class="line"><span class="type">int</span> i = <span class="number">36</span>;</span><br><span class="line"><span class="type">int</span> ca = <span class="number">5</span>;</span><br></pre></td></tr></table></figure>

<p>所以当我们将某个变量声明为const之后，虽然该变量及其值会被存储在.rdata（只读）区，编译阶段就已经确定了该变量的值，且无法修改该变量的值（实际上该变量的值在编译阶段会直接被替换为相应的值）。虽然程序运行时可以通过指针强行修改const变量所指向的内存区域的值，但当通过这个const变量来使用其值时，由于常量折叠，该值在编译完成之后就已经被替换成了实际的值（注意是编译阶段，而不是预编译阶段）</p>
<p>如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> a = <span class="number">4</span>;</span><br><span class="line">    <span class="type">int</span> *p = (<span class="type">int</span> *)&amp;a;   <span class="comment">//指针p强行指向a的地址，此时系统会为a指向的地址（实际上是虚拟地址）分配内存，并从.rodata中拷贝a5的值到该内存中</span></span><br><span class="line">    std::cout &lt;&lt; p &lt;&lt; <span class="string">&quot; : &quot;</span> &lt;&lt; *p &lt;&lt; std::endl &lt;&lt; std::endl;</span><br><span class="line">    *p = <span class="number">5</span>;</span><br><span class="line">    std::cout &lt;&lt; &amp;a &lt;&lt; <span class="string">&quot; : &quot;</span> &lt;&lt; a &lt;&lt; std::endl;  <span class="comment">//编译完成后，实际上后面这个a会被替换为4</span></span><br><span class="line">    std::cout &lt;&lt; p &lt;&lt; <span class="string">&quot; : &quot;</span> &lt;&lt; *p &lt;&lt; std::endl &lt;&lt; std::endl;</span><br><span class="line">    <span class="type">int</span> *p2 = (<span class="type">int</span> *)&amp;a;  <span class="comment">//将p2指向已经分配了内存的地址，此时该地址内存中的值为5</span></span><br><span class="line">    *p2 = <span class="number">6</span>;</span><br><span class="line">    std::cout &lt;&lt; &amp;a &lt;&lt; <span class="string">&quot; : &quot;</span> &lt;&lt; a &lt;&lt; std::endl;  <span class="comment">//a同样会被替换为4</span></span><br><span class="line">    std::cout &lt;&lt; p &lt;&lt; <span class="string">&quot; : &quot;</span> &lt;&lt; *p &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; p2 &lt;&lt; <span class="string">&quot; : &quot;</span> &lt;&lt; *p2 &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">0x7fffce11a0ec</span> : <span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="number">0x7fffce11a0ec</span> : <span class="number">4</span></span><br><span class="line"><span class="number">0x7fffce11a0ec</span> : <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="number">0x7fffce11a0ec</span> : <span class="number">4</span></span><br><span class="line"><span class="number">0x7fffce11a0ec</span> : <span class="number">6</span></span><br><span class="line"><span class="number">0x7fffce11a0ec</span> : <span class="number">6</span></span><br></pre></td></tr></table></figure>
<p>由于输出结果可知虽然a和p、p2的地址一样，但a的值并不会发生变化，因为实际上a的值在编译阶段就已经被替换为4，且被固定在.rodata区，编译器虽然为const定义的变量分配了地址但并不会分析存储空间。<br>当对const定义的变量强行取地址时，此时编译器才会为这些常量分配存储空间，并会从.rodata区域中取出它的值，并重新在内存中创建一个它的拷贝，所以第一次对p赋值后，它的值是5，当通过p2对这块内存赋值为6时，p和p2所指向的同一块内存值为6，但输出中显示的a依然是.rodata中存储的4（编译阶段就已经发生了替换）。<br>看如下程序：<br>rodata.cpp</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> a5 = <span class="number">33</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span>  <span class="comment">//之所以用个main函数是因为C++不允许在全局赋值，全局只在定义变量，或定义的同时初始化</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> *p = (<span class="type">int</span> *)&amp;a5;   </span><br><span class="line">    *p = <span class="number">6</span>;</span><br><span class="line">    <span class="type">int</span> dd = a5;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用<code>g++ -S rodata.cpp</code>编译生成汇编源文件rodata.s，并使用c++filt对变量名unmangling：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">        .file   &quot;rodata.cpp&quot;</span><br><span class="line">        .text</span><br><span class="line">        .globl  main</span><br><span class="line">        .type   main, @function</span><br><span class="line">main:</span><br><span class="line">.LFB0:</span><br><span class="line">        .cfi_startproc</span><br><span class="line">        pushq   %rbp</span><br><span class="line">        .cfi_def_cfa_offset 16</span><br><span class="line">        .cfi_offset 6, -16</span><br><span class="line">        movq    %rsp, %rbp</span><br><span class="line">        .cfi_def_cfa_register 6</span><br><span class="line">        movq    a5, -8(%rbp)  //从.rodata中取出a5的值，并拷贝到分配的内存中</span><br><span class="line">        movq    -8(%rbp), %rax</span><br><span class="line">        movl    $6, (%rax)</span><br><span class="line">        movl    $33, -12(%rbp)  //变量dd的值直接使用33而不是a5</span><br><span class="line">        movl    $0, %eax</span><br><span class="line">        popq    %rbp</span><br><span class="line">        .cfi_def_cfa 7, 8</span><br><span class="line">        ret</span><br><span class="line">        .cfi_endproc</span><br><span class="line">.LFE0:</span><br><span class="line">        .size   main, .-main</span><br><span class="line">        .section        .rodata</span><br><span class="line">        .align 4</span><br><span class="line">        .type   a5, @object</span><br><span class="line">        .size   a5, 4</span><br><span class="line">a5:</span><br><span class="line">        .long   33</span><br><span class="line">        .ident  &quot;GCC: (Ubuntu 4.8.4-2ubuntu1~14.04.3) 4.8.4&quot;</span><br><span class="line">        .section        .note.GNU-stack,&quot;&quot;,@progbits</span><br></pre></td></tr></table></figure>

<h1 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h1><p>volatile关键字用于修饰变量与const用法类似，但功能恰好相反。volatile 关键字修饰变量表示该变量可以被某些编译器未知的因素更改，比如：操作系统、硬件或者其它线程等。遇到这个关键字声明的变量，编译器对访问该变量的代码就不再进行优化，从而可以提供对特殊地址的稳定访问。声明时语法：int volatile vInt; 当要求使用 volatile 声明的变量的值的时候，系统总是重新从它所在的内存读取数据，即使它前面的指令刚刚从该处读取过数据。而且读取的数据立刻被保存。<br>也就是说volatile修饰的变量，不管在什么时候通过变量名使用该变量，都要直接从内存中读取，而不允许编译器对其修饰的变量做任何编译优化，例如常量折叠。volatile可以与const一起使用，const修饰的变量，只是说不能修改该变量的值，毕竟该变量会在编译时优化替换为原值，就像上面的例子一样，依然可以通过指针来修改const变量所指向的内存中的内容。<br>同样是上面的两段代码，如果将前面那段代码的<code>const int a = 4;</code>前面再加上volatile，改成<code>volatile const int a = 4</code>，则输出结果为</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">0x7fffda9fdf5c</span> : <span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="number">1</span> : <span class="number">5</span></span><br><span class="line"><span class="number">0x7fffda9fdf5c</span> : <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="number">1</span> : <span class="number">6</span></span><br><span class="line"><span class="number">0x7fffda9fdf5c</span> : <span class="number">6</span></span><br><span class="line"><span class="number">0x7fffda9fdf5c</span> : <span class="number">6</span></span><br></pre></td></tr></table></figure>
<p>注意这个地方在g++编译时会有警告<code>The address of &#39;a&#39; will always evaluate as &#39;true&#39; [-Waddress]</code>，然后a的地址都会输出成了1，这是因为operator&lt;&lt;重载的运算符没有volatile void *类型的形参，默认情况下iostream会将指针类型隐式转换为void *以用于显示，但对于volatile类型的指针却不转换，所以上面对于a地址的输出，可以加个到(void *)&amp;a的强制转换，当然输出地址与p是一样的。</p>
<p>如果将后面那段代码中的<code>const int a5 = 33;</code>改成<code>volatile const int a5 = 33;</code>，则编译后的汇编中可以发现，程序不再采用常量折叠的方式替换dd后面a5的值为33，而是从a5中获取<br>volatile用于多线程环境较多，当两个线程都要用到某一个变量且该变量的值会被改变时，应该用volatile声明，该关键字的作用是防止优化编译器把变量从内存装入CPU寄存器中。如果变量被装入寄存器，那么两个线程有可能一个使用内存中的变量，一个使用寄存器中的变量，这会造成程序的错误执行。<br>主要可用于以下三个方面：</p>
<ul>
<li>中断服务程序中修改的供其它程序检测的变量需要加 volatile；</li>
<li>多任务环境下各任务间共享的标志应该加 volatile；</li>
<li>存储器映射的硬件寄存器通常也要加 volatile 说明，因为每次对它的读写都可能由不同意义。</li>
</ul>
<p>volatile在修饰指针时，也存在类似const修饰指针时的常量指针和指针常量两种情况。所以volatile可用于修饰指针，或修饰指针所指的对象</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>Top</tag>
        <tag>CPP</tag>
      </tags>
  </entry>
  <entry>
    <title>Streaming MultiProcessor、Register、Shared-Memory对CUDA线程块尺寸的影响</title>
    <url>/2015/08/12/CUDA-Determine-block-size/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>线程块中线程总数的大小除了受到硬件中<code>Max Threads Per block</code>的限制，同时还要受到<code>Streaming Multiprocessor、Register</code>和<code>Shared Memory</code>的影响。这些条件的共同作用下可以获得一个相对更合适的<code>block</code>尺寸。当<code>block</code>尺寸太小时，将无法充分利用所有线程；当<code>block</code>尺寸太大时，如果线程需要的资源总和过多，<code>CUDA</code>将通过强制减少<code>block</code>数量来保证资源供应，同样无法利用所有线程。而<code>grid</code>的尺寸通常越大越好，当<code>grid</code>中的线程总数超过一次所能启动的并发线程总数时，过多的线程将以线程块为单位由CUDA进行新的调用，当然启动数量够用就可以了，以免浪费资源。</p>
<span id="more"></span>

<p>但具体最多我们可以定义的grid尺寸是多大跟计算能力倒是关系不大，所以你会发现消费级GTX970与专业级Tesla P4的计算能力分别是5.2和6.1，但可以定义的grid尺寸却相同。在我的测试中，同一段代码，一维网格和block的情况下，Block尺寸都为1024时，GTX1080的grid在win10系统桌面由显卡驱动的情况下，最多可以是78（WIN10系统。而linux下的Tesla P4和GTX970的grid最大值都是680。<br>然而二维grid和block的时候，block尺寸虽然有1024的限制，但grid尺寸可以大到你的int放不下，当然我们并没有这么多的流处理器在运算，只是过多的block在排着队等着被执行。<br>而CUDA的调度中为了隐藏内存访问带来的latency，一个block中的线程数量越多越好（确切来说是wrap数量）。</p>
<p>本文需要通过<code>NVIDIA</code>官方提供的一个非常有用的工具<code>C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v7.0\tools\CUDA_Occupancy_Calculator.xls</code>进行辅助计算来获得合适的<code>block</code>大小。这个<code>excle</code>表中的<code>Help</code>表单有详细的使用说明，以下分析将基于这个工具。<br>可以通过在编译时添加<code>--ptxas-options=-v</code>参数在编译时输出当前程序中核心函数所使用的<code>Register</code>、<code>Shared Memory</code>等大小，或者使用<code>nvcc --resource-usage kernel.cu</code>来获取，注意此处获取到的值只是nvcc在编译期为核函数分配的相应空间，如果通过动态的方式分配过shared memory，则需要单独加上你手动动态分配的shared memory才是总是shared memory。<br>输出的ptxas info可能包含的信息表示如下：<br><code>registers</code>: 寄存器<br><code>lmem</code>: <code>local memory</code> 局部内存<br><code>smem</code>: <code>shared memory</code> 共享内存<br><code>cmem</code>: <code>constant memory</code> 常量内存<br>其中<code>cmem</code>又可以分以一下一些情况（不全）：<br><code>cmem[0]</code> kernel arguments<br><code>cmem[2]</code> user defined <strong>constant</strong> objects<br><code>cmem[16]</code> compiler generated constants (some of which may correspond to literal constants in the source code)</p>
<p>参考：<a href="https://devtalk.nvidia.com/default/topic/493425/ptxas-info-unexplained-what-is-cmem-n-/">https://devtalk.nvidia.com/default/topic/493425/ptxas-info-unexplained-what-is-cmem-n-/</a></p>
<p>显卡信息可以由官方示例中的<code>deviceQuery</code>得出，当然也可以查官方说明。<br>看着这个表挺复杂，其实只需要记住我们所要设定的线程块尺寸只要能够保证<strong>SM满占</strong>即可。</p>
<h2 id="SM的限制对block尺寸的影响"><a href="#SM的限制对block尺寸的影响" class="headerlink" title="SM的限制对block尺寸的影响"></a>SM的限制对block尺寸的影响</h2><p><code>Multiprocessor</code>(以下所有的<code>Multiprocessor</code>都是指<code>Streaming Multiprocessor</code>，即SM,具体SM在GPU中的结构组织参见<a href="http://notes.maxwi.com/2015/06/11/CUDA-study-notes/">http://notes.maxwi.com/2015/06/11/CUDA-study-notes/</a>基本概念中的图示)中<code>thread</code>数量的限制主要影响工作状态的线程是否能够占满当前的整个<code>Multiprocessor</code>。为了使工作状态的线程能够占满整个<code>Multiprocessor</code>，<code>block</code>中的<code>thread</code>的总数应当不小于<code>Max Threads Per Multiprocessor / Max Thread Blocks Per Multiprocessor</code>，对于该表，也就是使<code>Occupancy of each Multiprocessor</code>为<code>100%</code>即可。<code>Max Thread Blocks Per Multiprocessor</code>无法由<code>deviceQuery</code>得到，表中会给出，其实也很容易计算得到<code>Max Threads Per Multiprocessor / 32</code>（因为一个block一次最小也要启动一个wrap，即32个线程），同一计算能力的显卡这些基本信息都是一样的。</p>
<p>下图所示为CUDA_Occupancy_Calculator给出的计算能力为5.0的GPU的参数。<br><img data-src="1.png" alt="Physical Limits for GPU Compute Capability">  </p>
<p>此时线程块的中线程数量应当不小于2048/32 = 64。当线程块的数量小于64时，由于每个Multiprocessor中可以含有的最大线程块只有32个，所以此时32个线程块乘以这个小于64的数字必然要小于2048，也就是无论怎样都无法使线程填满整个Multiprocessor，导致SM中会有空闲的Streaming Processor。所以根据要填满SM，则要求每个线程块中至少需要有64个线程。如果将线程块尺寸设置为1024，则此时根据SM总线程的限制2048，每个SM正好可以启动2个线程块，如果我们每个线程块上的资源都够用，那这就是一个最佳尺寸。然而通常资源是最大限制，所以下面借助官方工具来综合考虑资源占用下的线程块尺寸。</p>
<p>注意：1). 当前计算能力5.0的设备每个线程块中线程数量上限Maximum Thread Block Size=1024、2). CUDA中线程组织单位为Wrap，此处Threads per Warp=32，所以线程块中的线程数量应为32的倍数。3). 各维都有大小限制，计算能力5.0的三维分别为1024,1024,64</p>
<h2 id="CUDA-Occupancy-Calculator的使用"><a href="#CUDA-Occupancy-Calculator的使用" class="headerlink" title="CUDA_Occupancy_Calculator的使用"></a>CUDA_Occupancy_Calculator的使用</h2><p>下图为<code>CUDA_Occupancy_Calculator</code>计算结果，由于此处只讨论了SM中线程及线程块的限制对<code>block</code>尺寸的影响，所以这里只需要使曲线的红三角在波峰即可。注意第一张图中的1.)、1.b)需要根据自己的硬件情况进行选择；2).需要自己填入的程序参数(可以通过2.2的方法获得)，3).工具计算出的GPU使用率，显示此时占用为100%，也就是SM中的活动线程束为64个，即64*32=2048，SM处于满占状态。其他各图是其对应的曲线，由第二幅图可以看出在<code>register</code>和<code>shared memory</code>固定的情况下，block尺寸设置为256, 512, 1024时都可以占满SM，block尺寸越小，同一个block中可使用的Shared Memory和每个线程中可使用Register就越大，因为同一个SM中的block共享这些资源。。它们都有以下特点：1). 大于64，满足不小于<code>Max Threads Per Multiprocessor / Max Thread Blocks Per Multiprocessor</code>; 2). 32的整数倍，满足线程束的最小单位Wrap; 3). 总线程数可以被2048整除，因为<code>Max Threads Per Multiprocessor=2048</code>。<br><img data-src="2.png" alt="CUDA Occupancy Calculator"><br><img data-src="3.png" alt="Impact of Varying Block Size"><br><img data-src="4.png" alt="Impact of Varying Shared Memory Usage Per Block"><br><img data-src="5.png" alt="Impact of Varying Register Count Per Thread ">  </p>
<h2 id="Register对block尺寸的影响"><a href="#Register对block尺寸的影响" class="headerlink" title="Register对block尺寸的影响"></a>Register对block尺寸的影响</h2><p>计算能力为5.0的设备<code>Registers per Multiprocessor=65536，Max Registers per Thread=256</code>。也就是说一个SM总共也就只有65536个<code>register</code>，一个<code>thread</code>最多能定义256大小的<code>register</code>，根据上图可以看出，显然当<code>Register Per Thread</code>大于32时性能就要开始降低了。因为当前情况下SM中的所有线程都被占满了(此处占满意思是所有线程都为活动线程)，也就是说在这种block参数配置下，一个SM最多可以启动2048个线程(注意是最多可以，并不是说一定要，比如我一共就1000个数据，当然就启动1000个线程就可以了)，由于SM中能使用的register最多只有65536，当SM中的资源不够用时，SM就会强制减少block，所以<code>Register Per Thread</code>应该不大于<code>Registers per Multiprocessor / Max Threads per Multiprocessor</code>，也就是65536 / 2048 = 32，如何降低register占用是个很难的调整阶段，只能慢慢多调</p>
<h2 id="Shared-Memory对block尺寸的影响"><a href="#Shared-Memory对block尺寸的影响" class="headerlink" title="Shared Memory对block尺寸的影响"></a>Shared Memory对block尺寸的影响</h2><p>计算能力为5.0的设备<code>Shared Memory per Multiprocessor (bytes)=65536，Max Shared Memory per Block=49152</code>。也就是说block中的<code>smem(Shared Memory)</code>必须要小于49152，要想使得SM中的线程全部占满，那么整个SM中占用的smem必须小于65536。由于smem是以block为单位进行分配，所以当smem不够用时也就会以block为单位进行减少线程。所以<code>Shared Memory Per Block (bytes)</code>应该不大于<code>Shared Memory per Multiprocessor / Active Thread Blocks per Multiprocessor = Shared Memory per Multiprocessor / (Max Threads per Multiprocessor / Threads Per Block)</code>，当block尺寸设置为256时，<code>Shared Memory Per Block (bytes)</code>最大值为65536 / (2048/256) = 8192，单位是bytes。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>block最佳尺寸应该满足：<br>1). 不小于<code>Max Threads Per Multiprocessor / Max Thread Blocks Per Multiprocessor</code>；<br>2). 32的整数倍；<br>3). 可以被<code>Max Threads Per Multiprocessor</code>整除。<br>4). <code>Register Per Thread</code>应该不大于<code>Registers per Multiprocessor / Max Threads per Multiprocessor</code>，否则根据<code>CUDA_Occupancy_Calculator.xls</code>参考调节block尺寸以获得最佳性能。  </p>
<p>5). <code>Shared Memory Per Block (bytes)</code>最大值应该不大于<code>Shared Memory per Multiprocessor / (Max Threads per Multiprocessor / Threads Per Block)</code>，否则根据<code>CUDA_Occupancy_Calculator.xls</code>参考调节block尺寸以获得最佳性能。<br><strong>一句话总结：保证每个SM中可以启动的线程总数达到最大值的情况下block中的线程数越大越好。</strong></p>
<p>如果原理都懂了，也可以直接使用CUDA 6.5之后带的一个API，自动帮你计算Grid尺寸和block尺寸：<code>cudaOccupancyMaxPotentialBlockSize()</code>，该API在<code>cuda_runtime.h</code>头文件中，必须采用NVCC编译才能使用，其定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function">__inline__ __host__ CUDART_DEVICE cudaError_t <span class="title">cudaOccupancyMaxPotentialBlockSize</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span>    *minGridSize,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span>    *blockSize,</span></span></span><br><span class="line"><span class="params"><span class="function">    T       func,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">size_t</span>  dynamicSMemSize = <span class="number">0</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span>     blockSizeLimit = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">cudaOccupancyMaxPotentialBlockSizeVariableSMem</span>(minGridSize, blockSize, func, __cudaOccupancyB2DHelper(dynamicSMemSize), blockSizeLimit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参数意义：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">minGridSize     = Suggested min grid size to achieve a full machine launch.</span><br><span class="line">blockSize       = Suggested block size to achieve maximum occupancy.</span><br><span class="line">func            = Kernel function.</span><br><span class="line">dynamicSMemSize = Size of dynamically allocated shared memory. Of course, it is known at runtime before any kernel launch. The size of the statically allocated shared memory is not needed as it is inferred by the properties of func.</span><br></pre></td></tr></table></figure>
<p>参考：<a href="https://stackoverflow.com/questions/9985912/how-do-i-choose-grid-and-block-dimensions-for-cuda-kernels">https://stackoverflow.com/questions/9985912/how-do-i-choose-grid-and-block-dimensions-for-cuda-kernels</a></p>
<p>注意：  </p>
<ol>
<li>没有标明单位的量其单位都为个，例如register。  </li>
<li><code>CUDA_Occupancy_Calculator</code>给出了<code>register</code>和<code>shared memory</code>的分配单位，精确优化时应该非常有用。<br>Register allocation unit size        256<br>Register allocation granularity        warp<br>Shared Memory allocation unit size  256<br>Warp allocation granularity         4   </li>
</ol>
]]></content>
      <categories>
        <category>CUDA</category>
      </categories>
      <tags>
        <tag>CUDA</tag>
        <tag>Notes</tag>
        <tag>Top</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker run命令参数</title>
    <url>/2017/12/21/docker-run/</url>
    <content><![CDATA[<p><code>docker run</code>应该是我们日常使用docker中最常用，也最重要的命令。<br>命令格式如下：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker run [OPTIONS] IMAGE [COMMAND] [ARG...]</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2 id="OPTIONS"><a href="#OPTIONS" class="headerlink" title="OPTIONS"></a>OPTIONS</h2><p>现在的docker版本（17.09.1-ce）中run有很多可以选择的参数，用到再记录，以下是网上看到针对1.12的版本。</p>
<p>加粗的地方表示比较常用</p>
<p><strong><code>-d, --detach=false</code>         指定容器运行于前台还是后台，默认为false</strong><br><strong><code>-i, --interactive=false</code>   打开STDIN，用于控制台交互</strong><br><strong><code>-t, --tty=false</code>            分配tty设备，该可以支持终端登录，默认为false</strong><br><code>-u, --user=&quot;&quot;</code>              指定容器的用户<br><code>-a, --attach=[]</code>            登录容器（必须是以docker run -d启动的容器）<br><code>-w, --workdir=&quot;&quot;</code>           指定容器的工作目录<br><code>-c, --cpu-shares=0</code>        设置容器CPU权重，在CPU共享场景使用<br><code>-e, --env=[]</code>               指定环境变量，容器中可以使用该环境变量<br><code>-m, --memory=&quot;&quot;</code>            指定容器的内存上限<br><code>-P, --publish-all=false</code>    指定容器暴露的端口<br><strong><code>-p, --publish=[]</code>           指定容器暴露的端口</strong><br><code>-h, --hostname=&quot;&quot;</code>          指定容器的主机名<br><strong><code>-v, --volume=[]</code>            给容器挂载存储卷，挂载到容器的某个目录</strong><br><code>--volumes-from=[]</code>          给容器挂载其他容器上的卷，挂载到容器的某个目录<br><code>--cap-add=[]</code>               添加权限<br><code>--cap-drop=[]</code>              删除权限<br><code>--cidfile=&quot;&quot;</code>               运行容器后，在指定文件中写入容器PID值，一种典型的监控系统用法<br><code>--cpuset=&quot;&quot;</code>                设置容器可以使用哪些CPU，此参数可以用来容器独占CPU<br><code>--device=[]</code>                添加主机设备给容器，相当于设备直通<br><code>--dns=[]</code>                   指定容器的dns服务器<br><code>--dns-search=[]</code>            指定容器的dns搜索域名，写入到容器的/etc/resolv.conf文件<br><code>--entrypoint=&quot;&quot;</code>            覆盖image的入口点<br><code>--env-file=[]</code>              指定环境变量文件，文件格式为每行一个环境变量<br><code>--expose=[]</code>                指定容器暴露的端口，即修改镜像的暴露端口<br><code>--link=[]</code>                  指定容器间的关联，使用其他容器的IP、env等信息<br><code>--lxc-conf=[]</code>              指定容器的配置文件，只有在指定–exec-driver=lxc时使用<br><strong><code>--name=&quot;&quot;</code>                  指定容器名字，后续可以通过名字进行容器管理，links特性需要使用名字</strong><br><code>--net=&quot;bridge&quot;</code>             容器网络设置:  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bridge 使用docker daemon指定的网桥       </span><br><span class="line">host    //容器使用主机的网络    </span><br><span class="line">container:NAME_or_ID  &gt;//使用其他容器的网路，共享IP和PORT等网络资源    </span><br><span class="line">none 容器使用自己的网络（类似--net=bridge），但是不进行配置   </span><br></pre></td></tr></table></figure>
<p><code>--privileged=false</code>         指定容器是否为特权容器，特权容器拥有所有的capabilities<br><code>--restart=&quot;no&quot;</code>             指定容器停止后的重启策略:  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">no：容器退出时不重启    </span><br><span class="line">on-failure：容器故障退出（返回值非零）时重启   </span><br><span class="line">always：容器退出时总是重启    </span><br></pre></td></tr></table></figure>
<p><code>--rm=false</code>                 指定容器停止后自动删除容器(不支持以docker run -d启动的容器)<br><code>--sig-proxy=true</code>           设置由代理接受并处理信号，但是SIGCHLD、SIGSTOP和SIGKILL不能被代理    </p>
<h2 id="常用场景"><a href="#常用场景" class="headerlink" title="常用场景"></a>常用场景</h2><p><strong>后台运行一个容器用于开发</strong></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker run -itd --name dev -v ~/data:/root/data -p 1080:80 &lt;image&gt; /bin/bash </span><br></pre></td></tr></table></figure>

<p>然后通过以下命令连接：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it dev /bin/bash</span><br></pre></td></tr></table></figure>

<p><strong>让容器自动运行命令并在命令停止后自动重启后执行</strong></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker run -d --restart=always &lt;image&gt; ping docker.com</span><br></pre></td></tr></table></figure>

<p><strong>后台运行数据库容器并使用服务容器进行连接</strong></p>
<p>数据库容器，本机数据库目录将挂载到容器中：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker run -d --name=server-db --restart=always -v /server/mysql-data:/mysql-data &lt;image&gt; /usr/bin/mysql_safe -d</span><br></pre></td></tr></table></figure>

<p>服务容器，在服务容器中将可以直接通过server-db来访问数据库容器，并开放80端口给公网</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker run -d --name=server-http --restart=always --<span class="built_in">link</span>=server-db -p 8080:80 &lt;image&gt; /usr/bin/httpd --DFOREGROUND</span><br></pre></td></tr></table></figure>

<p><strong>让容器运行一个命令后自动删除</strong></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker run --<span class="built_in">rm</span> python:2.7-slim python --version </span><br></pre></td></tr></table></figure>

<p><strong>交互式运行python之后，当退出python交互时容器自动删除</strong></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker run -it --<span class="built_in">rm</span> python:2.7-slim python</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://docs.docker.com/engine/reference/commandline/run/">docker run</a></li>
<li><a href="http://blog.csdn.net/kunloz520/article/details/53839237">docker-1.12 run命令运行以及参数详解</a></li>
</ol>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>python pip源配置</title>
    <url>/2017/12/19/python-pip-conf/</url>
    <content><![CDATA[<p>由于种种原因我们可能无法正常连接到python的官方pip源，或者连接速度很慢，或者由于根证书的原因在安装包时会提示连接证书问题，可以通过修改pip的配置来修改为国内其他源，并信任相应的源，避免证书错误，提高包安装速度。</p>
<span id="more"></span>

<h2 id="配置方法"><a href="#配置方法" class="headerlink" title="配置方法"></a>配置方法</h2><p>pip源及配置文件位置：</p>
<p>Linux/Unix:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/etc/pip.conf</span><br><span class="line">~/.pip/pip.conf</span><br><span class="line">~/.config/pip/pip.conf</span><br></pre></td></tr></table></figure>

<p>Mac OSX:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">~/Library/Application Support/pip/pip.conf</span><br><span class="line">~/.pip/pip.conf</span><br><span class="line">/Library/Application Support/pip/pip.conf</span><br></pre></td></tr></table></figure>

<p>Windows:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">%APPDATA%\pip\pip.ini</span><br><span class="line">%HOME%\pip\pip.ini</span><br><span class="line">C:\Documents and Settings\All Users\Application Data\PyPA\pip\pip.conf # (Windows XP)</span><br><span class="line">C:\ProgramData\PyPA\pip\pip.conf # (Windows 7及以后)</span><br></pre></td></tr></table></figure>

<p>可以配置的选项：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[global]</span><br><span class="line">index-url = http://mirrors.aliyun.com/pypi/simple/ # 阿里源，可以换成其他的源  </span><br><span class="line">trusted-host = mirrors.aliyun.com            # 添加阿里源为可信主机，要不然可能报错  </span><br><span class="line">disable-pip-version-check = true             # 取消pip版本检查，排除每次都报最新的pip  </span><br><span class="line">timeout = 120  # 连接超时时长</span><br></pre></td></tr></table></figure>

<h2 id="只在安装时指定源"><a href="#只在安装时指定源" class="headerlink" title="只在安装时指定源"></a>只在安装时指定源</h2><p>也可以不修改配置，只在pip安装时指定，例如：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">pip install -i http://mirrors.aliyun.com/pypi/simple/ --trusted-host mirrors.aliyun.com &lt;package&gt;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Dockerfile的编写</title>
    <url>/2017/12/14/docker-Dockerfile/</url>
    <content><![CDATA[<p>记录Dockerfile的编写规则和用法</p>
<p>Dockerfile就是用于构建image的一系列命令和参数构成的脚本，通过<code>docker build -t &lt;image_name:tag&gt; -f &lt;/path/to/Dockerfile&gt; .</code>来构建。</p>
<p><code>docker build</code>命令从名为<code>Dockerfile</code>的文件和<code>context</code>来构建image，context是<code>PATH</code>（本地目录）或者<code>URL</code>（Git repository位置）处的文件。context会以递归方式处理，所以PATH的子目录和git的submodules都会处理，同样这里要小心用于作为PATH的目录最好不要有与镜像无关的文件，通常会新建一个空文件夹做为context的PATH。</p>
<p>PATH下的<code>.dockerignore</code>可以用于排除文件和目录。</p>
<p>构建工作由Docker守护进程运行，而不是docker的CLI，其中<code>-t</code>参数用于指定镜像的repository和tag，可以有多个<code>-t</code>，<code>-f</code>指定<code>Dockerfile</code>的路径，最后的<code>.</code>表示上下文件环境为当前目录。</p>
<p>例如：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker build -t blueyi/python-3.6:dev -f ~/docker/Dockerfile .</span><br></pre></td></tr></table></figure>

<span id="more"></span>


<h2 id="dockerignore"><a href="#dockerignore" class="headerlink" title=".dockerignore"></a>.dockerignore</h2><p>在docker CLI将上下文发送到docker守护程序之前，它会在上下文的根目录中查找名为.dockerignore的文件。如果此文件存在，CLI将修改上下文以排除匹配其中模式的文件和目录。这有助于避免不必要地向守护程序发送大型或敏感文件和目录，并可能使用ADD或COPY将其添加到映像。</p>
<p><code>.dockerignore</code>文件中以<code>#</code>开头的行将被视为注释，<code>!</code>开头用于排除例外（即不排除）</p>
<p>另外有一个特殊的通配符<code>**</code>，它匹配任何数量的目录（包含零），例如<code>**/*.go</code>将排除所有目录中找到的以<code>.go</code>结尾的所有文件，包含构建上下文的根。</p>
<p>举例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># comment</span><br><span class="line">*/temp*</span><br><span class="line">*/*/temp*</span><br><span class="line">temp?</span><br></pre></td></tr></table></figure>

<p>解释：</p>
<ul>
<li><code># comment</code> 忽略</li>
<li><code>/temp*</code> 在根的任何直接子目录中排除其名称以temp开头的文件和目录。 例如，普通文件<code>/somedir/temporary.txt</code>被排除，目录<code>/somedir/temp</code>也被排除。</li>
<li><code>*/*/temp*</code> 从根目录下两级的任何子目录中排除以temp开头的文件和目录。 例如，排除了<code>/somedir/subdir/temporary.txt</code>。</li>
<li><code>temp?</code>    排除根目录中名称为temp的单字符扩展名的文件和目录。 例如，<code>/tempa</code>和<code>/tempb</code>被排除。</li>
</ul>
<h2 id="Dockerfile编写规范"><a href="#Dockerfile编写规范" class="headerlink" title="Dockerfile编写规范"></a>Dockerfile编写规范</h2><p>Dockerfile文件内容格式如下：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Comment</span></span><br><span class="line">INSTRUCTION arguments</span><br></pre></td></tr></table></figure>

<p>其中<code>INSTRUCTION</code>不区分大小写，但建议大写，第一条指令必须是<code>FROM</code>，用于指定构建镜像的基础镜像，<code>#</code>后面跟注释，但解析器指令除外（Parser directives）</p>
<p><strong>每一条指令都会独立运行，相互之间没有没有上下文关系</strong></p>
<p>在构建过程中每次生成一层新的镜像的时候这个镜像就会被缓存。即使是后面的某个步骤导致构建失败，再次构建的时候就会从失败的那层镜像的前一条指令继续往下执行。<br>如果不想使用这种缓存功能，可以在构建的时候加上<code>--no-cache</code>选项：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker build --no-cache -t=<span class="string">&quot;blueyi/centos&quot;</span> .</span><br></pre></td></tr></table></figure>

<h3 id="解析器指令（Parser-directives）"><a href="#解析器指令（Parser-directives）" class="headerlink" title="解析器指令（Parser directives）"></a>解析器指令（Parser directives）</h3><p>解析器指令为可选的，会影响后续处理Dockerfile行，解析器指令形如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># directive = value</span><br></pre></td></tr></table></figure>

<p>解析器指令必须放在Dockerfile的最顶端，使用行延续（<code>\</code>）、出现2次、写在任何构建指令后等都将导致解析器指令无效。<br>暂时只有一个解析器指令<code>escape</code>，用于指定Dockerfile中的转义字符，如果未定义，则默认为<code>\</code>，用法如下：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># escape=\</span></span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># escape=`</span></span><br></pre></td></tr></table></figure>

<p>为了避免windows上的路径中会有<code>\</code>（例如：<code>c:\\</code>），建议windows上将转义符设置为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">`</span><br></pre></td></tr></table></figure>

<h3 id="环境变量（Environment-replacement）"><a href="#环境变量（Environment-replacement）" class="headerlink" title="环境变量（Environment replacement）"></a>环境变量（Environment replacement）</h3><p>环境变量由<code>ENV</code>语句声明（<code>ENV</code>其实也是一个指令），可以用于其他一些指令中被解释出来，声明之后可以通过类似于shell中变量引用的方式引用：<code>$variable_name</code>或者<code>$&#123;variable_name&#125;</code>。同样支持类似bash的修饰符：</p>
<ul>
<li><code>$&#123;variable:-word&#125;</code> 表示如果设置了variable，则结果将是该值。如果variable未设置，那么word将是结果。</li>
<li><code>$&#123;variable:+word&#125;</code> 表示如果设置了variable，那么word将是结果，否则结果是空字符串。</li>
</ul>
<p>ENV指令用法如下：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ENV</span> &lt;key&gt; &lt;value&gt;</span><br><span class="line"><span class="keyword">ENV</span> &lt;key&gt;=&lt;value&gt; ...</span><br></pre></td></tr></table></figure>

<p>第一种单行的形式value部分的任何内容包含空格，都会成为key的值，而第二种形式可以设置多个对，引号和反斜杠可用于值内包含空格。如：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ENV</span> myName=<span class="string">&quot;John Doe&quot;</span> myDog=Rex\ The\ Dog \</span><br><span class="line">    myCat=fluffy</span><br></pre></td></tr></table></figure>

<p>等价于：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ENV</span> myName John Doe</span><br><span class="line"><span class="keyword">ENV</span> myDog Rex The Dog</span><br><span class="line"><span class="keyword">ENV</span> myCat fluffy</span><br><span class="line">````</span><br><span class="line"></span><br><span class="line">当前前一咱更好，构建的镜像更高效。</span><br><span class="line"></span><br><span class="line">可以通过`\`来进行对`$`转义。用例：</span><br><span class="line"></span><br><span class="line">```Dockerfile</span><br><span class="line"><span class="keyword">FROM</span> busybox</span><br><span class="line"><span class="keyword">ENV</span> foo /bar</span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> <span class="variable">$&#123;foo&#125;</span>   <span class="comment"># WORKDIR /bar</span></span></span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> . <span class="variable">$foo</span>       <span class="comment"># ADD . /bar</span></span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> \<span class="variable">$foo</span> /quux <span class="comment"># COPY $foo /quux</span></span></span><br></pre></td></tr></table></figure>

<p><strong>由于每一条ENV对应一个镜像层，所以环境变量替换具有延迟性，即环境变量的声明将只会在其之后的指令中才有效</strong><br>例如：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ENV</span> abc=hello</span><br><span class="line"><span class="keyword">ENV</span> abc=bye def=$abc</span><br><span class="line"><span class="keyword">ENV</span> ghi=$abc</span><br></pre></td></tr></table></figure>

<p>def值为hello，不是bye，因为该句中设置的变量只在后面的指令中有效。而ghi的值为bye，因为abc在上一条指令中被修改为bye。</p>
<p>环境变量支持以下命令：</p>
<ul>
<li>ADD</li>
<li>COPY</li>
<li>ENV</li>
<li>EXPOSE</li>
<li>LABEL</li>
<li>USER</li>
<li>WORKDIR</li>
<li>VOLUME</li>
<li>STOPSIGNAL</li>
</ul>
<p>以及<code>ONBUILD</code>与上面指令的组合（1.4之前的版本不支持）。</p>
<p>注意：</p>
<ul>
<li><code>ENV</code>定义的环境变量不能被CMD引用</li>
<li>通过<code>ENV</code>定义的环境变量会永久保存到通过该镜像创建的任何容器中，可以通过<code>env</code>来查看</li>
<li>可以通过<code>docker run</code>命令中通过<code>-e &lt;key&gt;=&lt;value&gt;</code>（或<code>--env</code>）参数来传递环境变量，以便在运行容器后命令或修改该变量，如：<code>docker run -it -e &quot;TEST=hello&quot; &lt;image&gt;</code></li>
</ul>
<p>定义环境变量的同时可以引用已经定义的环境变量，ENV指令中可以直接引用的环境变量有：<code>HOME</code>、<code>HOSTNAME</code>、<code>PATH</code>和<code>TERM</code>（默认是xterm）。</p>
<p>举例：</p>
<p>如下Dockerfile是一个非常不合理的处理方式，因为多条的ENV可以合并为一条。</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">set</span> -ex &amp;&amp; apt-get update &amp;&amp; apt-get install -y iputils-ping</span></span><br><span class="line"><span class="keyword">ENV</span> PATH /usr/local/bin:$PATH</span><br><span class="line"><span class="keyword">ENV</span> LANG C.UTF-<span class="number">8</span></span><br><span class="line"><span class="keyword">ENV</span> TERM xterm</span><br><span class="line"><span class="keyword">ENV</span> PYTHON_VERSION <span class="number">3.5</span>.<span class="number">3</span></span><br><span class="line"><span class="keyword">ENV</span> name1=ping name2=on_ip</span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> <span class="variable">$name1</span> <span class="variable">$name2</span></span></span><br></pre></td></tr></table></figure>

<p>可以使用<code>docker inspect</code>来查看镜像的<code>ENV</code></p>
<h2 id="Dockerfile指令"><a href="#Dockerfile指令" class="headerlink" title="Dockerfile指令"></a>Dockerfile指令</h2><h3 id="FROM"><a href="#FROM" class="headerlink" title="FROM"></a>FROM</h3><p><code>FROM</code>用于为后续的指令指定其运行所需要的基础镜像（Base Image），所以Dockerfile中<code>FROM</code>必须是第一个指令（ARG除外），如果指定的该镜像不在本地，则Docker会自动从远程仓库获取。</p>
<p>新的docker版本中引入了一个新的指令<code>ARG</code>，该指令是唯一可以出现在FROM之前的指令，可以配合FROM指令来指定一些FROM指令中想要引用的变量，例如版本信息。</p>
<p>FROM指令用法如下：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> &lt;image&gt; [AS &lt;name&gt;]</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line"><span class="keyword">FROM</span> &lt;image&gt;[:&lt;tag&gt;] [AS &lt;name&gt;]</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line"><span class="keyword">FROM</span> &lt;image&gt;[@&lt;digest&gt;] [AS &lt;name&gt;]</span><br></pre></td></tr></table></figure>

<ul>
<li><code>ARG</code>是唯一可以出现在FROM之前的指令</li>
<li><code>FROM</code>可以在单个Dockerfile中多次出现，以创建多个镜像</li>
<li><code>AS &lt;name&gt;</code>选项为可选，如果有的话，该name将可以用于后面的FROM或<code>COPY --from=&lt;name|index&gt;</code>指令中的name，用以引用该image。</li>
<li><code>tag</code>和<code>digest</code>也为可选的，如果省略，则默认为latest</li>
</ul>
<p><code>ARG</code>与<code>FROM</code>一起使用的一个用法：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ARG</span>  CODE_VERSION=latest</span><br><span class="line"><span class="keyword">FROM</span> base:$&#123;CODE_VERSION&#125;</span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash">  /code/run-app</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> extras:$&#123;CODE_VERSION&#125;</span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash">  /code/run-extras</span></span><br></pre></td></tr></table></figure>

<h3 id="RUN"><a href="#RUN" class="headerlink" title="RUN"></a>RUN</h3><p><code>RUN</code>用于运行命令。<br>RUN有2种形式：</p>
<ul>
<li><code>RUN &lt;command&gt;</code> （<em>shell</em>形式，命令在shell中运行，Linux上为<code>/bin/sh -c</code>，Windows上为<code>cmd /S/C</code>）</li>
<li><code>RUN [&quot;executable&quot;，&quot;param1&quot;，&quot;param2&quot;]</code>（exec 形式）</li>
</ul>
<p><strong>每一条RUN指令都会提交一个新层到当前镜像，提交结果将会用于后续Dockerfile中的指令, 镜像历史类似于版本控制系统，可以从任何历史点进行镜像的创建，可以通过命令<code>docker history &lt;image&gt;</code>查看镜像历史层</strong></p>
<p>shell形式的RUN命令支持续行，例如：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="language-bash"> /bin/bash -c <span class="string">&#x27;source $HOME/.bashrc; \</span></span></span><br><span class="line"><span class="string"><span class="language-bash">echo $HOME&#x27;</span></span></span><br></pre></td></tr></table></figure>

<p>等价于</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="language-bash"> /bin/bash -c <span class="string">&#x27;source $HOME/.bashrc; echo $HOME&#x27;</span></span></span><br></pre></td></tr></table></figure>

<p>如果要使用不同的shell，例如<code>bash</code>，则需要使用<code>exec</code>形式，如：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="language-bash"> [<span class="string">&quot;/bin/bash&quot;</span>, <span class="string">&quot;-c&quot;</span>, <span class="string">&quot;echo hello&quot;</span>]</span></span><br></pre></td></tr></table></figure>

<p>由于exec形式作为JSON数组解析，所以单词必须使用双引号（”）而不是单引号（’）括住。</p>
<p>每一次运行RUN指令时，由于会重用缓存，并且不会对缓存进行有效性检查，例如<code>RUN apt-get dist-upgrade -y</code>生成的缓存也会用于下一次build，可以通过<code>docker build --no-cache</code>来禁止使用缓存。</p>
<h3 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h3><p><code>CMD</code>指令用于指定容器启动时需要运行的程序。例如我们通常运行容器时为了能够执行其中的<code>/bin/bash</code>来进入到容器中交互，会如下运行：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker run -it &lt;image&gt; /bin/bash</span><br></pre></td></tr></table></figure>

<p>后面的<code>/bin/bash</code>就相当于告诉容器运行之后运行<code>/bin/bash</code>，等效于我们在Dockerfile中添加一条：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&#x27;/bin/bash&#x27;</span>]</span></span><br></pre></td></tr></table></figure>

<p>如果Dockerfile已经有了CMD指令，我们传递的运行命令将会覆盖其中的CMD设置。</p>
<p><strong>一个Dockerfile中只能有一个CMD指令</strong></p>
<p><code>CMD</code>指令三种形式：</p>
<ul>
<li><code>CMD [&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;]</code> (exec形式, 首选形式)</li>
<li><code>CMD [&quot;param1&quot;,&quot;param2&quot;]</code> (做为ENTRYPOINT中命令的默认参数)</li>
<li><code>CMD command param1 param2</code> (shell形式，类似RUN，<code>&lt;cmd&gt;</code>将在<code>/bin/sh -c</code>中执行)</li>
</ul>
<p>当CMD指令做为ENTRYPOINT指令时的命令参数时，同样是以JSON格式解析，所以也要使用双引号来包围参数而不是单引号。</p>
<p><strong>尽量各命令参数都使用双引号而不是单引号</strong></p>
<p><strong>注意：CMD命令与RUN命令完全不同，RUN运行一个命令将提交一个镜像的层（layer），而CMD在构建时并不执行任何操作，只是用于指定容器的运行时要执行的命令</strong></p>
<h3 id="LABEL"><a href="#LABEL" class="headerlink" title="LABEL"></a>LABEL</h3><p><code>LABEL</code>指令用于向镜像中添加元数据，可以通过<code>docker inspect</code>命令查看，如</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">docker inspect --format=<span class="string">&#x27;&#123;&#123;.Config.Labels&#125;&#125;&#x27;</span> &lt;image&gt;</span><br></pre></td></tr></table></figure>
<p>每一个<code>LABEL</code>指令都会产生一个镜像层，所以尽量将多条<code>LABEL</code>放到一条中。</p>
<p><code>LABEL</code>用法：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">LABEL</span><span class="language-bash"> &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; ...</span></span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">LABEL</span><span class="language-bash"> <span class="string">&quot;com.example.vendor&quot;</span>=<span class="string">&quot;ACME Incorporated&quot;</span></span></span><br><span class="line"><span class="keyword">LABEL</span><span class="language-bash"> com.example.label-with-value=<span class="string">&quot;foo&quot;</span></span></span><br><span class="line"><span class="keyword">LABEL</span><span class="language-bash"> version=<span class="string">&quot;1.0&quot;</span></span></span><br><span class="line"><span class="keyword">LABEL</span><span class="language-bash"> description=<span class="string">&quot;This text illustrates \</span></span></span><br><span class="line"><span class="string"><span class="language-bash">that label-values can span multiple lines.&quot;</span></span></span><br></pre></td></tr></table></figure>

<p>等价于：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">LABEL</span><span class="language-bash"> <span class="string">&quot;com.example.vendor&quot;</span>=<span class="string">&quot;ACME Incorporated&quot;</span> \ </span></span><br><span class="line">       com.example.label-with-value=<span class="string">&quot;foo&quot;</span> \</span><br><span class="line">       version=<span class="string">&quot;1.0&quot;</span> \</span><br><span class="line">       description=<span class="string">&quot;This text illustrates \</span></span><br><span class="line"><span class="string">that label-values can span multiple lines.&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="MAINTAINER-deprecated"><a href="#MAINTAINER-deprecated" class="headerlink" title="MAINTAINER (deprecated)"></a>MAINTAINER (deprecated)</h3><p>该指令已经新废弃，用于指定该镜像的维护者，现在可以使用<code>LABEL</code>更好的实现该功能。用法如下：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">MAINTAINER</span> &lt;name&gt;</span><br></pre></td></tr></table></figure>

<p>等价于：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">LABEL</span><span class="language-bash"> maintainer=<span class="string">&quot;name&quot;</span></span></span><br></pre></td></tr></table></figure>

<h3 id="EXPOSE"><a href="#EXPOSE" class="headerlink" title="EXPOSE"></a>EXPOSE</h3><p>用于指定容器运行后容器中监听的端口（也称为私有端口），当运行容器时使用<code>-P</code>参数时，容器将自动为监听端口分配宿主主机上相应的映射端口（也称为公共端口）。</p>
<p>用法：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">EXPOSE</span> &lt;port&gt; [&lt;port&gt;/&lt;protocol&gt;...]</span><br></pre></td></tr></table></figure>

<p>协议可选为<code>TCP</code>或<code>UDP</code>，如果不指定协议，则默认为<code>TCP</code>。</p>
<p>虽然支持<code>EXPOSE</code>时指定端口映射（<code>EXPOSE 80:8080</code>私有<code>80</code>到公共<code>8080</code>），而由于镜像在构建时并不能确定当容器运行时该端口是否被其他程序占用，所以不建议在<code>Dockerfile</code>中进行端口映射。</p>
<p>用例：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># PORT</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">8080</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">22</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">8009</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">8005</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">8443</span></span><br></pre></td></tr></table></figure>

<h3 id="ENV"><a href="#ENV" class="headerlink" title="ENV"></a>ENV</h3><p>同上面的环境变量部分</p>
<h3 id="ADD"><a href="#ADD" class="headerlink" title="ADD"></a>ADD</h3><p>用于从指定目录或者URL拷贝文件到镜像中。<br>用法如下：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ADD</span><span class="language-bash"> &lt;src&gt;... &lt;dest&gt;</span></span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> [<span class="string">&quot;&lt;src&gt;&quot;</span>,... <span class="string">&quot;&lt;dest&gt;&quot;</span>] <span class="comment"># 用于路径中带有空格的情况</span></span></span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ul>
<li><code>src</code>不是URL时，必须是相对于本地上下文件环境路径的相对路径，因为Docker会有构建之前将上下文件内容全部发送给Docker Daemon。</li>
<li><code>dest</code>结尾带有<code>/</code>时，docker会自动推测文件名，将目标文件拷贝到镜像中。（与linux中的cp命令其实一样）</li>
<li><code>src</code>为目录时，将复制目录里面的所有内容，目录本身不会被复制</li>
<li><code>src</code>为可以识别的压缩格式（tar.gz、gzip、bzip2、xz）等时，docker将会自动将其解压，解压功能类似于<code>tar -x</code>，但src为url时不可以</li>
<li><code>dest</code>必须是绝对路径，或者相对于<code>WORKDIR</code>的相对路径。</li>
</ul>
<p>用法举例：</p>
<p><strong>不好的用法</strong></p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ADD</span><span class="language-bash"> http://foo.com/package.tar.bz2 /tmp/</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> tar -xjf /tmp/package.tar.bz2 \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; make -C /tmp/package \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; <span class="built_in">rm</span> /tmp/package.tar.bz2</span></span><br></pre></td></tr></table></figure>

<p>实际上最后的删除并不会生效，因为rm命令将位于另一个独立的镜像层。</p>
<p>可以这样：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="language-bash"> curl http://foo.com/package.tar.bz2 \</span></span><br><span class="line"><span class="language-bash">    | tar -xjC /tmp/package \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; make -C /tmp/package</span></span><br></pre></td></tr></table></figure>

<h3 id="COPY"><a href="#COPY" class="headerlink" title="COPY"></a>COPY</h3><p>用法与<code>ADD</code>几乎完全一样，但更纯粹，不支持URL，不支持自动解压。</p>
<p>所以现在Docker团队推荐使用<code>COPY</code>进行文件拷贝，而不是<code>ADD</code></p>
<h3 id="ENTRYPOINT"><a href="#ENTRYPOINT" class="headerlink" title="ENTRYPOINT"></a>ENTRYPOINT</h3><p><code>ENTRYPOINT</code>指令与CMD非常相似，都是指定容器运行后需要运行的命令，不同的是当与<code>docker run</code>配合使用时，<code>docker run</code>后跟的执行内容将做为<code>ENTRYPOINT</code>指令指定的运行命令的参数，例如：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> centos</span><br><span class="line"><span class="keyword">MAINTAINER</span> allocator</span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> yum install -y nginx</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">echo</span> <span class="string">&#x27;hello world&#x27;</span> &gt; /usr/share/nginx/html/index.html</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">80</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;/usr/sbin/nginx&quot;</span>]</span></span><br></pre></td></tr></table></figure>

<p>启动容器</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker run --name <span class="built_in">test</span> -p 1080:80 -it test_nginx -g <span class="string">&quot;daemon off&quot;</span></span><br></pre></td></tr></table></figure>

<p>后面两个参数<code>-g &quot;daemon off&quot;</code>将传递给<code>/usr/sbin/nginx</code>作为参数运行。</p>
<p>当CMD与ENTRYPOINT同时出现时，如果<code>CMD</code>的内容不是一个完整的指令，则不带参数运行容器时，CMD的内容将做为<code>ENTRYPOINT</code>指令的参数。而如果此时<code>CMD</code>是一个完整的命令，它将覆盖掉<code>ENTRYPOINT</code>中的内容。如果此时运行容器时再带参数，则此参数会覆盖掉<code>CMD</code>指令的内容。</p>
<p>所以，可以这样使用：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;/usr/sbin/nginx&quot;</span>]</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;-g daemon off&quot;</span>]</span></span><br></pre></td></tr></table></figure>

<h3 id="VOLUME"><a href="#VOLUME" class="headerlink" title="VOLUME"></a>VOLUME</h3><p><code>VOLUME</code>指令为容器创建挂载卷，类似于<code>docker run</code>时使用的<code>-v</code>命令进行目录映射，只是<code>-v</code>可以指定本地目录到容器指定目录的挂载，而Dockerfile中只能指定从该镜像创建容器时容器中的挂载点，具体对应的本地目录将由docker自动分配，可以通过<code>docker inspect &lt;container&gt;</code>查看。</p>
<p>用法：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">VOLUME</span><span class="language-bash"> [<span class="string">&quot;/data1&quot;</span>, <span class="string">&quot;/data2&quot;</span>, ...]</span></span><br></pre></td></tr></table></figure>

<h3 id="USER"><a href="#USER" class="headerlink" title="USER"></a>USER</h3><p><code>USER</code>指令用于设置其后的<code>RUN</code>、<code>CMD</code>、<code>ENTRYPOINT</code>命令的运行用户，因为默认docker将以root身份运行这些命令。</p>
<p>用法：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">USER</span> &lt;<span class="keyword">user</span>&gt;[:&lt;group&gt;] or</span><br><span class="line"><span class="keyword">USER</span> &lt;UID&gt;[:&lt;GID&gt;]</span><br></pre></td></tr></table></figure>

<h3 id="WORKDIR"><a href="#WORKDIR" class="headerlink" title="WORKDIR"></a>WORKDIR</h3><p><code>WORKDIR</code>用于设定Dockerfile中其命令之后的<code>RUN</code>、<code>CMD</code>、<code>ENTRYPOIHNT</code>、<code>COPY</code>和<code>ADD</code>命令的执行路径。如果指定的<code>WORKDIR</code>不存在，则会自动被创建。该命令可以出现多次，如果使用的是相对目录，则该相对目录将会相对于前一个<code>WORKDIR</code>设置的目录。</p>
<p>用法：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /path/to/workdir</span></span><br></pre></td></tr></table></figure>

<p>举例：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /a</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> b</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> c</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">pwd</span></span></span><br></pre></td></tr></table></figure>

<p>最终pwd输出为<code>/a/b/c</code></p>
<p><code>WORKDIR</code>中可以使用前面<code>ENV</code>设置的环境变量，如：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ENV</span> DIRPATH /path</span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> <span class="variable">$DIRPATH</span>/<span class="variable">$DIRNAME</span></span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">pwd</span></span></span><br></pre></td></tr></table></figure>

<p>pwd输出为<code>/path/$DIRNAME</code></p>
<h3 id="ARG"><a href="#ARG" class="headerlink" title="ARG"></a>ARG</h3><p><code>ARG</code>指令在Docker 1.9版本才引入，该指令用于定义变量，其定义的变量只在build镜像过程中有效，镜像创建完成后消失，并可以通过build命令的<code>--build-arg &lt;varname&gt;=&lt;value&gt;</code>来指定其构建过程中varname的值。</p>
<p>可以有多个<code>ARG</code>指令。</p>
<p><code>ARG</code>定义的变量只在其后的指定中才有效。</p>
<p>通过命令<code>docker history</code>可以看到在构建镜像时设置的<code>ARG</code>。</p>
<p>如果build过程中指定了在<code>Dockefile</code>中未经ARG定义的变量，构建将会给出警告：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">[Warning] One or more build-args [foo] were not consumed.</span><br></pre></td></tr></table></figure>

<p>用法：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ARG</span> &lt;name&gt;[=&lt;default value&gt;]</span><br></pre></td></tr></table></figure>

<p><code>ARG</code>设置的变量只会影响到构建过程，而<code>ENV</code>相当于改变了整个相应容器的环境变量。<br>如果在<code>ARG</code>指令的后面使用<code>ENV</code>进行了同名的定义，则即使在build时指定的新值，<code>ENV</code>的定义依然会覆盖<code>ARG</code>定义。</p>
<p><code>ARG</code>与<code>ENV</code>配合使用：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu</span><br><span class="line"><span class="keyword">ARG</span> CONT_IMG_VER</span><br><span class="line"><span class="keyword">ENV</span> CONT_IMG_VER $&#123;CONT_IMG_VER:-v1.<span class="number">0.0</span>&#125;</span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">echo</span> <span class="variable">$CONT_IMG_VER</span></span></span><br></pre></td></tr></table></figure>

<p>可以这样构建：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker build --build-arg CONT_IMG_VER=v2.0.1 .</span><br></pre></td></tr></table></figure>

<p>Docker中预定义了一些ARG变量：</p>
<ul>
<li><code>HTTP_PROXY</code></li>
<li><code>http_proxy</code></li>
<li><code>HTTPS_PROXY</code></li>
<li><code>https_proxy</code></li>
<li><code>FTP_PROXY</code></li>
<li><code>ftp_proxy</code></li>
<li><code>NO_PROXY</code></li>
<li><code>no_proxy</code></li>
</ul>
<p>这些变量可以在构建时直接进行设置，如：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">--build-arg HTTP_PROXY=http://user:pass@proxy.lon.example.com</span><br></pre></td></tr></table></figure>

<h3 id="ONBUILD"><a href="#ONBUILD" class="headerlink" title="ONBUILD"></a>ONBUILD</h3><p><code>ONBUILD</code>指令用于为镜像添加一个触发器，其参数是任意一个<code>Dockerfile</code>指令，该指令不会在当前的build过程中生效，而是会在当<code>FROM</code>这个镜像创建新镜像时首先触发执行。</p>
<p>用法：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ONBUILD</span> [INSTRUCTION]</span><br></pre></td></tr></table></figure>

<p>以下内容引用于网络：</p>
<blockquote>
<p>当我们在一个Dockerfile文件中加上ONBUILD指令，该指令对利用该Dockerfile构建镜像（比如为A镜像）不会产生实质性影响。</p>
</blockquote>
<blockquote>
<p>但是当我们编写一个新的Dockerfile文件来基于A镜像构建一个镜像（比如为B镜像）时，这时构造A镜像的Dockerfile文件中的ONBUILD指令就生效了，在构建B镜像的过程中，首先会执行ONBUILD指令指定的指令，然后才会执行其它指令。</p>
</blockquote>
<blockquote>
<p>需要注意的是，如果是再利用B镜像构造新的镜像时，那个ONBUILD指令就无效了，也就是说只能再构建子镜像中执行，对孙子镜像构建无效。其实想想是合理的，因为在构建子镜像中已经执行了，如果孙子镜像构建还要执行，相当于重复执行，这就有问题了。</p>
</blockquote>
<blockquote>
<p>利用ONBUILD指令,实际上就是相当于创建一个模板镜像，后续可以根据该模板镜像创建特定的子镜像，需要在子镜像构建过程中执行的一些通用操作就可以在模板镜像对应的dockerfile文件中用ONBUILD指令指定。 从而减少dockerfile文件的重复内容编写。</p>
</blockquote>
<h3 id="STOPSIGNAL"><a href="#STOPSIGNAL" class="headerlink" title="STOPSIGNAL"></a>STOPSIGNAL</h3><p><code>STOPSIGNAL</code>指令用于设置容器退出时所要发送给容器的退出信号，必须是内核系统调用表中的合法值，如<code>9</code>或<code>SIGKILL</code>。</p>
<p>用法：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">STOPSIGNAL</span> signal</span><br></pre></td></tr></table></figure>

<h3 id="HEALTHCHECK"><a href="#HEALTHCHECK" class="headerlink" title="HEALTHCHECK"></a>HEALTHCHECK</h3><p><code>HEALTHCHECK</code>指令用于告诉docker如何去检测容器的健康状态。1.12的版本中加入，用法如下：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">HEALTHCHECK</span><span class="language-bash"> [OPTIONS] CMD <span class="built_in">command</span> <span class="comment"># 通过运行一个CMD指令指定的命令来检查容器健康状态</span></span></span><br><span class="line"><span class="keyword">HEALTHCHECK</span><span class="language-bash"> NONE <span class="comment"># 禁用从基础镜像（base image）继承来的任何健康检查</span></span></span><br></pre></td></tr></table></figure>

<p><code>CMD</code>命令可以带有参数有：</p>
<ul>
<li><code>--interval=DURATION</code> (default: 30s)      表示检查的时间间隔</li>
<li><code>--timeout=DURATION</code> (default: 30s)       表示检查命令多久</li>
<li><code>--start-period=DURATION</code> (default: 0s)   表示启动预留给容器启动的时间</li>
<li><code>--retries=N</code> (default: 3)                表示命令重试次数</li>
</ul>
<p>每一个Dockerfile中只能有一个<code>HEALTHECK</code>指令，如果有多个，则只有最后一个有效。</p>
<p>用例：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">HEALTHCHECK</span><span class="language-bash"> --interval=5m --<span class="built_in">timeout</span>=3s \</span></span><br><span class="line"><span class="language-bash">  CMD curl -f http://localhost/ || <span class="built_in">exit</span> 1</span></span><br></pre></td></tr></table></figure>

<p>上述示例表示每隔5分钟，运行一次curl获取网页，如果3s未返回，则认为命令运行失败，容器报告不健康。可以看到CMD执行的curl如果成功，则会正常返回，即报告健康，但如果curl失败，则会执行<code>exit 1</code>，即返回不健康。（这里假设重试次数为1）<br>其中，<code>CMD</code>执行的命令退出状态码可以为以下3个中的一个：</p>
<ul>
<li><code>0</code>: success - 健康</li>
<li><code>1</code>: unhealthy - 不健康</li>
<li><code>2</code>: reserved - 系统保留，不建议用户使用</li>
</ul>
<h3 id="SHELL"><a href="#SHELL" class="headerlink" title="SHELL"></a>SHELL</h3><p><code>SHELL</code>指令用于覆盖其他指令以及容器中默认运行命令的shell程序，默认情况下Linux的shell为<code>[&quot;/bin/sh&quot;, &quot;-c&quot;]</code>，Windows为<code>[&quot;cmd&quot;, &quot;/S&quot;, &quot;/C&quot;]</code>。</p>
<p><strong>SHELL指令同样必须以JSON格式写在Dockerfile中</strong></p>
<p>指定的shell将会影响<code>RUN</code>、<code>CMD</code>和<code>ENTRYPOINT</code>的运行。</p>
<p>该指令在1.12中引入。</p>
<p>用法：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHELL</span><span class="language-bash"> [<span class="string">&quot;executable&quot;</span>, <span class="string">&quot;parameters&quot;</span>]</span></span><br></pre></td></tr></table></figure>

<p>如：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHELL</span><span class="language-bash"> [<span class="string">&quot;/bin/bash&quot;</span>, <span class="string">&quot;-c&quot;</span>]</span></span><br></pre></td></tr></table></figure>

<p>则将Linux容器的默认执行命令指定为<code>/bin/bash</code></p>
<p>下面一下Win下的例子：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> microsoft/windowsservercore</span><br><span class="line"></span><br><span class="line"><span class="comment"># Executed as cmd /S /C echo default</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">echo</span> default</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Executed as cmd /S /C powershell -command Write-Host default</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> powershell -<span class="built_in">command</span> Write-Host default</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Executed as powershell -command Write-Host hello</span></span><br><span class="line"><span class="keyword">SHELL</span><span class="language-bash"> [<span class="string">&quot;powershell&quot;</span>, <span class="string">&quot;-command&quot;</span>]</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> Write-Host hello</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Executed as cmd /S /C echo hello</span></span><br><span class="line"><span class="keyword">SHELL</span><span class="language-bash"> [<span class="string">&quot;cmd&quot;</span>, <span class="string">&quot;/S&quot;</span><span class="string">&quot;, &quot;</span>/C<span class="string">&quot;]</span></span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"><span class="string"> echo hello</span></span></span><br></pre></td></tr></table></figure>

<h2 id="Dockerfile最佳实践"><a href="#Dockerfile最佳实践" class="headerlink" title="Dockerfile最佳实践"></a>Dockerfile最佳实践</h2><h3 id="官方给出的建议"><a href="#官方给出的建议" class="headerlink" title="官方给出的建议"></a>官方给出的建议</h3><ul>
<li>容器应该是短暂的，其中不应该保存数据，让容器更容易创建和销毁</li>
<li>使用<code>.dockerignore</code>来排除不需要的文件，最好让新建镜像时都从一个空文件夹开始</li>
<li>使用多阶段构建（multi-stage build），仅限Docker17.05之后的版本，即使用多个FROM指令，例如：</li>
<li>避免安装不必要的包</li>
<li>一个容器只干一件事，最好一个进程一个容器</li>
<li>最小化镜像的层数，只有<code>RUN</code>、<code>COPY</code>和<code>ADD</code>创建层，其他指令只是创建临时的中间镜像，不会直接增加镜像大小</li>
<li>对多行参数排序，特别是安装包的时候，可以有效避免重复包或者重复参数</li>
</ul>
<p>对于多阶段构建的一个例子：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> golang:<span class="number">1.7</span>.<span class="number">3</span> as builder</span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /go/src/github.com/alexellis/href-counter/</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> go get -d -v golang.org/x/net/html</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> app.go    .</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o app .</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> alpine:latest</span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apk --no-cache add ca-certificates</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /root/</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> --from=builder /go/src/github.com/alexellis/href-counter/app .</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;./app&quot;</span>]</span></span><br></pre></td></tr></table></figure>

<p>对于参数排序的一例子，该例子基于debian配置一个带有很多依赖的镜像：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> buildpack-deps:jessie-scm</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">set</span> -ex; \</span></span><br><span class="line"><span class="language-bash">    apt-get update; \</span></span><br><span class="line"><span class="language-bash">    apt-get install -y --no-install-recommends \</span></span><br><span class="line"><span class="language-bash">        autoconf \</span></span><br><span class="line"><span class="language-bash">        automake \</span></span><br><span class="line"><span class="language-bash">        bzip2 \</span></span><br><span class="line"><span class="language-bash">        dpkg-dev \</span></span><br><span class="line"><span class="language-bash">        file \</span></span><br><span class="line"><span class="language-bash">        g++ \</span></span><br><span class="line"><span class="language-bash">        gcc \</span></span><br><span class="line"><span class="language-bash">        imagemagick \</span></span><br><span class="line"><span class="language-bash">        libbz2-dev \</span></span><br><span class="line"><span class="language-bash">        libc6-dev \</span></span><br><span class="line"><span class="language-bash">        libcurl4-openssl-dev \</span></span><br><span class="line"><span class="language-bash">        libdb-dev \</span></span><br><span class="line"><span class="language-bash">        libevent-dev \</span></span><br><span class="line"><span class="language-bash">        libffi-dev \</span></span><br><span class="line"><span class="language-bash">        libgdbm-dev \</span></span><br><span class="line"><span class="language-bash">        libgeoip-dev \</span></span><br><span class="line"><span class="language-bash">        libglib2.0-dev \</span></span><br><span class="line"><span class="language-bash">        libjpeg-dev \</span></span><br><span class="line"><span class="language-bash">        libkrb5-dev \</span></span><br><span class="line"><span class="language-bash">        liblzma-dev \</span></span><br><span class="line"><span class="language-bash">        libmagickcore-dev \</span></span><br><span class="line"><span class="language-bash">        libmagickwand-dev \</span></span><br><span class="line"><span class="language-bash">        libncurses5-dev \</span></span><br><span class="line"><span class="language-bash">        libncursesw5-dev \</span></span><br><span class="line"><span class="language-bash">        libpng-dev \</span></span><br><span class="line"><span class="language-bash">        libpq-dev \</span></span><br><span class="line"><span class="language-bash">        libreadline-dev \</span></span><br><span class="line"><span class="language-bash">        libsqlite3-dev \</span></span><br><span class="line"><span class="language-bash">        libssl-dev \</span></span><br><span class="line"><span class="language-bash">        libtool \</span></span><br><span class="line"><span class="language-bash">        libwebp-dev \</span></span><br><span class="line"><span class="language-bash">        libxml2-dev \</span></span><br><span class="line"><span class="language-bash">        libxslt-dev \</span></span><br><span class="line"><span class="language-bash">        libyaml-dev \</span></span><br><span class="line"><span class="language-bash">        make \</span></span><br><span class="line"><span class="language-bash">        patch \</span></span><br><span class="line"><span class="language-bash">        xz-utils \</span></span><br><span class="line"><span class="language-bash">        zlib1g-dev \</span></span><br><span class="line"><span class="language-bash">        \</span></span><br><span class="line"><span class="language-bash"><span class="comment"># https://lists.debian.org/debian-devel-announce/2016/09/msg00000.html</span></span></span><br><span class="line">        $( \</span><br><span class="line"><span class="comment"># if we use just &quot;apt-cache show&quot; here, it returns zero because &quot;Can&#x27;t select versions from package &#x27;libmysqlclient-dev&#x27; as it is purely virtual&quot;, hence the pipe to grep</span></span><br><span class="line">            if apt-cache show <span class="string">&#x27;default-libmysqlclient-dev&#x27;</span> <span class="number">2</span>&gt;/dev/null | grep -q <span class="string">&#x27;^Version:&#x27;</span>; then \</span><br><span class="line">                echo <span class="string">&#x27;default-libmysqlclient-dev&#x27;</span>; \</span><br><span class="line">            else \</span><br><span class="line">                echo <span class="string">&#x27;libmysqlclient-dev&#x27;</span>; \</span><br><span class="line">            fi \</span><br><span class="line">        ) \</span><br><span class="line">    ; \</span><br><span class="line">    rm -rf /var/lib/apt/lists/*</span><br></pre></td></tr></table></figure>

<h3 id="命令的建议"><a href="#命令的建议" class="headerlink" title="命令的建议"></a>命令的建议</h3><p><strong>FROM</strong></p>
<p>最好使用官方源中的镜像做为基础镜像，推荐使用<a href="https://hub.docker.com/_/alpine/">Alpine镜像</a>，因为它只有5mb</p>
<p><strong>LABEL</strong></p>
<p>为了更好地组织镜像，最好使用容易理解的LABEL内容，并且值都用双引号（”），多个键值对应该放在同一行，如下：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Set multiple labels at once, using line-continuation characters to break long lines</span></span><br><span class="line"><span class="keyword">LABEL</span><span class="language-bash"> vendor=ACME\ Incorporated \</span></span><br><span class="line"><span class="language-bash">      com.example.is-beta= \</span></span><br><span class="line"><span class="language-bash">      com.example.is-production=<span class="string">&quot;&quot;</span> \</span></span><br><span class="line"><span class="language-bash">      com.example.version=<span class="string">&quot;0.0.1-beta&quot;</span> \</span></span><br><span class="line"><span class="language-bash">      com.example.release-date=<span class="string">&quot;2015-02-12&quot;</span></span></span><br></pre></td></tr></table></figure>

<p><strong>RUN</strong></p>
<p>为了提高可读性，应该使用续行符（<code>\</code>）将命令分成多行。并且避免运行如<code>apt-get upgrade</code>或<code>dist-upgrade</code>等命令来升级整个系统，记得删除临时文件。<br>如下：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get update &amp;&amp; apt-get install -y \</span></span><br><span class="line"><span class="language-bash">    aufs-tools \</span></span><br><span class="line"><span class="language-bash">    automake \</span></span><br><span class="line"><span class="language-bash">    build-essential \</span></span><br><span class="line"><span class="language-bash">    curl \</span></span><br><span class="line"><span class="language-bash">    dpkg-sig \</span></span><br><span class="line"><span class="language-bash">    libcap-dev \</span></span><br><span class="line"><span class="language-bash">    libsqlite3-dev \</span></span><br><span class="line"><span class="language-bash">    mercurial \</span></span><br><span class="line"><span class="language-bash">    reprepro \</span></span><br><span class="line"><span class="language-bash">    ruby1.9.1 \</span></span><br><span class="line"><span class="language-bash">    ruby1.9.1-dev \</span></span><br><span class="line"><span class="language-bash">    s3cmd=1.1.* \</span></span><br><span class="line"><span class="language-bash"> &amp;&amp; <span class="built_in">rm</span> -rf /var/lib/apt/lists/*</span></span><br></pre></td></tr></table></figure>

<p>因为Ubuntu和Debian官方镜像会自动运行<code>apt-get clean</code>，所以不需要再在命令中添加。</p>
<p><strong>RUN中使用管道符要注意</strong></p>
<p>由于Docker只关注最好一个命令执行是否正确，所以当管道前面错误时，后面依然可能成功，所以应该设置<code>set -o pipefail &amp;&amp;</code>来使执行过程中任何产生的错误都失败。<br>如下：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="language-bash"> [<span class="string">&quot;/bin/bash&quot;</span>, <span class="string">&quot;-c&quot;</span>, <span class="string">&quot;set -o pipefail &amp;&amp; wget -O - https://some.site | wc -l &gt; /number&quot;</span>]</span></span><br></pre></td></tr></table></figure>

<p><strong>CMD</strong></p>
<p>通过将CMD指令用于交互模式，如<code>CMD [&quot;python&quot;]</code>，<code>docker run -it python</code>将会进入python的交互环境。除非你很了解CMD与ENTRYPOINT协同工作的方式，否则不要与ENTRYPOINT一起使用。</p>
<p><strong>EXPOSE</strong></p>
<p>指定容器的监听端口时，尽量使用通用的端口，如Apache web服务器的<code>EXPOSE 80</code>。</p>
<p><strong>ENV</strong></p>
<p>该指令通常用于应用程序提供必要的环境变量和版本号等设置：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ENV</span> PG_MAJOR <span class="number">9.3</span></span><br><span class="line"><span class="keyword">ENV</span> PG_VERSION <span class="number">9.3</span>.<span class="number">4</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> curl -SL http://example.com/postgres-<span class="variable">$PG_VERSION</span>.tar.xz | tar -xJC /usr/src/postgress &amp;&amp; …</span></span><br><span class="line"><span class="keyword">ENV</span> PATH /usr/local/postgres-$PG_MAJOR/bin:$PATH</span><br></pre></td></tr></table></figure>

<p><strong>ADD or COPY</strong></p>
<p>推荐能用<code>COPY</code>的地方就用它，而不是<code>ADD</code></p>
<p>不需要保存压缩包的情况下尽量使用管道替代：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">mkdir</span> -p /usr/src/things \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; curl -SL http://example.com/big.tar.xz \</span></span><br><span class="line"><span class="language-bash">    | tar -xJC /usr/src/things \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; make -C /usr/src/things all</span></span><br></pre></td></tr></table></figure>

<p><strong>ENTRYPOINT</strong></p>
<p>其与<code>CMD</code>一起使用时可以使镜像像命令一样运行：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;s3cmd&quot;</span>]</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;--help&quot;</span>]</span></span><br></pre></td></tr></table></figure>

<p>运行命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker run s3cmd</span><br></pre></td></tr></table></figure>

<p>也可以覆盖其默认命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker run s3cmd <span class="built_in">ls</span> s3://mybucket</span><br></pre></td></tr></table></figure>

<p>其也可以与脚本结合，让脚本成为其命令，组成更强大的功能。</p>
<p><strong>VOLUME</strong></p>
<p>VOLUME 指令应该用于如下内容：任何类型的数据库存储区域、配置存储、容器创建的文件或目录。<br>推荐 VOLUME 用于挂载镜像中那些经常变化（易变化的）或者用户可维护的部分。</p>
<p><strong>USER</strong></p>
<p>如果不需要root权限，可以通过USER切换成非root用户，在Dockerfile中如下方式创建：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="language-bash"> groupadd -r postgres &amp;&amp; useradd --no-log-init -r -g postgres postgres</span></span><br></pre></td></tr></table></figure>

<p>尽量避免安装和使用 sudo，如果一定要使用类似 sudo 功能，可以使用 gosu 替代它，为了减少层数和复杂度，避免频繁使用 USER 进行用户切换。</p>
<p><strong>WORKDIR</strong></p>
<p>为了清楚可靠，应该使用绝对路径作为<code>WORKDIR</code>，而不是增加指令，如<code>RUN cd ..</code></p>
<p><strong>ONBUILD</strong></p>
<p>ONBUILD 指令在当前 Dockerfile 构建完成后执行，存储到镜像 的manifest 清单中，我们可以通过 docker inspect 查看 OnBuild 的信息。</p>
<p>当我们使用带有 ONBUILD 触发器的镜像作为基础镜像来创建新镜像时，当 Dockerfile 执行到 FROM 时会自动查找 OnBuild 信息并执行这个触发器命令。成功后继续向下执行下一条指令，失败的话就停止向下执行并中止创建过程。如果成功创建了新的镜像后，这个新镜像中不会继承基础镜像中的 ONBUILD 触发器内容。</p>
<p>建立的带有 ONBUILD 的镜像时应该有一个单独的标签，例如：ruby:1.9-onbuild 或 ruby:2.0-onbuild。</p>
<p>当把 ADD 或 COPY 加入 ONBUILD 中时要小心，如果新创建镜像的上下文缺少这些要添加的资源时，会导致创建镜像失败。因而添加单独的标签可以帮助我们减小这种情况发生的可能， 让 Dockerfile 作者来做决定。</p>
<h2 id="Dockerfile举例"><a href="#Dockerfile举例" class="headerlink" title="Dockerfile举例"></a>Dockerfile举例</h2><p><strong>通过VNC从容器中运行Firefox</strong></p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Firefox over VNC</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># VERSION               0.3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> ubuntu</span><br><span class="line"></span><br><span class="line"><span class="comment"># Install vnc, xvfb in order to create a &#x27;fake&#x27; display and firefox</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get update &amp;&amp; apt-get install -y x11vnc xvfb firefox</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">mkdir</span> ~/.vnc</span></span><br><span class="line"><span class="comment"># Setup a password</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> x11vnc -storepasswd 1234 ~/.vnc/passwd</span></span><br><span class="line"><span class="comment"># Autostart firefox (might not be the best way, but it does the trick)</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> bash -c <span class="string">&#x27;echo &quot;firefox&quot; &gt;&gt; /.bashrc&#x27;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">5900</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash">    [<span class="string">&quot;x11vnc&quot;</span>, <span class="string">&quot;-forever&quot;</span>, <span class="string">&quot;-usepw&quot;</span>, <span class="string">&quot;-create&quot;</span>]</span></span><br></pre></td></tr></table></figure>

<p><strong>一次创建多个镜像</strong></p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Multiple images example</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># VERSION               0.1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> ubuntu</span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">echo</span> foo &gt; bar</span></span><br><span class="line"><span class="comment"># Will output something like ===&gt; 907ad6c2736f</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> ubuntu</span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">echo</span> moo &gt; oink</span></span><br><span class="line"><span class="comment"># Will output something like ===&gt; 695d7793cbe4</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># You&#x27;ll now have two images, 907ad6c2736f with /bar, and 695d7793cbe4 with</span></span><br><span class="line"><span class="comment"># /oink.</span></span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://docs.docker.com/engine/reference/builder/">Dockerfile reference</a></li>
<li><a href="https://docs.docker.com/engine/userguide/eng-image/dockerfile_best-practices/">Best practices for writing Dockerfiles</a></li>
<li><a href="">其他大量互联网资料</a></li>
</ol>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>Dockerfile</tag>
      </tags>
  </entry>
  <entry>
    <title>手动下载gcc-4.8.5源码在centos6.9上安装多版本GCC</title>
    <url>/2017/12/09/gnu-gcc-compile-for-centos6/</url>
    <content><![CDATA[<p>在一个系统较老的centos（6.9）上编译安装gcc4.8.5，系统源里面带的是4.7.2，对C++11中的特性支持不完整，所以需要手动编译一份新版本。<br>以为会很简单，直接下载源码，根据readme配置相关依赖源码，然而最后还是编译的时候报错，所以记录下来。</p>
<span id="more"></span>

<h2 id="GCC源码及源码依赖"><a href="#GCC源码及源码依赖" class="headerlink" title="GCC源码及源码依赖"></a>GCC源码及源码依赖</h2><p>安装基本编译依赖：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo yum groupinstall <span class="string">&quot;Development tools&quot;</span></span><br><span class="line">sudo yum install glibc-devel.i686 glibc-i686</span><br></pre></td></tr></table></figure>
<p>注意后面那两个包如果不安装会有错误<code>fatal error: gnu/stubs-32.h: No such file or directory</code>。</p>
<p>GCC官网下载你所需要的版本源码，我用的是GCC 4.8.5大概500多Mb的压缩包：<a href="https://gcc.gnu.org/">https://gcc.gnu.org/</a><br>除了GCC源码之外，它还需要以下依赖的源码，这里附上我用的版本号：<br>其中前3个依赖也可以通过GCC源码包中的脚本<code>./contrib/download_prerequisites</code>自动帮你下载好，如果你的网络环境跟我一样（公司内网），那就自己去下面那个链接里面下载。<br>所需要的依赖源码在这里都可以找到：<a href="https://gcc.gnu.org/pub/gcc/infrastructure/">https://gcc.gnu.org/pub/gcc/infrastructure/</a>，如果版本不对，可以自己去网上搜索一个老一些版本。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MPFR=mpfr-2.4.2</span><br><span class="line">GMP=gmp-4.3.2</span><br><span class="line">MPC=mpc-0.8.1</span><br><span class="line"></span><br><span class="line">isl-0.11.1.tar.bz2</span><br><span class="line">cloog-0.18.0.tar.gz</span><br></pre></td></tr></table></figure>
<p>确认<code>isl</code>使用<code>0.12</code>的版本会出错。<br>把这些源码解压到gcc源码要目录并重命名为相应不带版本后缀的文件夹名称，过程命令如下：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> ~</span><br><span class="line">$ wget https://gcc.gnu.org/pub/gcc/infrastructure/mpc-1.0.3.tar.gz</span><br><span class="line">$ wget https://gcc.gnu.org/pub/gcc/infrastructure/mpfr-3.1.4.tar.bz2</span><br><span class="line">$ wget https://gcc.gnu.org/pub/gcc/infrastructure/gmp-6.1.0.tar.bz2</span><br><span class="line">$ wget https://gcc.gnu.org/pub/gcc/infrastructure/isl-0.11.1.tar.bz2</span><br><span class="line">$ wget https://gcc.gnu.org/pub/gcc/infrastructure/cloog-0.18.1.tar.gz</span><br><span class="line">$ wget http://ftp.gnu.org/gnu/gcc/gcc-4.8.5/gcc-4.8.5.tar.gz</span><br><span class="line">$ tar -xzvf gcc-4.8.5.tar.gz</span><br><span class="line">$ <span class="built_in">cd</span> gcc-4.8.5</span><br><span class="line">$ tar -zxvf ../mpc-1.0.3.tar.gz</span><br><span class="line">$ tar -jxvf ../mpfr-3.1.4.tar.bz2</span><br><span class="line">$ tar -jxvf ../gmp-6.1.0.tar.bz2</span><br><span class="line">$ tar -jxvf ../isl-0.11.1.tar.bz2</span><br><span class="line">$ tar -zxvf ../cloog-0.18.1.tar.gz</span><br><span class="line">$ <span class="built_in">mv</span> mpc-1.0.3 mpc</span><br><span class="line">$ <span class="built_in">mv</span> mpfr-3.1.4 mpfr</span><br><span class="line">$ <span class="built_in">mv</span> gmp-6.1.0 gmp</span><br><span class="line">$ <span class="built_in">mv</span> isl-0.11.1 isl</span><br><span class="line">$ <span class="built_in">mv</span> cloog-0.18.1 cloog</span><br></pre></td></tr></table></figure>
<p>环境配置完成</p>
<h2 id="编译安装"><a href="#编译安装" class="headerlink" title="编译安装"></a>编译安装</h2><p>下面正常编译即可，通常不会有什么问题</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ ./configure --prefix=/opt/gcc-4.8.5/</span><br><span class="line">$ make -j8</span><br><span class="line">$ make -k check</span><br><span class="line">$ sudo make install</span><br></pre></td></tr></table></figure>
<p>如果<code>./configure</code>不配置安装路径，会安装到默认路径，有可能会覆盖你当前的版本，如果没有特殊需要，可以直接覆盖安装，后面会省很多事。</p>
<h2 id="配置版本选择"><a href="#配置版本选择" class="headerlink" title="配置版本选择"></a>配置版本选择</h2><p>通过<code>update-alternatives</code>命令添加版本切换：<br>首先重命名当前版本的</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ sudo <span class="built_in">mv</span> /usr/bin/gcc /usr/bin/gcc-4.4.7</span><br><span class="line">$ sudo <span class="built_in">mv</span> /usr/bin/g++ /usr/bin/g++-4.4.7</span><br></pre></td></tr></table></figure>
<p>添加配置选择入口：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-4.4.7</span><br><span class="line">$ sudo update-alternatives --install /usr/bin/gcc gcc /opt/gcc-4.8.5/bin/gcc</span><br><span class="line"></span><br><span class="line">$ sudo update-alternatives --install /usr/bin/g++ g++ /usr/bin/g++-4.4.7</span><br><span class="line">$ sudo update-alternatives --install /usr/bin/g++ g++ /opt/gcc-4.8.5/bin/g++</span><br></pre></td></tr></table></figure>
<p>然后根据需要切换版本即可：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ sudo update-alternatives --config gcc</span><br><span class="line">$ sudo update-alternatives --config g++</span><br></pre></td></tr></table></figure>
<p>想删除：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ sudo update-alternatives --remove gcc /usr/bin/gcc-4.4.7</span><br></pre></td></tr></table></figure>

<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>虽然我们的编译器已经可以切换到新版本了，但有些编译出来的库依赖在查找时依然是旧版本的库，例如有可能新编译的库运行时会报</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/usr/lib64/libstdc++.so.6: version `GLIBCXX_3.4.14&#x27; not found (required by...</span><br></pre></td></tr></table></figure>
<p>查看该库会发现少了我们需要的版本：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ strings /usr/lib64/libstdc++.so.6 | grep GLIBCXX</span><br></pre></td></tr></table></figure>
<p>我这里的输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GLIBCXX_3.4</span><br><span class="line">GLIBCXX_3.4.1</span><br><span class="line">GLIBCXX_3.4.2</span><br><span class="line">GLIBCXX_3.4.3</span><br><span class="line">GLIBCXX_3.4.4</span><br><span class="line">GLIBCXX_3.4.5</span><br><span class="line">GLIBCXX_3.4.6</span><br><span class="line">GLIBCXX_3.4.7</span><br><span class="line">GLIBCXX_3.4.8</span><br><span class="line">GLIBCXX_3.4.9</span><br><span class="line">GLIBCXX_3.4.10</span><br><span class="line">GLIBCXX_3.4.11</span><br><span class="line">GLIBCXX_3.4.12</span><br><span class="line">GLIBCXX_3.4.13</span><br><span class="line">GLIBCXX_FORCE_NEW</span><br><span class="line">GLIBCXX_DEBUG_MESSAGE_LENGTH</span><br></pre></td></tr></table></figure>
<p>而新库内容如下：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ strings /opt/gcc-4.8.5/lib64/libstdc++.so.6 | grep GLIBCXX</span><br><span class="line">GLIBCXX_3.4</span><br><span class="line">GLIBCXX_3.4.1</span><br><span class="line">GLIBCXX_3.4.2</span><br><span class="line">GLIBCXX_3.4.3</span><br><span class="line">GLIBCXX_3.4.4</span><br><span class="line">GLIBCXX_3.4.5</span><br><span class="line">GLIBCXX_3.4.6</span><br><span class="line">GLIBCXX_3.4.7</span><br><span class="line">GLIBCXX_3.4.8</span><br><span class="line">GLIBCXX_3.4.9</span><br><span class="line">GLIBCXX_3.4.10</span><br><span class="line">GLIBCXX_3.4.11</span><br><span class="line">GLIBCXX_3.4.12</span><br><span class="line">GLIBCXX_3.4.13</span><br><span class="line">GLIBCXX_3.4.14</span><br><span class="line">GLIBCXX_3.4.15</span><br><span class="line">GLIBCXX_3.4.16</span><br><span class="line">GLIBCXX_3.4.17</span><br><span class="line">GLIBCXX_3.4.18</span><br><span class="line">GLIBCXX_3.4.19</span><br><span class="line">GLIBCXX_FORCE_NEW</span><br><span class="line">GLIBCXX_DEBUG_MESSAGE_LENGTH</span><br></pre></td></tr></table></figure>

<p>需要将新版本的库加入到系统查找路径:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo echo `/opt/gcc-4.8.5/lib/../lib64` &gt;&gt; /etc/ld.so.conf</span><br><span class="line">$ sudo ldconfig</span><br></pre></td></tr></table></figure>

<p>其实刚才那个库是向下兼容的，也可以直接用软链接来解决。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://stackoverflow.com/questions/7412548/error-gnu-stubs-32-h-no-such-file-or-directory-while-compiling-nachos-source">https://stackoverflow.com/questions/7412548/error-gnu-stubs-32-h-no-such-file-or-directory-while-compiling-nachos-source</a></li>
<li><a href="https://wiki.mikejung.biz/Gcc_CentOS">https://wiki.mikejung.biz/Gcc_CentOS</a></li>
<li><a href="https://gcc.gnu.org/">https://gcc.gnu.org/</a></li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>CPP</tag>
        <tag>C</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>GCC在64位系统上编译32位程序遇到的问题</title>
    <url>/2017/12/06/compile-x32-executable-at-x64-linux-system/</url>
    <content><![CDATA[<p>默认的GCC编译选项会编译出与系统一致的输出，例如64位直接使用gcc或g++编译出的为64位程序或库，而32位系统编译的是对应32位的。<br>可以通过在编译时添加选项<code>-m32</code>或<code>-m64</code>来指定编译生成的相应版本，如果同时带上这2个选项，只有后一个会生效。<br>问题的关键时多数时候会提示缺少库，这里以64位下编译32位程序为例，给出ubuntu和centos下相关依赖包。</p>
<span id="more"></span>

<h2 id="Ubuntu下依赖包"><a href="#Ubuntu下依赖包" class="headerlink" title="Ubuntu下依赖包"></a>Ubuntu下依赖包</h2><p>没什么好说的，安装了这些依赖就能用了</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo apt-get install build-essential module-assistant</span><br><span class="line">sudo apt-get install gcc-multilib g++-multilib</span><br></pre></td></tr></table></figure>

<h2 id="Centos下依赖包"><a href="#Centos下依赖包" class="headerlink" title="Centos下依赖包"></a>Centos下依赖包</h2><p>Centos下的包好多名字与ubuntu下都不一样，应该说rpm系与dpkg系通常不一样</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">yum install glibc-devel.i686 libstdc++-devel.i686</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>Dev</category>
      </categories>
      <tags>
        <tag>Dev</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>让普通的VS项目支持编译CUDA代码</title>
    <url>/2017/12/06/cuda-compiled-for-normal-project-in-vs/</url>
    <content><![CDATA[<p>当安装了VS之后再安装CUDA套件就可以通过VS创建基于CUDA的项目，但往往我们会需要让之前的老项目支持对CUDA的编译，以便使用CUDA对原有项目中的部分算法加速，网上有各种各样的尝试，搜索SOF之后找到一个超简单的方法，记录之。</p>
<span id="more"></span>

<p>右键单击你的项目，然后：“生成依赖项——自定义生成”（vs2013）（对应英文的为：”Build Dependencies-Build Customizations”），在其中勾选相应的的CUDA版本的目标和属性选项即可，然后再去查看你的项目性能，会发现其中多了CUDA相应的编译和链接选项。此时即可编译你添加的<code>.cu</code>文件.</p>
]]></content>
      <categories>
        <category>Dev</category>
      </categories>
      <tags>
        <tag>CUDA</tag>
        <tag>Dev</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker 使用入门</title>
    <url>/2017/12/06/docker-useful-command/</url>
    <content><![CDATA[<p>首先 Docker 是由 go 语言编写，基于 Linux 容器技术（LXC）、Namespace、Cgroup 和 UnionFS（联合文件系统）等技术的轻量级操作系统虚拟化解决方案。</p>
<p>对于 docker 的概念，可以简单理解如下：</p>
<ul>
<li><strong>镜像（Image）</strong> 类似于虚拟机的快照，它是只读，可以以镜像为模板创建容器，在容器中的更改不会影响到原镜像。实际镜像是 UnionFS 的层级文件系统。</li>
<li><strong>容器（Container）</strong> 类似于轻量级的虚拟机，由 docker 镜像实例化而来，docker 推荐一个容器运行一个进程，可见其轻量程度。</li>
<li><strong>注册服务器（Registry）</strong> 提供在线存放 docker 镜像的在线服务，可以理解为 github 所提供的 repository 作用，当我们使用 docker run 运行一个本地不存在的镜像时，默认情况下 docker 会从 docker 官方的 registry 拉取该镜像，然后创建并运行一个容器。</li>
<li><strong>Dockerfile</strong> 可以理解为用于构建镜像的命令和设置组合</li>
</ul>
<p>本文将从安装开始，记录docker日常使用的一些命令、问题及深一点的理解</p>
<span id="more"></span>

<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>官方有非常详细的安装方法<a href="https://www.docker.com">https://www.docker.com</a>，由于某些共知原因，通常会出现各种问题，或者会很慢，这里推荐阿里云提供的 Docker CE 镜像站，安装如下：</p>
<h3 id="Ubuntu-14-04-16-04-（使用-apt-get-进行安装"><a href="#Ubuntu-14-04-16-04-（使用-apt-get-进行安装" class="headerlink" title="Ubuntu 14.04 16.04 （使用 apt-get 进行安装)"></a>Ubuntu 14.04 16.04 （使用 apt-get 进行安装)</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># step 1: 安装必要的一些系统工具</span></span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get -y install apt-transport-https ca-certificates curl software-properties-common</span><br><span class="line"><span class="comment"># step 2: 安装 GPG 证书</span></span><br><span class="line">curl -fsSL http://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | sudo apt-key add -</span><br><span class="line"><span class="comment"># Step 3: 写入软件源信息</span></span><br><span class="line">sudo add-apt-repository <span class="string">&quot;deb [arch=amd64] http://mirrors.aliyun.com/docker-ce/linux/ubuntu <span class="subst">$(lsb_release -cs)</span> stable&quot;</span></span><br><span class="line"><span class="comment"># Step 4: 更新并安装 Docker-CE</span></span><br><span class="line">sudo apt-get -y update</span><br><span class="line">sudo apt-get -y install docker-ce</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装指定版本的 Docker-CE:</span></span><br><span class="line"><span class="comment"># Step 1: 查找 Docker-CE 的版本：</span></span><br><span class="line"><span class="comment"># apt-cache madison docker-ce</span></span><br><span class="line"><span class="comment">#   docker-ce | 17.03.1~ce-0~ubuntu-xenial | http://mirrors.aliyun.com/docker-ce/linux/ubuntu xenial/stable amd64 Packages</span></span><br><span class="line"><span class="comment">#   docker-ce | 17.03.0~ce-0~ubuntu-xenial | http://mirrors.aliyun.com/docker-ce/linux/ubuntu xenial/stable amd64 Packages</span></span><br><span class="line"><span class="comment"># Step 2: 安装指定版本的 Docker-CE: (VERSION 例如上面的 17.03.1~ce-0~ubuntu-xenial)</span></span><br><span class="line"><span class="comment"># sudo apt-get -y install docker-ce=[VERSION]</span></span><br></pre></td></tr></table></figure>

<h3 id="CentOS-7-（使用-yum-进行安装"><a href="#CentOS-7-（使用-yum-进行安装" class="headerlink" title="CentOS 7 （使用 yum 进行安装)"></a>CentOS 7 （使用 yum 进行安装)</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># step 1: 安装必要的一些系统工具</span></span><br><span class="line">sudo yum install -y yum-utils device-mapper-persistent-data lvm2</span><br><span class="line"><span class="comment"># Step 2: 添加软件源信息</span></span><br><span class="line">sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br><span class="line"><span class="comment"># Step 3: 更新并安装 Docker-CE</span></span><br><span class="line">sudo yum makecache fast</span><br><span class="line">sudo yum -y install docker-ce</span><br><span class="line"><span class="comment"># Step 4: 开启 Docker 服务</span></span><br><span class="line">sudo service docker start</span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意：</span></span><br><span class="line"><span class="comment"># 官方软件源默认启用了最新的软件，您可以通过编辑软件源的方式获取各个版本的软件包。例如官方并没有将测试版本的软件源置为可用，你可以通过以下方式开启。同理可以开启各种测试版本等。</span></span><br><span class="line"><span class="comment"># vim /etc/yum.repos.d/docker-ee.repo</span></span><br><span class="line"><span class="comment">#   将 [docker-ce-test] 下方的 enabled=0 修改为 enabled=1</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 安装指定版本的 Docker-CE:</span></span><br><span class="line"><span class="comment"># Step 1: 查找 Docker-CE 的版本：</span></span><br><span class="line"><span class="comment"># yum list docker-ce.x86_64 --showduplicates | sort -r</span></span><br><span class="line"><span class="comment">#   Loading mirror speeds from cached hostfile</span></span><br><span class="line"><span class="comment">#   Loaded plugins: branch, fastestmirror, langpacks</span></span><br><span class="line"><span class="comment">#   docker-ce.x86_64            17.03.1.ce-1.el7.centos            docker-ce-stable</span></span><br><span class="line"><span class="comment">#   docker-ce.x86_64            17.03.1.ce-1.el7.centos            @docker-ce-stable</span></span><br><span class="line"><span class="comment">#   docker-ce.x86_64            17.03.0.ce-1.el7.centos            docker-ce-stable</span></span><br><span class="line"><span class="comment">#   Available Packages</span></span><br><span class="line"><span class="comment"># Step2 : 安装指定版本的 Docker-CE: (VERSION 例如上面的 17.03.0.ce.1-1.el7.centos)</span></span><br><span class="line"><span class="comment"># sudo yum -y install docker-ce-[VERSION]</span></span><br></pre></td></tr></table></figure>

<h3 id="验证安装"><a href="#验证安装" class="headerlink" title="验证安装"></a>验证安装</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ docker version</span><br><span class="line">Client:</span><br><span class="line"> Version:      17.09.0-ce</span><br><span class="line"> API version:  1.32</span><br><span class="line"> Go version:   go1.8.3</span><br><span class="line"> Git commit:   afdb6d4</span><br><span class="line"> Built:        Tue Sep 26 22:42:18 2017</span><br><span class="line"> OS/Arch:      linux/amd64</span><br><span class="line"></span><br><span class="line">Server:</span><br><span class="line"> Version:      17.09.0-ce</span><br><span class="line"> API version:  1.32 (minimum version 1.12)</span><br><span class="line"> Go version:   go1.8.3</span><br><span class="line"> Git commit:   afdb6d4</span><br><span class="line"> Built:        Tue Sep 26 22:40:56 2017</span><br><span class="line"> OS/Arch:      linux/amd64</span><br><span class="line"> Experimental: <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p>最好将当前用户添加到 docker 用户组：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo usermod -aG docker your_username</span><br></pre></td></tr></table></figure>

<p>然后我们再使用上阿里云的镜像加速器：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo <span class="built_in">mkdir</span> -p /etc/docker</span><br><span class="line">sudo <span class="built_in">tee</span> /etc/docker/daemon.json &lt;&lt;-<span class="string">&#x27;EOF&#x27;</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;registry-mirrors&quot;</span>: [<span class="string">&quot;https://your_unique_id.mirror.aliyuncs.com&quot;</span>]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure>

<p>注册地址：<a href="https://cr.console.aliyun.com/#/accelerator">https://cr.console.aliyun.com/#/accelerator</a></p>
<p>然后运行下<code>hello-world</code>试试：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ docker run hello-world</span><br><span class="line">Hello from Docker!</span><br><span class="line">This message shows that your installation appears to be working correctly.</span><br><span class="line"></span><br><span class="line">To generate this message, Docker took the following steps:</span><br><span class="line"> 1. The Docker client contacted the Docker daemon.</span><br><span class="line"> 2. The Docker daemon pulled the <span class="string">&quot;hello-world&quot;</span> image from the Docker Hub.</span><br><span class="line"> 3. The Docker daemon created a new container from that image <span class="built_in">which</span> runs the</span><br><span class="line">    executable that produces the output you are currently reading.</span><br><span class="line"> 4. The Docker daemon streamed that output to the Docker client, <span class="built_in">which</span> sent it</span><br><span class="line">    to your terminal.</span><br><span class="line"></span><br><span class="line">To try something more ambitious, you can run an Ubuntu container with:</span><br><span class="line"> $ docker run -it ubuntu bash</span><br><span class="line"></span><br><span class="line">Share images, automate workflows, and more with a free Docker ID:</span><br><span class="line"> https://cloud.docker.com/</span><br><span class="line"></span><br><span class="line">For more examples and ideas, visit:</span><br><span class="line"> https://docs.docker.com/engine/userguide/</span><br></pre></td></tr></table></figure>

<h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h2><h3 id="基本应用"><a href="#基本应用" class="headerlink" title="基本应用"></a>基本应用</h3><p><strong>查看本地镜像</strong></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker image <span class="built_in">ls</span></span><br></pre></td></tr></table></figure>

<p><strong>搜索远程仓库中名为 centos 的镜像</strong></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker search centos</span><br></pre></td></tr></table></figure>

<p><strong>从远程仓库将相应镜像拉回本地</strong></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker pull centos</span><br></pre></td></tr></table></figure>
<p>默认会将 docker.io 官方的最新版本的 centos 取回本地</p>
<p><strong>创建容器</strong><br>从刚才拉回本地的 centos 创建一个容器，并在其中启动一个 bash，让该容器在后台运行</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker run -itd --name centos7 -v /home/blueyi/docker:/home/docker -p 20080:80 centos /bin/bash</span><br></pre></td></tr></table></figure>

<p>上面的参数解释如下：</p>
<ul>
<li><code>-itd</code>：是 <code>-i -t -d</code> 的简写。<code>-i</code> 表示保持打开标准输入流（stdin），无论是否连接到此容器。<code>-t</code> 为容器分配一个虚拟的 tty。<code>-d</code> 表示后台模式运行容器，即容器启动后将断开与当前终端的连接。</li>
<li><code>--name</code>：这是为容器起一个名字，之后与容器的交互需要用到，当然用容器的 Id 也是可以的（就是 run 命令后那个巨长的回显）。当然，不写的话也会有默认的名字。</li>
<li><code>-v</code>：表示挂载宿主主机目录到容器的目录（宿主机目录路径：容器目录路径）。当然可以设置读写属性。</li>
<li><code>-p</code>：表示映射主机端口至容器端口（主机端口：容器端口）。这个参数可以重复出现，映射多个端口。</li>
<li><code>centos</code>：本地镜像名称（centos），如果本地没有名为 centos 我镜像，Docker 会自动搜索并下载远程仓库中的最新镜像。</li>
<li><code>/bin/bash</code>：这个是本次启动的镜像要执行的任务。这个门道比较多，我在后面会说一下。</li>
</ul>
<p><strong>查看运行中的容器</strong></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker container <span class="built_in">ls</span></span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">docker ps</span><br></pre></td></tr></table></figure>

<p><strong>查看所有容器</strong></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker container <span class="built_in">ls</span> -a</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">docker ps -a</span><br></pre></td></tr></table></figure>

<p><strong>连接容器</strong></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker attach centos7</span><br></pre></td></tr></table></figure>
<p>然后我们查看一下容器 centos7 的系统信息：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@c5eb1263ab93 /]<span class="comment"># cat /etc/*release</span></span><br><span class="line">CentOS Linux release 7.4.1708 (Core)</span><br><span class="line">NAME=<span class="string">&quot;CentOS Linux&quot;</span></span><br><span class="line">VERSION=<span class="string">&quot;7 (Core)&quot;</span></span><br><span class="line">ID=<span class="string">&quot;centos&quot;</span></span><br><span class="line">ID_LIKE=<span class="string">&quot;rhel fedora&quot;</span></span><br><span class="line">VERSION_ID=<span class="string">&quot;7&quot;</span></span><br><span class="line">PRETTY_NAME=<span class="string">&quot;CentOS Linux 7 (Core)&quot;</span></span><br><span class="line">ANSI_COLOR=<span class="string">&quot;0;31&quot;</span></span><br><span class="line">CPE_NAME=<span class="string">&quot;cpe:/o:centos:centos:7&quot;</span></span><br><span class="line">HOME_URL=<span class="string">&quot;https://www.centos.org/&quot;</span></span><br><span class="line">BUG_REPORT_URL=<span class="string">&quot;https://bugs.centos.org/&quot;</span></span><br><span class="line"></span><br><span class="line">CENTOS_MANTISBT_PROJECT=<span class="string">&quot;CentOS-7&quot;</span></span><br><span class="line">CENTOS_MANTISBT_PROJECT_VERSION=<span class="string">&quot;7&quot;</span></span><br><span class="line">REDHAT_SUPPORT_PRODUCT=<span class="string">&quot;centos&quot;</span></span><br><span class="line">REDHAT_SUPPORT_PRODUCT_VERSION=<span class="string">&quot;7&quot;</span></span><br><span class="line"></span><br><span class="line">CentOS Linux release 7.4.1708 (Core)</span><br></pre></td></tr></table></figure>

<p>查看当前容器中的运行的进程：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@c5eb1263ab93 /]<span class="comment"># ps -aux</span></span><br><span class="line">USER        PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND</span><br><span class="line">root          1  0.0  0.0  11784  2852 pts/0    Ss   03:18   0:00 /bin/bash</span><br><span class="line">root         18  0.0  0.0  47456  3336 pts/0    R+   06:24   0:00 ps -aux</span><br></pre></td></tr></table></figure>

<p>从未见过如此少的一次系统运行的所有进程，后面会详细说明原因。</p>
<p>现在想退出容器怎么办呢，使用<code>exit</code>或者给个<code>ctrl+d</code>，但一但 exit 出来这个 bash，也就表示容器中运行的唯一进程被关闭，代表着容器中的任务运行完成，容器就会停止。</p>
<p><strong>启动停止的容器</strong></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker start centos7</span><br></pre></td></tr></table></figure>

<p><strong>在容器中执行命令</strong></p>
<p>通过<code>docker exec</code>命令可以在容器中执行命令，而不用进入容器的 bash。<br>查看容器 centos7 中运行的进程：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> centos7 ps -aux</span><br></pre></td></tr></table></figure>

<p>启动 bash 并挂载输入输出流（前台模式）：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it centos7 bash</span><br></pre></td></tr></table></figure>

<p>这样我们就相当于另起一个 bash，并直接登录，需要退出时正常 exit 或者<code>ctrl+d</code>即可。当然也可以运行一个带<code>-d</code>参数的相应命令，但我们通过<code>docker attach centos7</code>连接时，依然连接的是最初创建容器时的 bash。</p>
<p><strong>停止容器</strong></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker stop centos7</span><br></pre></td></tr></table></figure>

<p><strong>删除容器</strong></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">rm</span> centos7</span><br></pre></td></tr></table></figure>

<p>默认只能删除停止后的容器，如果要强行删除，可以使用<code>-f</code>参数。</p>
<p><strong>所以针对容器名的操作都可以通过<code>CONTAINER ID</code>来操作，<code>CONTAINER ID</code>使用时只要不会冲突，可以只用前几位，类似于 git 中的<code>commit id</code></strong></p>
<p>例如：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"> docker container <span class="built_in">ls</span> -a</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS                        PORTS                  NAMES</span><br><span class="line">0651f9e070bc        ubuntu              <span class="string">&quot;/bin/bash&quot;</span>              3 hours ago         Exited (127) 18 minutes ago                          ubuntu17</span><br><span class="line">c5eb1263ab93        centos              <span class="string">&quot;/bin/bash&quot;</span>              4 hours ago         Exited (137) 4 minutes ago                           centos7</span><br><span class="line">ed454bbb94fc        centos:latest       <span class="string">&quot;/bin/bash&quot;</span>              4 days ago          Exited (255) 4 days ago                              elastic_engelbart</span><br><span class="line">96e80b0dc916        hello               <span class="string">&quot;python app.py&quot;</span>          5 days ago          Exited (255) 4 days ago       0.0.0.0:4000-&gt;80/tcp   affectionate_beaver</span><br><span class="line">2dbe5ef3a2b2        c4d750cbd468        <span class="string">&quot;python app.py&quot;</span>          5 days ago          Exited (0) 5 days ago                                pensive_murdock</span><br><span class="line">92a611c8b2cb        05a3bd381fc2        <span class="string">&quot;/hello&quot;</span>                 5 days ago          Exited (0) 5 days ago                                awesome_darwin</span><br><span class="line">a7012bd520ef        ubuntu              <span class="string">&quot;/bin/bash&quot;</span>              2 weeks ago         Exited (1) 2 weeks ago                               nervous_curran</span><br><span class="line">a182da89dbd8        c4d750cbd468        <span class="string">&quot;python app.py&quot;</span>          3 weeks ago         Exited (0) 3 weeks ago                               serene_thompson</span><br><span class="line">d55a2ccdf7f7        53ee9f9056e8        <span class="string">&quot;python app.py&quot;</span>          4 weeks ago         Exited (0) 4 weeks ago                               frosty_thompson</span><br><span class="line">3986f345898e        53ee9f9056e8        <span class="string">&quot;python app.py&quot;</span>          4 weeks ago         Exited (137) 4 weeks ago                             sleepy_roentgen</span><br><span class="line">12204ac36056        53ee9f9056e8        <span class="string">&quot;python app.py&quot;</span>          4 weeks ago         Exited (0) 4 weeks ago                               distracted_ride</span><br><span class="line">ad95e10fe6c3        ac5dec7779c5        <span class="string">&quot;/bin/sh -c &#x27;pip -...&quot;</span>   4 weeks ago         Exited (2) 4 weeks ago                               thirsty_turing</span><br><span class="line">b2aec3f6bcc8        352e58e1c04c        <span class="string">&quot;python app.py&quot;</span>          4 weeks ago         Exited (0) 4 weeks ago                               nervous_mestorf</span><br><span class="line">8e2ae86cb786        352e58e1c04c        <span class="string">&quot;python app.py&quot;</span>          4 weeks ago         Exited (0) 4 weeks ago     </span><br></pre></td></tr></table></figure>

<p>我想启动最后一个容器：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker start 8</span><br></pre></td></tr></table></figure>

<p>因为容器 ID 中以<code>8</code>开始的只有这一个，并不会歧义。</p>
<p>强制删除刚刚启动的容器：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">rm</span> -f 8</span><br></pre></td></tr></table></figure>

<h3 id="Docker-官方-Get-Started"><a href="#Docker-官方-Get-Started" class="headerlink" title="Docker 官方 Get Started"></a>Docker 官方 Get Started</h3><p>来自官方<code>Get Started</code>包含了 docker 的常用使用场景下的使用方式</p>
<h3 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h3><p>Dockerfile 用于定义在容器运行后的内部环境应该包含哪些东西，例如下面这个用于运行 flask 程序的 python 环境的 Dockerfile：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Use an official Python runtime as a parent image</span></span><br><span class="line"><span class="keyword">FROM</span> python:<span class="number">2.7</span>-slim</span><br><span class="line"></span><br><span class="line"><span class="comment"># Set the working directory to /app</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /app</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Copy the current directory contents into the container at /app</span></span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> . /app</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Install any needed packages specified in requirements.txt</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> pip install --trusted-host pypi.python.org -r requirements.txt</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Make port 80 available to the world outside this container</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">80</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Define environment variable</span></span><br><span class="line"><span class="keyword">ENV</span> NAME World</span><br><span class="line"></span><br><span class="line"><span class="comment"># Run app.py when the container launches</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;python&quot;</span>, <span class="string">&quot;app.py&quot;</span>]</span></span><br></pre></td></tr></table></figure>

<p>然后在<code>requirements.txt</code>中放入我们的依赖：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">Flask</span><br><span class="line">Redis</span><br></pre></td></tr></table></figure>

<p>flask 的 hellowrld 的<code>app.py</code>代码如下：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"><span class="keyword">from</span> redis <span class="keyword">import</span> Redis, RedisError</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"><span class="comment"># Connect to Redis</span></span><br><span class="line">redis = Redis(host=<span class="string">&quot;redis&quot;</span>, db=<span class="number">0</span>, socket_connect_timeout=<span class="number">2</span>, socket_timeout=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hello</span>():</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        visits = redis.incr(<span class="string">&quot;counter&quot;</span>)</span><br><span class="line">    <span class="keyword">except</span> RedisError:</span><br><span class="line">        visits = <span class="string">&quot;&lt;i&gt;cannot connect to Redis, counter disabled&lt;/i&gt;&quot;</span></span><br><span class="line"></span><br><span class="line">    html = <span class="string">&quot;&lt;h3&gt;Hello &#123;name&#125;!&lt;/h3&gt;&quot;</span> \</span><br><span class="line">           <span class="string">&quot;&lt;b&gt;Hostname:&lt;/b&gt; &#123;hostname&#125;&lt;br/&gt;&quot;</span> \</span><br><span class="line">           <span class="string">&quot;&lt;b&gt;Visits:&lt;/b&gt; &#123;visits&#125;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> html.<span class="built_in">format</span>(name=os.getenv(<span class="string">&quot;NAME&quot;</span>, <span class="string">&quot;world&quot;</span>), hostname=socket.gethostname(), visits=visits)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    app.run(host=<span class="string">&#x27;0.0.0.0&#x27;</span>, port=<span class="number">80</span>)</span><br></pre></td></tr></table></figure>

<h3 id="创建-docker-镜像"><a href="#创建-docker-镜像" class="headerlink" title="创建 docker 镜像"></a>创建 docker 镜像</h3><p>创建名为 hello 的镜像：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker build -t hello .</span><br></pre></td></tr></table></figure>

<p>然后会看到一下下载和配置过程，最后有一个<code>Successfully</code>的提示，并且跟了一个 id 和 tag，该 id 即为该镜像的唯一标识符，同一个 Dockerfile 可以创建同一镜像 ID 但不同名的多个镜像。</p>
<p>查看镜像：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker images <span class="comment"># 或者 docker image ls</span></span><br></pre></td></tr></table></figure>

<p>运行镜像：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker run -p 4000:80 hello</span><br></pre></td></tr></table></figure>

<p><code>-p</code>为端口映射，运行成功后可以通过<code>http://localhost:4000</code>访问，或者你的主机 IP 跟<code>4000</code>的端口号。</p>
<p>后台运行：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker run -d -p 4000:80 hello</span><br></pre></td></tr></table></figure>

<p>查看运行中的容器：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker container <span class="built_in">ls</span></span><br></pre></td></tr></table></figure>

<p>停止运行中的容器：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker container stop &lt;<span class="built_in">id</span>&gt;</span><br></pre></td></tr></table></figure>

<h3 id="push-自己的镜像到docker-repository"><a href="#push-自己的镜像到docker-repository" class="headerlink" title="push 自己的镜像到docker repository"></a>push 自己的镜像到<code>docker repository</code></h3><p>登录到<code>cloud.docker.com</code>：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker login</span><br></pre></td></tr></table></figure>

<p>为镜像添加标签：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker tag image username/repository:tag</span><br></pre></td></tr></table></figure>

<p>然后 push 就可以了：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker push username/repository:tag</span><br></pre></td></tr></table></figure>

<p>在新环境中，从远程 pull 并且运行：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker run -p 4000:80 username/repository:tag</span><br></pre></td></tr></table></figure>

<h2 id="对-docker-深一点的理解"><a href="#对-docker-深一点的理解" class="headerlink" title="对 docker 深一点的理解"></a>对 docker 深一点的理解</h2><p>先查看一下我当前的系统环境：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> /etc/*release</span><br><span class="line">DISTRIB_ID=Ubuntu</span><br><span class="line">DISTRIB_RELEASE=16.04</span><br><span class="line">DISTRIB_CODENAME=xenial</span><br><span class="line">DISTRIB_DESCRIPTION=<span class="string">&quot;Ubuntu 16.04.3 LTS&quot;</span></span><br><span class="line">NAME=<span class="string">&quot;Ubuntu&quot;</span></span><br><span class="line">VERSION=<span class="string">&quot;16.04.3 LTS (Xenial Xerus)&quot;</span></span><br><span class="line">ID=ubuntu</span><br><span class="line">ID_LIKE=debian</span><br><span class="line">PRETTY_NAME=<span class="string">&quot;Ubuntu 16.04.3 LTS&quot;</span></span><br><span class="line">VERSION_ID=<span class="string">&quot;16.04&quot;</span></span><br><span class="line">HOME_URL=<span class="string">&quot;http://www.ubuntu.com/&quot;</span></span><br><span class="line">SUPPORT_URL=<span class="string">&quot;http://help.ubuntu.com/&quot;</span></span><br><span class="line">BUG_REPORT_URL=<span class="string">&quot;http://bugs.launchpad.net/ubuntu/&quot;</span></span><br><span class="line">VERSION_CODENAME=xenial</span><br><span class="line">UBUNTU_CODENAME=xenial</span><br><span class="line"></span><br><span class="line">$  <span class="built_in">uname</span> -a</span><br><span class="line">Linux hik 4.4.0-103-generic <span class="comment">#126-Ubuntu SMP Mon Dec 4 16:23:28 UTC 2017 x86_64 x86_64 x86_64 GNU/Linux</span></span><br></pre></td></tr></table></figure>

<p>现在我们尝试拉取一个官方的 centos 镜像并运行：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker run -t -i centos:latest /bin/bash</span><br></pre></td></tr></table></figure>

<p>一段时间下载之后会进入新镜像 centos 创建的容器，并在其中运行 bash。前面已经细解释过该命令参数的意义。</p>
<p>现在我们再来查看一下系统信息：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@ed454bbb94fc /]<span class="comment"># cat /etc/*release</span></span><br><span class="line">CentOS Linux release 7.4.1708 (Core)</span><br><span class="line">NAME=<span class="string">&quot;CentOS Linux&quot;</span></span><br><span class="line">VERSION=<span class="string">&quot;7 (Core)&quot;</span></span><br><span class="line">ID=<span class="string">&quot;centos&quot;</span></span><br><span class="line">ID_LIKE=<span class="string">&quot;rhel fedora&quot;</span></span><br><span class="line">VERSION_ID=<span class="string">&quot;7&quot;</span></span><br><span class="line">PRETTY_NAME=<span class="string">&quot;CentOS Linux 7 (Core)&quot;</span></span><br><span class="line">ANSI_COLOR=<span class="string">&quot;0;31&quot;</span></span><br><span class="line">CPE_NAME=<span class="string">&quot;cpe:/o:centos:centos:7&quot;</span></span><br><span class="line">HOME_URL=<span class="string">&quot;https://www.centos.org/&quot;</span></span><br><span class="line">BUG_REPORT_URL=<span class="string">&quot;https://bugs.centos.org/&quot;</span></span><br><span class="line"></span><br><span class="line">CENTOS_MANTISBT_PROJECT=<span class="string">&quot;CentOS-7&quot;</span></span><br><span class="line">CENTOS_MANTISBT_PROJECT_VERSION=<span class="string">&quot;7&quot;</span></span><br><span class="line">REDHAT_SUPPORT_PRODUCT=<span class="string">&quot;centos&quot;</span></span><br><span class="line">REDHAT_SUPPORT_PRODUCT_VERSION=<span class="string">&quot;7&quot;</span></span><br><span class="line"></span><br><span class="line">CentOS Linux release 7.4.1708 (Core)</span><br><span class="line"></span><br><span class="line">[root@ed454bbb94fc /]<span class="comment"># uname -a</span></span><br><span class="line">Linux ed454bbb94fc 4.4.0-103-generic <span class="comment">#126-Ubuntu SMP Mon Dec 4 16:23:28 UTC 2017 x86_64 x86_64 x86_64 GNU/Linux</span></span><br></pre></td></tr></table></figure>

<p>神奇的事情发生了，我们运行着的 centos 容器，竟然使用的是本地操作系统 ubuntu 的 linux 内核，所以说 docker 可以看成是超轻量级的虚拟机。事实上，它只是使用 linux 容器和命名空间等技术，帮助我们实现进程的资源隔离。下面我们做一些验证。</p>
<p>在 centos 容器中运行 top，可以看到进程中只有一个 top 和一个 bash 在运行。</p>
<p>然后我们再来查看一下宿主系统（ubuntu）中是否有 top 在运行：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ps -ef | grep top</span><br><span class="line">root      12461   7786  0 09:26 pts/0    00:00:00 top</span><br></pre></td></tr></table></figure>

<p>下面来自网上的一段引用：</p>
<blockquote>
<p>这个 top 进程就是我们在容器中运行的 top，其实 docker 容器中运行的进程实际上就是宿主机上的进程。docker 实际上使用了命名空间（namespace）来对进程进行隔离，使不同 namespace 的进程彼此不可见，同时使用 cgroup 来对彼此隔离的进程的资源进行限制，docker 的容器（container）其实就是一个进程的容器，而并不是一个全虚拟化的操作系统，所以他不会有什么 init 进程。docker 将进程、进程所需要的操作系统、运行环境称为容器。所以它比传统的基于 hypervisor 的虚拟机拥有更高的效率，并使用更低的资源。它实际上是一个内核级别的虚拟化技术，容器还是在使用宿主机的内核，为了证实上述内容，我们可以在容器中用如下命令查看 docker 的内核版本：</p>
</blockquote>
<p>你也可以使用<code>free -hm</code>等命令查看容器的硬件信息，发现是与宿主主机信息是一样的。</p>
<h2 id="Docker-其他常用命令"><a href="#Docker-其他常用命令" class="headerlink" title="Docker 其他常用命令"></a>Docker 其他常用命令</h2><p>仅涉及前面没有用到或者没有仔细解释的命令<br><strong>命令中<code>name</code>与<code>id</code>一样，下述中的<code>container</code>指容器的名称或 ID，<code>image</code>指镜像的名称或 ID</strong></p>
<h3 id="镜像相关"><a href="#镜像相关" class="headerlink" title="镜像相关"></a>镜像相关</h3><p><strong>删除镜像</strong></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker rmi &lt;image&gt;</span><br></pre></td></tr></table></figure>

<p>删除镜像前必须先删除容器，或者使用<code>-f</code>参数。</p>
<p><strong>删除所有镜像</strong></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker rmi $(docker images | awk <span class="string">&#x27;&#123;if (NR&gt;4) &#123;print $3&#125;&#125;&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>如果镜像有关系容器未删除，可以使用<code>-f</code>参数强制删除</p>
<p><strong>查看镜像历史</strong></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker image <span class="built_in">history</span> &lt;image&gt;</span><br></pre></td></tr></table></figure>

<p><strong>保存和恢复镜像</strong></p>
<p>应用场景，当创建自己的镜像之后希望迁移到其他机器上，除了可以通过推送到公网，然后再 pull 回来之外，还可以保存到本地文件，然后拷贝过去之后再恢复</p>
<p>保存和恢复镜像有2组命令：<code>save-load</code>和<code>export-import</code></p>
<p><em><code>save-load</code></em></p>
<p>支持一次保存多个镜像，当然使用<code>load</code>恢复的时候也会一次恢复多个镜像</p>
<p>保存镜像</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker save centos:latest &gt; my_centos.tar</span><br></pre></td></tr></table></figure>

<p>save命令后面也可以跟容器</p>
<p>恢复镜像：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker load &lt; my_centos.tar</span><br></pre></td></tr></table></figure>

<p><em><code>export-import</code></em></p>
<p><code>docker export</code>的操作对象需要是容器，而不是镜像，所以适用于制作基础镜像的场景</p>
<p>导出镜像：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">export</span> -o my_centos_ex.tar centos7</span><br></pre></td></tr></table></figure>

<p>导入镜像：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker import my_centos_ex.tar blueyi/centos7:latest</span><br></pre></td></tr></table></figure>

<p><em>两种方式的区别</em></p>
<p><code>save</code>导出的镜像tar包会包含所有历史信息和层，这样就可以支持层回滚了，但<code>export</code>导致的镜像tar包不包含历史信息，所以它的导出文件也会小一些，可以在导入后使用后面的镜像历史命令查询。</p>
<p><code>import</code>导入<code>export</code>的镜像时支持指定镜像名</p>
<p><strong>显示镜像历史</strong></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">history</span> &lt;image&gt;</span><br></pre></td></tr></table></figure>

<p><strong>保存容器为一个新的镜像</strong></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker commit &lt;container&gt; &lt;NEW_IMAGE_NAME&gt;</span><br></pre></td></tr></table></figure>

<h3 id="容器相关"><a href="#容器相关" class="headerlink" title="容器相关"></a>容器相关</h3><p><strong>删除所有容器</strong></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">rm</span> $(docker -ps -a -q)</span><br></pre></td></tr></table></figure>

<p><strong>强制 kill 掉容器</strong></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">kill</span> 《容器名 /ID&gt;</span><br></pre></td></tr></table></figure>

<p>它与前面用过的<code>docker stop</code>的区别是，<code>docker stop</code>执行时会先向容器中 PID 为 1 的进程发送系统信号<code>SIGTERM</code>，然后等待容器中的应用程序终止，如果等待时间达到设定的时间，或者默认的 10 秒，则会继续发送<code>SIGKILL</code>系统信号强行 kill 掉进程。如<code>docker stop --time=20 &lt;container_name&gt;</code>。<br>而<code>docker kill</code>类似于 Linux 系统的<code>kill</code>，如：<code>docker kill --singal=SIGINT &lt;container_name&gt;</code>，默认不加指定信号相当于<code>kill -9</code> 或 <code>kill -SIGKILL</code>，强行终止进程。</p>
<p><strong>后台运行一个容器，并映射端口和文件夹</strong></p>
<p>前面已经使用过了，再举一例</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker run -idt --name debian8 -p 8080:80 -p 8022:22 -v /var/cpp:/mnt/cpp -v /home/blueyi/download:/mnt/download debian:latest /bin/bash</span><br></pre></td></tr></table></figure>

<p>文件夹映射也称数据卷挂载，这样就可以使容器中使用的数据能够持久化地保存到本地</p>
<p>为了避免运行后它立即退出，所以打开了输入流<code>-i</code>，分配虚拟 tty<code>-t</code>，在其中执行<code>/bin/bash</code></p>
<p><strong>端口映射</strong></p>
<p>如果只是<code>-p 80</code>则docker会随机从宿主主机中选择一个端口映射到该容器中的80端口</p>
<p>如果端口使用使用大写的 P（即<code>-P</code>)，则 docker 会随机映射一个<code>49000~49900</code>的端口到内部容器开放的网络端口</p>
<p>端口映射也可以通过指定范围一次映射多个端口，例如<code>-v 2000-3000:2000-3000</code>，注意在我的测试中如果这个范围太大，比如超过10000个端口映射会导致容器启动失败</p>
<p><strong>显示容器的内容的改变</strong></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker diff &lt;container&gt;</span><br></pre></td></tr></table></figure>

<p><strong>显示容器中的进程信息</strong></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker top &lt;container&gt;</span><br></pre></td></tr></table></figure>

<p><strong>重启容器</strong></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker restart &lt;container&gt;</span><br></pre></td></tr></table></figure>

<p><strong><code>attach</code>到容器</strong></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker attach &lt;container&gt;</span><br></pre></td></tr></table></figure>

<p>前面已经用过，这样进入容器后当需要退出时，使用<code>exit</code>会导致容器停止。我们可以使用快捷键：先按<code>ctrl+p</code>，再按<code>ctrl+q</code>来退出容器</p>
<p><strong>连接容器</strong></p>
<p>docker 的容器连接分为 2 种情况，一种是同一主机上不同容器之间的连接，使用<code>--link</code>的方式进行；另一种是跨主机连接，使用<code>ambassador</code>实现，这里只试验使用<code>link</code>方式连接，跨主机连接以后用到了再学习。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker run --name=mysql_client1 --<span class="built_in">link</span>=mysql_server:db -t -i mysql_client /usr/bin/mysql</span><br></pre></td></tr></table></figure>

<p>表示从名为<code>mysql_client</code>的镜像创建一个名为<code>mysql_client1</code>的容器，并将其链接到 <code>mysql_server</code>，同时将 <code>mysql_server</code>的别名命名为<code>db</code></p>
<p>容器连接后可以查看其<code>/etc/hosts</code>文件中对相应容器的 IP 容器名以及容器 id 进行了映射</p>
<p><strong>查看容器日志</strong></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker logs &lt;container&gt;</span><br></pre></td></tr></table></figure>

<p><strong>从容器中拷贝数据到本地</strong></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">cp</span> &lt;container&gt;:/etc/profile .</span><br></pre></td></tr></table></figure>

<p>会将容器上的<code>/etc/profile</code>拷贝到当前目录，支持目录拷贝</p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p><strong>查看 docker 对象的底层信息</strong></p>
<p>通过<code>docker inspect</code>可以查看较低层的 docker 容器以及 docker 镜像的内部信息：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker inspect &lt;image_name/container_name&gt;</span><br></pre></td></tr></table></figure>

<p>当然<code>id</code>也一样。</p>
<p><strong>数据卷</strong></p>
<p>关于数据卷前面已经多次使用，就是通过<code>-v 宿主机文件 / 目录：容器里对应的文件 / 目录：权限</code>参数在运行容器之前为其添加数据卷映射，容器中不存在的挂载目录会自动创建，不指定权限时默认为读写。<br>如果<code>-v</code>后面只跟一个目录，该目录将会在容器在创建，并在本地的<code>/var/lib/docker/volumes</code>目录下产生相应的一个对应目录，目录名随机，可以通过以下命令查看具体挂载信息及相应目录</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker inspect --format=<span class="string">&#x27;&#123;&#123;.Mounts&#125;&#125;&#x27;</span> &lt;container&gt;</span><br></pre></td></tr></table></figure>

<p>或者使用命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker inspect &lt;container&gt;  | grep volumes</span><br></pre></td></tr></table></figure>

<p><em>注意：<code>/var/lib/docker/volumes</code>下的文件夹，也就是挂载的数据卷只有在以下情况才会被删除，否则该目录中会遗留很多名称很长的目录</em></p>
<ul>
<li><code>docker rm -v</code>删除容器时添加了<code>-v</code>选项</li>
<li><code>docker run --rm</code>运行容器时添加了<code>--rm</code>选项</li>
</ul>
<p><strong>数据卷容器</strong></p>
<p>如果用户需要在多个容器之间共享一些持续更新的数据，最简单的方式是使用数据卷容器。数据卷容器也是一个容器，但是它的目的是专门用来提供数据卷供其他容器挂载。</p>
<p>例如，创建一个数据卷容器 <code>dbdata</code>，并在其中创建一个数据卷挂载到 <code>/dbdata</code>：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker run -it -v /dbdata --name dbdata centos</span><br></pre></td></tr></table></figure>

<p>然后，可以在其他容器中使用 <code>--volumes-from</code> 来挂载 <code>dbdata</code> 容器中的数据卷。</p>
<p>例如创建 db1 和 db2 两个容器，并从 dbdata 容器挂载数据卷：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker run -it --volumes-from dbdata --name db1 ubuntu</span><br><span class="line">docker run -it --volumes-from dbdata --name db2 ubuntu</span><br></pre></td></tr></table></figure>

<p>此时，容器 db1 和 db2 都挂载同一个数据卷到相同的 <code>/dbdata</code> 目录。三个容器任何一方在该目录下的写入，其他容器都可以看到。</p>
<p>可以多次使用<code>--volumes-from</code>参数来从多个容器挂载多个数据卷。还可以从其他已经挂载了容器卷的容器来挂载数据卷。<br>使用<code>--volumes-from</code>参数所挂载数据卷的容器自身并不需要保持在运行状态。<br>如果删除了挂载的容器（包括 dbdata、db1 和 db2），数据卷并不会被自动删除。如果要删除一个数据卷，必须在删除最后一个还挂载着它的容器时显式使用<code>docker rm -v</code>命令来指定同时删除关联的容器。</p>
<p><strong>利用数据卷容器来迁移数据</strong></p>
<p>可以利用数据卷容器对其中的数据卷进行备份、恢复，以实现数据的迁移。</p>
<p><em>备份</em></p>
<p>使用下面的命令来备份 dbdata 数据卷容器内的数据卷：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker run --volumes-from dbdata -v $(<span class="built_in">pwd</span>):/backup --name worker centos tar cvf /backup/backup.tar /dbdata</span><br></pre></td></tr></table></figure>

<p>首先利用 centos 镜像创建了一个容器 worker。使用 –volumes-from dbdata 参数来让 worker 容器挂载 dbdata 容器的数据卷（即 dbdata 数据卷), 使用 <code>-v  $(pwd):/backup</code> 参数来挂载本地的当前目录到 worker 容器的 <code>/backup</code> 目录。worker 容器启动后，使用了 <code>tar cvf  /backup/backup.tar /dbdata</code> 命令来将 <code>/dbdata</code> 下内容备份为容器内的 <code>/backup/backup.tar</code>，即宿主主机当前目录下的 <code>backup.tar</code>。</p>
<p><em>恢复</em></p>
<p>如果要将数据恢复到一个容器，可以按照下面的步骤操作。</p>
<p>首先创建一个带有数据卷的容器 dbdata2：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker run -v /dbdata --name dbdata2 centos /bin/bash</span><br></pre></td></tr></table></figure>

<p>然后创建另一个新的容器，挂载 dbdata2 的容器，并使用 untar 解压备份文件到所挂载的容器卷中：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker run --volumes-from dbdata2 -v $(<span class="built_in">pwd</span>):/backup --name worker centos bash</span><br><span class="line"><span class="built_in">cd</span> /dbdata</span><br><span class="line">tar xvf /backup/backup.tar</span><br></pre></td></tr></table></figure>

<h2 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h2><h3 id="64位系统中的docker是否可以使用32位镜像"><a href="#64位系统中的docker是否可以使用32位镜像" class="headerlink" title="64位系统中的docker是否可以使用32位镜像"></a>64位系统中的docker是否可以使用32位镜像</h3><p>经测试是可以的，需要内核依然使用的是宿主主机的64位内核，但其中的32程序和库都可以正常使用</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://yq.aliyun.com/articles/110806?spm=5176.100239.blogcont29941.16.DNvVnE">Docker CE 镜像源站</a></li>
<li><a href="https://docs.docker.com/get-started">Docker Get Started</a></li>
<li>其他大量互联网资源</li>
</ol>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>YUV 数据格式详解</title>
    <url>/2017/12/05/yuv/</url>
    <content><![CDATA[<h2 id="YUV-数据格式概览"><a href="#YUV-数据格式概览" class="headerlink" title="YUV 数据格式概览"></a>YUV 数据格式概览</h2><p>YUV 的原理是把亮度与色度分离，使用 Y、U、V 分别表示亮度，以及蓝色通道与亮度的差值和红色通道与亮度的差值。其中 Y 信号分量除了表示亮度 (luma) 信号外，还含有较多的绿色通道量，单纯的 Y 分量可以显示出完整的黑白图像。U、V 分量分别表示蓝 (blue)、红 (red) 分量信号，它们只含有色彩 (chrominance/color) 信息，所以 YUV 也称为 YCbCr，C 意思可以理解为 (component 或者 color)。</p>
<p>维基百科上的 RGB 转 YUV 的公式能更好的反应 YUV 与 RGB 的关系，以及为什么称为 YCbCr：<br><img data-src="yuv1.png" alt=""></p>
<p>Y 中含有三元色色信息，且有较多的 G，所以他们一起可以显示出全彩的图像。<br>很显然我们可以想到是不是会有 YCgCb、YCgCr 等，针对不同的应用场景，也确实有相关应用研究。</p>
<p>如下图，一张从上到下分别为原图、Y、U 和 V：</p>
<p><img data-src="yuv2.png" alt=""></p>
<p>采用 YUV 而不是使用 RGB，既有历史原因：为了兼容老式黑白电视，因为 YUV 如果只输出 Y 就成了黑白图像了。也有 YUV 自己的其他优点，例如可以根据需要，采用特定的 YUV 存储格式，以降低祼码流的空间占用。</p>
<span id="more"></span>

<h2 id="YUV-存储格式"><a href="#YUV-存储格式" class="headerlink" title="YUV 存储格式"></a>YUV 存储格式</h2><p>YUV 存储格式有两大类：planar 和 packed。<br>对于 planar 的 YUV 格式，先连续存储所有像素点的 Y，紧接着存储所有像素点的 U，随后是所有像素点的 V。相当于将 YUV 拆分成三个平面 (plane) 存储。<br>对于 packed 的 YUV 格式，每个像素点的 Y,U,V 是连续交替存储的。<br>YUV 码流又根据不同的采样方式分为 YUV4:4:4、YUV4:2:2、YUV4:2:0、YUV4:1:1 等存储格式，其中前 3 种较常见。所谓采样意思就是根据一定的间隔取值。其中的比例是指 Y、U、V 表示的像素，三者分别占的比值。可以按照如下方式理解，实现存储和扫描与 DVD 的扫描线有关。<br>例如：</p>
<ul>
<li><code>YUV4:4:4</code> 是指每个像素分别有一个 Y、一个 U 和一个 V 组成，即每 4 个 Y 采样，就对应 4 个 Cb 和 4 个 Cr 采样，也就是一个像素占用 <code>8+8+8=24</code> 位，这种存储方式图像质量最高，但空间占用也最大，空间占用与 RGB 存储时一样。对于一个 <code>M*N</code> 分辨率的图像，该模式下存储空间占用字节数为 <code>M*N*3</code>。</li>
<li><code>YUV4:2:2</code> 是指每 4 个 Y 采样，对应 2 个 Cb 和 2 个 Cr 采样，这样在解析时就会有一些像素点只有亮度信息而没有色度信息，缺失的色度信息就需要在解析时由相邻的其他色度信息根据一定的算法填充。这种方式下平均一个像素占用空间为 <code>8+4+4=16</code> 位。对于一个 <code>M*N</code> 分辨率的图像，空间占用 <code>16/24</code>，即 <code>M*N*3*(16/24) = M*n*2</code> 个字节。</li>
<li><code>YUV4:2:0</code> 是指每 4 个 4 采样，对应 2 个 U 采样或者 2 个 V 采样，注意其中并不是表示 2 个 U 和 0 个 V，而是指无论水平下采样还是垂直下采样，色度采样都只有亮度的一半。该存储格式下，平均每个像素占用空间为 <code>8+4+0=12</code> 位。对于一个 <code>M*N</code> 分辨率的图像来说，空间占用为原来的 <code>12/24</code>，即 <code>M*N*3*(12/24)=M*N*3/2</code>。节省较多存储空间，该存储格式也最常用。</li>
<li><code>YUV4:1:1</code> 是指每 4 个 Y 采样，对应 1 个 U 采样和一个 V 采样。平均每个像素占用空间为 <code>8+2+2=12</code> 位。图像空间占用情况同上。这种存储格式实际使用的非常少。</li>
</ul>
<p>对于 packed 存储格式，可以理解 YUV 内存模型如下图：</p>
<p><img data-src="yuv3.png" alt=""></p>
<h2 id="YV12-I420-YU12-NV12-NV21"><a href="#YV12-I420-YU12-NV12-NV21" class="headerlink" title="YV12/I420/YU12/NV12/NV21"></a>YV12/I420/YU12/NV12/NV21</h2><p><code>YV12/I420/YU12/NV12/NV21</code> 都属于 <code>YUV 4:2:0</code>。YU12 就是 I420，YV12/I420 也称为 YUV420P（即平面格式，planar），YV12 与标准模式 I420 的区别是 UV 顺序不同。<br>YV12 取名来源是 Y 后面紧跟 V（然后是 U），12 表示它位深为 12，也就是一个像素占用空间为 12 位。<br>在 I420(YU12) 格式中，U 平面紧跟在 Y 平面之后，然后才是 V 平面（即：YUV）；但 YV12 则是相反（即：YVU）。大部分视频解码器的输出的原始图像都是 I420 格式（例如安卓下的图像通常都是 I420 或 NV21），而多数硬解码器中使用的都是 NV12 格式（例如 Intel MSDK、NVIDIA 的 cuvid、IOS 硬解码）。<br>另一类 YUV420SP, Y 分量平面格式，UV 打包格式，即 NV12。 NV12 与 NV21 类似，U 和 V 交错排列，不同在于 UV 顺序。<br>可理解如下：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">I420: YYYYYYYY UU VV  =&gt; YUV420P</span><br><span class="line">YV12: YYYYYYYY VV UU  =&gt; YUV420P</span><br><span class="line">NV12: YYYYYYYY UVUV   =&gt; YUV420SP</span><br><span class="line">NV21: YYYYYYYY VUVU   =&gt; YUV420SP</span><br></pre></td></tr></table></figure>

<p>维基百科上有两张 I420 和 NV12 的两张图非常好：</p>
<p><strong>I420 的单帧结构示意图如下（Planar 方式）：</strong></p>
<p><img data-src="yuv4.png" alt=""><br>这幅图的上面一幅可以看出 Y1、Y2、Y7、Y8 共用 U1 和 V1。后面的线性数组为其存储顺序，可以看出 Y、U 和 V 都是顺序存储的，往外写的时候，先按顺序将 Y 分量写出，然后再根据 U、V 分别将它们依次写出即可。</p>
<p><strong>NV12 的单帧结构示意图如下（Planar 方式）：</strong></p>
<p><img data-src="yuv5.png" alt=""><br>可以看出与 YV12 不同的时，它的 Y 虽然也是顺序存储，但 U、V 却是交错存储的，这种方式存储在往外写出时则先直接顺序写出 Y，然后对 UV 分别</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li>维基百科：<a href="https://en.wikipedia.org/wiki/YUV">https://en.wikipedia.org/wiki/YUV</a></li>
<li>维基百科：<a href="https://en.wikipedia.org/wiki/Chroma_subsampling">https://en.wikipedia.org/wiki/Chroma_subsampling</a></li>
<li>Videolan：<a href="https://wiki.videolan.org/YUV">https://wiki.videolan.org/YUV</a></li>
<li>FOURCC:   <a href="https://www.fourcc.org/">https://www.fourcc.org/</a></li>
<li>简书：    <a href="http://www.jianshu.com/p/e67f79f10c65">http://www.jianshu.com/p/e67f79f10c65</a></li>
<li>其他网络资源</li>
</ol>
]]></content>
      <categories>
        <category>Video</category>
      </categories>
      <tags>
        <tag>YUV</tag>
        <tag>Video</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows 下的多线程应用</title>
    <url>/2017/12/04/windows-multi-threads/</url>
    <content><![CDATA[<p>Windows 下的多线程中线程锁是通过<code>CRITICAL_SECTION</code>实现，用以保护用户数据，即当串行代码断执行到该部分时，操作系统将告知下一来执行到此处的线程等待，直到上一个线程离开被保护的代码断，从而通过将需要访问数据的部分放在该代码段来保护数据被多线程访问时的一致性。</p>
<span id="more"></span>

<h2 id="线程创建"><a href="#线程创建" class="headerlink" title="线程创建"></a>线程创建</h2><p>Windows 下可以使用<code>CreateThread</code>（头文件 windows.h）和<code>_beginthreadex</code>（头文件 process.h ）来创建线程，针对 C/C++ 的开发，为了安全性考虑，推荐使用<code>_beginthreadex</code>来创建线程。<br><code>CreateThread</code>的函数原型如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">HANDLEWINAPICreateThread</span>(</span><br><span class="line">  LPSECURITY_ATTRIBUTES  lpThreadAttributes,</span><br><span class="line">  SIZE_T  dwStackSize,</span><br><span class="line">  LPTHREAD_START_ROUTINE  lpStartAddress,</span><br><span class="line">  LPVOID  lpParameter,</span><br><span class="line">  DWORD  dwCreationFlags,</span><br><span class="line">  LPDWORD  lpThreadId</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>函数说明：</p>
<ul>
<li>第一个参数表示线程内核对象的安全属性，一般传入 NULL 表示使用默认设置。</li>
<li>第二个参数表示线程栈空间大小。传入 0 表示使用默认大小（1MB）。</li>
<li>第三个参数表示新线程所执行的线程函数地址，多个线程可以使用同一个函数地址。</li>
<li>第四个参数是传给线程函数的参数。</li>
<li>第五个参数指定额外的标志来控制线程的创建，为 0 表示线程创建之后立即就可以进行调度，如果为 CREATE_SUSPENDED 则表示线程创建后暂停运行，这样它就无法调度，直到调用 ResumeThread()。</li>
<li>第六个参数将返回线程的 ID 号，传入 NULL 表示不需要返回该线程 ID 号。</li>
</ul>
<p>函数返回值：<br>成功返回新线程的句柄，失败返回 NULL。<br><code>_beginthreadex</code>的参数与上面一样，实际上<code>_beginthreadex</code>创建线程是会调用 CreateThread，但它通过为线程提供独享的数据块，能够更好的确保 C/C++ 库函数在多线程下的正确执行</p>
<h2 id="线程锁"><a href="#线程锁" class="headerlink" title="线程锁"></a>线程锁</h2><p>Windows 下的多线程的线程锁通过<code>CRITICAL_SECTION</code>实现，<code>CRITICAL_SECTION</code>用于定义一个关键段对象，如<code>CRITICAL_SECTION cs;</code>该对象可以记录线程对他的访问，从而使其他线程在访问 cs 时，当 cs 记录到有其他线程还未离开，就一直处理等待之中。类似于 C++ 中的智能指针的实现方式。<br><code>CRITICAL_SECTION</code>相关的函数如下（解释为个人理解，仅供参考）：</p>
<ul>
<li><code>InitializeCriticalSection(&amp;cs)</code> 初始化 cs<br><code>EnterCriticalSection(&amp;cs)</code> 该函数会修改 cs，相当于 cs 中有个计数器，初始时为 0（实际上是 -1），当有某个线程执行该函数时，将 cs 中的计数器 +1，如果 cs 的计数器在 +1 之后不为 1，则表示有其他线程在占用这个语句之后的部分，该线程一直等待，直到其值为 1 后开始执行其后语句，并在 cs 中记录这个线程，当这个线程再次进入这个语句时，会直接放行。<br><code>LeaveCriticalSection(&amp;cs)</code> 该函数同样会修改 cs，将 cs 中的计数器减 1，该语句执行后会直接继续往下执行<br><code>DeleteCriticalSection(&amp;cs)</code> 销毁 cs<br>所以<code>CRITICAL_SECTION</code>相当于保护了位于<code>EnterCriticalSection()</code>和<code>LeaveCriticalSection()</code>之间的一段代码，当该段代码中有对资源的读写访问时，也就起到了相应的资源保护功能。<br>这些都在<code>windows.h</code>头文件中</li>
</ul>
<p>另外两个配合多线程一起使用的函数：<br><strong><code>WaitForSingleObject</code></strong><br>函数功能：等待函数 – 使线程进入等待状态，直到指定的内核对象被触发<br>函数原形：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">DWORDWINAPIWaitForSingleObject</span>(</span><br><span class="line">  HANDLE hHandle,</span><br><span class="line">  DWORD dwMilliseconds</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>函数说明：</p>
<ul>
<li>第一个参数为要等待的内核对象。</li>
<li>第二个参数为最长等待的时间，以毫秒为单位，如传入 5000 就表示 5 秒，传入 0 就立即返回，传入 INFINITE 表示无限等待。</li>
</ul>
<p><strong>WaitForMultipleObjects(THREAD_NUM, handle, TRUE, INFINITE);</strong><br>该函数类似，可以用它们让线程等待其他线程都执行完再退出，<br>handle 参数可以是个包含多个线程句柄的数组<br>一个多线程的 HelloWorld 程序：<br><em>功能：创建 10 个线程，这 10 个线程都执行同一个函数，当然实际开发中不会这么做</em></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;process.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> g_nCount = <span class="number">0</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> THREAD_NUM = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">CRITICAL_SECTION g_csFunThread;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Child thread</span></span><br><span class="line"> <span class="function"><span class="type">unsigned</span> <span class="type">int</span> __stdcall <span class="title">ThreadFun</span><span class="params">(LPVOID pM)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">EnterCriticalSection</span>(&amp;g_csFunThread);</span><br><span class="line">    ++g_nCount;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Child Thread ID: &quot;</span> &lt;&lt; <span class="built_in">GetCurrentThreadId</span>() &lt;&lt; <span class="string">&quot;, say: &quot;</span> &lt;&lt; g_nCount &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">LeaveCriticalSection</span>(&amp;g_csFunThread);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">InitializeCriticalSection</span>(&amp;g_csFunThread);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Main Thread&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    HANDLE handle[THREAD_NUM];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; THREAD_NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        handle[i] = (HANDLE)_beginthreadex(<span class="literal">NULL</span>, <span class="number">0</span>, ThreadFun, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 当没有这句时将会由于主线程结束导致所有线程都被强制结束 */</span></span><br><span class="line">    <span class="built_in">WaitForMultipleObjects</span>(THREAD_NUM, handle, TRUE, INFINITE);  </span><br><span class="line">    <span class="built_in">DeleteCriticalSection</span>(&amp;g_csFunThread);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://msdn.microsoft.com/zh-cn/library/ms235302.aspx">https://msdn.microsoft.com/zh-cn/library/ms235302.aspx</a></li>
</ol>
]]></content>
      <categories>
        <category>Dev</category>
      </categories>
      <tags>
        <tag>Dev</tag>
      </tags>
  </entry>
  <entry>
    <title>gdb调试coredump文件</title>
    <url>/2017/12/03/coredump/</url>
    <content><![CDATA[<h2 id="生成coredump"><a href="#生成coredump" class="headerlink" title="生成coredump"></a>生成coredump</h2><p>当程序运行出现如下错误时：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Program terminated with signal 11, Segmentation fault   (core dumped).</span><br></pre></td></tr></table></figure>
<p>系统会提示有coredump产生，但通常我们在系统文件夹下并找不到core文件，是因为系统设置产生core文件大小为0，也即不会产生，所以我们这里可以做一些简单的设置：</p>
<p>设置core文件产生在当前目录，<code>%e</code>表示产生core文件的程序名，<code>%p</code>为pid号：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;core.%e.%p&quot;</span> &gt; /proc/sys/kernel/core_pattern  </span><br></pre></td></tr></table></figure>

<p>查看当前core文件设置的大小：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ulimit</span> -c</span><br></pre></td></tr></table></figure>

<p>设置core文件大小为无限制：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ulimit</span> -c unlimited</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p><code>ulimit -a</code> 可以显示出<code>/etc/security/limits.conf</code>中定义的所有限制选项。<br><strong>注意：通过命令修改的该限制只在当前session有效，修改的core_pattern也会在系统重启后消失</strong><br>所以，如果想每次开机都有交，可以加到<code>profile</code>或者直接修改文件<code>/etc/security/limits.conf</code></p>
<p>coredump文件实际上ELF格式，所以也可以使用readelf来查看其信息，如：查看ELF头，会发现其中<code>Type</code>为<code>CORE</code>：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ readelf -h core.test.29673</span><br><span class="line"></span><br><span class="line">ELF Header:</span><br><span class="line">  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00</span><br><span class="line">  Class:                             ELF64</span><br><span class="line">  Data:                              2<span class="string">&#x27;s complement, little endian</span></span><br><span class="line"><span class="string">  Version:                           1 (current)</span></span><br><span class="line"><span class="string">  OS/ABI:                            UNIX - System V</span></span><br><span class="line"><span class="string">  ABI Version:                       0</span></span><br><span class="line"><span class="string">  Type:                              CORE (Core file)</span></span><br><span class="line"><span class="string">  Machine:                           Advanced Micro Devices X86-64</span></span><br><span class="line"><span class="string">  Version:                           0x1</span></span><br><span class="line"><span class="string">  Entry point address:               0x0</span></span><br><span class="line"><span class="string">  Start of program headers:          64 (bytes into file)</span></span><br><span class="line"><span class="string">  Start of section headers:          0 (bytes into file)</span></span><br><span class="line"><span class="string">  Flags:                             0x0</span></span><br><span class="line"><span class="string">  Size of this header:               64 (bytes)</span></span><br><span class="line"><span class="string">  Size of program headers:           56 (bytes)</span></span><br><span class="line"><span class="string">  Number of program headers:         235</span></span><br><span class="line"><span class="string">  Size of section headers:           0 (bytes)</span></span><br><span class="line"><span class="string">  Number of section headers:         0</span></span><br><span class="line"><span class="string">  Section header string table index: 0</span></span><br></pre></td></tr></table></figure>

<p><strong>查看所有core文件相关的当前配置</strong></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># sysctl -a| grep core</span></span><br><span class="line">kernel.core_pattern = core.%e.%p</span><br><span class="line">kernel.core_pipe_limit = 0</span><br><span class="line">kernel.core_uses_pid = 1</span><br><span class="line">net.core.bpf_jit_enable = 0</span><br><span class="line">net.core.busy_poll = 0</span><br><span class="line">net.core.busy_read = 0</span><br><span class="line">net.core.default_qdisc = pfifo_fast</span><br><span class="line">net.core.dev_weight = 64</span><br><span class="line">net.core.message_burst = 10</span><br><span class="line">net.core.message_cost = 5</span><br><span class="line">net.core.netdev_budget = 300</span><br><span class="line">net.core.netdev_max_backlog = 1000</span><br><span class="line">net.core.netdev_tstamp_prequeue = 1</span><br><span class="line">net.core.optmem_max = 20480</span><br><span class="line">net.core.rmem_default = 212992</span><br><span class="line">net.core.rmem_max = 212992</span><br><span class="line">net.core.rps_sock_flow_entries = 0</span><br><span class="line">net.core.somaxconn = 128</span><br><span class="line">net.core.warnings = 1</span><br><span class="line">net.core.wmem_default = 212992</span><br><span class="line">net.core.wmem_max = 212992</span><br><span class="line">net.core.xfrm_acq_expires = 30</span><br><span class="line">net.core.xfrm_aevent_etime = 10</span><br><span class="line">net.core.xfrm_aevent_rseqth = 2</span><br><span class="line">net.core.xfrm_larval_drop = 1</span><br></pre></td></tr></table></figure>

<p>所以，同样可以通过sysctl来修改kernel.core_pattern：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sysctl -w kernel.core_pattern=core.%e.%p</span><br></pre></td></tr></table></figure>
<p>该修改依然会在重启后消失</p>
<p>sysctl会从<code>/etc/sysctl.conf</code>中读取配置，也可以通过修改该文件中的配置来使core相关配置永久生效，在<code>/etc/sysctl.conf</code>中加入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kernel.core_pattern=core.%e.%p</span><br></pre></td></tr></table></figure>



<h2 id="gdb调试coredump文件"><a href="#gdb调试coredump文件" class="headerlink" title="gdb调试coredump文件"></a>gdb调试coredump文件</h2><h3 id="进入coredump"><a href="#进入coredump" class="headerlink" title="进入coredump"></a>进入coredump</h3><p>首先记得编译可执行文件时使用<code>-g</code>参数产生可调试信息。<br>有以下两种方式来快速定位产生错误的程序位置：</p>
<p>1）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gdb 可执行文件 core文件</span><br></pre></td></tr></table></figure>

<p>2）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gdb -c core文件</span><br></pre></td></tr></table></figure>

<p>进入core文件的调试，然后使用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">file 可执行文件</span><br></pre></td></tr></table></figure>

<h3 id="快速定位到出错位置"><a href="#快速定位到出错位置" class="headerlink" title="快速定位到出错位置"></a>快速定位到出错位置</h3><p>进入coredump调试之后输入<code>where</code>（或者<code>backtrace</code>，简写<code>bt</code>）即可快速定位到出错的地方，当然这个时候常用的gdb调试命令也都是可用的</p>
<h3 id="coredump文件的调试命令"><a href="#coredump文件的调试命令" class="headerlink" title="coredump文件的调试命令"></a>coredump文件的调试命令</h3><p>显示所有线程：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">info threads</span><br></pre></td></tr></table></figure>

<p>显示线程堆栈信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bt # 即backtrace，与上面的where功能一样</span><br></pre></td></tr></table></figure>

<p>切换线程：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">thread thread_num</span><br></pre></td></tr></table></figure>

<p>切换栈：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">frame num</span><br></pre></td></tr></table></figure>
<p>上面使用bt或者where时，会有很多编号，该命令可以切换到相应的栈去查看具体出错代码</p>
<p>显示当前帧的寄存器信息 （每一帧的寄存器信息都是不相同的）:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">info r</span><br></pre></td></tr></table></figure>

<h2 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h2><h3 id="signal"><a href="#signal" class="headerlink" title="signal"></a>signal</h3><p>当我们加载core文件之后，往往可以看到gdb的输出中有这样一句：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Program terminated with signal 11, Segmentation fault.</span><br></pre></td></tr></table></figure>

<p>这里的<code>signal 11</code>对应于名称为<code>SIGSEGV</code>，表示”试图访问未分配给自己的内存, 或试图往没有写权限的内存地址写数据.”</p>
<p>命令：<code>kill -l</code>可以列出所以的singal和对应的编号，下面是从网上某处找到的常用信号及其对应功能<br>，其中的<code>kill -9</code>大家应该都不陌生。</p>
<p>1) SIGHUP<br>本信号在用户终端连接(正常或非正常)结束时发出, 通常是在终端的控制进程结束时, 通知同一session内的各个作业, 这时它们与控制终端不再关联。</p>
<p>登录Linux时，系统会分配给登录用户一个终端(Session)。在这个终端运行的所有程序，包括前台进程组和后台进程组，一般都属于这个Session。当用户退出Linux登录时，前台进程组和后台有对终端输出的进程将会收到SIGHUP信号。这个信号的默认操作为终止进程，因此前台进程组和后台有终端输出的进程就会中止。不过可以捕获这个信号，比如wget能捕获SIGHUP信号，并忽略它，这样就算退出了Linux登录，wget也能继续下载。</p>
<p>此外，对于与终端脱离关系的守护进程，这个信号用于通知它重新读取配置文件。</p>
<p>2) SIGINT<br>程序终止(interrupt)信号, 在用户键入INTR字符(通常是Ctrl-C)时发出，用于通知前台进程组终止进程。</p>
<p>3) SIGQUIT<br>和SIGINT类似, 但由QUIT字符(通常是Ctrl-/)来控制. 进程在因收到SIGQUIT退出时会产生core文件, 在这个意义上类似于一个程序错误信号。</p>
<p>4) SIGILL<br>执行了非法指令. 通常是因为可执行文件本身出现错误, 或者试图执行数据段. 堆栈溢出时也有可能产生这个信号。</p>
<p>5) SIGTRAP<br>由断点指令或其它trap指令产生. 由debugger使用。</p>
<p>6) SIGABRT<br>调用abort函数生成的信号。</p>
<p>7) SIGBUS<br>非法地址, 包括内存地址对齐(alignment)出错。比如访问一个四个字长的整数, 但其地址不是4的倍数。它与SIGSEGV的区别在于后者是由于对合法存储地址的非法访问触发的(如访问不属于自己存储空间或只读存储空间)。</p>
<p>8) SIGFPE<br>在发生致命的算术运算错误时发出. 不仅包括浮点运算错误, 还包括溢出及除数为0等其它所有的算术的错误。</p>
<p>9) SIGKILL<br>用来立即结束程序的运行. 本信号不能被阻塞、处理和忽略。如果管理员发现某个进程终止不了，可尝试发送这个信号。</p>
<p>10) SIGUSR1<br>留给用户使用</p>
<p>11) SIGSEGV<br>试图访问未分配给自己的内存, 或试图往没有写权限的内存地址写数据.</p>
<p>12) SIGUSR2<br>留给用户使用</p>
<p>13) SIGPIPE<br>管道破裂。这个信号通常在进程间通信产生，比如采用FIFO(管道)通信的两个进程，读管道没打开或者意外终止就往管道写，写进程会收到SIGPIPE信号。此外用Socket通信的两个进程，写进程在写Socket的时候，读进程已经终止。</p>
<p>14) SIGALRM<br>时钟定时信号, 计算的是实际的时间或时钟时间. alarm函数使用该信号.</p>
<p>15) SIGTERM<br>程序结束(terminate)信号, 与SIGKILL不同的是该信号可以被阻塞和处理。通常用来要求程序自己正常退出，shell命令kill缺省产生这个信号。如果进程终止不了，我们才会尝试SIGKILL。</p>
<p>17) SIGCHLD<br>子进程结束时, 父进程会收到这个信号。</p>
<p>如果父进程没有处理这个信号，也没有等待(wait)子进程，子进程虽然终止，但是还会在内核进程表中占有表项，这时的子进程称为僵尸进程。这种情况我们应该避免(父进程或者忽略SIGCHILD信号，或者捕捉它，或者wait它派生的子进程，或者父进程先终止，这时子进程的终止自动由init进程来接管)。</p>
<p>18) SIGCONT<br>让一个停止(stopped)的进程继续执行. 本信号不能被阻塞. 可以用一个handler来让程序在由stopped状态变为继续执行时完成特定的工作. 例如, 重新显示提示符</p>
<p>19) SIGSTOP<br>停止(stopped)进程的执行. 注意它和terminate以及interrupt的区别:该进程还未结束, 只是暂停执行. 本信号不能被阻塞, 处理或忽略.</p>
<p>20) SIGTSTP<br>停止进程的运行, 但该信号可以被处理和忽略. 用户键入SUSP字符时(通常是Ctrl-Z)发出这个信号</p>
<p>21) SIGTTIN<br>当后台作业要从用户终端读数据时, 该作业中的所有进程会收到SIGTTIN信号. 缺省时这些进程会停止执行.</p>
<p>22) SIGTTOU<br>类似于SIGTTIN, 但在写终端(或修改终端模式)时收到.</p>
<p>23) SIGURG<br>有”紧急”数据或out-of-band数据到达socket时产生.</p>
<p>24) SIGXCPU<br>超过CPU时间资源限制. 这个限制可以由getrlimit/setrlimit来读取/改变。</p>
<p>25) SIGXFSZ<br>当进程企图扩大文件以至于超过文件大小资源限制。</p>
<p>26) SIGVTALRM<br>虚拟时钟信号. 类似于SIGALRM, 但是计算的是该进程占用的CPU时间.</p>
<p>27) SIGPROF<br>类似于SIGALRM/SIGVTALRM, 但包括该进程用的CPU时间以及系统调用的时间.</p>
<p>28) SIGWINCH<br>窗口大小改变时发出.</p>
<p>29) SIGIO<br>文件描述符准备就绪, 可以开始进行输入/输出操作.</p>
<p>30) SIGPWR<br>Power failure</p>
<p>31) SIGSYS<br>非法的系统调用。</p>
<p>在以上列出的信号中，程序不可捕获、阻塞或忽略的信号有：SIGKILL,SIGSTOP<br>不能恢复至默认动作的信号有：SIGILL,SIGTRAP<br>默认会导致进程流产的信号有：SIGABRT,SIGBUS,SIGFPE,SIGILL,SIGIOT,SIGQUIT,SIGSEGV,SIGTRAP,SIGXCPU,SIGXFSZ<br>默认会导致进程退出的信号有：SIGALRM,SIGHUP,SIGINT,SIGKILL,SIGPIPE,SIGPOLL,SIGPROF,SIGSYS,SIGTERM,SIGUSR1,SIGUSR2,SIGVTALRM<br>默认会导致进程停止的信号有：SIGSTOP,SIGTSTP,SIGTTIN,SIGTTOU<br>默认进程忽略的信号有：SIGCHLD,SIGPWR,SIGURG,SIGWINCH</p>
<p>此外，SIGIO在SVR4是退出，在4.3BSD中是忽略；SIGCONT在进程挂起时是继续，否则是忽略，不能被阻塞</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>gdb</tag>
        <tag>coredump</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows和Linux下的动态链接库的编译、链接和引用相关问题</title>
    <url>/2017/12/01/dll-lib-export-for-windows/</url>
    <content><![CDATA[<p>关于动态链接库和静态链接库的区别可以参考另一篇笔记，其实也就一句话：静态链接库在编译期加载到相应的编译目标中（编译后不再需要），而动态链接库是在运行期由执行目标进行调用（每次运行都需要）。<br>Windows下动态链接库以后缀<code>.dll</code>标识，Linux下的动态链接库命名为<code>libxxx.so</code>，其中<code>xxx</code>为库名称。</p>
<span id="more"></span>

<h2 id="Windows下配置VS编译生成dll动态库和相应的lib文件"><a href="#Windows下配置VS编译生成dll动态库和相应的lib文件" class="headerlink" title="Windows下配置VS编译生成dll动态库和相应的lib文件"></a>Windows下配置VS编译生成dll动态库和相应的lib文件</h2><p>当我们的项目生成为DLL库提供给调用方使用时，同时还需要提供lib文件和头文件，如果只有头文件，VS编译时将会报错，因为编译器需要从相应的lib中查找需要引用的相关函数。该lib文件与静态库的lib文件不同的是它要小的多，其中并不包含实际相关函数实现，只是包含了需要引用的函数声明信息。该lib同样也只是在调用方编译时用一次，运行时只需要提供相应的DLL即可。所以我们除了创建能够生成DLL的项目之外，还需要配置VS生成包含指定函数的lib文件。</p>
<h3 id="创建生成DLL的项目"><a href="#创建生成DLL的项目" class="headerlink" title="创建生成DLL的项目"></a>创建生成DLL的项目</h3><p>创建VS的WIN32应用程序项目时，将“应用程序类型”直接选择为<code>DLL</code>即可。也可以创建一个普通的控制台项目，然后在项目属性——常规——配置类型中设置为动态库(.dll)。</p>
<h3 id="配置输出lib和dll"><a href="#配置输出lib和dll" class="headerlink" title="配置输出lib和dll"></a>配置输出lib和dll</h3><p>创建完DLL项目，或者在项目属性中更改项目类型为DLL之后，编译生成的目标文件即为相应的DLL，我们只需要配置能够生成lib即可。可以指定某些函数生成到lib中，相当于我们只暴露指定的函数给调用方。有2种方式来指定生成lib文件：</p>
<h4 id="通过-declspec-dllexport-生成lib"><a href="#通过-declspec-dllexport-生成lib" class="headerlink" title="通过_declspec(dllexport)生成lib"></a>通过<code>_declspec(dllexport)</code>生成lib</h4><p>只需要在要导出的函数声明前使用<code>_declspec(dllexport)</code>即可导出为lib，该方式不是很灵活，当需要添加函数时，添加的函数都需要在源码中添加该声明。<br>下面举例说明：<br><strong>创建一个DLL工程</strong><br>新建头文件<code>testDll.h</code>，内容如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> TEST_DLL_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TEST_DLL_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line">_declspec(dllexport) <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> std::string &amp;str)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>新建<code>testDll.cpp</code>，内容如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;testDll.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> std::string &amp;str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Come from dynamic library!\n&quot;</span> &lt;&lt; str &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后编译之后可以看到生成了<code>TestDll.lib</code>和<code>TestDll.dll</code>两个文件，如果上面在声明时不使用<code>_declspec(dllexport)</code>，只会生成dll，不会生成<code>lib</code>。</p>
<p><strong>引用DLL</strong></p>
<p>同一个解决方案下新建一个项目<code>TestDemo</code>，新建一个解决方案也是一样的，在同一个解决方案中省了指定lib路径和拷贝dll。<br>新建<code>testDemo.cpp</code>，内容为：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;testDll.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编辑项目属性，其中“通用属性——引用”中添加刚才那个DLL的项目，最好再启用“复制本地”，这样DLL生成之后就会自动引用到这里。在“配置属性——C/C++——常规”中附加包含目录添加含有<code>testDll.h</code>的路径。</p>
<p>现在编译之后就可以直接运行了。</p>
<p>附送一份跨平台的通用宏定义：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> WIN32</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WINDLL</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DLL_API _declspec(dllexport)  <span class="comment">// 用于DLL生成的导入导出</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DLL_API _declspec(dllimport)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  <span class="comment">// _WINDLL</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DLL_API</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __stdcall  <span class="comment">// 用于指定函数参数调用中的压栈和清理顺序</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __stdcall</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  <span class="comment">// __stdcall</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  <span class="comment">// WIN32</span></span></span><br></pre></td></tr></table></figure>

<p>该部分内容放在用于生成DLL项目的相关头文件中，后面需要导出到DLL中的函数都用宏<code>DLL_API</code>修饰，这样当这个项目编译时将会自动生成相应的DLL文件和lib文件，lib文件中将会含有被<code>_declspec(dllexport)</code>修饰的函数，以便用于其他项目的链接。</p>
<h4 id="通过-def文件生成lib"><a href="#通过-def文件生成lib" class="headerlink" title="通过.def文件生成lib"></a>通过<code>.def</code>文件生成lib</h4><p>也可以在项目中添加一个后缀为<code>.def</code>的文件，文件内容如下来指定DLL导出的文件相关信息，例如针对上面的代码，删除其中的<code>_declspec(dllexport)</code>，添加文件<code>Dllexport.def</code>（新建项，然后搜索def即可），内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; export for dll</span><br><span class="line">LIBRARY TestDll</span><br><span class="line"></span><br><span class="line">EXPORTS</span><br><span class="line">    print</span><br></pre></td></tr></table></figure>

<p>其中<code>;</code>后面为注释，<code>LIBRARY</code>后面跟导出库的名字，<code>EXPORTS</code>后面为需要导出库中包含的函数。<br>这种方式更加灵活</p>
<h2 id="Linux下动态链接库的生成和调用"><a href="#Linux下动态链接库的生成和调用" class="headerlink" title="Linux下动态链接库的生成和调用"></a>Linux下动态链接库的生成和调用</h2><p>linux下容易的多，只需要生成一个<code>libxxx.so</code>文件，然后引用的时候在编译期通过<code>-lxxx</code>加入对该so的引用即可。<br>还以上面例子中的三个代码文件为例，</p>
<h3 id="编译动态链接库"><a href="#编译动态链接库" class="headerlink" title="编译动态链接库"></a>编译动态链接库</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">g++ -fPIC -shared -o libtestDll.so</span><br></pre></td></tr></table></figure>

<p>其中<code>-shared</code>指定生成动态链接库，否则默认输出可执行文件，<code>-fPIC</code>表示编译为位置独立的代码，不用此选项的话编译后的代码是位置相关的所以动态载入时是通过代码拷贝的方式来满足不同进程的需要，而不能达到真正代码段共享的目的。</p>
<h3 id="引用动态链接库"><a href="#引用动态链接库" class="headerlink" title="引用动态链接库"></a>引用动态链接库</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">g++ -o testDemo testDemo.cpp -ltestDll -L.</span><br></pre></td></tr></table></figure>

<p>其中<code>-l</code>表示引用的动态链接库名，<code>-L.</code>用于指定动态链接库查找路径包含当前目录。<br>编译完成之后运行会报错，动态链接库不存在，需要指定动态链接库运行时查找路径：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> LD_LIBRARY_PATH=.</span><br></pre></td></tr></table></figure>

<p>或者将需要的路径加入到<code>/etc/ld.so.conf</code>后，运行<code>sudo ldconfig</code>来更新缓存。</p>
<p>关于Linux下动态链接库编译、链接和运行时加载的问题可以参考这里：<a href="http://notes.maxwi.com/2017/04/13/linux-dynamic-lib-ldconfig/">http://notes.maxwi.com/2017/04/13/linux-dynamic-lib-ldconfig/</a></p>
]]></content>
      <categories>
        <category>Dev</category>
      </categories>
      <tags>
        <tag>Dev</tag>
      </tags>
  </entry>
  <entry>
    <title>Google Test(gtest)使用</title>
    <url>/2017/11/29/gtest/</url>
    <content><![CDATA[<h2 id="GTest简介"><a href="#GTest简介" class="headerlink" title="GTest简介"></a>GTest简介</h2><p>GTest是Google官方团队开发的开源的C++单元测试框架，地址为：<a href="https://github.com/google/googletest">https://github.com/google/googletest</a>。该地址下同时有一个名为googlemock的项目，Google Mock可以理解为Google Test的辅助测试框架，Google Mock可以用于实现一个模拟类(mock类)，可以用于完成需要接口交互但相应的类又没有实现的测试。本文不涉及Mock，以后有空了再追加Google Mock的使用。<br>使用Google Test可以实现：<br>1、测试应该是独立并且可以重复的。<br>2、测试应该组织良好，能够清晰的反应出测试代码的结构。<br>3、测试应该是可移植和可利用的。<br>4、当测试失败时，Google Test将会提供尽可能多的测试信息，并继续后面的测试而不是结束测试。<br>5、Google Test会跟踪所有用户定义的新测试，而不需要用户一一再去调用它们。从而将测试人员从繁杂的测试用例调用中解放出来，将更多的精力关注中测试本身上。<br>6、测试实现起来很快，因为Google Test框架能够在测试用例之间共用资源，并且它们之前还不会相互依赖。</p>
<span id="more"></span>

<h2 id="VS下的GTest环境配置"><a href="#VS下的GTest环境配置" class="headerlink" title="VS下的GTest环境配置"></a>VS下的GTest环境配置</h2><p>本文测试的环境为VS IDE，linux下使用cmake生成所需要的内容，然后直接引用即可，主要是学习如何使用这个强大的工具。<br>首先将Google Test源码使用你喜欢的方式整到本地（以下命令是git bash中操作，如果是cmd，修改一下mkdir为md）：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/google/googletest.git</span><br><span class="line">$ <span class="built_in">cd</span> googletest</span><br><span class="line">$ <span class="built_in">mkdir</span> mybuild</span><br><span class="line">$ <span class="built_in">cd</span> mybuild</span><br><span class="line">$ cmake –G “Visual Studio 12 2013” ..</span><br></pre></td></tr></table></figure>

<p><code>-G</code>后面指定你的VS版本号（注意在git bash下有可能<code>-G</code>参数无效，需要在cmd执行，或者直接使用cmake-gui操作），可能通过查看cmake的帮助找到更多版本，如果需要同时生成示例代码的VS工程，添加参数-Dgtest_build_samples=ON<br>运行cmake命令之后会在mybuild目录下生成gtest和gmock的项目工程文件，通过vs打开名为<code>googletest-distribution.sln</code>的解决方案，直接生成即可编译完成gtest和gmock，我们这里只使用gtest，所以只关注gtest即可。在路径<code>“mybuild\googlemock\gtest\Debug”</code>下会有文件“gtest_maind.lib”和“gtestd.lib”两个静态库，用这两个文件即可在自己的测试项目中调用gtest了。<br>为了便于后面的VS或者其他编译器调用头文件和库，可以添加环境变量GTEST_DIR值为<code>/path/to/googletest</code>。值即为你的googletest代码根目录<br>创建项目属性表<br>为了便于以后新建项目可以复用项目属性表，简化新建测试项目的过程，我们可以首先生成gtest的项目属性表，以后直接引用即可。如果觉得下面的创建过程太复杂，可以直接跳过，复制下面项目属性表的内容，本地新建一个文本文件，命名为Gtest_Debug.props。注意其中的路径。<br>先随便建一个项目，然后在属性管理器中右键相应的配置属性，选择添加新项目属性表，任意命名，例如我的GTest_Debug。双击该属性表后在C/C++的附加包含目录添加<code>“$(GTEST_DIR)\include;$(GTEST_DIR)”</code>，在链接器的常规中为附加库目录添加“$(GTEST_DIR)\mybuild\googlemock\gtest\Debug;”，输入中的附加依赖项添加“gtestd.lib;gtest_maind.lib;”。然后保存该属性表后会在相应项目文件夹中生成名为“GTest_Debug.props”的文件，将它保存在一个好找的位置，以后再创建gtest项目直接在刚才的属性管理器中右键添加现有属性表选择它就可以了。<br>下面是我的Gtest_Debug.props文件内容：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Project</span> <span class="attr">ToolsVersion</span>=<span class="string">&quot;4.0&quot;</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://schemas.microsoft.com/developer/msbuild/2003&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ImportGroup</span> <span class="attr">Label</span>=<span class="string">&quot;PropertySheets&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">PropertyGroup</span> <span class="attr">Label</span>=<span class="string">&quot;UserMacros&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">PropertyGroup</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ItemDefinitionGroup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ClCompile</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">AdditionalIncludeDirectories</span>&gt;</span>$(GTEST_DIR)\include;$(GTEST_DIR)<span class="tag">&lt;/<span class="name">AdditionalIncludeDirectories</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ClCompile</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Link</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">AdditionalDependencies</span>&gt;</span>gtestd.lib;gtest_maind.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)<span class="tag">&lt;/<span class="name">AdditionalDependencies</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">AdditionalLibraryDirectories</span>&gt;</span>$(GTEST_DIR)\mybuild\googlemock\gtest\Debug;<span class="tag">&lt;/<span class="name">AdditionalLibraryDirectories</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ItemDefinitionGroup</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ItemGroup</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Project</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="Gtest-基础应用"><a href="#Gtest-基础应用" class="headerlink" title="Gtest-基础应用"></a>Gtest-基础应用</h2><p>举例一个例子说明gtest的用法，当然强烈建议看看官方的sample。</p>
<h3 id="创建自己的项目"><a href="#创建自己的项目" class="headerlink" title="创建自己的项目"></a>创建自己的项目</h3><p>首先创建一个简单的dll项目，该项目将包含一个名为IsLessStr的函数，检查字符串是否为小字符串，这里假定长度小于等于4的为小字符串。<br>IsLessStr.h文件内容如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> IS_LESS_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IS_LESS_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsLessStr</span><span class="params">(<span class="type">const</span> std::string &amp;str)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>IsLessStr.cpp文件内容如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;IsLessStr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsLessStr</span><span class="params">(<span class="type">const</span> std::string &amp;str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (str.<span class="built_in">length</span>() &gt; <span class="number">4</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建dll导出文件IsLessStr.def：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">LIBRARY <span class="string">&quot;IsLessStr&quot;</span></span><br><span class="line"></span><br><span class="line">EXPORTS</span><br><span class="line">    IsLessStr</span><br></pre></td></tr></table></figure>

<p>现在我们的这个项目将可以编译生成相应的lib和dll文件了，下面我们使用gtest进行相应的单元测试。</p>
<h3 id="创建gtest测试项目"><a href="#创建gtest测试项目" class="headerlink" title="创建gtest测试项目"></a>创建gtest测试项目</h3><p>在上面项目的解决方案中创建测试项目，可以命名为IsLessStrTest，在属性管理器中右键这个测试项目的属性选择添加现有属性表，选中我们刚才的那个属性表即可完全gtest的配置。然后再在属性管理器中双击IsLessStrTest会引出它的整体属性页，通用属性—引用中添加新引用，选择我们刚才的项目IsLessStr，以使该项目链接时可以找到IsLessStr的lib文件和dll文件(dll非必须)。在它的配置属性中找到C/C++将IsLessStr的头文件所在路径添加到它的附加包含目录。到此gtest测试项目配置完成。<br>基本测试使用TEST()，用法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">TEST</span>(test_case_name, test_name) &#123;</span><br><span class="line"> ... test body ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是测试的实际代码Test.cpp中的内容：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;gtest/gtest.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;IsLessStr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">GTEST_API_ <span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Study GTEST&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    testing::<span class="built_in">InitGoogleTest</span>(&amp;argc, argv);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">RUN_ALL_TESTS</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">TEST</span>(IsLessStr_Test, TestShortLen)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> std::string str = <span class="string">&quot;H&quot;</span>;</span><br><span class="line">    <span class="built_in">EXPECT_TRUE</span>(<span class="built_in">IsLessStr</span>(str)) &lt;&lt; <span class="string">&quot;Test H is the less str&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">TEST</span>(IsLessStr_Test, TestEmptyStr)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> std::string str;</span><br><span class="line">    <span class="built_in">EXPECT_TRUE</span>(<span class="built_in">IsLessStr</span>(str));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">TEST</span>(IsLessStr_Test, TestLongLen)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> std::string str = <span class="string">&quot;Hello World! I Love China&quot;</span>;</span><br><span class="line">    <span class="built_in">EXPECT_TRUE</span>(<span class="built_in">IsLessStr</span>(str)) &lt;&lt; <span class="string">&quot;AHA, This is an mistake&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意上面的main函数实现，也就是说可以将测试代码放在单独的文件中，而不用再去关注main函数的实现。<br>编译运行，输出如下（cmd窗口中会有彩色的标记）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Study GTEST</span><br><span class="line">[==========] Running 3 tests from 1 test case.</span><br><span class="line">[----------] Global test environment set-up.</span><br><span class="line">[----------] 3 tests from IsLessStr_Test</span><br><span class="line">[ RUN      ] IsLessStr_Test.TestShortLen</span><br><span class="line">d:\proj\gteststudy\gteststudy\getstrtest\test.cpp(16): error: Value of: IsLessStr(str)</span><br><span class="line">  Actual: true</span><br><span class="line">Expected: false</span><br><span class="line">Test H is the less str</span><br><span class="line">[  FAILED  ] IsLessStr_Test.TestShortLen (1 ms)</span><br><span class="line">[ RUN      ] IsLessStr_Test.TestEmptyStr</span><br><span class="line">[       OK ] IsLessStr_Test.TestEmptyStr (0 ms)</span><br><span class="line">[ RUN      ] IsLessStr_Test.TestLongLen</span><br><span class="line">d:\proj\gteststudy\gteststudy\getstrtest\test.cpp(28): error: Value of: IsLessStr(str)</span><br><span class="line">  Actual: false</span><br><span class="line">Expected: true</span><br><span class="line">AHA, This is an mistake</span><br><span class="line">[  FAILED  ] IsLessStr_Test.TestLongLen (1 ms)</span><br><span class="line">[----------] 3 tests from IsLessStr_Test (2 ms total)</span><br><span class="line"></span><br><span class="line">[----------] Global test environment tear-down</span><br><span class="line">[==========] 3 tests from 1 test case ran. (3 ms total)</span><br><span class="line">[  PASSED  ] 1 test.</span><br><span class="line">[  FAILED  ] 2 tests, listed below:</span><br><span class="line">[  FAILED  ] IsLessStr_Test.TestShortLen</span><br><span class="line">[  FAILED  ] IsLessStr_Test.TestLongLen</span><br><span class="line"></span><br><span class="line"> 2 FAILED TESTS</span><br></pre></td></tr></table></figure>

<p>为了测试输出信息更丰富，我们上面那最后一个测试用例其实故意写错了</p>
<h2 id="断言-测试宏"><a href="#断言-测试宏" class="headerlink" title="断言/测试宏"></a>断言/测试宏</h2><p>Google Test采用一系列的断言（assertion）来进行代码测试，这些宏有点类似于函数调用。<br>当断言失败时Google Test将会打印出assertion时的源文件和出错行的位置，以及附加的失败信息，<br>用户可以直接通过<code>“&lt;&lt;”</code>在这些断言宏后面跟上自己希望在断言命中时的输出信息。<br>测试宏可以分为两大类：<code>ASSERT_*</code>和<code>EXPECT_*</code>，这些成对的断言功能相同，但效果不同。其中<code>ASSERT_*</code>将会在失败时产生致命错误并中止当前调用它的函数执行。<code>EXPECT_*</code>版本的会生成非致命错误，不会中止当前函数，而是继续执行当前函数。通常情况应该首选使用<code>EXPECT_*</code>，因为<code>ASSERT_*</code>在报告完错误后不会进行清理工作，有可能导致内容泄露问题。</p>
<p>断言后面可以直接跟用户想要输出的信息：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ASSERT_EQ</span>(x.<span class="built_in">size</span>(), y.<span class="built_in">size</span>()) &lt;&lt; <span class="string">&quot;Vectors x and y are of unequal length&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; x.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">  <span class="built_in">EXPECT_EQ</span>(x[i], y[i]) &lt;&lt; <span class="string">&quot;Vectors x and y differ at index &quot;</span> &lt;&lt; i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>常用的一些宏如下：</p>
<h3 id="基础断言"><a href="#基础断言" class="headerlink" title="基础断言"></a>基础断言</h3><table>
<thead>
<tr>
<th>Fatal assertion</th>
<th>Nonfatal assertion</th>
<th>Verifies</th>
</tr>
</thead>
<tbody><tr>
<td>ASSERT_TRUE(condition);</td>
<td>EXPECT_TRUE(condition);</td>
<td>condition is true</td>
</tr>
<tr>
<td>ASSERT_FALSE(condition);</td>
<td>EXPECT_FALSE(condition);</td>
<td>condition is false</td>
</tr>
</tbody></table>
<h3 id="二值比较"><a href="#二值比较" class="headerlink" title="二值比较"></a>二值比较</h3><table>
<thead>
<tr>
<th>Fatal assertion</th>
<th>Nonfatal assertion</th>
<th>Verifies</th>
</tr>
</thead>
<tbody><tr>
<td>ASSERT_EQ(val1,val2);</td>
<td>EXPECT_EQ(val1,val2);</td>
<td>val1 == val2</td>
</tr>
<tr>
<td>ASSERT_NE(val1,val2);</td>
<td>EXPECT_NE(val1,val2);</td>
<td>val1 != val2</td>
</tr>
<tr>
<td>ASSERT_LT(val1,val2);</td>
<td>EXPECT_LT(val1,val2);</td>
<td>val1 &lt; val2</td>
</tr>
<tr>
<td>ASSERT_LE(val1,val2);</td>
<td>EXPECT_LE(val1,val2);</td>
<td>val1 &lt;= val2</td>
</tr>
<tr>
<td>ASSERT_GT(val1,val2);</td>
<td>EXPECT_GT(val1,val2);</td>
<td>val1 &gt; val2</td>
</tr>
<tr>
<td>ASSERT_GE(val1,val2);</td>
<td>EXPECT_GE(val1,val2);</td>
<td>val1 &gt;= val2</td>
</tr>
</tbody></table>
<h3 id="字符串比较"><a href="#字符串比较" class="headerlink" title="字符串比较"></a>字符串比较</h3><table>
<thead>
<tr>
<th>Fatal assertion</th>
<th>Nonfatal assertion</th>
<th>Verifies</th>
</tr>
</thead>
<tbody><tr>
<td>ASSERT_STREQ(str1,str2);</td>
<td>EXPECT_STREQ(str1,str2);</td>
<td>the two C strings have the same content</td>
</tr>
<tr>
<td>ASSERT_STRNE(str1,str2);</td>
<td>EXPECT_STRNE(str1,str2);</td>
<td>the two C strings have different content</td>
</tr>
<tr>
<td>ASSERT_STRCASEEQ(str1,str2);</td>
<td>EXPECT_STRCASEEQ(str1,str2);</td>
<td>the two C strings have the same content, ignoring case</td>
</tr>
<tr>
<td>ASSERT_STRCASENE(str1,str2);</td>
<td>EXPECT_STRCASENE(str1,str2);</td>
<td>the two C strings have different content, ignoring case</td>
</tr>
</tbody></table>
<p><code>Google Test</code>还有其他很多测试宏，例如单纯的测试成功与失败、测试指定代码块是否抛出指定异常等，更多内容参见：<br><a href="https://github.com/google/googletest/blob/master/googletest/docs/AdvancedGuide.md">https://github.com/google/googletest/blob/master/googletest/docs/AdvancedGuide.md</a></p>
<h2 id="Gtest-Test-Fixtures（多个Test共享一份代码）"><a href="#Gtest-Test-Fixtures（多个Test共享一份代码）" class="headerlink" title="Gtest-Test Fixtures（多个Test共享一份代码）"></a>Gtest-Test Fixtures（多个Test共享一份代码）</h2><p>通常我们测试一些小的代码时直接使用上面的TEST进行相应的宏调用测试即可，但很多时候我们的项目会需要对一些基础数据进行初始化，然后后面运行的代码都是基于这些初始化之后的内容进行。<br>如果我们继续使用TEST进行测试，为了保证代码的可重复性，我们就必须对每一个测试编写相同的基础操作代码，违反了编程中的代码利用性。<br>此时<code>TEST_F</code>就出现了，<code>Test Fixtures</code>通过对<code>::testing::Test</code>进行继承后，将该类做为测试的公共类，在其中进行公共代码的编写。Google Test会在每一个新的TEST_F调用之前删除前一个使用该Test Fixtures的公共类对象，这样就保证了所有测试用例的独立性。可以理解为Test Fixture的目的是为了即要少写代码，又要保证每一个测试用例数据环境的独立性。<br>Test Fixtures的用法：<br>首先需要创建一个fixture：</p>
<ol>
<li>通过继承自::testing::Test创建一个类，为了使子类可以访问我们fixture的成员，内容成员应该以protected:或public:开头。</li>
<li>在类内部声明测试中需要使用的使用成员变量或成员函数。</li>
<li>类内部会有两个默认的虚函数：默认构造函数SetUp()和默认析构函数TearDown()。SetUp在应该放置每个测试中都需要提前进行的公共操作，如初始化。而TearDown中应该放置每个测试在测试之后需要进行操作，如释放资源。</li>
</ol>
<p>创建完fixture之后，通过<code>TEST_F()</code>来使用它，其中_F来自于fixture，用法如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">TEST_F</span>(Test_Fixture_Name, test_name) &#123;</span><br><span class="line"> ... test body ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与TEST类似，只是test case名必须为我们定义的Test Fixture的类名，这样我们才能在test body中直接调用类对象和类成员函数（实际上是通过宏实现的）。<br>对于每一个TEST_F()，Google Test将会：</p>
<ol>
<li>在运行时创建一个全新的test fixture。</li>
<li>通过SetUp()立即对其进行初始化</li>
<li>运行测试代码。</li>
<li>调用TearDown()清理资源</li>
<li>删除该test fixture。也就是说对于同一个test case中的每一个测试都有一个不同的test fixture对象，并且google test总是会在创建下一下test fixture之前删除之前的。以避免改变某一个测试时对其他测试环境产生影响。</li>
</ol>
<p>TEST_F示例：<br>测试一下FIFO的例子，其中头文件sample3-in1.h中包含Queue的如下接口：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt; <span class="comment">// E is the element type.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Queue</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Queue</span>();</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Enqueue</span><span class="params">(<span class="type">const</span> E&amp; element)</span></span>;</span><br><span class="line">  <span class="function">E* <span class="title">Dequeue</span><span class="params">()</span></span>; <span class="comment">// Returns NULL if the queue is empty.</span></span><br><span class="line">  <span class="function"><span class="type">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>测试文件sample3_unittest.cc文件内容如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sample3-inl.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;gtest/gtest.h&quot;</span></span></span><br><span class="line"><span class="keyword">namespace</span> &#123;</span><br><span class="line"><span class="comment">// 首先通过继承testing::Test类创建一个测试Test Fixture</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">QueueTestSmpl3</span> : <span class="keyword">public</span> testing::Test &#123;</span><br><span class="line"> <span class="keyword">protected</span>: <span class="comment">// 为了子类可以访问其成员，将类成员定义为protected</span></span><br><span class="line">  <span class="comment">// SetUp()将会在每个test中被调用，可以在其中定义一些需要初始化的变量</span></span><br><span class="line">  <span class="comment">// 如果不需要，可以直接跳过</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">SetUp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    q1_.<span class="built_in">Enqueue</span>(<span class="number">1</span>);</span><br><span class="line">    q2_.<span class="built_in">Enqueue</span>(<span class="number">2</span>);</span><br><span class="line">    q2_.<span class="built_in">Enqueue</span>(<span class="number">3</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// TearDown()将会在每个test结束时调用，可以用于清理工作</span></span><br><span class="line">  <span class="comment">// 如果不需要，可以直接省略</span></span><br><span class="line">  <span class="comment">// virtual void TearDown() &#123;</span></span><br><span class="line">  <span class="comment">// &#125;</span></span><br><span class="line">  <span class="comment">// 有些测试中会用到的辅助函数</span></span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">Double</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>*n;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 用于测试Queue::Map()的辅助函数</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">MapTester</span><span class="params">(<span class="type">const</span> Queue&lt;<span class="type">int</span>&gt; * q)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Map函数接受一个函数做为参数，对queue中每一个元素调用该函数之后</span></span><br><span class="line">    <span class="comment">// 返回一个新的queue</span></span><br><span class="line">    <span class="type">const</span> Queue&lt;<span class="type">int</span>&gt; * <span class="type">const</span> new_q = q-&gt;<span class="built_in">Map</span>(Double);</span><br><span class="line">    <span class="comment">// 通过ASSERT_EQ验证新的queue是否具有相同的元素个数</span></span><br><span class="line">    <span class="built_in">ASSERT_EQ</span>(q-&gt;<span class="built_in">Size</span>(), new_q-&gt;<span class="built_in">Size</span>());</span><br><span class="line">    <span class="comment">// 调用EXPECT_EQ验证新queue中的每一个元素是否正确</span></span><br><span class="line">    <span class="keyword">for</span> ( <span class="type">const</span> QueueNode&lt;<span class="type">int</span>&gt; * n1 = q-&gt;<span class="built_in">Head</span>(), * n2 = new_q-&gt;<span class="built_in">Head</span>();</span><br><span class="line">          n1 != <span class="literal">NULL</span>; n1 = n1-&gt;<span class="built_in">next</span>(), n2 = n2-&gt;<span class="built_in">next</span>() ) &#123;</span><br><span class="line">      <span class="built_in">EXPECT_EQ</span>(<span class="number">2</span> * n1-&gt;<span class="built_in">element</span>(), n2-&gt;<span class="built_in">element</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> new_q;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 声明需要用到的成员变量</span></span><br><span class="line">  Queue&lt;<span class="type">int</span>&gt; q0_;</span><br><span class="line">  Queue&lt;<span class="type">int</span>&gt; q1_;</span><br><span class="line">  Queue&lt;<span class="type">int</span>&gt; q2_;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 通过TEST_F调用test fixture类</span></span><br><span class="line"><span class="comment">// 测试默认构造函数</span></span><br><span class="line"><span class="built_in">TEST_F</span>(QueueTestSmpl3, DefaultConstructor) &#123;</span><br><span class="line">  <span class="comment">// 注意这里看上去像是直接通过成员变量名调用了类成员变量</span></span><br><span class="line">  <span class="built_in">EXPECT_EQ</span>(<span class="number">0u</span>, q0_.<span class="built_in">Size</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 测试Dequeue</span></span><br><span class="line"><span class="built_in">TEST_F</span>(QueueTestSmpl3, Dequeue) &#123;</span><br><span class="line">  <span class="type">int</span> * n = q0_.<span class="built_in">Dequeue</span>();</span><br><span class="line">  <span class="built_in">EXPECT_TRUE</span>(n == <span class="literal">NULL</span>);</span><br><span class="line">  n = q1_.<span class="built_in">Dequeue</span>();</span><br><span class="line">  <span class="built_in">ASSERT_TRUE</span>(n != <span class="literal">NULL</span>);</span><br><span class="line">  <span class="built_in">EXPECT_EQ</span>(<span class="number">1</span>, *n);</span><br><span class="line">  <span class="built_in">EXPECT_EQ</span>(<span class="number">0u</span>, q1_.<span class="built_in">Size</span>());</span><br><span class="line">  <span class="keyword">delete</span> n;</span><br><span class="line">  n = q2_.<span class="built_in">Dequeue</span>();</span><br><span class="line">  <span class="built_in">ASSERT_TRUE</span>(n != <span class="literal">NULL</span>);</span><br><span class="line">  <span class="built_in">EXPECT_EQ</span>(<span class="number">2</span>, *n);</span><br><span class="line">  <span class="built_in">EXPECT_EQ</span>(<span class="number">1u</span>, q2_.<span class="built_in">Size</span>());</span><br><span class="line">  <span class="keyword">delete</span> n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 测试Map函数</span></span><br><span class="line"><span class="built_in">TEST_F</span>(QueueTestSmpl3, Map) &#123;</span><br><span class="line">  <span class="built_in">MapTester</span>(&amp;q0_);</span><br><span class="line">  <span class="built_in">MapTester</span>(&amp;q1_);</span><br><span class="line">  <span class="built_in">MapTester</span>(&amp;q2_);</span><br><span class="line">&#125;</span><br><span class="line">&#125;  <span class="comment">// namespace</span></span><br></pre></td></tr></table></figure>

<p>参考：<a href="https://github.com/google/googletest/blob/master/googletest/docs/Samples.md">https://github.com/google/googletest/blob/master/googletest/docs/Samples.md</a><br>Test Fixture中的test case如何共享数据资源<br>Test Fixture可以很好的做到复用一些公共代码，而有些时候我们需要同一个Test Fixture中的Test case可以共用一些基本的初始化数据，而不仅仅是公共的代码。Google Test也考虑了这个需求，通过在Test Fixture类中定义两个静态函数来解决：static void SetUpTestCase()将会在第一个测试用例调用时执行一次； static void TearDownTestCase()将会在最后一个测试用例被删除时执行一次。与SetUp()和TearDown()非常类似，很明显，你应该已经会用了。需要注意的时Google Test并不会保证测试用例按顺序执行，所以不要依赖与测试用例的顺序。下面是举例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FooTest</span> : <span class="keyword">public</span> ::testing::Test &#123;</span><br><span class="line"> <span class="keyword">protected</span>:</span><br><span class="line">  <span class="comment">// 将在第一个测试用例运行时调用</span></span><br><span class="line">  <span class="comment">// 不需要的话可以直接忽略</span></span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">SetUpTestCase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    shared_resource_ = <span class="keyword">new</span> ...;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 将在最后一个测试用例删除时调用</span></span><br><span class="line">  <span class="comment">// 不需要的话可以直接忽略</span></span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">TearDownTestCase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">delete</span> shared_resource_;</span><br><span class="line">    shared_resource_ = <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 每一个测试用例都需要执行的内容</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">SetUp</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">TearDown</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">  <span class="comment">// 一些由所有测试用例共用且消耗比较大的资源</span></span><br><span class="line">  <span class="type">static</span> T* shared_resource_;</span><br><span class="line">&#125;;</span><br><span class="line">T* FooTest::shared_resource_ = <span class="literal">NULL</span>;</span><br><span class="line"><span class="built_in">TEST_F</span>(FooTest, Test1) &#123;</span><br><span class="line">  ... 可以在这里引用你的shared_resource ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">TEST_F</span>(FooTest, Test2) &#123;</span><br><span class="line">  ... 可以在这里引用你的shared_resource ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Gtest-测试调用-main函数"><a href="#Gtest-测试调用-main函数" class="headerlink" title="Gtest-测试调用(main函数)"></a>Gtest-测试调用(main函数)</h2><p>Google Test将会自动注册TEST和<code>TEST_F</code>的调用，当定义了测试用例之后，可以通过调用<code>RUN_ALL_TESTS()</code>来运行测试，该函数当所有测试成功时返回0，否则返回1。<br>主函数通常如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;gtest/gtest.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 一些FLAG设置，例如xml的输出</span></span><br><span class="line">  ::testing::<span class="built_in">InitGoogleTest</span>(&amp;argc, argv);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">RUN_ALL_TESTS</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可见主函数确实很简洁，所以如果不想写这段代码，如果你还记得的话，之前与gtestd.lib同目录下有一个gtest_maind.lib，可以直接用它来链接你的代码。<br>InitGoogleTest()函数将会解析Google Test的命令行参数，用于影响后续的测试行为<br>关于其命令行参数，可以参见<br><a href="https://github.com/google/googletest/blob/master/googletest/docs/AdvancedGuide.md">https://github.com/google/googletest/blob/master/googletest/docs/AdvancedGuide.md</a></p>
<h2 id="Gtest-输出XML报告"><a href="#Gtest-输出XML报告" class="headerlink" title="Gtest-输出XML报告"></a>Gtest-输出XML报告</h2><p>Google Test有三种方式指定是否输出xml报告，不管哪一种方式，都是通过<code>”xml:_path_to_output_file_”</code>来设定xml文件路径，如果只有”xml”则会在项目目录下输出名为test_tetail.xml的报告。<br>三种配置方式如下：</p>
<ol>
<li>通过配置环境变量“GTEST_OUTPUT”指定xml输出路径。例如Windows下，添加环境变量：变量名为GTEST_OUTPUT，值为你需要的路径，如：xml，或者xml:D:/test.xml</li>
<li>通过命令行参数–gtest_output指定。例如： gtestTest.exe –gtest_output=xml:outputTest.xml</li>
<li>通过在程序中设置output的FLAG值指定。</li>
</ol>
<p>对于第3种情况，可以通过在调用testing::InitGoogleTest之前调用testing::GTEST_FLAG来指定，如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">GTEST_API_ <span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Study GTEST&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    testing::<span class="built_in">GTEST_FLAG</span>(output) = <span class="string">&quot;xml:d:/1.xml&quot;</span>;  <span class="comment">// 指定报告输出路径</span></span><br><span class="line">    testing::<span class="built_in">InitGoogleTest</span>(&amp;argc, argv);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">RUN_ALL_TESTS</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当三种方式同时使用时，优先级顺序为：命令行参数 &gt; 代码中指定FLAG &gt; 系统环境变量</p>
<h2 id="Gtest-filter-筛选需要运行的测试"><a href="#Gtest-filter-筛选需要运行的测试" class="headerlink" title="Gtest filter-筛选需要运行的测试"></a>Gtest filter-筛选需要运行的测试</h2><p>类似于上面输出报告<code>xml</code>文件，也有三种相似的方式来指定要运行哪些测试：</p>
<ul>
<li>环境变量<code>GTEST_FILTER</code></li>
<li>命令行参数<code>--gtest_filter</code></li>
<li>设置相应标示位<code>testing::GTEST_FLAG(filter)</code></li>
</ul>
<p><code>filter</code>支持通配符<code>*</code>（0个名多个字符）和<code>?</code>（一个字符），例如以命令行的形式让测试用例只运行以<code>FooTest_CreateHandle</code>开头的用例：<code>./foo_test --gtest_filter=FooTest_CreateHandle*</code>，等价于在其代码中，<code>InitGoogleTest()</code>之前设置标示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">testing::<span class="built_in">GTEST_FLAG</span>(filter) = <span class="string">&quot;FooTest_CreateHandle*&quot;</span></span><br></pre></td></tr></table></figure>

<p>当然该标志位也可能通过命令行参数来传递<br>当有很多测试用例时，该功能很好用。</p>
<h2 id="Gtest-portable-2个文件包含所有gtest代码"><a href="#Gtest-portable-2个文件包含所有gtest代码" class="headerlink" title="Gtest(portable)-2个文件包含所有gtest代码"></a>Gtest(portable)-2个文件包含所有gtest代码</h2><p>Google是一个很重视用户体验和用户需求的公司额，为了便于用户将gtest内嵌到自己的项目中，或者为了便于携带，google提供了一个python脚本可以将Google Test的所有代码打包到2个文件中（gtest.h和gtest-all.cc）。脚本位置（1.8.0版本）：<code>googletest\scripts\ fuse_gtest_files.py</code>。<br>用法：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">python fuse_gtest_files.py OUTPUT_DIR</span><br></pre></td></tr></table></figure>

<p>编译方法可以查看相应的<code>makefile</code>（<a href="https://github.com/google/googletest/blob/master/googletest/scripts/test/Makefile">https://github.com/google/googletest/blob/master/googletest/scripts/test/Makefile</a>），其实可以直接使用原项目编译成库然后使用这个头文件，当然这个cc文件也可以直接编译之后与你的测试进行链接，就不再需要头文件了。<br>更多内容可参考链接：<br><a href="https://github.com/google/googletest/blob/master/googletest/docs/AdvancedGuide.md#fusing-google-test-source-files">https://github.com/google/googletest/blob/master/googletest/docs/AdvancedGuide.md#fusing-google-test-source-files</a></p>
<h2 id="Gtest-其他高级功能"><a href="#Gtest-其他高级功能" class="headerlink" title="Gtest-其他高级功能"></a>Gtest-其他高级功能</h2><ol>
<li>更多的Assertion：SUCCEED()、FAIL()、ADD_FAILURE()等。</li>
<li>死亡测试（Death Test），是指对程序中那些断言后直接中断程序执行的代码进行测试，例如C标准库函数的assert函数，为了保证程序正常运行，我们通常会在程序中插入这些代码，以便在出错时快速定位错误，死亡测试的目的就是让程序运行在会导致这个assertion触发的情况下，以检查其是否可以正常工作。死亡测试的宏将与正则表达式一起使用。</li>
<li>通过继承::testing::Environment的子类设置全局的SetUp和TearDown</li>
<li>当有多个测试函数调用同一个子测试函数时，在子函数中使用Assertion有可能导致该子函数报错时并不知道哪个函数的调用导致的，可以通过SCOPED_TRACE宏来更好的跟踪错误，还有一些其他有关子测试函数的高级用法。</li>
<li>支持多机环境下的分布式测试，即使用多台机器进行分布式测试，以加快测试速度。</li>
<li>支持与其他测试框架一起使用。</li>
<li>支持控制输出报告，如标准输出的颜色、xml格式及内容等。</li>
<li>支持对测试用例进行混洗（shuffling），即打乱测试顺序。用–gtest_shuffle或GTEST_SHUFFLE环境变量设置。</li>
<li>通过–gtest_repeat指定测试的次数。</li>
<li>可以选择需要进行的测试，或者忽略的测试。</li>
<li>可以通过处理测试事件来扩展Google Test，例如监听测试的情况。</li>
</ol>
<p>这些高级功能的应用请参见：<br><a href="https://github.com/google/googletest/blob/master/googletest/docs/AdvancedGuide.md">https://github.com/google/googletest/blob/master/googletest/docs/AdvancedGuide.md</a></p>
<p>参考：<a href="https://github.com/google/googletest">https://github.com/google/googletest</a></p>
]]></content>
      <categories>
        <category>Dev</category>
      </categories>
      <tags>
        <tag>CPP</tag>
        <tag>Gtest</tag>
      </tags>
  </entry>
  <entry>
    <title>tmux简洁教程</title>
    <url>/2017/11/10/tmux/</url>
    <content><![CDATA[<p>tmux主要的功能有两点：</p>
<ul>
<li>终端利用，可以在一个terminal开启多个shell的session，这样就不需要vim一个terminal，命令又要需要一个，其他服务还要再开一个了。</li>
<li>断线保证任务在后台继续执行，以及当你上线后保证原来打开的多个窗口与断线之前完全一样。以后就不用再使用screen了</li>
</ul>
<span id="more"></span>

<p>两个功能都非常棒，值得花点时间学习，分分钟就能掌握基本应用。<br><code>tmux</code>中有三个最基本的概念： <strong>会话（session）、窗口（window）、窗格（Pane）</strong><br>当开启tmux后，它首先会创建一个会话，在会话中会首先创建一个窗口，窗口中会创建一个面板，一个面板就可以当成一个我们可以使用的shell窗口。<br>下面会混用窗格和面板，都指pane</p>
<p><code>tmux</code>使用<code>C/S</code>模型，主要包含以下模块：</p>
<ul>
<li>server服务器。输入tmux命令时就开启了一个服务器。</li>
<li>session会话。一个服务器可以包含多个会话</li>
<li>window窗口。一个会话可以包含多个窗口。</li>
<li>pane面板。一个窗口可以包含多个面板。</li>
</ul>
<h2 id="基本应用"><a href="#基本应用" class="headerlink" title="基本应用"></a>基本应用</h2><p><strong>启动tmux</strong><br>安装后在命令行输入<code>tmux</code>就启动了，看到只有一个窗口，窗口下方会有基本状态信息。<br><code>tmux</code>的使用可以完全靠快捷键，快捷键以前缀快捷键+快捷键构成，默认的前缀（prefix）快捷键是<code>ctrl-b</code>，用法是按下<code>Ctrl-b</code>，放开后再按下相应的快键即可，例如查看<code>tmux</code>会话的快捷键是s，可以按下<code>ctrl-b</code>，放开再按<code>s</code>，即可查看当前的所有会话。<br>知道怎么按快捷键也就会有tmux了，下面试一下纵向分隔窗口的快捷键：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">prefix %</span><br></pre></td></tr></table></figure>
<p>横向分隔窗口：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">prefix &quot;</span><br></pre></td></tr></table></figure>
<p>窗口间切换<code>prefix &lt;相应方向键&gt;</code><br>这样你就可以在一个terminal中即开多个vim，又进行其他操作了。<br>希望这些切换可以像vim的快捷键一样？看后面的配置</p>
<p><strong>退出或关闭tmux</strong><br>当要退出tmux时可以使用<code>exit</code>，这样会关闭当前的tmux面板，当所有面板关闭时也就退出了窗口。<br>如果要让它在后台运行，你要先回到普通的terminal，使用快捷键<code>prefix &amp;</code>。<br>想再回来，比如断线重连时，可以使用<code>tmux attach</code>，或者直接<code>tmux a</code>，可以可看其常用命令获取更多内容。<br>要关闭整个tmux服务的话使用<code>tmux kill-server</code><br>查看版本：<code>tmux -V</code></p>
<p><strong>会话相关命令</strong><br><code>tmux new -s [session_name]</code>  创新新会话<br><code>tmux new -s [session_name] -d</code> 在后台建立会话<br><code>tmux ls</code> 列出会话<br><code>tmux attach -t [session_name]</code> 进入某个会话<br>或者在tmux中使用命令<code>prefix :new-session</code>新一个会话</p>
<h3 id="复制面板中的内容"><a href="#复制面板中的内容" class="headerlink" title="复制面板中的内容"></a>复制面板中的内容</h3><ul>
<li><code>prefix [</code> 进入复制模式</li>
<li>按 <code>space</code> 开始复制，移动光标选择复制区域</li>
<li>按 <code>Enter</code> 复制并退出复制模式。</li>
<li>将光标移动到指定位置，按 <code>prefix ]</code> 粘贴</li>
</ul>
<h2 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h2><p>注意窗格是指Pane，窗口是指window</p>
<ul>
<li><code>C-b ?</code> 显示快捷键帮助</li>
<li><code>C-b :</code> 进入命令模式</li>
<li><code>C-b C-z</code> 挂起会话，不影响其他命令的运行</li>
<li><code>C-b C-o</code> 调换窗格位置，类似与vim 里的C-w</li>
<li><code>C-b 空格键</code> 采用下一个内置布局</li>
<li><code>C-b !</code> 把当前窗格（pane）变为新窗口（window）</li>
<li><code>C-b &quot;</code> 横向分隔窗格</li>
<li><code>C-b %</code> 纵向分隔窗格</li>
<li><code>C-b q</code> 显示分隔窗格的编号</li>
<li><code>C-b o</code> 跳到下一个分隔窗格</li>
<li><code>C-b 上下键</code> 上一个及下一个分隔窗格</li>
<li><code>C-b C-方向键</code> 调整分隔窗格大小，注意C表示Ctrl键</li>
<li><code>C-b z</code> 最大化当前窗格，再一次则恢复</li>
<li><code>C-b c</code> 创建新窗口</li>
<li><code>C-b 0~9</code> 选择几号窗口</li>
<li><code>C-b n</code> 选择下一个窗口</li>
<li><code>C-b p</code> 选择前一个窗口</li>
<li><code>C-b l</code> 切换到前一个窗口，该快捷键通常会被重定义为符合vim下的空格切换</li>
<li><code>C-b w</code> 以菜单方式显示及选择窗口</li>
<li><code>C-b s</code> 以菜单方式显示和选择会话</li>
<li><code>C-b t</code> 显示时钟</li>
<li><code>C-b ;</code> 切换到最后一个使用的面板</li>
<li><code>C-b x</code> 关闭面板</li>
<li><code>C-b &amp;</code> 关闭窗口</li>
<li><code>C-b d</code> 退出tumx，并保存当前会话，这时，tmux仍在后台运行，可以通过tmux attach进入 到指定的会话</li>
</ul>
<p>tmux中很多需要移动光标的地方都支持vim的<code>i,j,k,h</code>，可以自行试试</p>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>为了让tmux更加好用，就像vim一样，我们需要进行一些个性化的配置。tmux的系统级配置文件在<code>/etc/tmux.conf</code>，用户级配置文件可以放在<code>~/.tmux.conf</code><br>下面给出一份我自己在使用的，主要是针对vim的使用习惯进行了一些键绑定，增加了2个插件，功能内容都有注释：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># rebind prefix key</span><br><span class="line">unbind C-b</span><br><span class="line">set -g prefix C-x</span><br><span class="line"></span><br><span class="line"># bind a reload key for tmux configure</span><br><span class="line">bind r source-file ~/.tmux.conf \; display &quot;Config reloaded..&quot;</span><br><span class="line"></span><br><span class="line"># Use vim keybindings in copy mode</span><br><span class="line">setw -g mode-keys vi</span><br><span class="line"></span><br><span class="line"># Select text like vim</span><br><span class="line">bind -t vi-copy &#x27;v&#x27; begin-selection</span><br><span class="line">bind -t vi-copy &#x27;y&#x27; copy-selection</span><br><span class="line">bind -t vi-copy &#x27;Space&#x27; halfpage-down</span><br><span class="line">bind -t vi-copy &#x27;Bspace&#x27; halfpage-up</span><br><span class="line"></span><br><span class="line"># Switch pane use vi key bind</span><br><span class="line">bind-key k select-pane -U # up</span><br><span class="line">bind-key j select-pane -D # down</span><br><span class="line">bind-key h select-pane -L # left</span><br><span class="line">bind-key l select-pane -R # right</span><br><span class="line"></span><br><span class="line"># Adjust pane by mouse</span><br><span class="line">set -g mouse on</span><br><span class="line"></span><br><span class="line"># plugin</span><br><span class="line"># Tmux Plugin Manager</span><br><span class="line"># git clone https://github.com/tmux-plugins/tpm ~/.tmux/plugins/tpm</span><br><span class="line">set -g @plugin &#x27;tmux-plugins/tpm&#x27;</span><br><span class="line"></span><br><span class="line"># basic tmux settings everyone can agree on</span><br><span class="line">set -g @plugin &#x27;tmux-plugins/tmux-sensible&#x27;</span><br><span class="line"></span><br><span class="line"># Persists tmux environment across system restarts.</span><br><span class="line">run-shell ~/.tmux/tmux-resurrect/resurrect.tmux</span><br><span class="line">set -g @plugin &#x27;tmux-plugins/tmux-resurrect&#x27;</span><br><span class="line"></span><br><span class="line"># Continuous saving of tmux environment. Automatic restore when tmux is started. Automatic tmux start when computer is turned on.</span><br><span class="line">set -g @plugin &#x27;tmux-plugins/tmux-continuum&#x27;</span><br><span class="line">set -g @continuum-save-interval &#x27;60&#x27;</span><br><span class="line"></span><br><span class="line"># Initialize TMUX plugin manager (keep this line at the very bottom of tmux.conf)</span><br><span class="line">run &#x27;~/.tmux/plugins/tpm/tpm&#x27;</span><br></pre></td></tr></table></figure>

<p>修改完配置文件之后可以在tmux中按快捷键<code>Ctrl-b :</code>进入命令模式，输入<code>source-file ~/.tmux.conf</code>，使其生效。经过上述配置文件之后，以后修改完配置文件直接使用<code>Ctrl-b r</code>就可以重新加载新配置文件了。<br>如果是在terminal中，使用命令<code>tmux source-file ~/.tmux.conf</code>使配置生效。</p>
<h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><p>这里主要推荐4个插件，确切来说是2组。<br><strong>tpm</strong><br>用于管理tmux插件，类似与vim下的vundle<br>地址：<a href="https://github.com/tmux-plugins/tpm">https://github.com/tmux-plugins/tpm</a></p>
<p><strong>tmux-sensible</strong><br>一些tmux的基本配置，适合几乎所有人，可以看一下它的配置内容<br>地址：<a href="https://github.com/tmux-plugins/tmux-sensible">https://github.com/tmux-plugins/tmux-sensible</a></p>
<p><strong>tmux-resurrect</strong><br>用户保存和恢复tmux的运行环境，非常好用，当你需要对当前你打开的tmux的会话、窗口、空格以及其位置保存时，直接按快捷键<code>prefix Ctrl-s</code>即可保存，需要恢复时是<code>prefix Ctrl-r</code>。<br>地址：<a href="https://github.com/tmux-plugins/tmux-resurrect">https://github.com/tmux-plugins/tmux-resurrect</a></p>
<p><strong>tmux-continuum</strong><br>可以用于配合tmux-recurrect，它会自动化地帮你保存和恢复<br>地址：<a href="https://github.com/tmux-plugins/tmux-continuum">https://github.com/tmux-plugins/tmux-continuum</a></p>
<h2 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h2><h3 id="会话的命令行操作"><a href="#会话的命令行操作" class="headerlink" title="会话的命令行操作"></a>会话的命令行操作</h3><table>
<thead>
<tr>
<th>命令</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td><code>tmux ls</code></td>
<td># 显示所有会话</td>
</tr>
<tr>
<td><code>tmux new -s &lt;session-name&gt;</code></td>
<td>#新建会话，并指定会话名</td>
</tr>
<tr>
<td><code>tmux new</code></td>
<td># 新建会话，会话名自动为数字序号</td>
</tr>
<tr>
<td><code>tmux a</code></td>
<td># 接入上一个会话</td>
</tr>
<tr>
<td><code>tmux a -t &lt;session-name&gt;</code></td>
<td># 接入指定会话</td>
</tr>
<tr>
<td><code>tmux detach</code></td>
<td># 断开当前会话，等价于ctrl+b d</td>
</tr>
<tr>
<td><code>tmux kill-session -t &lt;session-name&gt;</code></td>
<td># 关闭指定会话</td>
</tr>
<tr>
<td><code>tmux kill-session -a -t &lt;session-name&gt;</code></td>
<td>#关闭除指定会话外的其他所有会话</td>
</tr>
<tr>
<td><code>tmux kill-server</code></td>
<td># 销毁所有会话并停止tmux</td>
</tr>
</tbody></table>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="http://blog.csdn.net/ZCF1002797280/article/details/51859524">tmux使用及个性化配置
</a></li>
<li>[StackOverFlow]</li>
<li>[man tmux]</li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>tmux</tag>
      </tags>
  </entry>
  <entry>
    <title>Makefile极简教程</title>
    <url>/2017/11/09/makefile/</url>
    <content><![CDATA[<p>关于Makefile的编写和<code>make</code>命令的简单应用，快速了解Makefile的编写规则，更多功能将在以后的使用中慢慢增加。</p>
<span id="more"></span>

<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p><code>makefile</code>用于定义自动化编译命令<code>make</code>的规则，通过<code>make</code>命令，配合相关工程的makefile，可以让我们不再需要手动去一条条的编译和链接我们的源程序，直接通过执行一个命令就可以代替那些需要执行的编译命令。同时make命令会根据配置文件的状态（是否被修改）来确定是否需要重新编译该文件。<br><code>make</code>命令的用法为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">make [TARGET ...]</span><br></pre></td></tr></table></figure>
<p>即make后面跟需要执行的目标规则，目标规则便由makefile来定义。当<code>make</code>命令后面不跟<code>TARGET</code>时，make默认执行makefile中定义的第一条规则。当不通过<code>-f</code>参数手动指定make命令需要使用的规则文件时，<code>make</code>命令默认以以下顺序查找到第一个可用的规则文件：<code>GNUmakefile, makefile, Makefile</code>。<br>所以我们使用make命令的首要工作就是编写一份包含有编译规则的<code>makefile</code>文件</p>
<h2 id="makefile规则"><a href="#makefile规则" class="headerlink" title="makefile规则"></a>makefile规则</h2><h3 id="规则原理"><a href="#规则原理" class="headerlink" title="规则原理"></a>规则原理</h3><p><code>makefile</code>文件由一系列的规则组成，每个规则由“目标名”+”依赖文件”+命令组成。形如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">target1 [target ...]: [component1 ...]</span><br><span class="line">Tab ↹[command 1]</span><br><span class="line">Tab ↹[command 2]</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">Tab ↹[command n]</span><br><span class="line"></span><br><span class="line">target2 [target ...]: [component2 ...]</span><br><span class="line">Tab ↹[command 1]</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<p>如上，包含了两条规则，通常目标名（即target）要唯一，命令必须以<code>Tab</code>开始（<strong>如果你的vim设置用4个空格替换Tab，可以通过在插入模式下使用<code>ctrl+v+i插入一个Tab键</code></strong>），依赖文件（即component）将指定命令（command）中需要引用的文件，可以以变量的方式在command中引用传递的依赖文件，以实现复用。当然上述的component部分可以省略，当没有component部分是，称为伪目标，伪目标相当于可以让make帮助我们执行一个shell命令，例如经常会见到的<code>clean</code><br>可以看到，一个规则中可以包含多个目标、多个依赖和多条命令。<br><strong><code>#</code>开头用于注释</strong><br>一个简单的makefile，用于编译HelloWorld，为了增加复杂度，将输出函数单独放在一个<code>hello.cpp</code>和<code>hello.h</code>的文件中，main函数在<code>main.cpp</code>中，代码及makefile如下：<br><code>hello.h</code>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> HELLO_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HELLO_H</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* !HELLO_H */</span></span></span><br></pre></td></tr></table></figure>

<p><code>hello.cpp</code>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hello.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Hello world!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>main.cpp</code>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hello.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">print</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>makefile</code>：</p>
<figure class="highlight make"><table><tr><td class="code"><pre><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># makefile</span></span><br><span class="line"><span class="comment"># blueyi, 2017-11-09 16:08</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"></span><br><span class="line"><span class="section">helloMain: main.cpp hello.cpp hello.h</span></span><br><span class="line">	g++ -o helloMain main.cpp hello.cpp hello.h</span><br><span class="line"></span><br><span class="line"><span class="section">clean:      # 伪目标</span></span><br><span class="line">	rm -rf helloMain</span><br><span class="line"></span><br><span class="line"><span class="comment"># vim:ft=make</span></span><br><span class="line"><span class="comment">#</span></span><br></pre></td></tr></table></figure>
<p>可以看到后面有一个伪目标<code>clean</code>用于删除编译生成的文件。<br><strong>注意：默认情况下make会查看当前目录的目标与依赖相比是否最新，如果是，则不再执行相应命令。这样就会导致如果文件夹下存在了clean文件，而其又没有依赖，那它的命令将永远不会执行。为了解决该问题，可以手动添加一句<code>.PHONY: clean</code>来指定<code>clean</code>为伪目标，这样make就总会执行该目标的命令</strong><br>makefile的规则如此简洁，极易理解和使用，但当我们文件越来越多，并且我们想有更多的控制时，每次都要手动去添加文件就会大大增加工作量，此时可能通过宏来进行更好的实现。</p>
<h3 id="宏（变量）"><a href="#宏（变量）" class="headerlink" title="宏（变量）"></a>宏（变量）</h3><p>makefile中可以定义变量，有些地方称之为宏，实际上这里并没有很确切的边界，都是可以的，所以下面会混用这两个概念。定义方式形如：</p>
<figure class="highlight make"><table><tr><td class="code"><pre><span class="line">MACRO = definition</span><br></pre></td></tr></table></figure>
<p>通过<code>$(MACRO_NAME)</code>或者<code>$&#123;MACRO_NAME&#125;</code>的方式来引用定义的宏。<br>通过简单的宏定义，我们可以将上述makefile改写如下，并加入中间文件obj文件的支持：<br><code>makefile</code>：</p>
<figure class="highlight make"><table><tr><td class="code"><pre><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># makefile</span></span><br><span class="line"><span class="comment"># blueyi, 2017-11-09 16:08</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"></span><br><span class="line">cc = g++</span><br><span class="line">prom = helloMain</span><br><span class="line">deps = hello.h</span><br><span class="line">obj = main.o hello.o</span><br><span class="line"></span><br><span class="line"><span class="variable">$(prom)</span>: <span class="variable">$(obj)</span></span><br><span class="line">	<span class="variable">$(cc)</span> -o <span class="variable">$(prom)</span> <span class="variable">$(obj)</span></span><br><span class="line"></span><br><span class="line"><span class="section">main.o: main.cpp <span class="variable">$(deps)</span></span></span><br><span class="line">	<span class="variable">$(cc)</span> -c main.cpp</span><br><span class="line"></span><br><span class="line"><span class="section">hello.o: hello.cpp <span class="variable">$(deps)</span></span></span><br><span class="line">	<span class="variable">$(cc)</span> -c hello.cpp</span><br><span class="line"></span><br><span class="line"><span class="section">clean:      # 伪目标</span></span><br><span class="line">	rm -rf helloMain hello.o main.o</span><br><span class="line"><span class="comment"># vim:ft=make</span></span><br><span class="line"><span class="comment">#</span></span><br></pre></td></tr></table></figure>
<p>可以看到我们细分了依赖，将头文件作为hello.o和main.o的依赖，而可执行文件则依赖中间文件<code>*.o</code></p>
<p><strong>可以通过make命令修改makefile中定义的宏：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">make MACRO=&quot;value&quot; [MACRO=&quot;value&quot; ...] TARGET [TARGET ...]</span><br></pre></td></tr></table></figure>

<p><strong>宏的值可以来源于shell命令，命令由”`”（Esc下面那个键）包围：</strong></p>
<figure class="highlight make"><table><tr><td class="code"><pre><span class="line">TIME = `date`</span><br></pre></td></tr></table></figure>
<p>多个宏可以直接连接在一起组成一个宏。<br>举例如下（功能为将当前目录下的文件打包）。<br><code>makeTar</code></p>
<figure class="highlight make"><table><tr><td class="code"><pre><span class="line">PACKAGE   = package</span><br><span class="line">VERSION   = ` date +<span class="string">&quot;%Y.%m%d&quot;</span> `</span><br><span class="line">ARCHIVE   = <span class="variable">$(PACKAGE)</span>-<span class="variable">$(VERSION)</span></span><br><span class="line"></span><br><span class="line"><span class="section">dist:</span></span><br><span class="line">    <span class="comment">#  Notice that only now macros are expanded for shell to interpret:</span></span><br><span class="line">    <span class="comment">#      tar -cf package-`date +&quot;%Y%m%d&quot;`.tar</span></span><br><span class="line"></span><br><span class="line">	tar -cf <span class="variable">$(ARCHIVE)</span>.tar .</span><br></pre></td></tr></table></figure>
<p>执行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">make PACKAGE=&quot;study&quot; -f makeTar</span><br></pre></td></tr></table></figure>
<p>生成文件名为<code>study-2017.1109.tar</code></p>
<p>利用宏可以让我们很方便的添加依赖关系、管理编译选项，但当我们的代码有了改动的时候依然会很麻烦，例如添加一些cpp和头文件后我们就不得不再次编辑makefile文件添加相关内容。通过自动变量可以在命令中引用target和component，以减少makefile工作量</p>
<h3 id="自动变量-模式匹配-通配符"><a href="#自动变量-模式匹配-通配符" class="headerlink" title="自动变量|模式匹配|通配符"></a>自动变量|模式匹配|通配符</h3><p>常用的内置宏如下：</p>
<ul>
<li><code>$@</code> 引用target</li>
<li><code>$^</code> component部分以空格分隔的所有文件</li>
<li><code>$?</code> 以空格分隔的，component部分比目标还要新的文件</li>
<li><code>$&lt;</code> 引用component中的第一个元素</li>
</ul>
<p>更多自动变量参见GNU文档<a href="https://www.gnu.org/software/make/manual/html_node/Automatic-Variables.html#Automatic-Variables">https://www.gnu.org/software/make/manual/html_node/Automatic-Variables.html#Automatic-Variables</a></p>
<p><strong>模式匹配：</strong></p>
<ul>
<li><code>%</code> 用于模式匹配，匹配连续的0个或更多个字符，可以理解为可用于匹配文件名，make会根据makefile中 第一个不带通配符的A目标构造规则对匹配模式进行展开<br>而通配符<code>*</code>用于单个文件名的匹配</li>
</ul>
<p><strong>通配符</strong><br>makefile中表示一个单一的文件名时可以使用通配符：<code>*</code>、<code>?</code>和<code>[...]</code>，通配符的含义与shell中的含义完全相同，通配符可以在以下两种场合使用：</p>
<ol>
<li>可以用在规则的目标、依赖中，此时make会自动将其展开；</li>
<li>可出现在规则的命令中，其展开是在shell在执行此命令时完成。</li>
</ol>
<p>利用内置宏和匹配模式，上述HelloWorld的makefile可改写如下：</p>
<figure class="highlight make"><table><tr><td class="code"><pre><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># makefile</span></span><br><span class="line"><span class="comment"># blueyi, 2017-11-09 16:08</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"></span><br><span class="line">cc = g++</span><br><span class="line">prom = helloMain</span><br><span class="line">deps = <span class="variable">$(<span class="built_in">shell</span> find ./ -name &quot;*.h&quot;)</span></span><br><span class="line">src = <span class="variable">$(<span class="built_in">shell</span> find ./ -name &quot;*.cpp&quot;)</span></span><br><span class="line">obj = $(src:%.c=%.o)</span><br><span class="line"></span><br><span class="line"><span class="variable">$(prom)</span>: <span class="variable">$(obj)</span></span><br><span class="line">	<span class="variable">$(cc)</span> -o <span class="variable">$(prom)</span> <span class="variable">$(obj)</span></span><br><span class="line"></span><br><span class="line"><span class="section">%.o: %.cpp <span class="variable">$(deps)</span></span></span><br><span class="line">	<span class="variable">$(cc)</span> -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="section">clean:      # 伪目标</span></span><br><span class="line">	rm -rf helloMain hello.o main.o</span><br><span class="line"><span class="comment"># vim:ft=make</span></span><br><span class="line"><span class="comment">#</span></span><br></pre></td></tr></table></figure>
<p>上述<code>$(cc) -c $&lt; -o $@</code>可以自动将每一个<code>.cpp</code>文件编译为相应的<code>.o</code>文件。<br>可以看到我们定义的<code>deps</code>和<code>src</code>通过shell命令自动搜索路径下的所有文件，obj中的用法表示将src中的所有<code>.c</code>替换为<code>.o</code>作为obj的值</p>
<h2 id="更多用法"><a href="#更多用法" class="headerlink" title="更多用法"></a>更多用法</h2><h3 id="多行命令共用shell上下文"><a href="#多行命令共用shell上下文" class="headerlink" title="多行命令共用shell上下文"></a>多行命令共用shell上下文</h3><p>默认情况下make执行的每条命令之间是独立的，例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /home/blueyi</span><br><span class="line">pwd</span><br></pre></td></tr></table></figure>
<p>这两条命令前后并没有任何关系，为了让<code>pwd</code>与前一条命令共用shell上下文，应该将其让在一行中执行，多条命令通过<code>;</code>（分号）放在一行中。<br><strong>当命令太长时，可以使用反斜杠（<code>\</code>）续行。</strong></p>
<h3 id="wikipedia上一个通用GNUMakefile"><a href="#wikipedia上一个通用GNUMakefile" class="headerlink" title="wikipedia上一个通用GNUMakefile"></a>wikipedia上一个通用GNUMakefile</h3><p>原makefile用于编译C语言，这里改成了C++</p>
<figure class="highlight make"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Generic GNUMakefile</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Just a snippet to stop executing under other make(1) commands</span></span><br><span class="line"><span class="comment"># that won&#x27;t understand these lines</span></span><br><span class="line"><span class="keyword">ifneq</span> (,)</span><br><span class="line">This makefile requires GNU Make.</span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line">PROGRAM = foo</span><br><span class="line">C_FILES := <span class="variable">$(<span class="built_in">wildcard</span> *.cpp)</span></span><br><span class="line">OBJS := <span class="variable">$(<span class="built_in">patsubst</span> %.cpp, %.o, <span class="variable">$(C_FILES)</span>)</span></span><br><span class="line">CC = g++</span><br><span class="line">CFLAGS = -Wall -pedantic</span><br><span class="line">LDFLAGS =</span><br><span class="line">LDLIBS = -lm</span><br><span class="line"></span><br><span class="line"><span class="section">all: <span class="variable">$(PROGRAM)</span></span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(PROGRAM)</span>: .depend <span class="variable">$(OBJS)</span></span><br><span class="line">	<span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> <span class="variable">$(OBJS)</span> <span class="variable">$(LDFLAGS)</span> -o <span class="variable">$(PROGRAM)</span> <span class="variable">$(LDLIBS)</span></span><br><span class="line"></span><br><span class="line"><span class="section">depend: .depend</span></span><br><span class="line"></span><br><span class="line"><span class="section">.depend: cmd = g++ -MM -MF depend <span class="variable">$(var)</span>; cat depend &gt;&gt; .depend;</span></span><br><span class="line"><span class="section">.depend:</span></span><br><span class="line">	@echo <span class="string">&quot;Generating dependencies...&quot;</span></span><br><span class="line">	@<span class="variable">$(<span class="built_in">foreach</span> var, <span class="variable">$(C_FILES)</span>, <span class="variable">$(cmd)</span>)</span></span><br><span class="line">	@rm -f depend</span><br><span class="line"></span><br><span class="line"><span class="keyword">-include</span> .depend</span><br><span class="line"></span><br><span class="line"><span class="comment"># These are the pattern matching rules. In addition to the automatic</span></span><br><span class="line"><span class="comment"># variables used here, the variable $* that matches whatever % stands for</span></span><br><span class="line"><span class="comment"># can be useful in special cases.</span></span><br><span class="line"><span class="section">%.o: %.c</span></span><br><span class="line">	<span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="section">%: %.c</span></span><br><span class="line">	<span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> -o <span class="variable">$@</span> <span class="variable">$&lt;</span></span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm -f .depend <span class="variable">$(OBJS)</span></span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: clean depend</span></span><br></pre></td></tr></table></figure>


<h3 id="命令前面加个-号（或-IGNORE）"><a href="#命令前面加个-号（或-IGNORE）" class="headerlink" title="命令前面加个-号（或.IGNORE）"></a>命令前面加个<code>-</code>号（或.IGNORE）</h3><p>make在执行makefile中的命令时会检测每个命令的返回值，当某个命令出错时（即返回非0），make就会终止当前规则中该命令之后的所有命令，也就有可能终止执行所有规则。有些时候我们的命令返回错误并不影响整个项目的编译，例如<code>mkdir</code>或<code>rm</code>等，此时就可以在命令前面加上一个<code>-</code>（减号）表示不管该命令返回值如何，都认为其执行成功，例如上面的clean中的命令可改为<code>-rm -f .depend $(OBJS)</code>。<br><strong><code>.IGNORE</code></strong> 当使用<code>.IGNORE</code>来做为一个规则（target）的目标时，则表示这个规则中的所有命令执行错误将被忽略。<br>如果给<code>make</code>加上<code>-i</code>（或<code>--ignore-errors</code>）参数，则该makefile中的所有命令执行错误将被忽略。<br>如果给<code>make</code>加上<code>-k</code>（或<code>--keep-going</code>）参数，如果某规则中的命令出错，则终止该规则的执行，但会继续执行其他规则。</p>
<h3 id="include引用其他makefile"><a href="#include引用其他makefile" class="headerlink" title="include引用其他makefile"></a><code>include</code>引用其他makefile</h3><p>通过在makefile中使用<code>include&lt;file_name&gt;</code>来引用其他makefile文件，make命令会找到相应的file_name中的内容插入到当前位置，file_name可以含宏以及通配符。<code>include</code>不能以<code>Tab</code>开始。<br>file_name的查找路径类似C++中的头文件的查找路径，make同样也会去<code>-I</code>（或<code>--include-dir</code>）包含的目录中查找。</p>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>函数的用法形如：</p>
<figure class="highlight make"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(function arguments)</span></span><br><span class="line"><span class="comment"># OR</span></span><br><span class="line">$&#123;function arguments&#125;</span><br></pre></td></tr></table></figure>
<p>调用方式与变量很像。其中<code>function</code>为函数名，后面为参数，多个参数以<code>,</code>（逗号）分隔，函数名与参数之后用空格分隔。<br>以替换子字符串的函数<code>subst</code>举例：</p>
<figure class="highlight make"><table><tr><td class="code"><pre><span class="line">comma:= ,</span><br><span class="line">empty:=</span><br><span class="line">space:= <span class="variable">$(empty)</span> <span class="variable">$(empty)</span>  <span class="comment"># 通过这种方式定义一个值为空格的变量</span></span><br><span class="line">foo:= a b c</span><br><span class="line">bar:= <span class="variable">$(<span class="built_in">subst</span> <span class="variable">$(space)</span>,<span class="variable">$(comma)</span>,<span class="variable">$(foo)</span>)</span></span><br><span class="line"><span class="comment"># bar is now ‘a,b,c’.</span></span><br></pre></td></tr></table></figure>
<p><code>subst</code>的参数作用是第一个参数为将要被替换的子串，第二个参数为替换成的子串，第三个参数为替换操作将发生作用的字符串。<br>常用函数形如下，（注意：<code>text</code>通常指可以由空白分隔的多个字符串，<code>string</code>指字符串，也可以含空白）：</p>
<ul>
<li><code>$(subst from,to,text)</code> 替换子串函数</li>
<li><code>$(patsubst pattern,replacement,text)</code>  模式匹配替换</li>
<li><code>$(strip string)</code> 去掉string开头和结尾的空白字符</li>
<li><code>$(findstring find,in)</code> 从in中查到find，如果找到，则返回find，否则返回空字符串</li>
<li><code>$(filter pattern…,text)</code> 过滤text中符合pattern的字符串返回</li>
<li><code>$(filter-out pattern…,text)</code> 与上述相反，过滤掉text中符合pattern的字符串，将剩下的返回</li>
<li><code>$(sort list)</code> 将list以字典序排序，并去掉重复的字符串，返回以一个空格分隔的字符串。</li>
<li><code>$(word n,text)</code> 返回text中的第n个字符串，n从1开始</li>
<li><code>$(wordlist s,e,text)</code> 取text中第s个到第e个字符串返回，如：<code>$(wordlist 2, 3, foo bar baz)返回值是“bar baz”</code></li>
<li><code>$(words text)</code> 返回text中的单词个数</li>
<li><code>$(firstword names…)</code>  返回第一个单词</li>
<li><code>$(lastword names…)</code> 返回最后一个单词</li>
</ul>
<h3 id="文件名相关的函数"><a href="#文件名相关的函数" class="headerlink" title="文件名相关的函数"></a>文件名相关的函数</h3><ul>
<li><code>$(dir &lt;names...&gt;)</code>  取目录，从文件名序列中取出目录部分，即最后一个反斜杠（<code>/</code>）之前的内容</li>
<li><code>$(notdir &lt;names...&gt;)</code> 取文件名，非目录部分，即文件名，包括扩展名</li>
<li><code>$(suffix &lt;names...&gt;)</code> 取后缀名</li>
<li><code>$(basename &lt;names...&gt;)</code> 取文件名前缀，即不带后缀的文件名</li>
<li><code>$(addsuffix &lt;suffix&gt;,&lt;names...&gt;)</code> 加后缀</li>
<li><code>$(addprefix &lt;prefix&gt;,&lt;names...&gt;)</code> 加前缀，可用于为文件添加路径</li>
<li><code>$(join &lt;list1&gt;,&lt;list2&gt;)</code> 把list2的每个单词对应地添加后list1单词的后面，如：<code>$(join aaa bbb , 111 222 333)返回值是“aaa111 bbb222 333”</code></li>
<li><code>$(wildcard pattern)</code> 扩展通配符，由于makefile中变量定义和函数引用时，通配符将失效，这咱情况下就可以使用该函数。</li>
<li><code>$(realpath names…)</code> 返回真实绝对地址</li>
<li><code>$(abspath names…)</code> 返回绝对地址，与上一个函数相比，它不会解析链接</li>
</ul>
<h3 id="foreach函数"><a href="#foreach函数" class="headerlink" title="foreach函数"></a>foreach函数</h3><p>大家应该都很熟悉了，就是遍历，形式如下：</p>
<figure class="highlight make"><table><tr><td class="code"><pre><span class="line"><span class="variable">$(<span class="built_in">foreach</span> &lt;var&gt;,&lt;list&gt;,&lt;text&gt;)</span></span><br></pre></td></tr></table></figure>
<p>作用是把参数<code>&lt;list&gt;</code>中的单词逐一取出放到参数<code>&lt;var&gt;</code>所指定的变量中，然后再执行<code>&lt;text&gt;</code>所包含的表达式。每一次<code>&lt;text&gt;</code>会返回一个字符串，循环过程中，<code>&lt;text&gt;</code>的所返回的每个字符串会以空格分隔，最后当整个循环结束时，<code>&lt;text&gt;</code>所返回的每个字符串所组成的整个字符串（以空格分隔）将会是foreach函数的返回值。<br>用法举例：</p>
<figure class="highlight make"><table><tr><td class="code"><pre><span class="line">dirs := a b c d</span><br><span class="line">files := <span class="variable">$(<span class="built_in">foreach</span> <span class="built_in">dir</span>,<span class="variable">$(dirs)</span>,$(<span class="built_in">wildcard</span> <span class="variable">$(dir)</span>/*)</span>)</span><br></pre></td></tr></table></figure>
<p>类似于<code>files := $(wildcard a/* b/* c/* d/*)</code><br>等价于：</p>
<figure class="highlight make"><table><tr><td class="code"><pre><span class="line">find_files = <span class="variable">$(<span class="built_in">wildcard</span> <span class="variable">$(dir)</span>/*)</span></span><br><span class="line">dirs := a b c d</span><br><span class="line">files := <span class="variable">$(<span class="built_in">foreach</span> <span class="built_in">dir</span>,<span class="variable">$(dirs)</span>,<span class="variable">$(find_files)</span>)</span></span><br></pre></td></tr></table></figure>

<h3 id="shell函数"><a href="#shell函数" class="headerlink" title="shell函数"></a>shell函数</h3><p>前面已经用过了，用法如下：</p>
<figure class="highlight make"><table><tr><td class="code"><pre><span class="line">contents := <span class="variable">$(<span class="built_in">shell</span> cat foo)</span></span><br></pre></td></tr></table></figure>
<p>与</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">`</span><br></pre></td></tr></table></figure>
<p>功能一样。</p>
<p>更多函数参见：<a href="https://www.gnu.org/software/make/manual/make.html#Syntax-of-Functions">https://www.gnu.org/software/make/manual/make.html#Syntax-of-Functions</a></p>
<h3 id="GNU-make的执行步骤"><a href="#GNU-make的执行步骤" class="headerlink" title="GNU make的执行步骤"></a>GNU make的执行步骤</h3><ol>
<li>读入所有的Makefile。</li>
<li>读入被include的其它Makefile。</li>
<li>初始化文件中的变量。</li>
<li>推导隐晦规则，并分析所有规则。</li>
<li>为所有的目标文件创建依赖关系链。</li>
<li>根据依赖关系，决定哪些目标要重新生成。</li>
<li>执行生成命令。</li>
</ol>
<h3 id="VPATH（文件搜索路径）"><a href="#VPATH（文件搜索路径）" class="headerlink" title="VPATH（文件搜索路径）"></a>VPATH（文件搜索路径）</h3><p>makefile中可以通过一个特殊的宏名<code>VPATH</code>来指定make命令的文件搜索路径，当不手动定义该宏时，默认情况下make只在当前目录下搜索文件。而有了该宏之后，make会在当前目录搜索不到时去<code>VPATH</code>中搜索。</p>
<figure class="highlight make"><table><tr><td class="code"><pre><span class="line">VPATH=src:../header:/usr/<span class="keyword">include</span></span><br></pre></td></tr></table></figure>
<p>上述指定了三个搜索目录：<code>src</code>、<code>../header</code>和<code>/usr/include</code>，make会按照这个顺序去搜索，目录名由冒号分隔。<br><strong>另一种<code>vpath</code></strong><br>采用全小写的<code>vpath</code>关键字可以很灵活地指定不同的文件在不同的目录进行搜索，<code>vpath</code>有3种用法：</p>
<ol>
<li><code>vpath &lt;pattern&gt; &lt;directories&gt;</code> 为符合模式<code>&lt;pattern&gt;</code>的文件指定搜索目录<code>&lt;directories&gt;</code>。</li>
<li><code>vpath &lt;pattern&gt;</code> 清除符合模式<code>&lt;pattern&gt;</code>的文件的搜索目录。</li>
<li><code>vpath</code>                                                 清除所有已被设置好了的文件搜索目录。<br>其中<code>&lt;pattern&gt;</code>中需要包含模式匹配符<code>%</code>，如：<figure class="highlight make"><table><tr><td class="code"><pre><span class="line"><span class="keyword">vpath</span> %.h ../header</span><br><span class="line"><span class="keyword">vpath</span> %.c build/src</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="隐藏执行的具体命令"><a href="#隐藏执行的具体命令" class="headerlink" title="隐藏执行的具体命令"></a>隐藏执行的具体命令</h3><p>默认情况下make会将需要执行的命令行本身也输出到屏幕上，可以通过在命令行前面加上字符<code>@</code>来让make不显示该命令行本身，而直接执行。<br>如果<code>make</code>带参数<code>-n</code>（或<code>--just-print</code>），则只是显示命令，而不执行，可以用于调试makefile。<br>如果<code>make</code>带参数<code>-s</code>（或<code>--slient</code>），则禁止显示所有命令。</p>
<h3 id="嵌套执行子目录中的makefile"><a href="#嵌套执行子目录中的makefile" class="headerlink" title="嵌套执行子目录中的makefile"></a>嵌套执行子目录中的makefile</h3><p>当一个工程中包含有多个子目录的工程时，可以通过<code>subsystem</code>来在外层的<code>makefile</code>中嵌套执行各子目录中的makefile，这样就可以为每个子目录编写一个独立的makefile来执行相应目录下的工作。<br>例如假设我们有一个子目录名为<code>subdir</code>，其目录中有一个makefile，我们的外层目录中的makefile称其为总控makefile，那总控makefile可以如下：</p>
<figure class="highlight make"><table><tr><td class="code"><pre><span class="line"><span class="section">subsystem:</span></span><br><span class="line">	cd subdir &amp;&amp; <span class="variable">$(MAKE)</span></span><br></pre></td></tr></table></figure>
<p>等价于：</p>
<figure class="highlight make"><table><tr><td class="code"><pre><span class="line"><span class="section">subsystem:</span></span><br><span class="line">	<span class="variable">$(MAKE)</span> -C subdir</span><br></pre></td></tr></table></figure>
<p>推荐使用第2种方式，因为该方式将会自动为子make启用<code>-w</code>（或<code>--print-directory</code>）选项，也就是会在执行子make是出现提示：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">make: Entering directory `/home/src&#x27;.</span><br></pre></td></tr></table></figure>
<p>和相应的：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">make: Leaving directory `/home/src&#x27;</span><br></pre></td></tr></table></figure>
<p>其中的<code>$(MAKE)</code>是自己定义宏变量，其中包含<code>make</code>命令和想传递给它的参数。这种情况下子make命令会继承总控make的<code>SHELL</code>变量和<code>MAKEFLAGS</code>变量，但在子makefile中的同名变量会覆盖SHELL中定义的变量。也可以通过<code>export</code>将总控<code>makefile</code>中的宏定义传送到子makefile中。如果子make使用了<code>-e</code>参数，则系统环境变量将覆盖其中的同名变量。<br><code>export</code>用法：</p>
<figure class="highlight make"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> &lt;variable ...&gt;  <span class="comment"># 传递相应的宏</span></span><br><span class="line"><span class="keyword">unexport</span> &lt;variable ...&gt; <span class="comment">#不传递相应的宏</span></span><br><span class="line"><span class="keyword">export</span>  <span class="comment">#传递所有宏</span></span><br></pre></td></tr></table></figure>
<p>其中</p>
<figure class="highlight make"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> MACRO = value</span><br><span class="line"><span class="comment"># 等价于</span></span><br><span class="line">MACRO = value</span><br><span class="line"><span class="keyword">export</span> MACRO</span><br></pre></td></tr></table></figure>

<p><strong>内置宏<code>$&#123;MAKELEVEL&#125;</code>用于记录嵌套调用的层数，从0开始，第0层也即主控makefile</strong></p>
<h3 id="变量赋值（-）"><a href="#变量赋值（-）" class="headerlink" title="变量赋值（=, :=, ?=, +=）"></a>变量赋值（<code>=</code>, <code>:=</code>, <code>?=</code>, <code>+=</code>）</h3><p><strong><code>=</code></strong><br>最基本的赋值，使用该赋值时make会将整个makefile展开后进行赋值，也就是说make会取最后的变量值进行赋值。例如：</p>
<figure class="highlight make"><table><tr><td class="code"><pre><span class="line">x = foo</span><br><span class="line">y = <span class="variable">$(x)</span> bar <span class="variable">$(z)</span></span><br><span class="line">x = abc</span><br><span class="line">z = def</span><br></pre></td></tr></table></figure>
<p>最终y的值是<code>abc bar def</code>，因为make最终确定到的x的值为<code>abc</code>，而不是之前的<code>foo</code>，这样有一个好处是可以引用未被定义的值，上述看到z也被成功展开了。</p>
<p><strong><code>:=</code></strong><br>用于赋值的宏只展开到当前位置，而不去读取后面的赋值。例如：</p>
<figure class="highlight make"><table><tr><td class="code"><pre><span class="line">x := foo</span><br><span class="line">y := <span class="variable">$(x)</span> bar <span class="variable">$(z)</span></span><br><span class="line">x := abc</span><br><span class="line">z := def</span><br></pre></td></tr></table></figure>
<p>最终y的值为<code>foo bar</code></p>
<p><strong><code>?=</code></strong><br>作用是如果没有被赋值过就赋予等号后面的值，如果该宏未被定义过，则什么也不做。</p>
<p><strong><code>+=</code></strong><br>用于添加等号后面的值，类似于C++中的<code>+=</code>，如果被赋值的宏未被定义过，则相当于普通等号（<code>=</code>）。赋值方式会继承之前的宏定义时的等号模式（<code>=</code>或<code>:=</code>）。</p>
<h3 id="变量支持递推赋值和子串替换"><a href="#变量支持递推赋值和子串替换" class="headerlink" title="变量支持递推赋值和子串替换"></a>变量支持递推赋值和子串替换</h3><p><strong>递推赋值</strong></p>
<figure class="highlight make"><table><tr><td class="code"><pre><span class="line">x = y</span><br><span class="line">y = z</span><br><span class="line">z = hello</span><br><span class="line">a := $(<span class="variable">$(x)</span>)</span><br><span class="line">b := $($(<span class="variable">$(x)</span>))</span><br></pre></td></tr></table></figure>
<p>注意其结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a = z</span><br><span class="line">b = hello</span><br></pre></td></tr></table></figure>

<p><strong>子串替换</strong><br>前面用过了，格式为<code>$(var:a=b)</code>或<code>$&#123;var:a=b&#125;</code>，即将宏<code>var</code>中的所有以<code>a</code>子串“结尾”的<code>a</code>替换为<code>b</code>子串，”结尾”的意思是”空格“或”结束符”。</p>
<h3 id="定义多行变量（define）"><a href="#定义多行变量（define）" class="headerlink" title="定义多行变量（define）"></a>定义多行变量（define）</h3><p>当有多个命令需要一起顺序执行时，虽然我们可以使用分号的方式将它们连接在一起，但无法复用这些命令，此时可以通过关键字<code>define</code>定义为多行的变量，然后像引用普通变量一样调用：</p>
<figure class="highlight make"><table><tr><td class="code"><pre><span class="line"><span class="keyword">define</span> run_it =</span><br><span class="line">echo <span class="variable">$(foo)</span></span><br><span class="line">echo <span class="variable">$(bar)</span></span><br><span class="line">ls</span><br><span class="line"><span class="keyword">endef</span></span><br></pre></td></tr></table></figure>
<p>引用时就直接<code>$(run_it)</code>即可，赋值符号也可以为<code>:=</code>或<code>+=</code>，当省略<code>=</code>时，make默认为<code>=</code>号。<br>注意<code>define</code>和<code>endef</code>之间只能是命令，不能进行变量定义。<br>可以通过<code>undefine &lt;variable&gt;</code>取消定义的变量。</p>
<h3 id="override取消make命令行的覆盖定义"><a href="#override取消make命令行的覆盖定义" class="headerlink" title="override取消make命令行的覆盖定义"></a>override取消make命令行的覆盖定义</h3><p>默认情况下通过make命令行指定的变量定义会覆盖makefile中的定义值，可以通过在变量名前加关键字<code>override</code>来取消make命令行参数对makefile中变量的修改，也就是使用override之后make定义的同名变量将失效。<br>当<code>override</code>与<code>define</code>一起使用时，直接将它放在<code>define</code>前面即可。</p>
<h3 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h3><p>可以为目标定义一个局部变量，这样由该目标所关联的依赖做为目标时的子目标中，该局部变量将都是由目标定义的值，用法如下：</p>
<figure class="highlight make"><table><tr><td class="code"><pre><span class="line">target … : variable-assignment</span><br><span class="line">target … : <span class="keyword">override</span> variable-assignment <span class="comment"># 针对make传参的形式</span></span><br></pre></td></tr></table></figure>
<p><code>variable-assignment</code>可以是上述赋值语句提到的任意一种形式。<br>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">prog : CFLAGS = -g</span><br><span class="line">prog : prog.o foo.o bar.o</span><br><span class="line">	$(CC) $(CFLAGS) prog.o foo.o bar.o</span><br><span class="line"></span><br><span class="line">prog.o : prog.c</span><br><span class="line">	$(CC) $(CFLAGS) prog.c</span><br><span class="line"></span><br><span class="line">foo.o : foo.c</span><br><span class="line">	$(CC) $(CFLAGS) foo.c</span><br><span class="line"></span><br><span class="line">bar.o : bar.c</span><br><span class="line">	$(CC) $(CFLAGS) bar.c</span><br></pre></td></tr></table></figure>
<p>这样当有全局<code>CFLAGS</code>时并不会影响到目标prog中所使用的<code>CFLAGS</code>值。</p>
<h3 id="模式变量"><a href="#模式变量" class="headerlink" title="模式变量"></a>模式变量</h3><p>当目标为符合某一模式时，使用相应的模式下定义的变量，形式：</p>
<figure class="highlight make"><table><tr><td class="code"><pre><span class="line">pattern … : variable-assignment</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight make"><table><tr><td class="code"><pre><span class="line"><span class="section">%.o: %.c</span></span><br><span class="line">	<span class="variable">$(CC)</span> -c <span class="variable">$(CFLAGS)</span> <span class="variable">$(CPPFLAGS)</span> <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="section">lib/%.o: CFLAGS := -fPIC -g  # 模式变量</span></span><br><span class="line"><span class="section">%.o: CFLAGS := -g # 模式变量</span></span><br><span class="line"></span><br><span class="line"><span class="section">all: foo.o lib/bar.o</span></span><br></pre></td></tr></table></figure>
<p>这样就可以针对不同的输出情况调用不同的编译参数了。</p>
<h3 id="条件判断（ifeq-else-endif）"><a href="#条件判断（ifeq-else-endif）" class="headerlink" title="条件判断（ifeq..else..endif）"></a>条件判断（ifeq..else..endif）</h3><p>条件判断形式如下：</p>
<figure class="highlight make"><table><tr><td class="code"><pre><span class="line">conditional-directive-one</span><br><span class="line">text-if-one-is-true</span><br><span class="line"><span class="keyword">else</span> conditional-directive-two</span><br><span class="line">text-if-two-is-true</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">text-if-one-and-two-are-false</span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure>

<p>直接上例子就好：</p>
<figure class="highlight make"><table><tr><td class="code"><pre><span class="line">libs_for_gcc = -lgnu</span><br><span class="line">normal_libs =</span><br><span class="line"></span><br><span class="line"><span class="section">foo: <span class="variable">$(objects)</span></span></span><br><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(CC)</span>,gcc)  <span class="comment"># 判断$(CC)是否为&quot;gcc&quot;</span></span><br><span class="line">        <span class="variable">$(CC)</span> -o foo <span class="variable">$(objects)</span> <span class="variable">$(libs_for_gcc)</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">        <span class="variable">$(CC)</span> -o foo <span class="variable">$(objects)</span> <span class="variable">$(normal_libs)</span></span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure>

<p>等价于：</p>
<figure class="highlight make"><table><tr><td class="code"><pre><span class="line">libs_for_gcc = -lgnu</span><br><span class="line">normal_libs =</span><br><span class="line"></span><br><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(CC)</span>,gcc)</span><br><span class="line">  libs=<span class="variable">$(libs_for_gcc)</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  libs=<span class="variable">$(normal_libs)</span></span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line"><span class="section">foo: <span class="variable">$(objects)</span></span></span><br><span class="line">        <span class="variable">$(CC)</span> -o foo <span class="variable">$(objects)</span> <span class="variable">$(libs)</span></span><br></pre></td></tr></table></figure>

<p>除了<code>ifeq</code>相应的也有以下判断方式：</p>
<ul>
<li><code>ifneq</code> 判断是否不相等，不相等为true</li>
<li><code>ifdef</code> 判断相应变量的值是否为空，不空为true，注意是指该变量是否被赋过值</li>
<li><code>ifndef</code> 与上面相反</li>
</ul>
<p><strong>注意：条件判断用于命令部分时，不能以<code>Tab</code>开始</strong></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li>[wikipedia:Make]</li>
<li><a href="https://www.gnu.org/software/make/manual/html_node/">GNU make</a></li>
<li><a href="http://www.cnblogs.com/owlman/p/5514724.html">Makefile简易教程</a></li>
<li><a href="http://blog.csdn.net/ruglcc/article/details/7814546/">Makefile经典教程</a></li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>make</tag>
        <tag>Linux</tag>
        <tag>cmake</tag>
      </tags>
  </entry>
  <entry>
    <title>为Linux系统导入根证书</title>
    <url>/2017/10/14/certificates-import-linux/</url>
    <content><![CDATA[<p>公司里面通常都会为了信息安全而要求个人电脑通过公司的根证书访问SSL加密的链接，如果系统里面没有根证书不管是浏览器还是需要访问SSL加密网络的系统命令都会出现证书相关错误。虽然这些证书错误都可以通过其他一些设置绕过去，但还是直接设置一下系统根证书更方便，一劳永逸（自己公司，忽略安全性）。</p>
<span id="more"></span>

<p>例如当系统缺失公司证书运行<code>docker search centos</code>命令可能会出现以下证书错误：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Error response from daemon: Get https://index.docker.io/v1/search...</span><br></pre></td></tr></table></figure>

<p><code>curl</code>到https网站可能会出现以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Peer certificate cannot be authenticated with known CA certificates</span><br></pre></td></tr></table></figure>
<p>浏览器通常可以通过在相关设置中导入，windows下面可以直接双击后导入。所以这里只针对Linux操作系统。验证环境为Ubuntu16.04。</p>
<h2 id="准备证书文件"><a href="#准备证书文件" class="headerlink" title="准备证书文件"></a>准备证书文件</h2><p>导入的文件需要是pem格式(后缀通常为crt或者pem)，公司提供的通常是ca证书（后缀通常为cer），如果系统是公司已经安装好的操作系统，可以通过IE-设置(Internet Options)-内容(Content)-证书(Certificates)中找到受信任的根证书机构（Trusted Root Certification Authorities）中找到你的公司名字，选择导出后就可以被导出为ca证书了。如果是Firefox浏览器，可以直接导出为pem格式的证书，所以如果你不想使用下面的命令行，也可以将CA证书导入到Firefox之后再导出，Firefox支持ca证书的导入。<br>ca证书转为pem证书的命令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">openssl x509 -inform der -in /path/to/ca.cer -out /path/to/foo.crt</span><br></pre></td></tr></table></figure>

<h2 id="导入证书"><a href="#导入证书" class="headerlink" title="导入证书"></a>导入证书</h2><ol>
<li><p>在目录<code>/usr/share/ca-certificates</code>创建一个存放自己额外证书的文件夹:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo mkdir /usr/share/ca-certificates/extra</span><br></pre></td></tr></table></figure>
</li>
<li><p>将pem证书拷贝到证书文件夹：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo cp foo.crt /usr/share/ca-certificates/extra/foo.crt</span><br></pre></td></tr></table></figure>
</li>
<li><p>运行以下命令将<code>/usr/share/ca-Certificates</code>文件夹下的<code>.crt</code>文件添加到证书配置文件<code>/etc/ca-certificates.conf</code>文件中：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo dpkg-reconfigure ca-certificates</span><br></pre></td></tr></table></figure>
<p>该命令会让用户选择是否将刚才拷贝到<code>extra</code>子文件夹下的<code>crt</code>文件添加到配置文件，然后会自动使证书生效。<br>也可以直接手动在<code>/etc/ca-certificates.conf</code>文件中添加一行<code>extra/foo.crt</code>。然后运行以下命令更新系统根证书：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo update-ca-certificates</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>导入证书后那些在导入证书前就已经运行服务需要将相应服务重启后才能使用系统新证书，例如<code>docker</code>，当然可以直接重启下系统</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://askubuntu.com/questions/73287/how-do-i-install-a-root-certificate">https://askubuntu.com/questions/73287/how-do-i-install-a-root-certificate</a></li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker可用的镜像加速器</title>
    <url>/2017/10/14/docker-install-registry-mirrors/</url>
    <content><![CDATA[<h3 id="普通用户无法运行docker命令"><a href="#普通用户无法运行docker命令" class="headerlink" title="普通用户无法运行docker命令"></a>普通用户无法运行docker命令</h3><p>需要将用户添加到docker的用户组中，docker在安装完成之后会创建一个名为docker的用户组：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo usermod -aG docker your_username</span><br></pre></td></tr></table></figure>
<p>记得重新登录后生效</p>
<h3 id="无法连接docker服务器下载镜像，或者连接很慢"><a href="#无法连接docker服务器下载镜像，或者连接很慢" class="headerlink" title="无法连接docker服务器下载镜像，或者连接很慢"></a>无法连接docker服务器下载镜像，或者连接很慢</h3><p>由于众所周知的原因，需要使用相应的国内镜像，不同的docker版本修改镜像地址的方法不一样，参考<daocloud>提供的方法，当然它家提供的镜像也很好用（2017/10/14）。<br>Docker版本在1.12或更高：<br>创建或修改<code>/etc/docker/daemon.json</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line">Docker版本在1.8与1.11之间，Ubuntu下修改文件`/etc/default/docker`，我的docker版本为`1.13.1`：</span><br></pre></td></tr></table></figure>
<p>DOCKER_OPTS=”–registry-mirror=<a href="http://your_addr.m.daocloud.io&quot;">http://your_addr.m.daocloud.io&quot;</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">如果之前DOCKER_OPTS中就有配置命令了，直接将上面的配置命令跟在后面即可。</span><br><span class="line">然后重启docker服务即可：</span><br></pre></td></tr></table></figure>
<p>sudo service docker restart</p>
<pre><code>或者使用**阿里云提供的docker镜像也很好用**

### docker国内可用的加速镜像

* 官方国内镜像站  : `https://registry.docker-cn.com`
* 网易docker镜像站: `http://hub-mirror.c.163.com`
* ustc的docker镜像: `https://docker.mirrors.ustc.edu.cn`
* daocloud镜像    : `http://&#123;your_id&#125;.m.daocloud.io`
* aliyun的镜像    : `https://&#123;your_id&#125;.mirror.aliyuncs.com`  **重点推荐**</code></pre>]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Git submodule使用方法</title>
    <url>/2017/08/18/git-submodule/</url>
    <content><![CDATA[<p>git的submodule可以用于在项目中添加子项目，这样就可以让主项目可以引用子项目的同时，子项目又可以进行独立的版本控制管理。当子项目有了更新之后，可以便捷的在主项目中对相应子项目进行更新。</p>
<span id="more"></span>

<h2 id="查看submodule-状态"><a href="#查看submodule-状态" class="headerlink" title="查看submodule 状态"></a>查看submodule 状态</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git submodule</span><br><span class="line"># or</span><br><span class="line">git submodule status</span><br></pre></td></tr></table></figure>

<h2 id="添加submodule"><a href="#添加submodule" class="headerlink" title="添加submodule"></a>添加submodule</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git submodule add [-b master] [remote_repo] [dest_dir]</span><br><span class="line">eg:</span><br><span class="line">git submodule add https://github.com/test/test.git libs/lib1  # 将test添加到本项目根目录下libs/lib1，lib1中即为test项目的根目录</span><br></pre></td></tr></table></figure>
<p>上面的命令会将仓库地址remote_repo项目添加到当前项目的dest_dir文件夹。执行完成之后会在当前项目根目录中多一个<code>.gitmodules</code>文件，并在<code>.git/config</code>中添加<code>submodule</code>字段。实际上执行的内容是首先将项目克隆到指定目录，然后在刚才说的两个文件中进行子模块的注册。所以该操作相当于修改了当前项目，所以可以使用<code>git status</code>查看到新添加了一个目录和一个<code>.gitmodules</code>文件。<br>现在直接添加并提交当前项目的修改就完成了子模块的添加</p>
<h2 id="克隆带有submodule的项目"><a href="#克隆带有submodule的项目" class="headerlink" title="克隆带有submodule的项目"></a>克隆带有submodule的项目</h2><p>两种方式：</p>
<h3 id="先克隆主项目再更新子模块"><a href="#先克隆主项目再更新子模块" class="headerlink" title="先克隆主项目再更新子模块"></a>先克隆主项目再更新子模块</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone [remote_repo] [dest_dir]  # 克隆主项目</span><br><span class="line">cd dest_dir</span><br><span class="line">git submodule init  # 在主项目中注册子模块</span><br><span class="line">git submodule update # 根据注册过的子模块更新各子模块</span><br></pre></td></tr></table></figure>
<p>直接克隆再有子模块的项目时只会建立子模块的目录，并不会把子模块克隆回来，<code>.git/config</code>中也没有<code>submodule</code>字段，此时使用<code>git submodule</code>查看子模块时，可以看到它们<code>commit id</code>前面会有个<code>-</code>。只有执行了后面子模块的<code>init</code>命令后才会在<code>.git/config</code>中注册子模块。<code>update</code>命令执行完才会将子模块拉回主项目中，此时使用<code>git submodule</code>可以看到<code>commit id</code>前面没有了<code>-</code>。<br>对于克隆之后的项目，也可以将<code>init</code>和<code>update</code>一起执行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git submodule update --init --recursive</span><br></pre></td></tr></table></figure>

<h3 id="递归克隆子模块"><a href="#递归克隆子模块" class="headerlink" title="递归克隆子模块"></a>递归克隆子模块</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone --recurse-submodules [remote_repo] [dest_dir]  # 克隆项目remote_repo并递归克隆其子模块</span><br></pre></td></tr></table></figure>
<p>等价于上面的那些命令</p>
<p><strong>注意：此时子模块位于临时分支，不在主分支上</strong></p>
<h2 id="更新submodule"><a href="#更新submodule" class="headerlink" title="更新submodule"></a>更新submodule</h2><p><strong>上面说了拉回来的子模块位于临时分支，不在主分支上</strong><br>如果在主项目中的子模块发生了更新，需要首先进入子模块，将子模块切换到主分支，再拉回来。<br>如果有多个子模块，可以使用如下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git submodule foreach [command]</span><br></pre></td></tr></table></figure>
<p>command会在所有子模块中执行，所以可以如下更新所有子模块：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git submodule foreach git checkout master</span><br><span class="line">git submodule foreach git pull</span><br></pre></td></tr></table></figure>
<p>然后在主模块中提交更新即可</p>
<h2 id="删除submodule"><a href="#删除submodule" class="headerlink" title="删除submodule"></a>删除submodule</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git submodule deinit &lt;submodule path&gt;  # 取消submodule的注册，即从`.gitmodules`中删除</span><br><span class="line">git rm &lt;submodule path&gt; &amp;&amp; git commit  # 删除相应子模块的目录</span><br><span class="line">git rm --cached &lt;submodule path&gt;  # 撤消并删除索引中的路径</span><br><span class="line">rm -rf .git/modules/&lt;submodule path&gt;  # 删除相应的子模块文件</span><br></pre></td></tr></table></figure>
<p><code>git submodule deinit &lt;submodule path&gt;</code> 会取消submodule的注册，即从<code>.gitmodules</code>中删除相应的子模块。</p>
<h2 id="其他submodule命令"><a href="#其他submodule命令" class="headerlink" title="其他submodule命令"></a>其他submodule命令</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git submodule [--quiet] sync [--recursive] [--] [&lt;path&gt;]</span><br></pre></td></tr></table></figure>
<p>同步已注册的submodule的URL</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://git-scm.com/docs/git-submodule">git-submodule</a></li>
<li><a href="https://git-scm.com/book/en/v2/Git-Tools-Submodules">Git Tools - Submodules</a></li>
<li><a href="http://www.kafeitu.me/git/2012/03/27/git-submodule.html">Git Submodule使用完整教程</a></li>
</ul>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>Shell脚本简单入门</title>
    <url>/2017/04/23/shell-script/</url>
    <content><![CDATA[<p>Shell脚本简单入门，如果你分不清shell是什么，此文一定不适合你。毕竟只花了十多分钟看的教程，不会涉及细节，细节将在以后的使用中逐渐以示例形式给出。</p>
<span id="more"></span>

<p>PS:借来的东西，果然迟早是要还的。刚在linux下学习时，为了批量处理，当时会C语言，就用C语言编个程序实现，心想虽然不会shell，不是也很方便嘛。然后会了C++，发现比C用起来方便多了。再然后越来越的批处理工作需要程序，C++有点太大杀气了，Python这么火，而且也很强大，学了肯定不白学，遂各种自动化的工作就交给了Python。然后最近发现Python这货也有点太大杀所了，我只是想写个简单的自动化指令而已。所以现在来还当年欠下的shell。假如你也如此，还是花上几十分钟，掌握一把小刀，何乐而不为呢。</p>
<h2 id="关于"><a href="#关于" class="headerlink" title="关于"></a>关于</h2><p>记得脚本最前面添加shell解释器，通常为sh、bash，其他的不常见，依然先给个HelloWorld</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/sh</span></span><br><span class="line">echo &quot;HelloWorld&quot; #我是注释</span><br></pre></td></tr></table></figure>
<p>然后给了执行权限即可直接执行，或者手动通过<code>sh script.sh</code>来执行，shell脚本后缀通常为<code>.sh</code>。当然Linux下面文件只要有了可执行权限（chmod +x file），什么后缀都没有影响。<br>我们平时使用的terminal其实就是个shell解释器的交互窗口，所以学习shell编程直接开个terminal就可以开编了。shell中可以直接执行任何linux/unix命令（其实这些命令就是shell内部的）正是它方便之处</p>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>shell变量不分类型，默认都是字符串。单引号的字符串类似raw字符串，不能解析转义字符及变量。不被引号引住的字符串中不能用空格。<br>变量定义形如：变量名=值，等号中间不能有空格。变量名要求即编程语言的常规要求<br>变量引用则直接在变量名前加<code>$</code>符号，为了限定shell解释器解释变量名的边界可以用大括号包围变量名：${变量名}<br>ex：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">var=&quot;maxwi&quot;</span><br><span class="line">echo &quot;Hello $&#123;var&#125;.com&quot;</span><br></pre></td></tr></table></figure>

<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p><strong>在shell的语句中间执行命令只需要将命令放在”`”（ESC下面那个键）之间即可，当然任何命令都可以在命令前面没有内容时直接执行：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd $HOME;ls #进入个人目录并执行ls</span><br><span class="line">var=`ls` #ls结果以空格分隔的字符串返回给var</span><br><span class="line">for file in $var  # for...in循环输出以空格分隔的字符串内容</span><br><span class="line">do</span><br><span class="line">  echo $file</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<p>多个命令通过分号（;）并入一行执行</p>
<p><strong>只读变量</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">var=8</span><br><span class="line">readonly var</span><br><span class="line">var=9 #出错</span><br></pre></td></tr></table></figure>

<p><strong>删除变量</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">unset var</span><br></pre></td></tr></table></figure>

<p><strong>拼接字符直接将其放在一起即可</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">a=I</span><br><span class="line">b=&#x27;love&#x27;</span><br><span class="line">c=&quot;China&quot;</span><br><span class="line">d=&quot;$a $b $c&quot;</span><br><span class="line">echo $d</span><br></pre></td></tr></table></figure>
<p>输出：<code>I love China</code></p>
<p><strong>获取字符串长</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo $&#123;#var&#125;</span><br></pre></td></tr></table></figure>

<p><strong>字符串切片</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo $&#123;var:2:5&#125;</span><br></pre></td></tr></table></figure>
<p>注意字符串中字符是从0计数，上述切片内容是从第3个字符到第6个字符，包含位置2和5位置上的字符</p>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>数组下标从0开始，使用小括号（<code>()</code>）定义数组，元素以空格或回车分隔：<code>arr=(val1, val2, val3)</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">&#123;arr[index]&#125; <span class="comment"># 使用下标获取相应元素</span></span></span><br><span class="line">echo $&#123;arr[@]&#125; or echo $&#123;arr[*]&#125; # 获取数组中的所有元素</span><br><span class="line">echo $&#123;#arr[@]&#125; # 获取数组长度，当然里面可以是  *</span><br></pre></td></tr></table></figure>


<p><code>for...in</code>循环可以用于遍历数组中的元素</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">var=(1 2 3 I &#x27;love&#x27; &quot;China&quot;)</span><br><span class="line">for v in $&#123;var[@]&#125;</span><br><span class="line">do</span><br><span class="line">  str=&quot;$str $v&quot;</span><br><span class="line">done</span><br><span class="line">echo $str</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 2 3 I love China</span><br></pre></td></tr></table></figure>

<h2 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h2><p>通过<code>$n</code>来访问传递给shell脚本的命令行参数，<code>$0</code>为脚本本身，下面为几个特殊的参数：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>$#</td>
<td>传递到脚本的参数个数</td>
</tr>
<tr>
<td>$*</td>
<td>以一个单字符串显示所有向脚本传递的参数。如”$*”用「”」括起来的情况、以”$1 $2 … $n”的形式输出所有参数。即无法用for…in遍历每一个元素</td>
</tr>
<tr>
<td>$$</td>
<td>脚本运行的当前进程ID号</td>
</tr>
<tr>
<td>$!</td>
<td>后台运行的最后一个进程的ID号</td>
</tr>
<tr>
<td>$@</td>
<td>与$*相同，但是使用时加引号，并在引号中返回每个参数。 如”$@”用「”」括起来的情况、以”$1” “$2” … “$n” 的形式输出所有参数。</td>
</tr>
<tr>
<td>$-</td>
<td>显示Shell使用的当前选项，与set命令功能相同。</td>
</tr>
<tr>
<td>$?</td>
<td>显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。”</td>
</tr>
</tbody></table>
<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><h3 id="数字关系运算符"><a href="#数字关系运算符" class="headerlink" title="数字关系运算符"></a>数字关系运算符</h3><p>该运算符只支持数字：</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>说明</th>
<th>举例</th>
</tr>
</thead>
<tbody><tr>
<td>-eq</td>
<td>检测两个数是否相等，相等返回 true。</td>
<td>[ $a -eq $b ] 返回 false。</td>
</tr>
<tr>
<td>-ne</td>
<td>检测两个数是否相等，不相等返回 true。</td>
<td>[ $a -ne $b ] 返回 true。</td>
</tr>
<tr>
<td>-gt</td>
<td>检测左边的数是否大于右边的，如果是，则返回 true。</td>
<td>[ $a -gt $b ] 返回 false。</td>
</tr>
<tr>
<td>-lt</td>
<td>检测左边的数是否小于右边的，如果是，则返回 true。</td>
<td>[ $a -lt $b ] 返回 true。</td>
</tr>
<tr>
<td>-ge</td>
<td>检测左边的数是否大于等于右边的，如果是，则返回 true。</td>
<td>[ $a -ge $b ] 返回 false。</td>
</tr>
<tr>
<td>-le</td>
<td>检测左边的数是否小于等于右边的，如果是，则返回 true。</td>
<td>[ $a -le $b ] 返回 true。</td>
</tr>
</tbody></table>
<p>也可以使用<code>==</code>和<code>!=</code></p>
<p>注意使用时必须使用方括号括住<br>eg:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">a=1</span><br><span class="line">b=2</span><br><span class="line">if [ $a -eq $b ]</span><br><span class="line">then</span><br><span class="line">   echo &quot;$a -eq $b : a 等于 b&quot;</span><br><span class="line">else</span><br><span class="line">   echo &quot;$a -eq $b: a 不等于 b&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<h3 id="布尔运算符"><a href="#布尔运算符" class="headerlink" title="布尔运算符"></a>布尔运算符</h3><ul>
<li><code>!</code> 取非，如[!false]返回true</li>
<li><code>-o</code> 或运算</li>
<li><code>-a</code> 与运算</li>
</ul>
<h3 id="逻辑运行符"><a href="#逻辑运行符" class="headerlink" title="逻辑运行符"></a>逻辑运行符</h3><ul>
<li><code>&amp;&amp;</code> 逻辑与</li>
<li><code>||</code> 逻辑或</li>
</ul>
<h3 id="字符串比较运算符"><a href="#字符串比较运算符" class="headerlink" title="字符串比较运算符"></a>字符串比较运算符</h3><table>
<thead>
<tr>
<th>运算符</th>
<th>说明</th>
<th>举例</th>
</tr>
</thead>
<tbody><tr>
<td>=</td>
<td>检测两个字符串是否相等，相等返回 true。</td>
<td>[ $a = $b ] 返回 false。</td>
</tr>
<tr>
<td>!=</td>
<td>检测两个字符串是否相等，不相等返回 true。</td>
<td>[ $a != $b ] 返回 true。</td>
</tr>
<tr>
<td>-z</td>
<td>检测字符串长度是否为0，为0返回 true。</td>
<td>[ -z $a ] 返回 false。</td>
</tr>
<tr>
<td>-n</td>
<td>检测字符串长度是否为0，不为0返回 true。</td>
<td>[ -n $a ] 返回 true。</td>
</tr>
<tr>
<td>str</td>
<td>检测字符串是否为空，不为空返回 true。</td>
<td>[ $a ] 返回 true。</td>
</tr>
</tbody></table>
<h3 id="文件测试运算符"><a href="#文件测试运算符" class="headerlink" title="文件测试运算符"></a>文件测试运算符</h3><p>常用的几个</p>
<ul>
<li><code>[-f file]</code> 检测文件是否为普通文件，既不能是目录也不能是设备</li>
<li><code>[-d file]</code> 检测是否为目录</li>
<li><code>[-s file]</code> 检测文件是否为空</li>
<li><code>[-e file]</code> 检测文件是否存在</li>
<li><code>[-r file]</code> 检测文件是否可读</li>
<li><code>[-w file]</code> 检测文件是否可写</li>
<li><code>[-x file]</code> 检测文件是否可执行</li>
</ul>
<h3 id="通过expr实现的算术运行符"><a href="#通过expr实现的算术运行符" class="headerlink" title="通过expr实现的算术运行符"></a>通过expr实现的算术运行符</h3><p>expr命令可以执行算术表达式并返回结果<br>如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">a=1</span><br><span class="line">b=2</span><br><span class="line"></span><br><span class="line">val=`expr $a + $b`</span><br><span class="line"></span><br><span class="line">val=`expr 9 \* $b`</span><br></pre></td></tr></table></figure>

<p>注意乘运算需要有转义符，表达示之间必须用空格隔开</p>
<h2 id="输入、输出控制"><a href="#输入、输出控制" class="headerlink" title="输入、输出控制"></a>输入、输出控制</h2><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><p><code>echo</code>默认输出会换行，可以使用<code>\c</code>转义实现不换行<br>可以通过<code>echo</code>直接回显命令执行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo `date`</span><br></pre></td></tr></table></figure>
<p>可以使用linux下类型C语言中printf的格式控制输出命令，详见<code>man printf</code></p>
<h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><p>通过<code>read</code>读取输入：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo &#x27;Input number&#x27;</span><br><span class="line">read a b c d</span><br></pre></td></tr></table></figure>
<p>如果输入为<code>1 2 3 4 5 6</code>，则a,b,c分别为1,2,3，但d是<code>4 5 6</code></p>
<h3 id="文件重定向"><a href="#文件重定向" class="headerlink" title="文件重定向"></a>文件重定向</h3><p>shell的重定向功能非常强大，重定向命令列表如下：</p>
<p>| 命令 | 说明 |<br>|—|—|—| |<br>| <code>command &gt; file</code> |将标准输出重定向到file。 |<br>| <code>command &lt; file</code> |将标准输入重定向到file。 |<br>| <code>command &gt;&gt; file</code> | 将输出以追加的方式重定向到 file。 |<br>| <code>n&gt;file</code> | 将文件描述符为n的文件重定向到 file。<strong>注意不能有空格，下同</strong> |<br>| <code>n&gt;&gt;file</code> | 将文件描述符为 n 的文件以追加的方式重定向到 file。 |<br>| <code>n&gt;&amp;m</code> | 将输出流n合并到m。可以理解为使用&amp;n来引用名为n的文件描述符，即将文件描述符n重定向到文件描述符m |<br>| <code>n&lt;&amp;m</code> | 将输入流m合并到n。 |<br>| <code>&lt;&lt; tag</code> | 将开始标记 tag 和结束标记 tag 之间的内容作为输入。</p>
<p><strong>文件描述符0通常是标准输入（stdin），1是标准输出（stdout），2是标准错误输出（stderr），<code>/dev/null为黑洞文件，所有写入到它的内容都会被丢弃</code>，如果不指定数字，则默认为输出为1，输入为0</strong><br>查看系统文件描述符路径：<code>ls /proc/self/fd/ -l</code><br>几个特殊的用法：<br><strong><code>n&gt;&amp;-</code></strong><br><code>n&gt;&amp;-</code>表示关闭输出文件描述符n，如<code>1&gt;&amp;-</code>或<code>&gt;&amp;-</code>表示关闭标准输出；类似的<code>n&lt;&amp;-</code>表示关闭输入文件描述符n，如<code>0&lt;&amp;-</code>或<code>&lt;&amp;-</code>表示关闭标准输出。</p>
<p><strong><code>|&amp;</code></strong><br><code>|&amp;</code>等价于<code>2&gt;&amp;1</code>，即将标准错误合并到标准输出并作为管道的标准输入，输出结果中标准错误将在标准输出的前面，用法为cmd1 |&amp; cmd2，cmd2将以cmd1的输出和错误输出作为输入。</p>
<p><strong><code>&amp;&gt;/dev/null</code></strong><br><code>&amp;&gt;/dev/null</code>等价于<code>&gt;/dev/null 2&gt;&amp;1</code>，即将标准输出和错误输出重定向到null，什么也不会输出</p>
<p><strong><code>&gt;/dev/null</code></strong><br>等价于<code>1&gt;/dev/null</code>，即将标准输出重定向到null，只会输出标准错误</p>
<p>举例：<br>1.<code>cat ss.py &gt; cat_test.txt</code>，获取文件ss.py中的内容，并将其重定向到文件cat_test.txt，由于没有指定文件描述符，所以默认为将cat输出到标准输出中的内容重定向到文件。其等价于<code>cat ss.py 1&gt;cat_test.txt</code>。<br>2.<code>ls tes ss.py 1&gt;out.txt 2&gt;err.txt</code> 表示将标准输出输出到文件out.txt，标准错误输出到文件err.txt<br>3.<code>ls tes ss.py &gt; oe.txt 2&gt;&amp;1</code> 表示将标准错误输出重定向到标准输出，并将标准输出重定向到文件oe.txt。<br>4.<code>ls tes ss.py 1&gt;&amp;- 2&gt;&amp;-</code> 关闭标准输出和错误输出，效果等价于以下几个命令<code>ls tes ss.py 1&gt;/dev/null 2&gt;/dev/null</code>，<code>ls tes ss.py 1&gt;/dev/null 2&gt;&amp;1</code>，<code>ls tes ss.py &gt;/dev/null 2&gt;&amp;1</code>， <code>ls tes ss.py &amp;&gt;/dev/null</code><br>5.<code>cat &gt; t.txt</code> 将标准输入重定向到t.txt，输入内容之后，通过ctrl+d发送文件结束符停止输入。<br>6.<code>cat &gt; t.txt &lt; ss.py</code> 从ss.py读取数据，并重定向到t.txt</p>
<p><strong>Here Document是shell用于将delimiter之间的内容重定向到命令的特殊重定向：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">command &lt;&lt; delimiter</span><br><span class="line">    document</span><br><span class="line">delimiter</span><br></pre></td></tr></table></figure>
<p>注意，第二个<code>delimiter</code>必须顶格写，这样其之间的document内容将都会传递给command</p>
<p><strong>修改当前shell session下的所有命令重定向</strong><br><code>exec 1&gt;out.txt</code>，执行之后会将当前shell窗口下执行的所有命令的标准输出内容重定向到文件out.txt，而在命令行窗口中不会输出任何内容。可以通过关闭当前shell终端并重新开一个来解决。也可以通过提前将标准输出绑定到一个新的文件描述符，重定向到文件之后，再将其绑回来的方式解决。<br>如：<br><code>exec 6&gt;&amp;1</code>，将6绑定到标准输出1，可以通过<code>ls /proc/self/fd/ -l</code>查看。<br><code>exec 1&gt;out.txt</code>，进行一些操作，发现没有输出，实际上结果都在out.txt中<br><code>exec 1&gt;&amp;6</code>，将1绑定到文件描述符6，其实就是最初是标准输出<br><code>exec 6&gt;&amp;-</code> 现关闭文件描述符6即可</p>
<h2 id="控制流"><a href="#控制流" class="headerlink" title="控制流"></a>控制流</h2><h3 id="if"><a href="#if" class="headerlink" title="if"></a>if</h3><p>一个完整的if控制流程：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">if condition1</span><br><span class="line">then</span><br><span class="line">    command1</span><br><span class="line">elif condition2</span><br><span class="line">then</span><br><span class="line">    command2</span><br><span class="line">else</span><br><span class="line">    commandN</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<h3 id="for-in"><a href="#for-in" class="headerlink" title="for..in"></a>for..in</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for var in item1 item2 ... itemN</span><br><span class="line">do</span><br><span class="line">    command1</span><br><span class="line">    command2</span><br><span class="line">    ...</span><br><span class="line">    commandN</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<p>列表也可以是文件名</p>
<h3 id="for"><a href="#for" class="headerlink" title="for()"></a>for()</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>((i=1;i&lt;=10;i++));<span class="keyword">do</span> <span class="built_in">echo</span> $(<span class="built_in">expr</span> <span class="variable">$i</span> \* 4);<span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<h3 id="while"><a href="#while" class="headerlink" title="while"></a>while</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">while condition</span><br><span class="line">do</span><br><span class="line">    command</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<p>三种死循环：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">while :</span><br><span class="line">do</span><br><span class="line">    command</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">while true</span><br><span class="line">do</span><br><span class="line">    command</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">for (( ; ; ))</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="until"><a href="#until" class="headerlink" title="until"></a>until</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">until condition</span><br><span class="line">do</span><br><span class="line">    command</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<p>条件为真是停止，类似do..while，循环体至少执行一次</p>
<h3 id="case"><a href="#case" class="headerlink" title="case"></a>case</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">case 值 in</span><br><span class="line">模式1)</span><br><span class="line">    command1</span><br><span class="line">    command2</span><br><span class="line">    ...</span><br><span class="line">    commandN</span><br><span class="line">    ;;</span><br><span class="line">模式2）</span><br><span class="line">    command1</span><br><span class="line">    command2</span><br><span class="line">    ...</span><br><span class="line">    commandN</span><br><span class="line">    ;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure>
<p>每一个格式后面为右括号结束，模式匹配后一直执行，直到<code>;;</code>（与break功能一样）然后执行<code>*)</code>后面的命令，不再匹配 其他选项。</p>
<p><strong>支持break、continue</strong></p>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>函数的定义方式为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func() &#123;</span><br><span class="line">  command</span><br><span class="line">  return val</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用直接函数名后跟参数列表即可：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">func arg1 arg2</span><br></pre></td></tr></table></figure>
<p>参数性质与上面说的命令行参数一样，也有那几个特殊参数<br>注意参数超过10个时必须使用<code>&#123;&#125;</code>引用，如<code>$&#123;10&#125;</code><br>函数返回值通过$?</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">add() &#123;</span><br><span class="line">  return $(($1+$2))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">add 3 5</span><br><span class="line">echo $?</span><br></pre></td></tr></table></figure>

<h2 id="Shell多脚本内容共享"><a href="#Shell多脚本内容共享" class="headerlink" title="Shell多脚本内容共享"></a>Shell多脚本内容共享</h2><p>当有两个shell脚本文件时，可以通过<code>. filename</code>或<code>source filename</code>来引用另一个文件中的代码，其实就是同一个shell session之中信息是共享的。</p>
<h2 id="其他相关内容"><a href="#其他相关内容" class="headerlink" title="其他相关内容"></a>其他相关内容</h2><h3 id="eval"><a href="#eval" class="headerlink" title="eval"></a>eval</h3><p>脚本中需要使用到的命令<br>用法为<code>eval cmd args</code><br>该命令后面跟的所有内容都做为其参数，它会对后面的内容（即cmd args）进行两次扫描，第一次扫描将其中的变量替换为实际值，所以如果args中含有需要在bash中执行的以$开头的内容，应该加上转换符（<code>\</code>），以避免被替换，例如如果cmd为awk，而awk是通过$来进行参数过滤的。第二次扫描时将eval后面的所有内容当作同一个命令组合来执行，相当于你直接在命令行中执行该命令。例如脚本如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">a=5</span><br><span class="line">cmd=&quot;echo $a | cat &gt; tcat.txt&quot;</span><br><span class="line">eval $cmd</span><br></pre></td></tr></table></figure>
<p>如果对cmd的执行不通过eval调用，而是直接<code>$cmd</code>，输出结果为<code>5 | cat &gt; tcat.txt</code>。这显然不是我们想要的，shell将echo后面的所有内容当成了echo参数来执行。这种情况就需要使用eval。</p>
<h3 id="exec"><a href="#exec" class="headerlink" title="exec"></a>exec</h3><p>与source功能有点相反，source命令会在当前shell进程的上下文件环境中执行各命令。而exec虽然也不会创建新的进程，但会清除当前shell进程的上下文件内容，并执行相应命令。当然它也可以用来对文件描述符进行操作，上文已经提及。</p>
<h3 id="declare-typeset"><a href="#declare-typeset" class="headerlink" title="declare(typeset)"></a>declare(typeset)</h3><p>内建命令declare与typeset功能类似，用于为变量指定类型，因为默认所有变量都会被当成字符串，当然数组除外。<br>用法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">declare [-aAfFgilnrtux] [-p] [name[=value] ...]</span><br><span class="line">typeset [-aAfFgilnrtux] [-p] [name[=value] ...]</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">a=1</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">b=2</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> <span class="variable">$a</span>+<span class="variable">$b</span></span></span><br><span class="line">1+2</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">declare</span> -i a=1</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">declare</span> -i b=2</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">declare</span> -i c</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">c=<span class="variable">$a</span>+<span class="variable">$b</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> <span class="variable">$c</span></span></span><br><span class="line">3</span><br></pre></td></tr></table></figure>


<h3 id="local"><a href="#local" class="headerlink" title="local"></a>local</h3><p>用于在shell函数内部声明该变量为局部变量，只对当前函数或其子进程有效。用法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">local [option] [name[=value] ...]</span><br></pre></td></tr></table></figure>
<p>option为declare可以接受的选项。</p>
<p><strong>一不小心这里就会有一个很大的坑，因为默认情况下shell中的变量作用域是全局的，所以你一个for用了i，然后又在另一个函数调用中用了i，那这个i就会被前面的i覆盖，所以尽量在函数中有类似情况的地方用local</strong></p>
<h2 id="用例"><a href="#用例" class="headerlink" title="用例"></a>用例</h2><h3 id="输出系统中的所有磁盘"><a href="#输出系统中的所有磁盘" class="headerlink" title="输出系统中的所有磁盘"></a>输出系统中的所有磁盘</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">disks=`fdisk -l | grep &#x27;Disk /dev/&#x27; | grep -oP &#x27;/dev/.&#123;3&#125;&#x27;`</span><br><span class="line">for disk in $disks</span><br><span class="line">do</span><br><span class="line">    echo &#x27;**&#x27;</span><br><span class="line">    echo $disk</span><br><span class="line">    echo &#x27;**&#x27;</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>1.<a href="https://www.shellscript.sh/">https://www.shellscript.sh/</a><br>2.<a href="http://ryanstutorials.net/bash-scripting-tutorial/">http://ryanstutorials.net/bash-scripting-tutorial/</a><br>3.<a href="http://www.runoob.com/linux/">http://www.runoob.com/linux/</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>Java通过JNI调用C/C++动态链接库之参数传递及结果返回</title>
    <url>/2017/04/20/java-jni-cpp-passing-arguments/</url>
    <content><![CDATA[<p>接上一篇关于JNI的基本入门<a href="/2017/04/19/java-jni-cpp-hello/" title="Java通过JNI调用C&#x2F;C++动态链接库之HelloWorld">Java通过JNI调用C&#x2F;C++动态链接库之HelloWorld</a>，简述给JNI函数传递参数，以及通过JNI函数返回值的方式。</p>
<span id="more"></span>
<h2 id="JNI类型映射"><a href="#JNI类型映射" class="headerlink" title="JNI类型映射"></a>JNI类型映射</h2><p>首先来回顾一下上一篇基础文章中通过javah生成的头文件的以下内容：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Class:     hello</span></span><br><span class="line"><span class="comment"> * Method:    helloWorld</span></span><br><span class="line"><span class="comment"> * Signature: ()V</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">JNIEXPORT <span class="type">void</span> JNICALL <span class="title">Java_hello_helloWorld</span></span></span><br><span class="line"><span class="function">  <span class="params">(JNIEnv *, jobject)</span></span>;</span><br></pre></td></tr></table></figure>
<p>发现注释中给出了类名<code>hello</code>，是我们JAVA程序的类名，后面跟着方法名以及方法的签名，注意方法的签名类型为<code>()V</code>，表示该方法不接收任何参数，且返回类型为void，即没有返回值。<br>JNI定义了一些基本类型用于在java与native代码之间的映射，这些基本类型都是<code>j</code>开头，后面跟java中的实际类型，具体的基本类型及方法签名类型如下表所示：</p>
<table>
<thead>
<tr>
<th>Native类型</th>
<th>Java类型</th>
<th>描述</th>
<th>签名类型</th>
</tr>
</thead>
<tbody><tr>
<td>unsigned char</td>
<td>jboolean</td>
<td>unsigned 8 bits</td>
<td>Z</td>
</tr>
<tr>
<td>signed char</td>
<td>jbyte</td>
<td>signed 8 bits</td>
<td>B</td>
</tr>
<tr>
<td>unsigned short</td>
<td>jchar</td>
<td>unsigned 16 bits</td>
<td>C</td>
</tr>
<tr>
<td>short</td>
<td>jshort</td>
<td>signed 16 bits</td>
<td>S</td>
</tr>
<tr>
<td>long</td>
<td>jint</td>
<td>signed 32 bits</td>
<td>I</td>
</tr>
<tr>
<td>long long <code>__int64</code></td>
<td>jlong</td>
<td>signed 64 bits</td>
<td>J</td>
</tr>
<tr>
<td>float</td>
<td>jfloat</td>
<td>32 bits</td>
<td>F</td>
</tr>
<tr>
<td>double</td>
<td>jdouble</td>
<td>64 bits</td>
<td>D</td>
</tr>
<tr>
<td>void</td>
<td></td>
<td></td>
<td>V</td>
</tr>
</tbody></table>
<p>方法签名的形式即为<code>(参数签名)返回值类型签名</code>。例如一个形如<code>double func(int a, int b)</code>的方法签名为<code>(II)D</code><br>另外还有几个比较特殊的签名，如<code>object</code>签名为<code>L&#123;用/分割的完整类名&#125;</code>如<code>Ljava/lang/String</code>表示一个String对象。<code>Array</code>的签名为<code>[&#123;相应类型的签名&#125;</code>，如<code>[D</code>，表示类型为D的数组，<code>[Ljava/lang/String</code>表示String对象的数组。<br>当然JNI也定义了很多引用类型的映射，其中<code>jobject</code>对应于<code>java.lang.Object</code>，以及其之类型：</p>
<ul>
<li><code>jclass</code>—<code>java.lang.Class</code></li>
<li><code>jstring</code>—<code>java.lang.String</code></li>
<li><code>jthrowable</code>—<code>java.lang.Throwable</code></li>
<li><code>jarray</code>与java中的Array对应，由于Array在java中支持8种基本数据类型，所以相应的有8种Array，分别为<code>jintArray</code>、<code>jbyteArray</code>、<code>jshortArray</code>、<code>jlongArray</code>、<code>jfloatArray</code>、<code>jdoubleArray</code>、<code>jcharArray</code>和<code>jbooleanArray</code>。以及一个对象类型的Array：<code>jobjectArray</code>。</li>
</ul>
<p>查看<code>jni.h</code>头文件会发现里面都是使用typedef进行的定义：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 头文件&quot;jni.h&quot;中的声明</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span>   jboolean;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">short</span>  jchar;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">short</span>           jshort;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">float</span>           jfloat;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">double</span>          jdouble;</span><br><span class="line"><span class="keyword">typedef</span> jint            jsize;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">_jobject</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_jobject</span> *jobject;</span><br><span class="line"><span class="keyword">typedef</span> jobject jclass;</span><br><span class="line"><span class="keyword">typedef</span> jobject jthrowable;</span><br><span class="line"><span class="keyword">typedef</span> jobject jstring;</span><br><span class="line"><span class="keyword">typedef</span> jobject jarray;</span><br><span class="line"><span class="keyword">typedef</span> jarray jbooleanArray;</span><br><span class="line"><span class="keyword">typedef</span> jarray jbyteArray;</span><br><span class="line"><span class="keyword">typedef</span> jarray jcharArray;</span><br><span class="line"><span class="keyword">typedef</span> jarray jshortArray;</span><br><span class="line"><span class="keyword">typedef</span> jarray jintArray;</span><br><span class="line"><span class="keyword">typedef</span> jarray jlongArray;</span><br><span class="line"><span class="keyword">typedef</span> jarray jfloatArray;</span><br><span class="line"><span class="keyword">typedef</span> jarray jdoubleArray;</span><br><span class="line"><span class="keyword">typedef</span> jarray jobjectArray;</span><br><span class="line"></span><br><span class="line"><span class="comment">//&quot;linux/jni_mh.h&quot;中的声明</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> jint;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _LP64 <span class="comment">/* 64-bit Solaris */</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> jlong;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> jlong;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">signed</span> <span class="type">char</span> jbyte;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>现在可以清楚的知道JNI在java代码和native代码之间做了类型转换，以使两种语言之间的数据类型可以互通。</p>
<h2 id="基本类型参数传递"><a href="#基本类型参数传递" class="headerlink" title="基本类型参数传递"></a>基本类型参数传递</h2><p>举一个例子说明，程序的功能为给java程序传递两个int做为参数，将该参数传递给native函数，native函数累加两个参数之间的数字，然后取平均后将结果返回给java程序并输出。<br><strong>java代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//TestJint.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestJint</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.loadLibrary(<span class="string">&quot;myjint&quot;</span>);  <span class="comment">//载入本地的动态链接库</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">native</span> <span class="type">double</span> <span class="title function_">avg</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>;    <span class="comment">//声明一个本地方法，接受2个int变量做为参数，返回其double类型的累加和的平均值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (args.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Input Error!&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> Integer.parseInt(args[<span class="number">0</span>]);</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> Integer.parseInt(args[<span class="number">1</span>]);</span><br><span class="line">        System.out.println(a + <span class="string">&quot; + ... + &quot;</span> + b + <span class="string">&quot; / &quot;</span> + (b - a + <span class="number">1</span>) + <span class="string">&quot; = &quot;</span> + <span class="keyword">new</span> <span class="title class_">TestJint</span>().avg(a, b));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>头文件</strong><br>通过<code>javah</code>生成头文件内容如下：<br><code>TestJint.h</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* DO NOT EDIT THIS FILE - it is machine generated */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;jni.h&gt;</span></span></span><br><span class="line"><span class="comment">/* Header for class TestJint */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _Included_TestJint</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _Included_TestJint</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Class:     TestJint</span></span><br><span class="line"><span class="comment"> * Method:    avg</span></span><br><span class="line"><span class="comment"> * Signature: (II)D</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">JNIEXPORT jdouble JNICALL <span class="title">Java_TestJint_avg</span></span></span><br><span class="line"><span class="function">  <span class="params">(JNIEnv *, jobject, jint, jint)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>可以看到其中的方法签名为<code>(II)D</code>，函数参数列表中多了2个jint类型的形参。</p>
<p><strong>C++代码</strong><br>注意其中传递进行的形参类型都是j开头的JNI类型，而在函数内部则可以使用任何你需要的C++数据结构。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//TestJint.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;TestJint.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">JNIEXPORT jdouble JNICALL <span class="title">Java_TestJint_avg</span><span class="params">(JNIEnv *, jobject, jint a, jint b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">double</span> res = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = a; i &lt;= b; ++i) &#123;</span><br><span class="line">        res += i;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;In C++, the sum &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot; ... &quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; res &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> res / <span class="built_in">double</span>(b - a + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>编译并运行</strong><br>编译动态链接库</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">g++ -fPIC -shared -o libmyjint.so -I /usr/lib/jvm/java-8-oracle/include/ -I /usr/lib/jvm/java-8-oracle/include/linux/ TestJint.cpp</span><br></pre></td></tr></table></figure>

<p>编译java</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">javac TestJint.java</span><br></pre></td></tr></table></figure>

<p>运行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">java -Djava.library.path=. TestJint 5 8</span><br></pre></td></tr></table></figure>
<p>输出为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> In C++, the sum 5 ... 8 = 26</span><br><span class="line">5 + ... + 8 / 4 = 6.5</span><br></pre></td></tr></table></figure>

<h2 id="String类型的参数传递"><a href="#String类型的参数传递" class="headerlink" title="String类型的参数传递"></a>String类型的参数传递</h2><p>String其实与基本类型的参数传递类似，只是需要通过JNIEnv参数调用调用jni中的函数进行转换成符合C/C++的字符串后再操作。因为java中的字符串是以unicode表示，而c/c++中是以utf方式表示。<br>举例说明，实现功能为通过向java程序传递字符串参数，然后该字符串传递给native函数，native函数将其反转后与在native函数中获取到的用户输入一起返回给java，并输出</p>
<p><strong>java程序</strong><br>如下，并没有太大区别：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// TestJstr.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestJstr</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.loadLibrary(<span class="string">&quot;mystr&quot;</span>); <span class="comment">//载入动态库</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//native方法接受一个String对象，该String将由用户从java代码中以命令行参数方式输入</span></span><br><span class="line">    <span class="comment">// 将返回一个C++库中用户输入的字符串加该字符串倒序字符串</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">native</span> String <span class="title function_">andReverse</span><span class="params">(String msg)</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (args.length &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Input Error!&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TestJstr</span>().andReverse(args[<span class="number">0</span>]);</span><br><span class="line">        System.out.println(<span class="string">&quot;In Java, Result: &quot;</span> + res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>生成头文件</strong><br>通过javah生成头文件，头文件中的函数声明如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Class:     TestJstr</span></span><br><span class="line"><span class="comment"> * Method:    andReverse</span></span><br><span class="line"><span class="comment"> * Signature: (Ljava/lang/String;)Ljava/lang/String;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">JNIEXPORT jstring JNICALL <span class="title">Java_TestJstr_andReverse</span></span></span><br><span class="line"><span class="function">  <span class="params">(JNIEnv *, jobject, jstring)</span></span>;</span><br></pre></td></tr></table></figure>
<p>可以看到方法签名与我们之前的讨论一样，函数接收一个jstring参数</p>
<p><strong>C++代码</strong><br>注意里面的函数调用与oracle官方给的文档并不完全致，可以通过查看jni.h头文件来获取相关函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//TestJstr.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;TestJstr.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">JNIEXPORT jstring JNICALL <span class="title">Java_TestJstr_andReverse</span><span class="params">(JNIEnv *env, jobject obj, jstring jStr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//将Java的String转成C语言的char *</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *cStr = env-&gt;<span class="built_in">GetStringUTFChars</span>(jStr, <span class="literal">NULL</span>); </span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == cStr) <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">//如果转换失败，则返回空</span></span><br><span class="line"></span><br><span class="line">    std::string tstr = cStr;  <span class="comment">//拷贝一份字符串</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//释放cStr，如果不释放，该数组会一直存在，并且不会被自动回收</span></span><br><span class="line">    env-&gt;<span class="built_in">ReleaseStringUTFChars</span>(jStr, cStr);  </span><br><span class="line"></span><br><span class="line">    std::<span class="built_in">reverse</span>(tstr.<span class="built_in">begin</span>(), tstr.<span class="built_in">end</span>()); <span class="comment">//反转字符串</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//在C++中获取用户输入的字符串</span></span><br><span class="line">    std::string ustr;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Enter a string in C++: &quot;</span>;</span><br><span class="line">    std::cin &gt;&gt; ustr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将c风格字符串转换成jstring并返回</span></span><br><span class="line">    <span class="keyword">return</span> env-&gt;<span class="built_in">NewStringUTF</span>((<span class="string">&quot;Reverse: &quot;</span> + tstr + <span class="string">&quot; C++ string: &quot;</span> + ustr).<span class="built_in">c_str</span>());  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意调用方法为<code>env-&gt;GetStringUTFChars(jStr, NULL);</code>，官方文档中需要传递三个参数，是C风格的函数调用方式，C和C++的调用语法如下：</strong></p>
<ul>
<li>C syntax: <code>cls = (*env)-&gt;FindClass(env, &quot;Sample2&quot;);</code></li>
<li>C++ syntax: <code>cls = env-&gt;FindClass(&quot;Sample2&quot;);</code><br>更多字符串操作相关函数参见<a href="https://docs.oracle.com/javase/8/docs/technotes/guides/jni/spec/functions.html#string_operations">https://docs.oracle.com/javase/8/docs/technotes/guides/jni/spec/functions.html#string_operations</a></li>
</ul>
<p><strong>编译并运行</strong><br>编译java代码：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">javac TestJstr.java</span><br></pre></td></tr></table></figure>

<p>编译C++代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">g++ -fPIC -shared -o libmystr.so -I /usr/lib/jvm/java<span class="number">-8</span>-oracle/include/ -I /usr/lib/jvm/java<span class="number">-8</span>-oracle/include/linux/ TestJstr.cpp</span><br></pre></td></tr></table></figure>

<p>运行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">java -Djava.library.path=. TestJstr HelloWorld</span><br></pre></td></tr></table></figure>
<p>中间的输入部分，输入<code>Maxwi</code>，输出如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Enter a string in C++: Maxwi</span><br><span class="line">In Java, Result: Reverse: dlroWolleH C++ string: Maxwi</span><br></pre></td></tr></table></figure>
<p>完全正确运行</p>
<h2 id="通过JNI传递数组"><a href="#通过JNI传递数组" class="headerlink" title="通过JNI传递数组"></a>通过JNI传递数组</h2><p>数组的传递同时是通过调用JNI函数进行转换后进行正常的操作即可，数组相关的JNI操作函数参见Oracle官网<a href="https://docs.oracle.com/javase/8/docs/technotes/guides/jni/spec/functions.html#array_operations">https://docs.oracle.com/javase/8/docs/technotes/guides/jni/spec/functions.html#array_operations</a><br>下面直接上代码，实现功能为从java中传递一个int数组到native中，native计算出其和以及平均值之后以数组形式返回。<br><strong>java代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//TestJarr.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestJarr</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.loadLibrary(<span class="string">&quot;myjarr&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//该native函数接收一个int类型的数组，通过C++代码计算出其和以及平均值后以数组方式返回</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">native</span> <span class="type">double</span>[] sumAndAvg(<span class="type">int</span>[] num);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] num = &#123;<span class="number">8</span>, <span class="number">19</span>, <span class="number">22</span>, <span class="number">45</span>&#125;;</span><br><span class="line">        <span class="type">double</span>[] result = <span class="keyword">new</span> <span class="title class_">TestJarr</span>().sumAndAvg(num);</span><br><span class="line">        System.out.println(<span class="string">&quot;In java, the sum is &quot;</span> + result[<span class="number">0</span>]);</span><br><span class="line">        System.out.println(<span class="string">&quot;In java, the average is &quot;</span> + result[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>生成的头文件</strong><br>只写函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Class:     TestJarr</span></span><br><span class="line"><span class="comment"> * Method:    sumAndAvg</span></span><br><span class="line"><span class="comment"> * Signature: ([I)[D</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">JNIEXPORT jdoubleArray JNICALL <span class="title">Java_TestJarr_sumAndAvg</span></span></span><br><span class="line"><span class="function">  <span class="params">(JNIEnv *, jobject, jintArray)</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>C++代码</strong><br>注意里面的转换，C++数组转成jintArray时需要先分配内存，再拷贝数据，而不是直接有函数进行转换</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//TestJarr.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;TestJarr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">JNIEXPORT jdoubleArray JNICALL <span class="title">Java_TestJarr_sumAndAvg</span><span class="params">(JNIEnv *env, jobject obj, jintArray num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//将输入的jintArray转换为C风格的数组</span></span><br><span class="line">    jint *carr = env-&gt;<span class="built_in">GetIntArrayElements</span>(num, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == carr) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    jsize length = env-&gt;<span class="built_in">GetArrayLength</span>(num);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对数组进行累加</span></span><br><span class="line">    jdouble sum = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; ++i)</span><br><span class="line">        sum += carr[i];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//求平均值</span></span><br><span class="line">    jdouble avg = sum / length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//释放资源</span></span><br><span class="line">    env-&gt;<span class="built_in">ReleaseIntArrayElements</span>(num, carr, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义C++中的数组</span></span><br><span class="line">    jdouble resArr[] = &#123;sum, avg&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//转换为JNI数组后返回</span></span><br><span class="line">    jdoubleArray outRes = env-&gt;<span class="built_in">NewDoubleArray</span>(<span class="number">2</span>); <span class="comment">//分配数组所需要的空间</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == outRes) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    env-&gt;<span class="built_in">SetDoubleArrayRegion</span>(outRes, <span class="number">0</span>, <span class="number">2</span>, resArr);  <span class="comment">//将数据拷贝到jdoubleArray所在空间</span></span><br><span class="line">    <span class="keyword">return</span> outRes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>编译并运行</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">javac TestJarr.java</span><br><span class="line">g++ -fPIC -shared -o libmyjarr.so -I /usr/lib/jvm/java-8-oracle/include/ -I /usr/lib/jvm/java-8-oracle/include/linux/ TestJarr.cpp</span><br><span class="line">java -Djava.library.path=. TestJarr</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">In java, the sum is 94.0</span><br><span class="line">In java, the average is 23.5</span><br></pre></td></tr></table></figure>

<p>这些内容对于我当前已经够用，关于访问native访问java对象变量以及方法回调的内容请参见下面的参考文档。<br>以上这些例子都比较简单，实际上可以通过将复杂的计算放在C++函数中运行，最后通过native函数包裹该C++函数之后在JNI中调用，这样需要处理的内容会少很多，而且应该速度也会比较快，少去了那些过多的转换工作。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>1.<a href="https://www3.ntu.edu.sg/home/ehchua/programming/java/JavaNativeInterface.html">Java Native Interface (JNI)</a><br>2.<a href="https://en.wikipedia.org/wiki/Java_Native_Interface">Wikipdeia-Java Native Interface</a><br>3.<a href="https://docs.oracle.com/javase/8/docs/technotes/guides/jni/">Oracle-JNI</a><br>4.<a href="https://www.ibm.com/developerworks/java/tutorials/j-jni/j-jni.html">Java programming with JNI</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java通过JNI调用C/C++动态链接库之HelloWorld</title>
    <url>/2017/04/19/java-jni-cpp-hello/</url>
    <content><![CDATA[<p>Java可以通过JNI（Java Native Interface）来调用本地库，从而解决一些需要使用C/C++来提高效率但却需要使用JAVA调用的场景，例如opencv库编写的图像处理函数，需要使用spark等大数据框架来调用。</p>
<span id="more"></span>

<h2 id="关于"><a href="#关于" class="headerlink" title="关于"></a>关于</h2><p>演示一个Hello world的C++通过java调用的过程，系统环境为linux，编译工具使用g++，java版本为jdk1.8。<br>JNI调用C/C++基本步骤很简单：</p>
<ul>
<li>java代码中声明带有native修饰的类方法，该native方法只是在java中进行声明，而不进行实现，在需要调用navtive方法之前进行system.loadLibrary(“xxx”)，然后通过类调用方法xxx即可</li>
<li>使用javah从java的class文件生成与native函数相应的头文件</li>
<li>通过引用含有native方法声明的头文件，采用C++编写native方法的实现，并将其编译为动态链接库</li>
<li>然后正常对java编译并执行即可</li>
</ul>
<p>下面进行详细分析</p>
<h2 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h2><p>Java代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//文件名为hello.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">hello</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">helloWorld</span><span class="params">()</span>;  <span class="comment">//声明本地库中的函数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.loadLibrary(<span class="string">&quot;helloWorld&quot;</span>); <span class="comment">//载入本地库</span></span><br><span class="line">        <span class="type">hello</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">hello</span>();</span><br><span class="line">        t.helloWorld();  <span class="comment">//调用本地库中的函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，如果本地库中有多个函数，只需要调用一次<code>System.loadLibrary</code>即可<br>调用库中只需要写库的名字，windows下不需要添加后缀<code>.dll</code>，linux下不需要添加前面的lib和后缀<code>.so</code><br>此时可以直接使用<code>javac hello.java</code>编译生成<code>class</code>字节码，因为此时实际上java编译器并不会去查看是否已经有了函数<code>helloWorld</code>的实现。</p>
<h2 id="生成头文件"><a href="#生成头文件" class="headerlink" title="生成头文件"></a>生成头文件</h2><p>运行以下命令生成头文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">javah hello</span><br></pre></td></tr></table></figure>
<p>很多教程中提及此命令执行之前需要先使用<code>javac</code>对代码编译，其实可以直接使用javah来从java源代码生成头文件，javah会自动生成临时的class文件（该class文件不会在源文件夹中保存），然后再生成头文件。我通常是直接生成头文件，最后再编译java源代码为class，以避免虽时可能需要修改java源代码。<br>注意，不需要添加后缀<code>.java</code>，因为它实际上是从class文件生成的头文件，然后文件夹中会生成头文件<code>hello.h</code>，内容如下：</p>
<figure class="highlight hpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* DO NOT EDIT THIS FILE - it is machine generated */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;jni.h&gt;</span></span></span><br><span class="line"><span class="comment">/* Header for class hello */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _Included_hello</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _Included_hello</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Class:     hello</span></span><br><span class="line"><span class="comment"> * Method:    helloWorld</span></span><br><span class="line"><span class="comment"> * Signature: ()V</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">JNIEXPORT <span class="type">void</span> JNICALL <span class="title">Java_hello_helloWorld</span></span></span><br><span class="line"><span class="function">  <span class="params">(JNIEnv *, jobject)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>可以看到在第15、16行有一个名为<code>Java_hello_helloWorld</code>的函数声明，其中名称以Java开头，包含了包名、类名和函数名，并以下划线分隔，形如<code>Java_&#123;package_and_classname&#125;_&#123;function_name&#125;(JNI arguments)</code>。后面编写C/C++代码时的函数名字必须与此处一样。<br>其中的2个参数作用是：</p>
<ul>
<li><code>JNIEnv*</code>：用于引用JNI环境，该指针变量可以访问所有JNI函数</li>
<li><code>jobject</code>：引用<code>this</code> Java对象，也就是可以用来访问当前java调用者</li>
</ul>
<p><em>注意该函数被<code>extern &quot;C&quot;</code>包围着，是为了告诉C++编译器编译时采用C风格的函数命名协议，而不是C++风格的函数命名协议。因为C++为了支持函数重载，编译时采用一种叫做<code>mangling</code>的方式为每一个重载函数命命名。详细信息可以参见我的另一篇文章<a href="/2016/07/28/cpp-gleaning-extern-c/" title="C&#x2F;C++拾遗之extern &quot;C&quot;">C&#x2F;C++拾遗之extern &quot;C&quot;</a></em></p>
<p>该头文件中引用了一个java的头文件<code>jni.h</code>，该头文件所在目录为<code>$JAVA_HOME/include</code>，也就是你的JDK安装目录下面。实际上根据平台的不同，<code>jni.h</code>头文件中还引用了一个名为<code>jni_md.h</code>的头文件，该文件目录为<code>$JAVA_HOME/include/linux</code></p>
<h2 id="C-C-代码"><a href="#C-C-代码" class="headerlink" title="C/C++代码"></a>C/C++代码</h2><p>引用头文件并编写C++代码实现函数helloWorld：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hello.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">JNIEXPORT <span class="type">void</span> JNICALL <span class="title">Java_hello_helloWorld</span><span class="params">(JNIEnv *env, jobject obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Hello world!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码非常简单，只是需要注意函数的声明与原头文件中完全一致</p>
<h2 id="编译并运行"><a href="#编译并运行" class="headerlink" title="编译并运行"></a>编译并运行</h2><h3 id="编译C-代码为动态链接库"><a href="#编译C-代码为动态链接库" class="headerlink" title="编译C++代码为动态链接库"></a>编译C++代码为动态链接库</h3><p>使用以下命令编译C++代码为动态链接库：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">g++ -fPIC -shared -o libhelloWorld.so helloWorld.cpp -I/usr/lib/jvm/java-8-oracle/include/ -I/usr/lib/jvm/java-8-oracle/include/linux/</span><br></pre></td></tr></table></figure>
<p>注意其中的编译选项：</p>
<ul>
<li><code>-fPIC</code>选项使编译器在编译阶段生成与位置无关的代码，以使共享库能够在内存中被正确加载，PIC即<code>Position, Independent Code</code>。使用<code>-shared</code>选项时必须有该选项，否则编译期会出错</li>
<li><code>-shared</code>编译器生成共享链接库</li>
<li><code>-o</code>后面的动态链接库的命名规则必须与linux下的动态链接库一致，即<code>libxxx.so</code>的形式</li>
<li><code>-I</code>后面跟的是jni所需要的头文件路径<br>编译完成后会生成名为<code>libhelloWorld.so</code>的文件</li>
<li>提示，如果是C代码，使用gcc编译时，需要通过<code>-Wl,--add-stdcall-alias</code>向链接器传递链接选项，以避免出现<code>UnsatisfiedLinkError</code>错误。*</li>
</ul>
<h3 id="编译java代码"><a href="#编译java代码" class="headerlink" title="编译java代码"></a>编译java代码</h3><p>java代码直接使用javac编译即可：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">javac hello.java</span><br></pre></td></tr></table></figure>

<h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><p>注意运行的时候需要手动指定java的库引用路径，或者手动将相应的动态链接库文件拷贝到系统库路径。关于系统库路径的问题，可以参考<a href="/2017/04/13/linux-dynamic-lib-ldconfig/" title="Linux动态链接库以及链接器相关知识">Linux动态链接库以及链接器相关知识</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">java  -Djava.library.path=. hello</span><br></pre></td></tr></table></figure>
<p>如果以上过程都没有问题，输出应该是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Hello world!</span><br></pre></td></tr></table></figure>

<h2 id="与java包管理结合的JNI"><a href="#与java包管理结合的JNI" class="headerlink" title="与java包管理结合的JNI"></a>与java包管理结合的JNI</h2><p>非常简单，正常将java源代码放到相应的包文件夹中，然后重新使用javah生成相应头文件即可。<br><strong>java代码</strong><br>新建一个文件夹名为myjni，将hello.java放在该文件夹，并在源代码最前面添加<code>package myjni;</code><br>java源代码<code>hello.java</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> myjni;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">hello</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">helloWorld</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.loadLibrary(<span class="string">&quot;helloWorld&quot;</span>);</span><br><span class="line">        <span class="type">hello</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">hello</span>();</span><br><span class="line">        t.helloWorld();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译java代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javac myjni/hello.java</span><br></pre></td></tr></table></figure>

<p><strong>生成头文件</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">javah -d include myjni.hello</span><br></pre></td></tr></table></figure>
<p>javah的<code>-d</code>参数是指定头文件存储路径<br>此时发现头文件中的函数名字中包括了包名：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">JNIEXPORT <span class="type">void</span> JNICALL <span class="title">Java_myjni_hello_helloWorld</span><span class="params">(JNIEnv *, jobject)</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>修改C++代码包含新的头文件</strong><br>C++源代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;include/myjni_hello.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">JNIEXPORT <span class="type">void</span> JNICALL <span class="title">Java_myjni_hello_helloWorld</span><span class="params">(JNIEnv *env, jobject obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Hello world!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除了修改头文件之外，其他都不需要变动</p>
<p><strong>编译C++为动态链接库</strong><br>命令并无变化：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">g++ -fPIC -shared -o libhelloWorld.so -I /usr/lib/jvm/java-8-oracle/include/ -I /usr/lib/jvm/java-8-oracle/include/linux/ helloWorld.cpp</span><br></pre></td></tr></table></figure>

<p><strong>执行</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">java -Djava.library.path=. myjni.hello</span><br></pre></td></tr></table></figure>
<p>加上了包名字正常执行即可。</p>
<p><strong>打包为jar并执行</strong><br>打包命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">jar -cevf myjni.hello myjni.jar myjni</span><br></pre></td></tr></table></figure>
<p>jar命令用于java打包，参数意义如下：</p>
<ul>
<li><code>c</code>表示创建jar包</li>
<li><code>e</code>代表可执行的类，即含有main方法的类，要带上包名</li>
<li><code>v</code>表示显示详细生成过程</li>
<li><code>f</code>表示生成的jar包名称</li>
</ul>
<p>执行jar包：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">java -Djava.library.path=. -jar myjni.jar</span><br></pre></td></tr></table></figure>
<p>同样需要注意添加库路径，且库路径选项需要在执行程序名之前</p>
<p><strong>发现JAVA调用C++库并没有那么复杂，总结来说是只是给java一个函数调用入口即可，具体的函数内部实现可以使用你熟悉的任何C/C++方式进行实现，然后编译成动态链接库给JNI调用就可以了。更多兴趣可以参见进阶内容<a href="/2017/04/20/java-jni-cpp-passing-arguments/" title="Java通过JNI调用C&#x2F;C++动态链接库之参数传递及结果返回">Java通过JNI调用C&#x2F;C++动态链接库之参数传递及结果返回</a></strong></p>
<h2 id="可能遇到的问题"><a href="#可能遇到的问题" class="headerlink" title="可能遇到的问题"></a>可能遇到的问题</h2><p><strong>java.lang.UnsatisfiedLinkError</strong><br>整个错误提示为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.UnsatisfiedLinkError: no helloWorld in java.library.path</span><br><span class="line">        at java.lang.ClassLoader.loadLibrary(ClassLoader.java:1867)</span><br><span class="line">        at java.lang.Runtime.loadLibrary0(Runtime.java:870)</span><br><span class="line">        at java.lang.System.loadLibrary(System.java:1122)</span><br><span class="line">        at hello.main(hello.java:13)</span><br></pre></td></tr></table></figure>
<p><strong>应该是你运行程序时没有指定库路径，注意指定库路径的那个命令行参数必须在所运行的java程序的前面</strong><br><strong>或者是你生成的动态链接库名称不是<code>libhelloWorld.so</code></strong></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>1.<a href="https://www3.ntu.edu.sg/home/ehchua/programming/java/JavaNativeInterface.html">Java Native Interface (JNI)</a><br>2.<a href="https://en.wikipedia.org/wiki/Java_Native_Interface">Wikipdeia-Java Native Interface</a><br>3.<a href="https://docs.oracle.com/javase/8/docs/technotes/guides/jni/">Oracle-JNI</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux动态链接库以及链接器相关知识</title>
    <url>/2017/04/13/linux-dynamic-lib-ldconfig/</url>
    <content><![CDATA[<p>网上关于Linux中动态链接库和动态链接库的博客有很多，其实大部分博客都没有分清楚linux下面动态链接库运行时的查找路径跟编译期的查找路径并不相同，导致很多人在编译程序时库引用出错，按教程添加库路径后依然出错。下面一并总结，不涉及太多二进制中ELF的相关内容。<br>Linux系统中有大量共用的动态链接库和静态链接库，当对程序源代码编译之后进行链接时往往需要引用系统中已经有的动态链接库或静态链接库。关于动态链接库可以简单理解为在链接时只是将动态库中需要引用的内容（包括变量、函数）在目标程序的符号表中创建一个链接，只在运行到该部分调用时才去查看动态链接库，linux下动态链接库通常为<code>libxxx.so</code>，windows下为<code>.dll</code>。而静态链接库是将整个库一并打包到链接后的目标程序中，并直接映射好所需要的符号表，静态链接库后缀通常为<code>.a</code>，windows下通常为<code>.lib</code>。如果也不明白符号表，可以参考<a href="http://notes.maxwi.com/2016/06/05/source-to-program/">实例验证C/C++源代码变成程序的过程</a></p>
<span id="more"></span>

<p>Linux下有两个很好用的实用程序：</p>
<ul>
<li><code>ldd</code>：用于查看共享库依赖信息</li>
<li><code>ldconfig</code>：用于配置动态链接器的运行时绑定</li>
</ul>
<p>还有两个Linux下非常重要的动态链接器/载入器：</p>
<ul>
<li><code>ld.so</code></li>
<li><code>ld-linux.so*</code></li>
</ul>
<p>以及GNU的链接器：</p>
<ul>
<li><code>ld</code>：这个就是将一堆的目标文件通过符号表链接成最终的程序，可以参考上面推荐的另一篇文章</li>
</ul>
<h2 id="ldd"><a href="#ldd" class="headerlink" title="ldd"></a>ldd</h2><p>通过ldd命令后面直接跟文件名即可，不仅可以查看可执行二进制程序的依赖库，也可以查看库本身的依赖，如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ldd /lib/x86_64-linux-gnu/libm.so.6</span><br></pre></td></tr></table></figure>
<p>输出为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">linux-vdso.so.1 =&gt;  (0x00007ffd3afe6000)</span><br><span class="line">libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f35df5f5000)</span><br><span class="line">/lib64/ld-linux-x86-64.so.2 (0x000055a75e17f000)</span><br></pre></td></tr></table></figure>

<p>查看ls的依赖库：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ldd /bin/ls</span><br></pre></td></tr></table></figure>
<p>输出为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">linux-vdso.so.1 =&gt;  (0x00007ffc6492b000)</span><br><span class="line">libselinux.so.1 =&gt; /lib/x86_64-linux-gnu/libselinux.so.1 (0x00007f5128ace000)</span><br><span class="line">libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f5128705000)</span><br><span class="line">libpcre.so.3 =&gt; /lib/x86_64-linux-gnu/libpcre.so.3 (0x00007f5128494000)</span><br><span class="line">libdl.so.2 =&gt; /lib/x86_64-linux-gnu/libdl.so.2 (0x00007f5128290000)</span><br><span class="line">/lib64/ld-linux-x86-64.so.2 (0x0000563eda70b000)</span><br><span class="line">libpthread.so.0 =&gt; /lib/x86_64-linux-gnu/libpthread.so.0 (0x00007f5128073000)</span><br></pre></td></tr></table></figure>

<p><strong>对于运行时或链接时可能会出现的<code>undefined symbol</code>错误可以通过<code>ldd -r &lt;libxx.so&gt;</code>来查看其有哪些符号未定义，它会输出很详细的相关符号的名字</strong>，如：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ ldd -r /usr/lib/libGL.so</span><br><span class="line">        linux-gate.so.1 =&gt;  (0xf77a5000)</span><br><span class="line">        libdl.so.2 (0xf771c000)</span><br><span class="line">        libGLX.so.0 (0xf76fd000)</span><br><span class="line">        libGLdispatch.so.0 (0xf767d000)</span><br><span class="line">        libc.so.6 (0xf74bc000)</span><br><span class="line">        /lib/ld-linux.so.2 (0xf77a6000)</span><br><span class="line">        libX11.so.6 =&gt; not found</span><br><span class="line">        libXext.so.6 =&gt; not found</span><br><span class="line">undefined symbol: _XAsyncErrorHandler   (libGLX.so.0)</span><br><span class="line">undefined symbol: _XFlush       (libGLX.so.0)</span><br><span class="line">undefined symbol: XScreenCount  (libGLX.so.0)</span><br><span class="line">undefined symbol: _XReply       (libGLX.so.0)</span><br><span class="line">undefined symbol: XFree (libGLX.so.0)</span><br><span class="line">undefined symbol: _XDeqAsyncHandler     (libGLX.so.0)</span><br><span class="line">undefined symbol: _XError       (libGLX.so.0)</span><br><span class="line">undefined symbol: XQueryExtension       (libGLX.so.0)</span><br><span class="line">undefined symbol: _XRead        (libGLX.so.0)</span><br><span class="line">undefined symbol: XESetCloseDisplay     (libGLX.so.0)</span><br><span class="line">undefined symbol: XAddExtension (libGLX.so.0)</span><br><span class="line">undefined symbol: _XEatData     (libGLX.so.0)</span><br></pre></td></tr></table></figure>

<p>通过这个名字可以知道这个是为了支持C++重载被编译器mangle之后的函数引用名字，如果是C语言引用C++的库中的函数，此处的库函数引用应该加上<code>extern &quot;C&quot;</code>.</p>
<p><strong>也可以使用<code>nm -A &lt;libxxx.so&gt;</code>来查看符号表</strong></p>
<p>更多ldd功能查看<code>man ldd</code></p>
<h2 id="ldconfig"><a href="#ldconfig" class="headerlink" title="ldconfig"></a>ldconfig</h2><p>ldconfig管理的库路径通常有<code>/usr/lib</code>、<code>/lib</code>、<code>/usr/lib64</code>、<code>/lib64</code>以及<code>/etc/ld.so.conf</code>中指定的所有路径。<br>ldconfig常用的功能如下：</p>
<h3 id="更新动态链接库缓存"><a href="#更新动态链接库缓存" class="headerlink" title="更新动态链接库缓存"></a>更新动态链接库缓存</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo ldconfig</span><br></pre></td></tr></table></figure>
<p>当安装完新库或者在<code>/etc/ld.so.conf</code>，或者<code>/etc/ld.so.conf.d/*.conf</code>中添加库路径时都需要运行<code>ldconfig</code>来更新缓存使新添加的库生效。当然系统启动时会自动运行<code>ldconfig</code>，因为好多软件重装完成之后都会建议重启电脑。</p>
<h3 id="查看ld搜索到的所有库路径以及创建的库链接"><a href="#查看ld搜索到的所有库路径以及创建的库链接" class="headerlink" title="查看ld搜索到的所有库路径以及创建的库链接"></a>查看ld搜索到的所有库路径以及创建的库链接</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo ldconfig -v</span><br></pre></td></tr></table></figure>
<p><code>-v</code>参数也就是<code>--verbose</code>模式，很多人称为开启啰嗦模式也很贴切</p>
<h3 id="只输入动态链接库搜索路径"><a href="#只输入动态链接库搜索路径" class="headerlink" title="只输入动态链接库搜索路径"></a>只输入动态链接库搜索路径</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo ldconfig -v 2&gt;/dev/null | grep -v ^$&#x27;\t&#x27;</span><br></pre></td></tr></table></figure>

<h3 id="只查看当前缓存中的库"><a href="#只查看当前缓存中的库" class="headerlink" title="只查看当前缓存中的库"></a>只查看当前缓存中的库</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo ldconfig -p</span><br></pre></td></tr></table></figure>

<h2 id="链接器"><a href="#链接器" class="headerlink" title="链接器"></a>链接器</h2><h3 id="程序运行时库查找路径"><a href="#程序运行时库查找路径" class="headerlink" title="程序运行时库查找路径"></a>程序运行时库查找路径</h3><p><code>ld.so</code>和<code>ld-linux.so</code>可以在程序运行前搜索所需要支持库路径，它们的库搜索路径除了在ldconfig中提到的之外，还包含通过环境变量<code>LD_LIBRARY_PATH</code>指定的路径。<br>所以当你的程序在运行时提示缺少库，可以通过将所需要的的动态库添加到该环境变量中，或者加入到<code>/etc/ld.so.conf</code>中，然后采用ldconfig更新库缓存。<br>更多内容可以<code>man ld.so</code></p>
<h3 id="编译期链接库路径"><a href="#编译期链接库路径" class="headerlink" title="编译期链接库路径"></a>编译期链接库路径</h3><p>当通过GNU的gcc或g++编译并链接程序时（下面举例中使用的gcc，g++情况类似），其实链接部分的功能跟刚才提到的链接器<code>ld</code>一样，甚至很多时候就是调用系统中的<code>ld</code>。在将目标文件链接成可执行的二进制程序时搜索的库路径通常都是系统库路径，注意与程序运行时载入的动态库路径不一样，所以无论你怎么修改运行时搜索库目录，编译依然会失败，可以通过以下方式查看链接器ld的库搜索路径：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ld --verbose | grep SEARCH_DIR | tr -s &#x27; ;&#x27; \\012</span><br></pre></td></tr></table></figure>

<p>或者通过gcc的啰嗦模式查看，gcc会比ld多搜索通过<code>-L</code>参数指定的库路径，以及环境变量<code>LIBRARY_PATH</code>中指定的路径：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -print-search-dirs | sed &#x27;/^lib/b 1;d;:1;s,/[^/.][^/]*/\.\./,/,;t 1;s,:[^=]*=,:;,;s,;,;  ,g&#x27; | tr \; \\012</span><br></pre></td></tr></table></figure>

<p>所以当你在编译并链接程序时如果出现库缺少的情况，可以通过<code>-L</code>来指定所需要的库，gcc的<code>-L</code>用法为<code>-Ldir</code>，或者将其加到环境变量<code>LIBRARY_PATH</code>中，注意前面没有<em>LD_*。静态库可以通过<code>-llibrary</code>或<code>-l library</code>指定。<br>*注意这里跟通过<code>-I</code>参数指定头文件搜索路径不同，gcc的<code>-Idir</code>用来指定头文件搜索路径。当然也可以通过以下环境变量来为gcc或g++添加头文件搜索路径：</em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export CPLUS_INCLUDE_PATH=/usr/lib/jvm/java-8-oracle/include/:/usr/lib/jvm/java-8-oracle/include/linux/:$CPLUS_INCLUDE_PATH</span><br><span class="line">export C_INCLUDE_PATH=/usr/lib/jvm/java-8-oracle/include/:/usr/lib/jvm/java-8-oracle/include/linux/:$C_INCLUDE_PATH</span><br></pre></td></tr></table></figure>
<p><em>上面那行用于g++，下面那行用于gcc，本例是添加java的jni头文件路径</em></p>
<p><strong>关于<code>LD_LIBRARY_PATH</code>和<code>LD_RUN_PATH</code>的区别，下面这两句来自gcc的make install提示很棒</strong></p>
<ul>
<li>add LIBDIR to the <code>LD_LIBRARY_PATH</code> environment variable during execution</li>
<li>add LIBDIR to the <code>LD_RUN_PATH</code> environment variable during linking</li>
</ul>
<p>更多内容可以<code>man ld</code>、<code>man gcc</code></p>
<h3 id="gcc编译时verbose选项"><a href="#gcc编译时verbose选项" class="headerlink" title="gcc编译时verbose选项"></a>gcc编译时verbose选项</h3><p>使用gcc编译时可以通过添加<code>-v</code>或者<code>--verbose</code>来开启啰嗦模式，查看链接器的调用情况，但并不会显示链接器的啰嗦模式的输出内容。</p>
<p>可以通过<code>-Wl</code>向链接器传递参数的方式来查看链接器的啰嗦模式信息输出情况，例如<code>-Wl,--verbose</code>，gcc的<code>-Wl</code>的用法为<code>-Wl,option</code>，其中option为要传递给链接器的参数。</p>
<p>更多内容可以<code>man gcc</code></p>
<p>参考：<br>1.<a href="http://stackoverflow.com/questions/9922949/how-to-print-the-ldlinker-search-path">How to print the ld(linker) search path</a></p>
<p>2.<a href="http://stackoverflow.com/questions/4250624/ld-library-path-vs-library-path">LD_LIBRARY_PATH vs LIBRARY_PATH</a><br>当然还有一堆的man手册</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>FFmpeg支持的压缩格式和编解码格式</title>
    <url>/2017/04/05/ffmpeg-codecs-formats/</url>
    <content><![CDATA[<p>FFmpeg支持大量的音视频压缩格式和编解码格式，通常大家所说的视频格式（format）就可以理解为压缩格式（container）或者混流格式（Muxing），例如<code>avi</code>、<code>mp4</code>、<code>mkv</code>等，它们相当于是一个容器，可以将视频与音频数据包装在一起，并让它们能够按照指定的同步方式输出。<br>编、解码格式（codec）也就是所谓的视频祼流格式（raw bitstream），视频编码格式也很多，现在使用最多的就是<code>H.264</code>，当然<code>H.265</code>要逐渐引领潮流了。其他的编码格式还有很多，例如<code>MPEG-2</code>、<code>MEPG-4 Part 2</code>、<code>MPEG-4 Part 10</code>等<br><em>PS:有人的场合切勿尝试百度搜索什么是视频祼流，万恶的百度，可以google</em></p>
<span id="more"></span>

<p>下面查看你编译的FFMPEG所支持的Formats和codecs</p>
<h2 id="Format-muxer和demuxer-相关的命令"><a href="#Format-muxer和demuxer-相关的命令" class="headerlink" title="Format(muxer和demuxer)相关的命令"></a>Format(muxer和demuxer)相关的命令</h2><p><strong>列出所有format</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ffmpeg -formats</span><br></pre></td></tr></table></figure>
<p>输出的格式很多，在格式的前面会标有<code>E</code>、<code>D</code>和<code>DE</code>字样，并且最前面的2行内容为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">File formats:</span><br><span class="line"> D. = Demuxing supported</span><br><span class="line"> .E = Muxing supported</span><br></pre></td></tr></table></figure>
<p>表示ffmpeg所支持的相应解析格式的编码还是解码，注意这里所说的编码和解码分别是指混流和解析混流。因为视频中可以包含多种流（steam）类型，例如视频、音频、字幕等。</p>
<p><strong>查看指定format的混流格式的详细信息</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ffmpeg -h muxer=mp4</span><br></pre></td></tr></table></figure>

<p><strong>查看指定format的解混流格式的详细信息</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ffmpeg -h demuxer=mov</span><br></pre></td></tr></table></figure>

<h2 id="Codec-encoder和decoder-相关命令"><a href="#Codec-encoder和decoder-相关命令" class="headerlink" title="Codec(encoder和decoder)相关命令"></a>Codec(encoder和decoder)相关命令</h2><p><strong>列出所有支持的编解码格式</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ffmpeg -codecs</span><br></pre></td></tr></table></figure>
<p>同样所有格式前面都会有相应的字母来表示它的作用，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Codecs:</span><br><span class="line"> D..... = Decoding supported</span><br><span class="line"> .E.... = Encoding supported</span><br><span class="line"> ..V... = Video codec</span><br><span class="line"> ..A... = Audio codec</span><br><span class="line"> ..S... = Subtitle codec</span><br><span class="line"> ...I.. = Intra frame-only codec</span><br><span class="line"> ....L. = Lossy compression</span><br><span class="line"> .....S = Lossless compression</span><br></pre></td></tr></table></figure>

<p><strong>列出所有支持编码格式</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ffmpeg -encoders</span><br></pre></td></tr></table></figure>

<p><strong>列出所有支持解码格式</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ffmpeg -decoders</span><br></pre></td></tr></table></figure>

<p><strong>显示指定编码格式的详细信息</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ffmpeg -h encoder=mpeg4</span><br></pre></td></tr></table></figure>

<p><strong>显示指定解码格式的详细信息</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ffmpeg -h decoder=aac</span><br></pre></td></tr></table></figure>


<p>参考：<br>1.<a href="https://superuser.com/questions/300897/what-is-a-codec-e-g-divx-and-how-does-it-differ-from-a-file-format-e-g-mp/300997#300997">What is a Codec (e.g. DivX?), and how does it differ from a File Format (e.g. MPG)?</a><br>2.<a href="http://stackoverflow.com/questions/3377300/what-are-all-codecs-supported-by-ffmpeg">What are all codecs supported by FFmpeg?</a></p>
<p>3.<a href="http://www.ffmpeg.org/general.html#Supported-File-Formats_002c-Codecs-or-Features">Supported File Formats, Codecs or Features</a></p>
]]></content>
      <categories>
        <category>FFMPEG</category>
      </categories>
      <tags>
        <tag>ffmpeg</tag>
      </tags>
  </entry>
  <entry>
    <title>FFmpeg处理视频流</title>
    <url>/2017/04/05/ffmpeg-streaming/</url>
    <content><![CDATA[<p>FFMPEG支持创建多种协议的视频流，举例说明使用FFMPEG创建视频流，以及接受视频流</p>
<span id="more"></span>

<h2 id="UDP协议"><a href="#UDP协议" class="headerlink" title="UDP协议"></a>UDP协议</h2><p>UDP全称为用户数据报协议（User Datagram Protocol，UDP）<br>下面的命令实现将本地文件以H.264祼流发送到地址<code>udp://127.0.0.1:1234</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ffmpeg -re -i minis.mp4 -vcodec copy -f h264 udp://127.0.0.1:1234</span><br></pre></td></tr></table></figure>
<p>使用ffplay接收UDP视频流：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ffplay  udp://127.0.0.1:1234</span><br></pre></td></tr></table></figure>
<p>ffplay也可以手动指定解码参数：<code>ffplay -f h264 udp://127.0.0.1:1234</code></p>
<h2 id="RTP协议"><a href="#RTP协议" class="headerlink" title="RTP协议"></a>RTP协议</h2><p>RTP是实时传输协议（Real-time Transport Protocol）<br>通过FFMPEG将本地文件作为输入创建基于RTP的视频流：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ffmpeg -re -i input.mpg -vcodec copy -an -f rtp rtp://127.0.0.1:20000 -vn -acodec copy -f rtp rtp://127.0.0.1:30000</span><br></pre></td></tr></table></figure>
<ul>
<li>“-re” 指定ffmpeg以正确的速率推送流，如果不指定ffmpeg会尽可能快的推送流</li>
<li>“input.mpg” 输入文件</li>
<li>“-vcodec copy”和“-acodec copy” 表示不改变原来视频文件的视频和音频的编码格式</li>
<li>“-an”（no audio）和“-vn”（no video）分别用来单独输出视频和音频，否则会出现错误<code>[rtp @ 0x353cb00] Only one stream supported in the RTP muxer</code></li>
<li>“-f rtp” 指定输出的视频流格式为RTP</li>
<li>“rtp://ip:port” 指定IP和端口</li>
</ul>
<p>例如我的测试命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ffmpeg -re -i bunny.avi -vcodec copy -an -f rtp rtp://127.0.0.1:20000 -vn -acodec aac -f rtp rtp://127.0.0.1:30000</span><br></pre></td></tr></table></figure>
<p>我把音频编码格式改成了aac，否则我这里由于系统中不支持AC3会导致失败</p>
<p>上述命令创建后会输出很多信息，其中包含SDP信息：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">SDP:</span><br><span class="line">v=0</span><br><span class="line">o=- 0 0 IN IP4 127.0.0.1</span><br><span class="line">s=No Name</span><br><span class="line">t=0 0</span><br><span class="line">a=tool:libavformat 57.66.102</span><br><span class="line">m=video 20000 RTP/AVP 96</span><br><span class="line">c=IN IP4 127.0.0.1</span><br><span class="line">b=AS:2500</span><br><span class="line">a=rtpmap:96 MP4V-ES/90000</span><br><span class="line">a=fmtp:96 profile-level-id=1; config=000001B001000001B58913000001000000012000C48D8800C51AB43C1463000001B24C61766335312E34342E30</span><br><span class="line">m=audio 30000 RTP/AVP 97</span><br><span class="line">c=IN IP4 127.0.0.1</span><br><span class="line">b=AS:341</span><br><span class="line">a=rtpmap:97 MPEG4-GENERIC/48000/6</span><br><span class="line">a=fmtp:97 profile-level-id=1;mode=AAC-hbr;sizelength=13;indexlength=3;indexdeltalength=3; config=11B056E500</span><br></pre></td></tr></table></figure>
<p>将上述内容保存到文件，命名为<code>a.sdp</code></p>
<p>然后运行ffplay接收流：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ffplay bunny.sdp -protocol_whitelist file,udp,rtp</span><br></pre></td></tr></table></figure>
<p>注意，如果没有添加后面的<code>-protocol_whitelist</code>选项，会报错<code>Protocol not on whitelist &#39;file,crypto&#39;!/0   
bunny.sdp: Invalid data found when processing input</code></p>
<h2 id="RTSP协议"><a href="#RTSP协议" class="headerlink" title="RTSP协议"></a>RTSP协议</h2><p>RTSP协议全称为实时流协议（Real Time Streaming Protocol）</p>
<h2 id="ffserver"><a href="#ffserver" class="headerlink" title="ffserver"></a>ffserver</h2><p>参考：<br>1.<a href="https://www.ffmpeg.org/ffmpeg-protocols.html">FFmpeg Protocols Documentation</a><br>2.<a href="https://trac.ffmpeg.org/wiki/StreamingGuide">FFmpeg wiki:StreamingGuide</a><br>3.<a href="https://trac.ffmpeg.org/wiki/ffserver">FFmpeg wiki:ffserver</a><br>4.<a href="http://lucabe72.blogspot.com/2010/04/rtp-streaming-with-ffmpeg.html">RTP streaming with ffmpeg</a></p>
]]></content>
      <categories>
        <category>FFMPEG</category>
      </categories>
      <tags>
        <tag>ffmpeg</tag>
      </tags>
  </entry>
  <entry>
    <title>FFmpeg与HDFS上的文件操作</title>
    <url>/2017/04/04/ffmpeg-hdfs/</url>
    <content><![CDATA[<p>获取HDFS上的视频文件并通过ffmpeg播放，或者通过ffmpeg将视频流转码后存储到HDFS</p>
<span id="more"></span>
<p>下面的命令基本都是通过管道实现<br><strong>获取HDFS视频文件，采用ffmpeg转码后存到本地</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hdfs dfs -cat hdfs://192.168.1.187:9000/user/root/video/bunny.avi | ffmpeg -i - -f mp4 out.mp4</span><br></pre></td></tr></table></figure>
<p>如果由于用户不是配置的HDFS用户，导致HDFS权限不足，可以指定HDFS配置文件和用户名变量：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export HADOOP_CONF_DIR=/usr/hadoop/etc/hadoop/</span><br><span class="line">export HADOOP_USER_NAME=root</span><br></pre></td></tr></table></figure>

<p><strong>将本地文件直接转码到HDFS</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ffmpeg -i out.mp4 -f avi - | hdfs dfs -put - /usr/root/video/test.avi</span><br></pre></td></tr></table></figure>

<p><strong>视频流转码后存储到HDFS</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ffmpeg -i rtsp://127.0.0.1:8090/bunny.mp4 -f avi - | hadoop fs -put - /usr/root/video/test.avi</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>FFMPEG</category>
      </categories>
      <tags>
        <tag>ffmpeg</tag>
        <tag>HDFS</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux设置命令行代理</title>
    <url>/2017/04/01/linux-proxy-ss/</url>
    <content><![CDATA[<p>有些场景下需要为系统设置代理，比如OpenCV3在进行cmake编译时需要在线从amazon下载一些第三方包。现在多数同学采用的代理方案应该都是基于socks5协议，而默认的终端工具支持的代理类型都是http或https，所以这里需要socks协议到http协议的转换，转换之后采用终端的代理变量设置http代理即可。</p>
<span id="more"></span>
<p>我的系统环境为ubuntu 16.04，其他系统类似<br>两种方案，一种是采用<code>polipo</code>将socks代理转为http，然后为相应命令指定http代理。另一种方案是采用<code>proxychains</code>重定向连接来解决。两种方案看个人喜好，个人倾向于proxychains的方式</p>
<h1 id="proxychains进行代理重定向"><a href="#proxychains进行代理重定向" class="headerlink" title="proxychains进行代理重定向"></a>proxychains进行代理重定向</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get install proxychains</span><br></pre></td></tr></table></figure>

<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p><code>proxychains</code>会从以下文件中加载配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./proxychains.conf</span><br><span class="line">$(HOME)/.proxychains/proxychains.conf</span><br><span class="line">/etc/proxychains.conf</span><br><span class="line"># see more in /etc/proxychains.conf</span><br></pre></td></tr></table></figure>
<p>本文以修改<code>$(HOME)/.proxychains/proxychains.conf</code>为例<br>修改其内容如下（如果没有该文件，则创建）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">trict_chain</span><br><span class="line">proxy_dns</span><br><span class="line">remote_dns_subnet 224</span><br><span class="line">tcp_read_time_out 15000</span><br><span class="line">tcp_connect_time_out 8000</span><br><span class="line">localnet 127.0.0.0/255.0.0.0</span><br><span class="line">quiet_mode</span><br><span class="line"></span><br><span class="line">[ProxyList]</span><br><span class="line">socks5  127.0.0.1 1081</span><br></pre></td></tr></table></figure>

<p>其中<code>[ProxyList]</code>字段中添加你的代理，由于采用shadowsocks的方式进行代理，并且监听的本地端口为1081，所以最后一行为<code>socks5 127.0.0.1 1081</code></p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">proxychains [command]</span><br></pre></td></tr></table></figure>
<p>例如：<br><code>proxychains</code>后面直接跟需要走代理的命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ proxychains curl ip.gs</span><br><span class="line">ProxyChains-3.1 (http://proxychains.sf.net)</span><br><span class="line">Current IP / 当前 IP: 165.227.9.118</span><br><span class="line">ISP / 运营商:  digitalocean.com</span><br><span class="line">City / 城市: San Francisco California</span><br><span class="line">Country / 国家: United States</span><br><span class="line"></span><br><span class="line">$ proxychains git push origin master</span><br></pre></td></tr></table></figure>

<p>或者直接让整个bash下的命令都走代理：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ proxychains bash</span><br><span class="line">$ ping google.com</span><br><span class="line">$ git push origin master</span><br></pre></td></tr></table></figure>

<h1 id="polipo转socks为http"><a href="#polipo转socks为http" class="headerlink" title="polipo转socks为http"></a>polipo转socks为http</h1><h2 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h2><p>默认你使用的是SS方式进行代理上网，并且已经有了SS账号。<br><strong>安装ss客户端</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install python</span><br><span class="line">sudo apt-get install python-pip</span><br><span class="line">sudo pip install shadowsocks</span><br></pre></td></tr></table></figure>

<p><strong>安装polipo</strong><br>polipo是一个web代理缓存工具，可以转发web请求到指定的服务器和端口，它本身支持socks协议，所以可以把它当成可以进行socks协议与http协议转换的工具。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install polipo</span><br></pre></td></tr></table></figure>

<h2 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h2><p><strong>配置并启动ss客户端</strong><br>为了避免系统中配置的多个ss客户端监听端口冲突，可以修改ss监听端口，这里指定监听端口为1081，下面是我的ss配置：<br><em>config.json</em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">&quot;server&quot;:&quot;your-server-ip&quot;,</span><br><span class="line">&quot;server_port&quot;:your-server-port,</span><br><span class="line">&quot;local_port&quot;:1081,</span><br><span class="line">&quot;password&quot;:&quot;your-password&quot;,</span><br><span class="line">&quot;method&quot;: &quot;aes-128-cfb&quot;,</span><br><span class="line">&quot;timeout&quot;:600</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>启动ss客户端：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sslocal -c config.json</span><br></pre></td></tr></table></figure>
<p>可以让它在后台运行，如果只是临时用，可以另开一个terminal进行其他操作</p>
<p><strong>配置并启动polipo</strong><br>修改polipo配置文件如下：<br>配置文件路径<em>/etc/polipo/config</em></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">logSyslog = true</span><br><span class="line">logFile = /var/log/polipo/polipo.log</span><br><span class="line">socksParentProxy = &quot;127.0.0.1:1081&quot;</span><br><span class="line">socksProxyType = socks5</span><br></pre></td></tr></table></figure>
<p>启动polipo服务：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo systemctl start polipo</span><br></pre></td></tr></table></figure>
<p>此时polipo已经开始监听本地的8123端口，并将请求通过socks5协议转发到127.0.0.1的1081端口，如果需要修改默认的8123端口，可以查看man手册</p>
<h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>在需要使用代理的命令前面加上<code>http_proxy=http://127.0.0.1:8123 https_proxy=http://127.0.0.1:8123</code>，如果只需要使用http，可以只设置http代理，如下验证代理后的ip：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">http_proxy=http://127.0.0.1:8123 curl ip.gs</span><br><span class="line">当前 IP：138.68.252.43 来自：美国加利福尼亚州旧金山</span><br></pre></td></tr></table></figure>

<p>验证google的https访问：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">https_proxy=http://127.0.0.1:8123 curl https://google.com</span><br></pre></td></tr></table></figure>

<h2 id="使用技巧"><a href="#使用技巧" class="headerlink" title="使用技巧"></a>使用技巧</h2><p>如果想让整个当前会话都走代理，可以直接设置环境变量：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export http_proxy=http://127.0.0.1:8123 https_proxy=http://127.0.0.1:8123</span><br></pre></td></tr></table></figure>
<p>取消代理的环境变量：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">unset http_proxy</span><br><span class="line">unset https_proxy</span><br></pre></td></tr></table></figure>

<p>如果想让用户登录后自动进行代理设置，可以直接将<code>export http_proxy=http://127.0.0.1:8123/ https_proxy=http://127.0.0.1:8123/</code>放在<code>~/.bashrc</code>中。</p>
<p>可以为命令设置别名，以减少输入，在<code>~/.bashrc</code>中增加如下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alias hp=&quot;http_proxy=http://127.0.0.1:8123 https_proxy=http://127.0.0.1:8123&quot;</span><br></pre></td></tr></table></figure>
<p>执行<code>source ~/.bashrc</code>使其生效，然后可以如下执行需要代理的命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hp curl ip.gs</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu 16.04下编译OpenCV 3.2.0支持Java、FFmpeg以及CUDA8</title>
    <url>/2017/04/01/ubuntu-compile-opencv3-with-cuda-and-ffmpeg/</url>
    <content><![CDATA[<p>Ubuntu 16.04下手动编译OpenCV 3.2.0，并提供对FFmpeg以及CUDA 8的支持来使用GPU加速视频图像处理。<br>考虑到大数据处理系统spark的需要，这里也同时加入opencv对java的支持。</p>
<span id="more"></span>
<p>系统为ubuntu 16.04.1 x64服务器版的最小化系统，具体参数如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DISTRIB_ID=Ubuntu</span><br><span class="line">DISTRIB_RELEASE=16.04</span><br><span class="line">DISTRIB_CODENAME=xenial</span><br><span class="line">DISTRIB_DESCRIPTION=&quot;Ubuntu 16.04.1 LTS&quot;</span><br></pre></td></tr></table></figure>
<p>假定已经安装好了CUDA 8，如果还没有安装CUDA 8环境可以参考这里安装<a href="/2017/02/26/ubuntu-cuda8-env-set/" title="Ubuntu 16.04下CUDA8环境配置的2种方法">Ubuntu 16.04下CUDA8环境配置的2种方法</a><br>也需要提前安装好FFmpeg并将其二进制放到环境变量中，如果还没有编译安装好FFmpeg对GPU解码的支持，可以参考这里<a href="/2017/03/01/ubuntu-compile-ffmpeg-with-cuvid-nvenc-npp/" title="Ubuntu 16.04下编译ffmpeg支持CUDA下的cuvid vnenc和NPP">Ubuntu 16.04下编译ffmpeg支持CUDA下的cuvid vnenc和NPP</a> </p>
<p>还有Java环境也需要提前安装好，如果还没有安装，可以参考<a href="/2016/10/01/java-env-set/" title="ubuntu下2种配置oracle jdk的方法">ubuntu下2种配置oracle jdk的方法</a></p>
<h1 id="安装OpenCV依赖包"><a href="#安装OpenCV依赖包" class="headerlink" title="安装OpenCV依赖包"></a>安装OpenCV依赖包</h1><p>官方要求的必装包：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install build-essential cmake git libgtk2.0-dev pkg-config libavcodec-dev libavformat-dev libswscale-dev</span><br></pre></td></tr></table></figure>
<p>上面的git如果采用zip方式安装可以不需要，但如果是通过zip方式安装则需要安装上unzip用于解压</p>
<p>官方推荐的可选包：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install  python-dev python-numpy libtbb2 libtbb-dev libjpeg-dev libpng-dev libtiff-dev libjasper-dev libdc1394-22-dev</span><br></pre></td></tr></table></figure>
<p>添加对OpenGL的支持所需要的包：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install freeglut3-dev mesa-common-dev  libgtkglext1 libgtkglext1-dev</span><br></pre></td></tr></table></figure>

<p>添加对Java的支持需要ant：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install ant</span><br></pre></td></tr></table></figure>

<p>其他一些推荐包，包括视频编解码所需要的开发包等：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install checkinstall yasm libgstreamer0.10-dev libgstreamer-plugins-base0.10-dev libv4l-dev libtbb-dev libqt4-dev libgtk2.0-dev libmp3lame-dev libtheora-dev libvorbis-dev libxvidcore-dev x264 v4l-utils </span><br></pre></td></tr></table></figure>
<p>我这里把这些包全部安装上</p>
<h1 id="验证OpenGL的配置"><a href="#验证OpenGL的配置" class="headerlink" title="验证OpenGL的配置"></a>验证OpenGL的配置</h1><p>如果不需要OpenGL可以跳过此步<br>保存如下代码，并命名为testgl.c：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GL/glut.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Drawing funciton</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">//Background color</span></span><br><span class="line">  <span class="built_in">glClearColor</span>(<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">  <span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT );</span><br><span class="line">  <span class="comment">//Draw order</span></span><br><span class="line">  <span class="built_in">glFlush</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Main program</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">glutInit</span>(&amp;argc, argv);</span><br><span class="line">  <span class="comment">//Simple buffer</span></span><br><span class="line">  <span class="built_in">glutInitDisplayMode</span>(GLUT_SINGLE | GLUT_RGB );</span><br><span class="line">  <span class="built_in">glutInitWindowPosition</span>(<span class="number">50</span>,<span class="number">25</span>);</span><br><span class="line">  <span class="built_in">glutInitWindowSize</span>(<span class="number">500</span>,<span class="number">250</span>);</span><br><span class="line">  <span class="built_in">glutCreateWindow</span>(<span class="string">&quot;Green window&quot;</span>);</span><br><span class="line">  <span class="comment">//Call to the drawing function</span></span><br><span class="line">  <span class="built_in">glutDisplayFunc</span>(draw);</span><br><span class="line">  <span class="built_in">glutMainLoop</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc testgl.c -o testgl -lGL -lGLU -lglut</span><br></pre></td></tr></table></figure>
<p>如果编译通过，则表示OpenGl安装成功，运行的话需要有桌面环境，可以通过如下代码为服务器系统安装桌面环境用于测试：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt install ubuntu-desktop</span><br></pre></td></tr></table></figure>
<p>如果需要远程通过VNC在windows上连接ubuntu，可以打开ubuntu上的vino，也就是那个desktop sharing，设置允许远程连接，再在命令行中执行以下语句即可（这些操作要求ubuntu有桌面环境）：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gsettings set org.gnome.Vino require-encryption false</span><br></pre></td></tr></table></figure>

<p><strong>实际测试代码性能时，为了避免由于桌面占用GPU/CPU影响系统性能，可能使用以下命令禁用桌面</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo systemctl disable lightdm</span><br><span class="line">sudo systemctl stop lightdm</span><br></pre></td></tr></table></figure>
<p>第一条命令会让你重启后依然无法进入桌面</p>
<p>需要启用桌面时使用以下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo systemctl enable lightdm</span><br><span class="line">sudo systemctl start lightdm</span><br></pre></td></tr></table></figure>

<h1 id="编译OpenCV"><a href="#编译OpenCV" class="headerlink" title="编译OpenCV"></a>编译OpenCV</h1><p>下载OpenCV，可以通过git获取官方最新的版本，然后切换到自己所需要的3.2.0进行编译：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/opencv/opencv.git </span><br><span class="line">cd opencv</span><br><span class="line">git checkout 3.2.0</span><br></pre></td></tr></table></figure>

<p>这里同时安装<code>OpenCV&#39;s extra modules</code>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/opencv/opencv_contrib.git</span><br><span class="line">cd opencv_contrib</span><br><span class="line">git checkout 3.2.0</span><br></pre></td></tr></table></figure>

<p>为了方便后面验证时的测试，安装OpenCV官方提供的附加测试代码（<code>extra data for the OpenCV library</code>）：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/opencv/opencv_extra.git</span><br><span class="line">cd opencv_extra</span><br><span class="line">git checkout 3.2.0</span><br></pre></td></tr></table></figure>

<p>进入opencv根目录，创建一个build文件夹，然后进入build文件后执行以下编译代码，注意编译选项上包含了CUDA的支持，NVCUVID的支持，OpenGL的支持，以及对ffmpeg和java的支持，这些内容都需要提前配置好。</p>
<p><strong>由于编译时的第三方库需要在线下载，而且服务器貌似是AWS，所以如果不配置代理，可能会cmake失败。设置代理可以参见：<a href="http://notes.maxwi.com/2017/04/01/linux-proxy-ss">http://notes.maxwi.com/2017/04/01/linux-proxy-ss</a></strong></p>
<p>cmake选项：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cmake \</span><br><span class="line">    -D CMAKE_BUILD_TYPE=RELEASE \</span><br><span class="line">    -D CMAKE_INSTALL_PREFIX=/usr/local \</span><br><span class="line">    -D OPENCV_EXTRA_MODULES_PATH=../../opencv_contrib/modules \</span><br><span class="line">    -D OPENCV_TEST_DATA_PATH=../../opencv_extra \</span><br><span class="line">    -D WITH_CUDA=ON \</span><br><span class="line">    -D WITH_CUBLAS=ON \</span><br><span class="line">    -D CUDA_FAST_MATH=ON \</span><br><span class="line">    -D WITH_CUFFT=ON \</span><br><span class="line">    -D WITH_NVCUVID=ON \</span><br><span class="line">    -D WITH_V4L=ON \</span><br><span class="line">    -D WITH_LIBV4L=ON \</span><br><span class="line">    -D WITH_OPENGL=ON \</span><br><span class="line">    -D WITH_FFMPEG=ON \</span><br><span class="line">    -D INSTALL_C_EXAMPLES=ON \</span><br><span class="line">    -D BUILD_EXAMPLES=ON \</span><br><span class="line">    -D BUILD_SHARED_LIBS=OFF \</span><br><span class="line">    ..</span><br></pre></td></tr></table></figure>
<p>更多cmake选项可以查看OpenCV源码目录下的CMakeLists.txt文件内容。<br>默认你的opencv_contrib目录与opencv根目录同级，指定的OpenCV安装路径为<code>/usr/local/share/OpenCV/</code><br>如果你之前的CUDA、支持CUDA, NVCUVID, NVENC的FFmpeg、JAVA以及opengl编译安装的都没有问题的话，cmake输出的最后一部分内容应该如下，<em>注意java显示在OpenCV modules中</em>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">--   OpenCV modules:</span><br><span class="line">--     To be built:                 cudev core cudaarithm flann imgproc ml reg surface_matching video cudabgsegm cudafilters cudaimgproc cudawarping dnn freetype fuzzy imgcodecs photo shape videoio cudacodec highgui objdetect plot ts xobjdetect xphoto bgsegm bioinspired dpm face features2d line_descriptor saliency text calib3d ccalib cudafeatures2d cudalegacy cudaobjdetect cudaoptflow cudastereo datasets rgbd stereo superres tracking videostab xfeatures2d ximgproc aruco optflow phase_unwrapping stitching structured_light java python2</span><br><span class="line">--     Disabled:                    world contrib_world</span><br><span class="line">--     Disabled by dependency:      -</span><br><span class="line">--     Unavailable:                 python3 viz cnn_3dobj cvv hdf matlab sfm</span><br><span class="line">-- </span><br><span class="line">--   GUI: </span><br><span class="line">--     QT:                          NO</span><br><span class="line">--     GTK+ 2.x:                    YES (ver 2.24.30)</span><br><span class="line">--     GThread :                    YES (ver 2.48.2)</span><br><span class="line">--     GtkGlExt:                    YES (ver 1.2.0)</span><br><span class="line">--     OpenGL support:              YES (/usr/lib/x86_64-linux-gnu/libGLU.so /usr/lib/x86_64-linux-gnu/libGL.so)</span><br><span class="line">--     VTK support:                 NO</span><br><span class="line">-- </span><br><span class="line">--   Media I/O: </span><br><span class="line">--     ZLib:                        /usr/lib/x86_64-linux-gnu/libz.so (ver 1.2.8)</span><br><span class="line">--     JPEG:                        /usr/lib/x86_64-linux-gnu/libjpeg.so (ver )</span><br><span class="line">--     WEBP:                        build (ver 0.3.1)</span><br><span class="line">--     PNG:                         /usr/lib/x86_64-linux-gnu/libpng.so (ver 1.2.54)</span><br><span class="line">--     TIFF:                        /usr/lib/x86_64-linux-gnu/libtiff.so (ver 42 - 4.0.6)</span><br><span class="line">--     JPEG 2000:                   /usr/lib/x86_64-linux-gnu/libjasper.so (ver 1.900.1)</span><br><span class="line">--     OpenEXR:                     build (ver 1.7.1)</span><br><span class="line">--     GDAL:                        NO</span><br><span class="line">--     GDCM:                        NO</span><br><span class="line">-- </span><br><span class="line">--   Video I/O:</span><br><span class="line">--     DC1394 1.x:                  NO</span><br><span class="line">--     DC1394 2.x:                  YES (ver 2.2.4)</span><br><span class="line">--     FFMPEG:                      YES</span><br><span class="line">--       avcodec:                   YES (ver 56.60.100)</span><br><span class="line">--       avformat:                  YES (ver 56.40.101)</span><br><span class="line">--       avutil:                    YES (ver 54.31.100)</span><br><span class="line">--       swscale:                   YES (ver 3.1.101)</span><br><span class="line">--       avresample:                NO</span><br><span class="line">--     GStreamer:                   </span><br><span class="line">--       base:                      YES (ver 0.10.36)</span><br><span class="line">--       video:                     YES (ver 0.10.36)</span><br><span class="line">--       app:                       YES (ver 0.10.36)</span><br><span class="line">--       riff:                      YES (ver 0.10.36)</span><br><span class="line">--       pbutils:                   YES (ver 0.10.36)</span><br><span class="line">--     OpenNI:                      NO</span><br><span class="line">--     OpenNI PrimeSensor Modules:  NO</span><br><span class="line">--     OpenNI2:                     NO</span><br><span class="line">--     PvAPI:                       NO</span><br><span class="line">--     GigEVisionSDK:               NO</span><br><span class="line">--     Aravis SDK:                  NO</span><br><span class="line">--     UniCap:                      NO</span><br><span class="line">--     UniCap ucil:                 NO</span><br><span class="line">--     V4L/V4L2:                    Using libv4l1 (ver 1.10.0) / libv4l2 (ver 1.10.0)</span><br><span class="line">--     XIMEA:                       NO</span><br><span class="line">--     Xine:                        NO</span><br><span class="line">--     gPhoto2:                     NO</span><br><span class="line">-- </span><br><span class="line">--   Parallel framework:            pthreads</span><br><span class="line">-- </span><br><span class="line">--   Other third-party libraries:</span><br><span class="line">--     Use IPP:                     9.0.1 [9.0.1]</span><br><span class="line">--          at:                     /home/dutoeserver/OpenCV/opencv/build/3rdparty/ippicv/ippicv_lnx</span><br><span class="line">--     Use IPP Async:               NO</span><br><span class="line">--     Use VA:                      NO</span><br><span class="line">--     Use Intel VA-API/OpenCL:     NO</span><br><span class="line">--     Use Lapack:                  NO</span><br><span class="line">--     Use Eigen:                   YES (ver 3.2.92)</span><br><span class="line">--     Use Cuda:                    YES (ver 8.0)</span><br><span class="line">--     Use OpenCL:                  YES</span><br><span class="line">--     Use OpenVX:                  NO</span><br><span class="line">--     Use custom HAL:              NO</span><br><span class="line">-- </span><br><span class="line">--   NVIDIA CUDA</span><br><span class="line">--     Use CUFFT:                   YES</span><br><span class="line">--     Use CUBLAS:                  YES</span><br><span class="line">--     USE NVCUVID:                 YES</span><br><span class="line">--     NVIDIA GPU arch:             20 30 35 37 50 52 60 61</span><br><span class="line">--     NVIDIA PTX archs:</span><br><span class="line">--     Use fast math:               YES</span><br><span class="line">-- </span><br><span class="line">--   OpenCL:                        &lt;Dynamic loading of OpenCL library&gt;</span><br><span class="line">--     Include path:                /home/dutoeserver/OpenCV/opencv/3rdparty/include/opencl/1.2</span><br><span class="line">--     Use AMDFFT:                  NO</span><br><span class="line">--     Use AMDBLAS:                 NO</span><br><span class="line">-- </span><br><span class="line">--   Python 2:</span><br><span class="line">--     Interpreter:                 /usr/bin/python2.7 (ver 2.7.12)</span><br><span class="line">--     Libraries:                   /usr/lib/x86_64-linux-gnu/libpython2.7.so (ver 2.7.12)</span><br><span class="line">--     numpy:                       /usr/lib/python2.7/dist-packages/numpy/core/include (ver 1.11.0)</span><br><span class="line">--     packages path:               lib/python2.7/dist-packages</span><br><span class="line">-- </span><br><span class="line">--   Python 3:</span><br><span class="line">--     Interpreter:                 /usr/bin/python3 (ver 3.5.2)</span><br><span class="line">-- </span><br><span class="line">--   Python (for build):            /usr/bin/python2.7</span><br><span class="line">-- </span><br><span class="line">--   Java:</span><br><span class="line">--     ant:                         /usr/bin/ant (ver 1.9.6)</span><br><span class="line">--     JNI:                         /usr/lib/jvm/java-8-oracle/include /usr/lib/jvm/java-8-oracle/include/linux /usr/lib/jvm/java-8-oracle/include</span><br><span class="line">--     Java wrappers:               YES</span><br><span class="line">--     Java tests:                  YES</span><br><span class="line">-- </span><br><span class="line">--   Matlab:                        Matlab not found or implicitly disabled</span><br><span class="line">-- </span><br><span class="line">--   Documentation:</span><br><span class="line">--     Doxygen:                     NO</span><br><span class="line">-- </span><br><span class="line">--   Tests and samples:</span><br><span class="line">--     Tests:                       YES</span><br><span class="line">--     Performance tests:           YES</span><br><span class="line">--     C/C++ Examples:              YES</span><br><span class="line">-- </span><br><span class="line">--   Install path:                  /usr/local</span><br><span class="line">-- </span><br><span class="line">--   cvconfig.h is in:              /home/dutoeserver/OpenCV/opencv/build</span><br><span class="line">-- -----------------------------------------------------------------</span><br><span class="line">-- </span><br><span class="line">-- Configuring done</span><br><span class="line">-- Generating done</span><br><span class="line">-- Build files have been written to: /home/dutoeserver/OpenCV/opencv/build</span><br></pre></td></tr></table></figure>
<p>从中可以看到我们所添加的编译选项后面都有YES<br>下面使用make进行编译：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">make -j $(($(nproc) + 1))</span><br></pre></td></tr></table></figure>

<p>然后便是漫长的编译过程，具体时间根据你的电脑配置而不同，如果没有问题的话，编译会顺利进行。<br>然后使用make进行安装并配置环境：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo make -j $(($(nproc) + 1)) install</span><br><span class="line">sudo /bin/bash -c &#x27;echo &quot;/usr/local/lib&quot; &gt; /etc/ld.so.conf.d/opencv.conf&#x27;</span><br><span class="line">sudo ldconfig</span><br></pre></td></tr></table></figure>
<p>建议上述安装完成之后重启一次系统</p>
<p><strong>可以将上面<code>sudo make install</code>部分换成<code>sudo checkinstall</code>，这样安装完成之后checkinstall会在当前目录生成一个相应的deb，可以二次安装，也可以用sudo dpkg -r xx.deb来卸载</strong><br>更多checkinstall的用法可以参见IBM的一篇文章：<a href="http://www.ibm.com/developerworks/cn/linux/l-cn-checkinstall/">http://www.ibm.com/developerworks/cn/linux/l-cn-checkinstall/</a></p>
<h1 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h1><p>编译完成之后，会在<code>build/bin</code>目录下创建很多例子的二进制文件，可以进行测试。如果该文件夹下没有任何文件，检查你的编译选项是否选择了例子，以及上面的编译是否都已经正确完成。<br>这里我测试一个gpu性能的例子：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bin/performance_gpu</span><br></pre></td></tr></table></figure>
<p>执行之后首先它会显示出来你的GPU信息，然后会经过一段时间的测试，如果你没有提前把<code>opencv_extra</code>下面的测试视频拷贝过来，还会提示一个文件丢失的错误，不过不影响测试。输出内容的最后部分如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">average GPU speedup: x33.717</span><br></pre></td></tr></table></figure>

<p>下面手动编译一个例子<br>找到OpenCV源代码文件夹下的<code>samples/gpu</code><br>里面有很多gpu的示例代码，这里以其中的hog.cpp为例，它的功能就是利用方向梯度直方图（Histogram of oriented gradient）进行目标检测<br>将该代码单独拷贝到一个文件中，并在该文件夹下创建<code>CMakeLists.txt</code>，内容如下：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">2.8</span>)</span><br><span class="line"><span class="keyword">project</span>(HOG)</span><br><span class="line"><span class="keyword">find_package</span>(OpenCV REQUIRED)</span><br><span class="line"><span class="keyword">find_package</span>(CUDA  REQUIRED)</span><br><span class="line"><span class="keyword">include_directories</span>(<span class="string">&quot;$&#123;CUDA_INCLUDE_DIRS&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">add_executable</span>(hog hog.cpp)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(hog <span class="variable">$&#123;OpenCV_LIBS&#125;</span>)</span><br></pre></td></tr></table></figure>
<p>然后执行编译：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir build</span><br><span class="line">cd build</span><br><span class="line">cmake -D CUDA_USE_STATIC_CUDA_RUNTIME=OFF ..</span><br><span class="line">make</span><br></pre></td></tr></table></figure>
<p>如果环境配置没有问题的话，build文件下就会生成可执行的程序hog，可以通过<code>hog --help</code>查看帮助，下面使用hog来播放视频，或者也可以直接接摄像头：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./hog --video ~/input.mp4</span><br></pre></td></tr></table></figure>
<p>输出结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Device 0:  &quot;GeForce GTX 1080&quot;  8112Mb, sm_61, Driver/Runtime ver.8.0/8.0</span><br><span class="line"></span><br><span class="line">Controls:</span><br><span class="line">	ESC - exit</span><br><span class="line">	m - change mode GPU &lt;-&gt; CPU</span><br><span class="line">	g - convert image to gray or not</span><br><span class="line">	1/q - increase/decrease HOG scale</span><br><span class="line">	2/w - increase/decrease levels count</span><br><span class="line">	3/e - increase/decrease HOG group threshold</span><br><span class="line">	4/r - increase/decrease hit threshold</span><br><span class="line"></span><br><span class="line">Scale: 1.05</span><br><span class="line">Group threshold: 8</span><br><span class="line">Levels number: 13</span><br><span class="line">Win width: 48</span><br><span class="line">Win stride: (8, 8)</span><br><span class="line">Hit threshold: 1.4</span><br><span class="line">Gamma correction: 1</span><br></pre></td></tr></table></figure>
<p>可以通过m键来切换使用CPU mode或者CUDA mode。<br>可以打开nvidia-setting来查看CUDA mode下GPU的占用情况</p>
<h1 id="可能出现的错误"><a href="#可能出现的错误" class="headerlink" title="可能出现的错误"></a>可能出现的错误</h1><h2 id="如果出现NVCUVID后面是NO，而CUDA后面是YES"><a href="#如果出现NVCUVID后面是NO，而CUDA后面是YES" class="headerlink" title="如果出现NVCUVID后面是NO，而CUDA后面是YES"></a>如果出现NVCUVID后面是NO，而CUDA后面是YES</h2><p>这种情况下将无法使用CUDA编解码功能，这是由于cmake在查找库的时候采用的路径是<code>/usr/lib</code>以及<code>/usr/lib/nvidia-current</code>路径，而实际上我的nvidia显卡驱动安装路径为<code>/usr/lib/nvidia-378</code>，所以导致无法找到这个路径。<br>PS：为了解决这个问题，查看了opencv的cmake中的相关代码后才发现，但在些之前搜索了很久，也乱试了很久都无果，所以一定要有根据的解决问题，还不是盲目地去试。<br>解决：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo ln -s /usr/lib/nvidia-378/libnvcuvid.so /usr/lib/libnvcuvid.so</span><br><span class="line">sudo ln -s /usr/lib/nvidia-378/libnvcuvid.so.1 /usr/lib/libnvcuvid.so.1</span><br></pre></td></tr></table></figure>
<p><strong>记得修改成你自己的nvidia驱动安装路径</strong></p>
<h2 id="如果FFmpeg没有YES"><a href="#如果FFmpeg没有YES" class="headerlink" title="如果FFmpeg没有YES"></a>如果FFmpeg没有YES</h2><p>可能是你的FFmpeg编译后没有将其添加到环境变量中。</p>
<h2 id="编译OpenCV程序出现cannot-find-lopencv-dep-cudart"><a href="#编译OpenCV程序出现cannot-find-lopencv-dep-cudart" class="headerlink" title="编译OpenCV程序出现cannot find -lopencv_dep_cudart"></a>编译OpenCV程序出现cannot find -lopencv_dep_cudart</h2><p>错误详情：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/usr/bin/ld: cannot find -lopencv_dep_cudart</span><br><span class="line">collect2: error: ld returned 1 exit status</span><br><span class="line">CMakeFiles/hog.dir/build.make:120: recipe for target &#x27;hog&#x27; failed</span><br><span class="line">make[2]: *** [hog] Error 1</span><br><span class="line">CMakeFiles/Makefile2:67: recipe for target &#x27;CMakeFiles/hog.dir/all&#x27; failed</span><br><span class="line">make[1]: *** [CMakeFiles/hog.dir/all] Error 2</span><br><span class="line">Makefile:83: recipe for target &#x27;all&#x27; failed</span><br><span class="line">make: *** [all] Error 2</span><br></pre></td></tr></table></figure>
<p>添加cmake编译选项来解决：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cmake -D CUDA_USE_STATIC_CUDA_RUNTIME=OFF ..</span><br></pre></td></tr></table></figure>

<h2 id="编译java版本的OpenCV程序出现NoClassDefFoundError"><a href="#编译java版本的OpenCV程序出现NoClassDefFoundError" class="headerlink" title="编译java版本的OpenCV程序出现NoClassDefFoundError"></a>编译java版本的OpenCV程序出现NoClassDefFoundError</h2><p><strong>Exception in thread “main” java.lang.NoClassDefFoundError: org/opencv/core/Core</strong><br>如果需要配置java调用opencv，需要修改如下配置文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export CLASSPATH=.:$JAVA_HOME/lib:$JRE_HOME/lib:/usr/local/share/OpenCV/java/opencv-2413.jar</span><br><span class="line">export LD_LIBRARY_PATH=/usr/local/lib/:/usr/lib/:/usr/local/share/OpenCV/java:$LD_LIBRARY_PATH</span><br></pre></td></tr></table></figure>

<h2 id="编译选项后面显示Unavaialbe里面有Java"><a href="#编译选项后面显示Unavaialbe里面有Java" class="headerlink" title="编译选项后面显示Unavaialbe里面有Java"></a>编译选项后面显示Unavaialbe里面有Java</h2><p>需要安装包ant</p>
]]></content>
      <categories>
        <category>OpenCV</category>
      </categories>
      <tags>
        <tag>CUDA</tag>
        <tag>Linux</tag>
        <tag>ffmpeg</tag>
        <tag>OpenCV</tag>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>python 2.7 UnicodeEncodError</title>
    <url>/2017/03/20/python-UnicodeEncodError/</url>
    <content><![CDATA[<p>python 2.7.13中采用print输出内容后，通过terminal的管道重定向到文件时出错：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UnicodeEncodeError: &#x27;ascii&#x27; codec can&#x27;t encode characters in position 19-20: ordinal not in range(128)</span><br></pre></td></tr></table></figure>
<p>应该是编码的问题，然后就搜索发现python处理的代码文件的编码，系统默认编码都不一样，虽然可以通过对str进行decode(‘gbk’)的方式将中文正常输出，但重定向时，由于系统编码不一致，导致上述错误。可以通过设置系统编码来解决：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">reload(sys).setdefaultencoding(<span class="string">&quot;utf8&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>使用场景，通过requests获取中文网页，为了方便日常分析使用，会考虑将内容正常输出到标准输出，然后需要输出到文件时再进行重定向，而且还希望文件编码格式统一采用utf-8，代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ...</span></span><br><span class="line">reload(sys).setdefaultencoding(<span class="string">&quot;utf8&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(re.search(regex, requests.get(<span class="string">&#x27;http://example.com&#x27;</span>).content).group(<span class="number">0</span>).decode(<span class="string">&#x27;gbk&#x27;</span>))</span><br></pre></td></tr></table></figure>
<p>这样即可以正常输出中文到标准输出，也可以将其正常重定向到文件，而且不需要修改系统的默认文件编码</p>
<p>参考：<br>1.<a href="http://stackoverflow.com/questions/15530635/why-is-sys-getdefaultencoding-different-from-sys-stdout-encoding-and-how-does">http://stackoverflow.com/questions/15530635/why-is-sys-getdefaultencoding-different-from-sys-stdout-encoding-and-how-does</a><br>2.<a href="http://stackoverflow.com/questions/11741574/how-to-print-utf-8-encoded-text-to-the-console-in-python-3">http://stackoverflow.com/questions/11741574/how-to-print-utf-8-encoded-text-to-the-console-in-python-3</a></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Spark 2.1.0 On Hadoop 2.7集群配置过程</title>
    <url>/2017/03/10/spark-on-yarn-configure/</url>
    <content><![CDATA[<p>系统环境为Ubuntu 16.04.2 x86_64，已经配置好了Hadoop 2.7。配置Hadoop集群环境可以参考<a href="http://notes.maxwi.com/2017/03/09/hadoop-configure-ubuntu/">这里</a></p>
<p>约定将spark安装在<code>/usr/spark</code>，之前安装的Hadoop在路径<code>/usr/hadoop</code>，这里直接在已经配置好的三台hadoop上配置spark，依然将master节点做为master及worker，其他2个节点做为worker。<br>Spark官方下载地址：<a href="http://spark.apache.org/downloads.html">http://spark.apache.org/downloads.html</a></p>
<span id="more"></span>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p><strong>下载并安装</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget http://mirrors.tuna.tsinghua.edu.cn/apache/spark/spark-2.1.0/spark-2.1.0-bin-hadoop2.7.tgz</span><br><span class="line">tar -zxvf spark-2.1.0-bin-hadoop2.7.tgz</span><br><span class="line">mv spark-2.1.0-bin-hadoop2.7 /usr/spark</span><br></pre></td></tr></table></figure>

<p><strong>配置</strong><br>需要修改的文件在路径<code>/usr/spark/conf</code>下，这里我们只需要简单修改<code>spark-env.sh</code>和<code>slaves</code>，更多参数可以参见官方文档。<br><strong>spark-env.sh</strong><br>将官方提供的模板复制一份</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cp spark-env.sh.template spark-env.sh</span><br></pre></td></tr></table></figure>
<p>添加如下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export HADOOP_CONF_DIR=/usr/hadoop/etc/hadoop</span><br><span class="line">export SPARK_MASTER_HOST=master</span><br></pre></td></tr></table></figure>
<p><strong>slaves</strong><br>将官方提供的模板复制一份</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mv slaves.template slaves</span><br></pre></td></tr></table></figure>
<p>添加如下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">localhost</span><br><span class="line">slave1</span><br><span class="line">slave2</span><br></pre></td></tr></table></figure>

<p>如果环境变量配置的都没有问题的话，现在可以运行以下官方示例计算pi值（在路径<code>/usr/spark</code>下执行）：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./bin/run-example SparkPi 10</span><br></pre></td></tr></table></figure>
<p>输出内容的最后面为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">17/03/11 00:28:31 INFO ui.SparkUI: Stopped Spark web UI at http://192.168.1.124:4040</span><br><span class="line">17/03/11 00:28:31 INFO spark.MapOutputTrackerMasterEndpoint: MapOutputTrackerMasterEndpoint stopped!</span><br><span class="line">17/03/11 00:28:31 INFO memory.MemoryStore: MemoryStore cleared</span><br><span class="line">17/03/11 00:28:31 INFO storage.BlockManager: BlockManager stopped</span><br><span class="line">17/03/11 00:28:31 INFO storage.BlockManagerMaster: BlockManagerMaster stopped</span><br><span class="line">17/03/11 00:28:31 INFO scheduler.OutputCommitCoordinator$OutputCommitCoordinatorEndpoint: OutputCommitCoordinator stopped!</span><br><span class="line">17/03/11 00:28:31 INFO spark.SparkContext: Successfully stopped SparkContext</span><br><span class="line">17/03/11 00:28:31 INFO util.ShutdownHookManager: Shutdown hook called</span><br><span class="line">17/03/11 00:28:31 INFO util.ShutdownHookManager: Deleting directory /tmp/spark-8e83fd0b-bc88-4452-998a-9ca4300097b8</span><br></pre></td></tr></table></figure>
<p>往上翻就会看到<code>Pi is roughly 3.1413151413151414</code></p>
<p>为了方便执行spark-shell，将spark的bin路径添加到PATH，修改<code>.bashrc</code>添加如下内容：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Spark</span></span><br><span class="line">export SPARK_HOME=/usr/spark</span><br><span class="line">PATH=$PATH:$SPARK_HOME/bin</span><br><span class="line">export PATH</span><br></pre></td></tr></table></figure>

<p>将spark拷贝到其他节点：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">scp -r /usr/spark slave1:/usr/</span><br><span class="line">scp -r /usr/spark slave1:/usr/</span><br></pre></td></tr></table></figure>
<p>同样将修改的<code>.bashrc</code>拷贝到其他节点，这里spark的环境变量并非必须，只是为了方便执行spark目录下bin中的程序</p>
<h2 id="启动spark集群"><a href="#启动spark集群" class="headerlink" title="启动spark集群"></a>启动spark集群</h2><p>首先启动HDFS和yarn：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/usr/hadoop/sbin/start-dfs.sh</span><br><span class="line">/usr/hadoop/sbin/start-yarn.sh</span><br></pre></td></tr></table></figure>

<p>为了方便查看完成的历史任务，启动jobhistory：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/usr/hadoop/sbin/mr-jobhistory-daemon.sh start historyserver</span><br></pre></td></tr></table></figure>

<p>启动spark，为了省事，一次性启动所有master和worker：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">usr/spark/sbin/start-all.sh</span><br></pre></td></tr></table></figure>
<p>现在查看master上的java进程信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1377 NameNode</span><br><span class="line">5235 Worker</span><br><span class="line">6997 Jps</span><br><span class="line">5461 SparkSubmit</span><br><span class="line">5096 Master</span><br><span class="line">3593 ResourceManager</span><br><span class="line">3737 NodeManager</span><br><span class="line">2362 JobHistoryServer</span><br><span class="line">1533 DataNode</span><br><span class="line">1726 SecondaryNameNode</span><br></pre></td></tr></table></figure>
<p>worker上的信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2577 Worker</span><br><span class="line">1267 DataNode</span><br><span class="line">2787 Jps</span><br><span class="line">2159 NodeManager</span><br></pre></td></tr></table></figure>
<p>可以查看web UI：<a href="http://192.168.1.187:8080">http://192.168.1.187:8080</a><br>如果显示的<code>Alive Worker</code>数量为3以及内容和CPU核数都与实际相符，则表示spark已经配置并启动完成<br>该页面前面的REST URL即是在cluster模式提交spark任务所需要的地址</p>
<h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p><strong>YARN方式计算Pi</strong><br>可以在任何节点上运行以下命令，注意<code>--master</code>替换成你自己的</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/usr/spark/bin/spark-submit \</span><br><span class="line">  --class org.apache.spark.examples.SparkPi \</span><br><span class="line">  --master spark://wyl-node1:6066 \</span><br><span class="line">  --deploy-mode cluster \</span><br><span class="line">  --supervise \</span><br><span class="line">  --executor-memory 1G \</span><br><span class="line">  --total-executor-cores 10 \</span><br><span class="line">  /usr/spark/examples/jars/spark-examples_2.11-2.1.0.jar \</span><br><span class="line">  100000</span><br></pre></td></tr></table></figure>
<p>可以根据自己的配置调整参数，输出中会包含如下信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">client token: N/A</span><br><span class="line">diagnostics: N/A</span><br><span class="line">ApplicationMaster host: 192.168.1.187</span><br><span class="line">ApplicationMaster RPC port: 0</span><br><span class="line">queue: default</span><br><span class="line">start time: 1489166056893</span><br><span class="line">final status: UNDEFINED</span><br><span class="line">tracking URL: http://master:8099/proxy/application_1489144101889_0003/</span><br><span class="line">user: root</span><br></pre></td></tr></table></figure>
<p>由于是yarn模式运行，所以无法通过4040端口的页面查看信息，但可以打开提示的相应节点的URL查看到当前的任务执行情况，点击<code>Executors</code>可以看到各work及RDD信息，如果显示的信息与实际相符，说明集群已经完全启动并正在工作<br>本例中YARN的网页地址是<a href="http://192.168.1.187:8099">http://192.168.1.187:8099</a><br><em>注意Spark Master的WEB UI默认商品是8080，即本例中的网址<a href="http://192.168.1.187:8080/">http://192.168.1.187:8080/</a></em><br><em>当Spark运行于standalone cluster模式时可以通过4040端口的WEB UI查看详细信息，即本例中的<a href="http://192.168.1.187:4040">http://192.168.1.187:4040</a>，注意该页面只在有standalone任务运行时才能查看，例如使用spark-shell时</em><br>计算完成之后，输出中会有<code>final status: SUCCEEDED</code><br>通过8099端口的网页，打开相应的任务ID，进入后从Logs里面点击stdout，会看到<code>Pi is roughly 3.141758431417584</code></p>
<p><strong>Standalone Cluster模式运行Spark</strong><br>运行代码为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/usr/spark/bin/spark-submit \</span><br><span class="line">  --class org.apache.spark.examples.SparkPi \</span><br><span class="line">  --master spark://wyl-node1:6066 \</span><br><span class="line">  --deploy-mode cluster \</span><br><span class="line">  --supervise \</span><br><span class="line">  --executor-memory 1G \</span><br><span class="line">  --total-executor-cores 10 \</span><br><span class="line">  /usr/spark/examples/jars/spark-examples_2.11-2.1.0.jar \</span><br><span class="line">  10000</span><br></pre></td></tr></table></figure>
<p>通过master的4040端口查看</p>
<p><strong>spark shell</strong><br>这里使用python语言，所以需要用<code>pyspark</code><br>首先将Spark根目录下面的<code>README.md</code>上传到相应用户的HDFS目录下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hdfs dfs -put README.md /user/root</span><br></pre></td></tr></table></figure>
<p>进入spark shell：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./bin/pyspark</span><br></pre></td></tr></table></figure>
<p>如果刚才设置过spark环境变量，可以直接执行pyspark，输出如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Python 2.7.12 (default, Nov 19 2016, 06:48:10) </span><br><span class="line">[GCC 5.4.0 20160609] on linux2</span><br><span class="line">Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.</span><br><span class="line">Setting default log level to &quot;WARN&quot;.</span><br><span class="line">To adjust logging level use sc.setLogLevel(newLevel). For SparkR, use setLogLevel(newLevel).</span><br><span class="line">17/03/10 23:50:50 WARN metastore.ObjectStore: Failed to get database global_temp, returning NoSuchObjectException</span><br><span class="line">Welcome to</span><br><span class="line">      ____              __</span><br><span class="line">     / __/__  ___ _____/ /__</span><br><span class="line">    _\ \/ _ \/ _ `/ __/  &#x27;_/</span><br><span class="line">   /__ / .__/\_,_/_/ /_/\_\   version 2.1.0</span><br><span class="line">      /_/</span><br><span class="line"></span><br><span class="line">Using Python version 2.7.12 (default, Nov 19 2016 06:48:10)</span><br><span class="line">SparkSession available as &#x27;spark&#x27;.</span><br></pre></td></tr></table></figure>
<p>输出中的那个警告应该是没有安装HIVE或HBase引起的。<br>下面就是正常的python语言：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>textFile = sc.textFile(<span class="string">&quot;README.md&quot;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>textFile.count()  <span class="comment">#统计RDD中的元素数</span></span><br><span class="line"><span class="number">104</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>textFile.first()  <span class="comment">#返回RDD中的第一个元素</span></span><br><span class="line"><span class="string">u&#x27;# Apache Spark&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>linesWithSpark = textFile.<span class="built_in">filter</span>(<span class="keyword">lambda</span> line: <span class="string">&quot;Spark&quot;</span> <span class="keyword">in</span> line)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>textFile.<span class="built_in">filter</span>(<span class="keyword">lambda</span> line: <span class="string">&quot;Spark&quot;</span> <span class="keyword">in</span> line).count() <span class="comment"># 包含`Spark`的行数</span></span><br><span class="line"><span class="number">20</span></span><br></pre></td></tr></table></figure>
<p>如果这里都没有问题，说明Spark已经可以正常工作，剩下的就是学习Spark了</p>
<p><strong>默认配置情况下spark从非master节点启动会有web ui相关的错误提示，直接从master节点关闭spark之后再重新启动即可</strong></p>
<p>参考：<br>1.Spark官网：<a href="http://spark.apache.org/">http://spark.apache.org/</a><br>2.Running Spark on YARN: <a href="http://spark.apache.org/docs/latest/running-on-yarn.html">http://spark.apache.org/docs/latest/running-on-yarn.html</a><br>3.Submitting Applications：<a href="http://spark.apache.org/docs/latest/submitting-applications.html">http://spark.apache.org/docs/latest/submitting-applications.html</a><br>4.Quora-<a href="https://www.quora.com/How-do-I-set-up-Apache-Spark-with-Yarn-Cluster">How do I set up Apache Spark with Yarn Cluster?</a></p>
]]></content>
      <categories>
        <category>Spark</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>Spark</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu 16.04下配置Hadoop 2.7.3集群</title>
    <url>/2017/03/09/hadoop-configure-ubuntu/</url>
    <content><![CDATA[<p>为了Spark使用HDFS，所以先配置Hadoop集群，系统参数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DISTRIB_ID=Ubuntu</span><br><span class="line">DISTRIB_RELEASE=16.04</span><br><span class="line">DISTRIB_CODENAME=xenial</span><br><span class="line">DISTRIB_DESCRIPTION=&quot;Ubuntu 16.04.2 LTS&quot;</span><br><span class="line">NAME=&quot;Ubuntu&quot;</span><br><span class="line">VERSION=&quot;16.04.2 LTS (Xenial Xerus)&quot;</span><br><span class="line">ID=ubuntu</span><br><span class="line">ID_LIKE=debian</span><br><span class="line">PRETTY_NAME=&quot;Ubuntu 16.04.2 LTS&quot;</span><br><span class="line">VERSION_ID=&quot;16.04&quot;</span><br><span class="line">HOME_URL=&quot;http://www.ubuntu.com/&quot;</span><br><span class="line">SUPPORT_URL=&quot;http://help.ubuntu.com/&quot;</span><br><span class="line">BUG_REPORT_URL=&quot;http://bugs.launchpad.net/ubuntu/&quot;</span><br><span class="line">VERSION_CODENAME=xenial</span><br><span class="line">UBUNTU_CODENAME=xenial</span><br></pre></td></tr></table></figure>
<p>Hadoop版本为官方当前最新的2.7.3：<a href="http://www.apache.org/dyn/closer.cgi/hadoop/common/hadoop-2.7.3/hadoop-2.7.3.tar.gz">http://www.apache.org/dyn/closer.cgi/hadoop/common/hadoop-2.7.3/hadoop-2.7.3.tar.gz</a></p>
<span id="more"></span>

<h1 id="基础准备"><a href="#基础准备" class="headerlink" title="基础准备"></a>基础准备</h1><p><strong>配置Java环境</strong><br>可以参见这里：<a href="http://notes.maxwi.com/2016/10/01/java-env-set/">http://notes.maxwi.com/2016/10/01/java-env-set/</a></p>
<p><strong>配置SSH免密登录</strong><br>可以参见这里：<a href="http://notes.maxwi.com/2017/03/09/linux-ssh-nopasswd/">http://notes.maxwi.com/2017/03/09/linux-ssh-nopasswd/</a></p>
<p><strong>配置hosts映射</strong><br>首先准备三台机器，可以是虚拟机。三台机器根据其ip将分别命名为：</p>
<table>
<thead>
<tr>
<th>主机名</th>
<th>ip</th>
</tr>
</thead>
<tbody><tr>
<td>master</td>
<td>192.168.1.187</td>
</tr>
<tr>
<td>slave1</td>
<td>192.168.1.188</td>
</tr>
<tr>
<td>slave2</td>
<td>192.168.1.188</td>
</tr>
</tbody></table>
<p>修改各主机名，主机名文件为：<code>/etc/hostname</code>，分别将三台主机的名称修改为对应的名称。<br>修改hosts文件映射，hosts文件路径为<code>/etc/hosts</code>，修改三台主机的hosts内容为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">127.0.0.1	localhost</span><br><span class="line"></span><br><span class="line">192.168.1.187 master</span><br><span class="line">192.168.1.188 slave1</span><br><span class="line">192.168.1.189 slave2</span><br></pre></td></tr></table></figure>
<p><strong>注意：一定要删除ubuntu系统自动添加的那行<code>127.0.1.1 master</code></strong></p>
<p>上面这里是每一台机器都需要进行的配置，也可以配置其中一台的java环境，然后直接克隆后再修改其他内容</p>
<p>然后重启机器，主机名就可以生效了，这里面其实主机名的修改并不是必须的，包括hosts映射也非必须，只是为了后面方便配置，同时也为了避免由于ip变动而需要修改各配置文件。</p>
<p>推荐先根据官方的单节点配置方法走一遍，熟悉一下过程：<a href="https://hadoop.apache.org/docs/stable/hadoop-project-dist/hadoop-common/SingleCluster.html">https://hadoop.apache.org/docs/stable/hadoop-project-dist/hadoop-common/SingleCluster.html</a><br>当然也可以直接看下面的内容。</p>
<h1 id="配置Hadoop"><a href="#配置Hadoop" class="headerlink" title="配置Hadoop"></a>配置Hadoop</h1><h2 id="下载并配置hadoop环境变量"><a href="#下载并配置hadoop环境变量" class="headerlink" title="下载并配置hadoop环境变量"></a>下载并配置hadoop环境变量</h2><p>这里将hadoop安装在/usr/hadoop目录，下面的操作非特殊说明都是在master上进行操作，为了避免权限问题，在root用户下操作，其实普通用户也是一样的。<br><strong>下载hadoop 2.7.3</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget http://mirrors.tuna.tsinghua.edu.cn/apache/hadoop/common/hadoop-2.7.3/hadoop-2.7.3.tar.gz</span><br></pre></td></tr></table></figure>
<p>这里选择的是清华的源，可以根据需要选择<br><strong>解压并进入到hadoop目录</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tar -zxvf hadoop-2.7.3.tar.gz</span><br><span class="line">mv hadoop-2.7.3 /usr/hadoop</span><br><span class="line">cd /usr/hadoop</span><br></pre></td></tr></table></figure>
<p>将以下环境变量添加到自己的<code>~/.bashrc</code>或者<code>/etc/profile</code>中，这里为了方便就直接放到<code>~/.bashrc</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># for Hadoop</span><br><span class="line">export HADOOP_HOME=/usr/hadoop</span><br><span class="line">PATH=$PATH:$HADOOP_HOME/bin:$HADOOP_HOME/sbin</span><br><span class="line">CLASSPATH=$CLASSPATH:$HADOOP_HOME/share/hadoop/common/hadoop-common-2.7.3.jar:$HADOOP_HOME/share/hadoop/common/lib/commons-cli-1.2.jar:$HADOOP_HOME/share/hadoop/mapreduce/hadoop-mapreduce-client-core-2.7.3.jar</span><br><span class="line"></span><br><span class="line">export HADOOP_PREFIX=/usr/hadoop</span><br><span class="line">export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$HADOOP_HOME/lib/native/</span><br><span class="line"></span><br><span class="line">PATH=$PATH:$HOME/bin</span><br><span class="line">export PATH</span><br><span class="line">export CLASSPATH</span><br></pre></td></tr></table></figure>

<p><strong>PATH变量中最好不要添加sbin目录，因为会与spark的sbin目录下的脚本冲突，需要启动的时候直接手动到相应目录下启动相应服务</strong></p>
<p>scp到其他机器：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">scp ~/.bashrc slave1:~</span><br><span class="line">scp ~/.bashrc slave2:~</span><br></pre></td></tr></table></figure>
<p>分别在三台机器上执行source使环境变量生效：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">source ~/.bashrc</span><br></pre></td></tr></table></figure>

<p>如果环境变量配置都没有问题的话，现在已经可以查看到hadoop的版本等信息了：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hadoop version</span><br></pre></td></tr></table></figure>

<h2 id="验证Hadoop单机配置"><a href="#验证Hadoop单机配置" class="headerlink" title="验证Hadoop单机配置"></a>验证Hadoop单机配置</h2><p>修改<code>/usr/hadoop</code>目录下的<code>etc/hadoop/hadoop-env.sh</code>文件，修改Java路径：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export JAVA_HOME=/usr/lib/jvm/java-8-oracle</span><br></pre></td></tr></table></figure>

<p>通过拷贝hadoop的配置文件，并在调用hadoop自带示例中的正则表达式来搜索配置文件，并将结果输出到output：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /usr/hadoop</span><br><span class="line">cp etc/hadoop/*.xml input</span><br><span class="line">hadoop jar share/hadoop/mapreduce/hadoop-mapreduce-examples-2.7.3.jar grep input output &#x27;dfs[a-z.]+&#x27;</span><br><span class="line">cat output/*</span><br></pre></td></tr></table></figure>
<p>如果执行中没有报错，并且输出如下，则表示hadoop环境变量配置完成：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1	dfsadmin</span><br></pre></td></tr></table></figure>

<p>下面开始配置集群环境</p>
<h2 id="修改Hadoop配置文件"><a href="#修改Hadoop配置文件" class="headerlink" title="修改Hadoop配置文件"></a>修改Hadoop配置文件</h2><p>下面的操作都是在hadoop目录之中的<code>etc/hadoop</code>路径下，即<code>/usr/hadoop/etc/hadoop</code>，该文件夹存放了hadoop所需要的几乎所有配置文件。<br>需要修改的配置文件主要有：<code>hadoop-env.sh</code>, <code>core-site.xml</code>, <code>hdfs-site.xml</code>, <code>mapred-site.xml</code>, <code>yarn-env.sh</code>, <code>yarn-site.xml</code>, <code>slaves</code></p>
<p><strong>hadoop-env.sh</strong><br>除了上面需要在其中添加JAVA_HOME之外，还需要增加HADOOP_PREFIX变量：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export HADOOP_PREFIX=/usr/hadoop</span><br></pre></td></tr></table></figure>

<p><strong>core-site.xml</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line">  &lt;property&gt;</span><br><span class="line">    &lt;name&gt;fs.defaultFS&lt;/name&gt;</span><br><span class="line">    &lt;value&gt;hdfs://master:9000&lt;/value&gt;</span><br><span class="line">    &lt;description&gt;HDFS的URL，文件系统：//namenode标识:端口号&lt;/description&gt;</span><br><span class="line">  &lt;/property&gt;</span><br><span class="line"></span><br><span class="line">  &lt;property&gt;</span><br><span class="line">    &lt;name&gt;hadoop.tmp.dir&lt;/name&gt;</span><br><span class="line">    &lt;value&gt;/usr/hadoop/tmp&lt;/value&gt;</span><br><span class="line">    &lt;description&gt;namenode上本地的hadoop临时文件夹&lt;/description&gt;</span><br><span class="line">  &lt;/property&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure>
<p>这里指定master为namenode及相应端口号，并设置本地的临时文件夹为hadoop安装目录下的tmp，该目录需要手动创建</p>
<p><strong>hdfs-site.xml</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line">  &lt;property&gt;</span><br><span class="line">    &lt;name&gt;dfs.name.dir&lt;/name&gt;</span><br><span class="line">    &lt;value&gt;/usr/hadoop/hdfs/name&lt;/value&gt;</span><br><span class="line">    &lt;description&gt;namenode上存储hdfs名字空间元数据&lt;/description&gt;</span><br><span class="line">  &lt;/property&gt;</span><br><span class="line"></span><br><span class="line">  &lt;property&gt;</span><br><span class="line">    &lt;name&gt;dfs.data.dir&lt;/name&gt;</span><br><span class="line">    &lt;value&gt;/usr/hadoop/hdfs/data&lt;/value&gt;</span><br><span class="line">    &lt;description&gt;datanode上数据块的物理存储位置&lt;/description&gt;</span><br><span class="line">  &lt;/property&gt;</span><br><span class="line"></span><br><span class="line">  &lt;property&gt;</span><br><span class="line">    &lt;name&gt;dfs.replication&lt;/name&gt;</span><br><span class="line">    &lt;value&gt;3&lt;/value&gt;</span><br><span class="line">    &lt;description&gt;副本个数，配置默认是3，应小于datanode机器数量&lt;/description&gt;</span><br><span class="line">  &lt;/property&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure>
<p>指定namenode和datanode数据的存储位置（需要手动创建），以及副本个数</p>
<p><strong>mapred-site.xml</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line">  &lt;property&gt;</span><br><span class="line">    &lt;name&gt;mapreduce.framework.name&lt;/name&gt;</span><br><span class="line">    &lt;value&gt;yarn&lt;/value&gt;</span><br><span class="line">  &lt;/property&gt;</span><br><span class="line"></span><br><span class="line">  &lt;property&gt;</span><br><span class="line">    &lt;name&gt;mapreduce.jobhistory.address&lt;/name&gt;</span><br><span class="line">    &lt;value&gt;master:10020&lt;/value&gt;</span><br><span class="line">  &lt;/property&gt;</span><br><span class="line"></span><br><span class="line">  &lt;property&gt;</span><br><span class="line">    &lt;name&gt;mapreduce.jobhistory.webapp.address&lt;/name&gt;</span><br><span class="line">    &lt;value&gt;master:19888&lt;/value&gt;</span><br><span class="line">  &lt;/property&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure>

<p><strong>yarn-env.sh</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># export JAVA_HOME=/home/y/libexec/jdk1.6.0/</span><br><span class="line">export JAVA_HOME=/usr/lib/jvm/java-8-oracle</span><br></pre></td></tr></table></figure>
<p>修改JAVA_HOME</p>
<p><strong>yarn-site.xml</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- Site specific YARN configuration properties --&gt;</span><br><span class="line">  &lt;property&gt;</span><br><span class="line">    &lt;name&gt;yarn.nodemanager.aux-services&lt;/name&gt;</span><br><span class="line">    &lt;value&gt;mapreduce_shuffle&lt;/value&gt;</span><br><span class="line">  &lt;/property&gt;</span><br><span class="line"></span><br><span class="line">  &lt;property&gt;</span><br><span class="line">    &lt;name&gt;yarn.resourcemanager.hostname&lt;/name&gt;</span><br><span class="line">    &lt;value&gt;master&lt;/value&gt;</span><br><span class="line">  &lt;/property&gt;</span><br><span class="line"></span><br><span class="line">  &lt;property&gt;</span><br><span class="line">    &lt;name&gt;yarn.resourcemanager.webapp.address&lt;/name&gt;</span><br><span class="line">    &lt;value&gt;master:8099&lt;/value&gt;</span><br><span class="line">  &lt;/property&gt;</span><br><span class="line"></span><br><span class="line">  &lt;property&gt;</span><br><span class="line">    &lt;name&gt;yarn.resourcemanager.address&lt;/name&gt;</span><br><span class="line">    &lt;value&gt;master:8032&lt;/value&gt;</span><br><span class="line">  &lt;/property&gt;</span><br><span class="line"></span><br><span class="line">  &lt;property&gt;</span><br><span class="line">    &lt;name&gt;yarn.resourcemanager.scheduler.address&lt;/name&gt;</span><br><span class="line">    &lt;value&gt;master:8030&lt;/value&gt;</span><br><span class="line">  &lt;/property&gt;</span><br><span class="line"></span><br><span class="line">  &lt;property&gt;</span><br><span class="line">    &lt;name&gt;yarn.resourcemanager.resource-tracker.address&lt;/name&gt;</span><br><span class="line">    &lt;value&gt;master:8031&lt;/value&gt;</span><br><span class="line">  &lt;/property&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure>
<p>指定resourcemanager为master，并修改相应端口，这些端口如果不修改都有默认值，可以根据自己的网络情况进行修改</p>
<p><strong>slaves</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">master</span><br><span class="line">slave1</span><br><span class="line">slave2</span><br></pre></td></tr></table></figure>
<p>master即是namenode，同时也是datanode<br>创建刚才配置中用到的文件夹：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir -p /usr/hadoop/hdfs/data /usr/hadoop/hdfs/name /usr/hadoop/tmp</span><br></pre></td></tr></table></figure>

<p>配置完成之后将该配置复制到slave1和slave2上：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scp -r /usr/hadoop slave1:/usr/</span><br><span class="line">scp -r /usr/hadoop slave2:/usr/</span><br></pre></td></tr></table></figure>

<h1 id="启动Hadoop集群"><a href="#启动Hadoop集群" class="headerlink" title="启动Hadoop集群"></a>启动Hadoop集群</h1><h2 id="启动hdfs"><a href="#启动hdfs" class="headerlink" title="启动hdfs"></a>启动hdfs</h2><p>记得其他2个slave上的环境变量都已经生效<br>在master上格式化namenode：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hdfs namenode -format</span><br></pre></td></tr></table></figure>
<p>在master上执行以下命令启动hadoop：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">start-dfs.sh</span><br></pre></td></tr></table></figure>
<p>启动完成之后在master上启动jps命令查看其java进程：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4949 NameNode</span><br><span class="line">5415 Jps</span><br><span class="line">5289 SecondaryNameNode</span><br><span class="line">5102 DataNode</span><br></pre></td></tr></table></figure>
<p>查看slave1和slave2上进程：<br>slave1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1827 DataNode</span><br><span class="line">1903 Jps</span><br></pre></td></tr></table></figure>
<p>slave2:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2024 Jps</span><br><span class="line">1950 DataNode</span><br></pre></td></tr></table></figure>
<p>找一个能够访问master的浏览器通过50070端口可以查看namenode和datanode情况<a href="http://192.168.1.187:50070/dfshealth.html#tab-overview">http://192.168.1.187:50070/dfshealth.html#tab-overview</a><br>如果看到Summary中的Live Nodes显示为3，并且<code>Configured Capacity</code>中显示的DFS总大小刚好为三台机器的可用空间大小，则表示已经配置没有问题</p>
<h2 id="启动yarn"><a href="#启动yarn" class="headerlink" title="启动yarn"></a>启动yarn</h2><p>执行以下命令启动yarn：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">start-yarn.sh</span><br></pre></td></tr></table></figure>
<p>使用jps查看master及2个slave：<br>master：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5476 ResourceManager</span><br><span class="line">4949 NameNode</span><br><span class="line">5289 SecondaryNameNode</span><br><span class="line">5883 Jps</span><br><span class="line">5102 DataNode</span><br><span class="line">5775 NodeManager</span><br></pre></td></tr></table></figure>
<p>slave1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1827 DataNode</span><br><span class="line">1971 NodeManager</span><br><span class="line">2079 Jps</span><br></pre></td></tr></table></figure>
<p>slave2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2198 Jps</span><br><span class="line">1950 DataNode</span><br><span class="line">2095 NodeManager</span><br></pre></td></tr></table></figure>
<p>根据我们的配置，通过master的端口8099端口可以在web端查看集群的内存、CPU、及任务调度情况<a href="http://192.168.1.187:8099/cluster">http://192.168.1.187:8099/cluster</a>，如果显示的<code>Memory Total</code>、<code>Active Nodes</code>等内容与你的实际相符，则表示yarn启动成功<br>通过各节点的8042端口可以查看各节点的资源情况，如查看slave1的节点信息：<a href="http://192.168.1.188:8042">http://192.168.1.188:8042</a></p>
<p>也可以通过以下命令查看hdfs的全局信息：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hdfs dfsadmin -report</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Configured Capacity: 59837042688 (55.73 GB)</span><br><span class="line">Present Capacity: 41174982656 (38.35 GB)</span><br><span class="line">DFS Remaining: 40219471872 (37.46 GB)</span><br><span class="line">DFS Used: 955510784 (911.25 MB)</span><br><span class="line">DFS Used%: 2.32%</span><br><span class="line">Under replicated blocks: 0</span><br><span class="line">Blocks with corrupt replicas: 0</span><br><span class="line">Missing blocks: 0</span><br><span class="line">Missing blocks (with replication factor 1): 0</span><br><span class="line"></span><br><span class="line">-------------------------------------------------</span><br><span class="line">Live datanodes (3):</span><br><span class="line"></span><br><span class="line">Name: 192.168.1.188:50010 (slave1)</span><br><span class="line">Hostname: slave1</span><br><span class="line">Decommission Status : Normal</span><br><span class="line">Configured Capacity: 19945680896 (18.58 GB)</span><br><span class="line">DFS Used: 318500864 (303.75 MB)</span><br><span class="line">Non DFS Used: 6454030336 (6.01 GB)</span><br><span class="line">DFS Remaining: 13173149696 (12.27 GB)</span><br><span class="line">DFS Used%: 1.60%</span><br><span class="line">DFS Remaining%: 66.05%</span><br><span class="line">Configured Cache Capacity: 0 (0 B)</span><br><span class="line">Cache Used: 0 (0 B)</span><br><span class="line">Cache Remaining: 0 (0 B)</span><br><span class="line">Cache Used%: 100.00%</span><br><span class="line">Cache Remaining%: 0.00%</span><br><span class="line">Xceivers: 1</span><br><span class="line">Last contact: Fri Mar 10 00:57:51 CST 2017</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Name: 192.168.1.187:50010 (master)</span><br><span class="line">Hostname: master</span><br><span class="line">Decommission Status : Normal</span><br><span class="line">Configured Capacity: 19945680896 (18.58 GB)</span><br><span class="line">DFS Used: 318500864 (303.75 MB)</span><br><span class="line">Non DFS Used: 6287228928 (5.86 GB)</span><br><span class="line">DFS Remaining: 13339951104 (12.42 GB)</span><br><span class="line">DFS Used%: 1.60%</span><br><span class="line">DFS Remaining%: 66.88%</span><br><span class="line">Configured Cache Capacity: 0 (0 B)</span><br><span class="line">Cache Used: 0 (0 B)</span><br><span class="line">Cache Remaining: 0 (0 B)</span><br><span class="line">Cache Used%: 100.00%</span><br><span class="line">Cache Remaining%: 0.00%</span><br><span class="line">Xceivers: 1</span><br><span class="line">Last contact: Fri Mar 10 00:57:51 CST 2017</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Name: 192.168.1.189:50010 (slave2)</span><br><span class="line">Hostname: slave2</span><br><span class="line">Decommission Status : Normal</span><br><span class="line">Configured Capacity: 19945680896 (18.58 GB)</span><br><span class="line">DFS Used: 318509056 (303.75 MB)</span><br><span class="line">Non DFS Used: 5920800768 (5.51 GB)</span><br><span class="line">DFS Remaining: 13706371072 (12.77 GB)</span><br><span class="line">DFS Used%: 1.60%</span><br><span class="line">DFS Remaining%: 68.72%</span><br><span class="line">Configured Cache Capacity: 0 (0 B)</span><br><span class="line">Cache Used: 0 (0 B)</span><br><span class="line">Cache Remaining: 0 (0 B)</span><br><span class="line">Cache Used%: 100.00%</span><br><span class="line">Cache Remaining%: 0.00%</span><br><span class="line">Xceivers: 1</span><br><span class="line">Last contact: Fri Mar 10 00:57:49 CST 2017</span><br></pre></td></tr></table></figure>

<h2 id="启动Job-History"><a href="#启动Job-History" class="headerlink" title="启动Job History"></a>启动Job History</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mr-jobhistory-daemon.sh start historyserver</span><br></pre></td></tr></table></figure>
<p>master上的jps进程：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">8720 Jps</span><br><span class="line">7809 DataNode</span><br><span class="line">8628 JobHistoryServer</span><br><span class="line">7656 NameNode</span><br><span class="line">8155 ResourceManager</span><br><span class="line">8285 NodeManager</span><br><span class="line">7999 SecondaryNameNode</span><br></pre></td></tr></table></figure>
<p>查看web页面：<a href="http://192.168.1.187:19888">http://192.168.1.187:19888</a></p>
<p>至此整个Hadoop集群已经启动成功<br>Job history并不是必须的</p>
<h1 id="验证HDFS"><a href="#验证HDFS" class="headerlink" title="验证HDFS"></a>验证HDFS</h1><p>查看当前hdfs中的文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hdfs dfs -ls /</span><br></pre></td></tr></table></figure>
<p>在hdfs上创建一个文件夹：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hdfs dfs -mkdir /test</span><br></pre></td></tr></table></figure>
<p>再次查看：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@master:/usr/hadoop# hdfs dfs -ls /</span><br><span class="line">Found 1 items</span><br><span class="line">drwxr-xr-x   - root supergroup          0 2017-03-09 23:44 /test</span><br></pre></td></tr></table></figure>
<p>将hadoop目录下的README.txt存储到hdfs上刚刚创建的test文件夹：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hdfs dfs -put README.txt /test</span><br></pre></td></tr></table></figure>
<p>查看：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"> hdfs dfs -ls /test</span><br><span class="line">Found 1 items</span><br><span class="line">-rw-r--r--   3 root supergroup       1366 2017-03-09 23:47 /test/README.txt</span><br></pre></td></tr></table></figure>
<p>也可以通过web页面查看刚刚在hdfs上创建的文件：<a href="http://192.168.1.187:50070/explorer.html">http://192.168.1.187:50070/explorer.html</a><br>查看hadoop目录下我们创建的hdfs文件夹name和data中的文件也可以看到其中有了变化，因为我们的副本数为3，所以各节点上应该都会有数据：<br>master：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hdfs/</span><br><span class="line">├── data</span><br><span class="line">│  ├── current</span><br><span class="line">│  │  ├── BP-109196317-192.168.1.187-1489073016129</span><br><span class="line">│  │  │  ├── current</span><br><span class="line">│  │  │  │  ├── finalized</span><br><span class="line">│  │  │  │  │  └── subdir0</span><br><span class="line">│  │  │  │  │      └── subdir0</span><br><span class="line">│  │  │  │  │          ├── blk_1073741825</span><br><span class="line">│  │  │  │  │          └── blk_1073741825_1001.meta</span><br><span class="line">│  │  │  │  ├── rbw</span><br><span class="line">│  │  │  │  └── VERSION</span><br><span class="line">│  │  │  ├── scanner.cursor</span><br><span class="line">│  │  │  └── tmp</span><br><span class="line">│  │  └── VERSION</span><br><span class="line">│  └── in_use.lock</span><br><span class="line">└── name</span><br><span class="line">    ├── current</span><br><span class="line">    │  ├── edits_inprogress_0000000000000000001</span><br><span class="line">    │  ├── fsimage_0000000000000000000</span><br><span class="line">    │  ├── fsimage_0000000000000000000.md5</span><br><span class="line">    │  ├── seen_txid</span><br><span class="line">    │  └── VERSION</span><br><span class="line">    └── in_use.lock</span><br><span class="line"></span><br><span class="line">11 directories, 12 files</span><br></pre></td></tr></table></figure>
<p>2个slave中的文件内容完全一致：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hdfs/</span><br><span class="line">├── data</span><br><span class="line">│  ├── current</span><br><span class="line">│  │  ├── BP-109196317-192.168.1.187-1489073016129</span><br><span class="line">│  │  │  ├── current</span><br><span class="line">│  │  │  │  ├── finalized</span><br><span class="line">│  │  │  │  │  └── subdir0</span><br><span class="line">│  │  │  │  │      └── subdir0</span><br><span class="line">│  │  │  │  │          ├── blk_1073741825</span><br><span class="line">│  │  │  │  │          └── blk_1073741825_1001.meta</span><br><span class="line">│  │  │  │  ├── rbw</span><br><span class="line">│  │  │  │  └── VERSION</span><br><span class="line">│  │  │  ├── scanner.cursor</span><br><span class="line">│  │  │  └── tmp</span><br><span class="line">│  │  └── VERSION</span><br><span class="line">│  └── in_use.lock</span><br><span class="line">└── name</span><br><span class="line"></span><br><span class="line">10 directories, 6 files</span><br></pre></td></tr></table></figure>

<p>更多HDFS命令参考这里：<a href="https://hadoop.apache.org/docs/stable/hadoop-project-dist/hadoop-common/FileSystemShell.html#ls">https://hadoop.apache.org/docs/stable/hadoop-project-dist/hadoop-common/FileSystemShell.html#ls</a></p>
<h1 id="验证Hadoop集群"><a href="#验证Hadoop集群" class="headerlink" title="验证Hadoop集群"></a>验证Hadoop集群</h1><p>使用hadoop自带的一个wordcount程序来验证集群的运行情况<br>通过hadoop程序目录下的三个文件创建文本：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat NOTICE.txt LICENSE.txt README.txt &gt;&gt; word.txt</span><br></pre></td></tr></table></figure>
<p>为了能够在网页端看到执行进度，可以多执行几次，或者手动上传一个较大的文件，我这里通过vim的p命令，连点了几次，产生了一个60多M的文件后，再将其复制一份word2，然后：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat word2 &gt;&gt; word.txt</span><br></pre></td></tr></table></figure>
<p>一次增加60M，可以多执行几次，我这里增加到300M<br>将word.txt上传的hdfs的test目录：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hdfs dfs -put word.txt /test</span><br></pre></td></tr></table></figure>
<p>查看hdfs的test目录：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root@slave1:/usr/hadoop# hdfs dfs -ls /test</span><br><span class="line">Found 2 items</span><br><span class="line">-rw-r--r--   3 root supergroup       1366 2017-03-09 23:47 /test/README.txt</span><br><span class="line">-rw-r--r--   3 root supergroup  315737315 2017-03-10 00:06 /test/word.txt</span><br></pre></td></tr></table></figure>
<p>注意此时我的操作是在slave1中，当hadoop集群配置完成之后，可以在任意通过连通namenode的节点上访问HDFS。</p>
<p>运行hadoop分布式运算，这里为了测试，我们在slave2节点上提交任务：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hadoop jar /usr/hadoop/share/hadoop/mapreduce/hadoop-mapreduce-examples-2.7.3.jar wordcount /test /out</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">17/03/10 00:11:15 INFO client.RMProxy: Connecting to ResourceManager at master/192.168.1.187:8032</span><br><span class="line">17/03/10 00:11:15 INFO input.FileInputFormat: Total input paths to process : 2</span><br><span class="line">17/03/10 00:11:16 INFO mapreduce.JobSubmitter: number of splits:4</span><br><span class="line">17/03/10 00:11:16 INFO mapreduce.JobSubmitter: Submitting tokens for job: job_1489073635090_0001</span><br><span class="line">17/03/10 00:11:16 INFO impl.YarnClientImpl: Submitted application application_1489073635090_0001</span><br><span class="line">17/03/10 00:11:16 INFO mapreduce.Job: The url to track the job: http://master:8099/proxy/application_1489073635090_0001/</span><br><span class="line">17/03/10 00:11:16 INFO mapreduce.Job: Running job: job_1489073635090_0001</span><br><span class="line">17/03/10 00:11:23 INFO mapreduce.Job: Job job_1489073635090_0001 running in uber mode : false</span><br><span class="line">17/03/10 00:11:23 INFO mapreduce.Job:  map 0% reduce 0%</span><br><span class="line">17/03/10 00:11:31 INFO mapreduce.Job:  map 25% reduce 0%</span><br><span class="line">17/03/10 00:11:36 INFO mapreduce.Job:  map 41% reduce 0%</span><br><span class="line">17/03/10 00:11:39 INFO mapreduce.Job:  map 42% reduce 0%</span><br><span class="line">17/03/10 00:11:42 INFO mapreduce.Job:  map 54% reduce 0%</span><br><span class="line">17/03/10 00:11:43 INFO mapreduce.Job:  map 54% reduce 8%</span><br><span class="line">17/03/10 00:11:45 INFO mapreduce.Job:  map 55% reduce 8%</span><br><span class="line">17/03/10 00:11:46 INFO mapreduce.Job:  map 63% reduce 8%</span><br><span class="line">17/03/10 00:11:48 INFO mapreduce.Job:  map 68% reduce 8%</span><br><span class="line">17/03/10 00:11:49 INFO mapreduce.Job:  map 68% reduce 17%</span><br><span class="line">17/03/10 00:11:51 INFO mapreduce.Job:  map 73% reduce 17%</span><br><span class="line">17/03/10 00:11:54 INFO mapreduce.Job:  map 78% reduce 17%</span><br><span class="line">17/03/10 00:11:58 INFO mapreduce.Job:  map 83% reduce 17%</span><br><span class="line">17/03/10 00:12:01 INFO mapreduce.Job:  map 92% reduce 17%</span><br><span class="line">17/03/10 00:12:02 INFO mapreduce.Job:  map 100% reduce 100%</span><br><span class="line">17/03/10 00:12:03 INFO mapreduce.Job: Job job_1489073635090_0001 completed successfully</span><br></pre></td></tr></table></figure>
<p>可以看到首先连接了ResourceManager，即master节点<br>现在可以在<a href="http://192.168.1.187:8099/cluster">http://192.168.1.187:8099/cluster</a>通过浏览器查看任务进度，如果你的word.txt文件太小，可能progress已经为100%</p>
<p>查看hdfs上的运行结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hdfs dfs -cat /out/part-r-00000</span><br></pre></td></tr></table></figure>

<p>输出中会有大量单词的统计，如果都没有报错，则表示Hadoop集群已经配置成功</p>
<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p><strong>各节点通过jps命令查看运行正常，但网页端显示Live Nodes并不是3</strong><br>确保hosts中没有将自己的hostname映射到127.0.0.1或127.0.1.1，并且防火墙设置没有问题</p>
<p><strong>50070端口的web无法访问</strong><br>有可能是格式化namenode之后，hdfs目录下的文件依然存在，可以删除之前创建的namenode和datanode物理存储位置以及tmp文件夹，然后重新创建，并重新格式化namenode之后再执行，记得其他各节点也需要删除相应的目录并重新创建</p>
<p><strong>配置文件放在单独的文件夹</strong><br>为了便于修改配置文件之后进行不同节点之间的同步，可以将配置文件放在单独的用户文件夹下，然后通过以下环境变量指定配置文件路径即可：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export HADOOP_CONF_DIR=/home/user/conf</span><br></pre></td></tr></table></figure>
<p><strong>注意：最好将hadoop根据目录下的配置文件夹下的所有文件都拷贝进去，至少根据我们上面的配置文件需要有capacity-scheduler.xml，否则将导致ResourceManager无法启动</strong></p>
<p><strong>重要的几个环境变量</strong></p>
<ul>
<li><code>export HADOOP_CONF_DIR=/home/user/conf</code> 用于指定Hadoop配置文件夹</li>
<li><code>export HADOOP_USER_NAME=root</code> 指定当前shell访问HDFS的用户名，以免权限不足</li>
<li><code>HADOOP_PATH=hdfs://127.0.0.1:8020/user/root</code> 指定Hadoop访问路径</li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>1.<a href="https://hadoop.apache.org/docs/stable/hadoop-project-dist/hadoop-common/ClusterSetup.html">Hadoop Cluster Setup</a><br>2.<a href="https://wiki.apache.org/hadoop/ConnectionRefused">Connection Refused</a><br>3.<a href="https://hadoop.apache.org/docs/stable/hadoop-project-dist/hadoop-common/SingleCluster.html">Hadoop: Setting up a Single Node Cluster</a><br>4.<a href="https://hadoop.apache.org/docs/stable/hadoop-project-dist/hadoop-common/CommandsManual.html">Hadoop Commands Guide</a><br>5.<a href="https://hadoop.apache.org/docs/stable/hadoop-project-dist/hadoop-hdfs/HDFSCommands.html">HDFS Commands Guide</a><br>6.<a href="https://hadoop.apache.org/docs/stable/hadoop-project-dist/hadoop-common/FileSystemShell.html">FileSystemShell</a></p>
]]></content>
      <categories>
        <category>Hadoop</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux下配置SSH免密访问</title>
    <url>/2017/03/09/linux-ssh-nopasswd/</url>
    <content><![CDATA[<p>SSH的免密钥登录原理其实就是SSH认证时将自己的公钥提前存储在需要被访问主机（可以是本主机，也可以是远程主机）的认证文件中，默认该文件路径为：<code>~/.ssh/authorized_keys</code>。该文件中存储了哪台主机的公钥，那么那台主机就可以通过SSH免密钥登录本主机。<br>所以过程就是首先生成本机公钥和私钥，然后将公钥插入到需要免密码访问的主机的<code>~/.ssh/authorized_keys</code>文件中</p>
<span id="more"></span>

<h1 id="配置本机SSH免密登录"><a href="#配置本机SSH免密登录" class="headerlink" title="配置本机SSH免密登录"></a>配置本机SSH免密登录</h1><h2 id="生成密钥对"><a href="#生成密钥对" class="headerlink" title="生成密钥对"></a>生成密钥对</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ssh-keygen -t rsa -P <span class="string">&#x27;&#x27;</span> -f ~/.ssh/id_rsa</span></span><br></pre></td></tr></table></figure>
<p>其中<code>-t</code>后面跟加密方法，推荐rsa，如果你想使用dsa算法，或者使用dsa算法后发现无法免密登录，可以查看这里（貌似dsa算法以后不再支持免密码登录）：<a href="http://superuser.com/questions/1016989/ssh-dsa-keys-no-longer-work-for-password-less-authentication">http://superuser.com/questions/1016989/ssh-dsa-keys-no-longer-work-for-password-less-authentication</a><br><code>-P</code>后面跟的是密码，这里表示密码为空，<code>-f</code>后面为么钥存储路径。<br>此时<code>.ssh</code>目录中文件如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.ssh</span><br><span class="line">├── id_rsa</span><br><span class="line">└── id_rsa.pub</span><br></pre></td></tr></table></figure>
<p>其中<code>.pub</code>结尾的即为公钥，另一个是私钥</p>
<h2 id="将密码插入到authorized-keys"><a href="#将密码插入到authorized-keys" class="headerlink" title="将密码插入到authorized_keys"></a>将密码插入到<code>authorized_keys</code></h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> ~/.ssh/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys</span></span><br></pre></td></tr></table></figure>

<h2 id="修改权限"><a href="#修改权限" class="headerlink" title="修改权限"></a>修改权限</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">chmod</span> 0600 ~/.ssh/authorized_keys</span></span><br></pre></td></tr></table></figure>
<p>如果可以正常免密访问，可以不进行权限修改</p>
<h2 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ssh localhost</span></span><br></pre></td></tr></table></figure>
<p>第一次登录会询问yes or no，直接回车，或者输入yes后回车即可</p>
<h1 id="配置远程主机SSH免密登录"><a href="#配置远程主机SSH免密登录" class="headerlink" title="配置远程主机SSH免密登录"></a>配置远程主机SSH免密登录</h1><p>假设远程主机的ip已经在本地的hosts文件中添加了映射，并且映射主机名为node1</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ssh-keygen -t dsa -P <span class="string">&#x27;&#x27;</span> -f ~/.ssh/id_dsa</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ssh-copy-id -i user@node1</span></span><br></pre></td></tr></table></figure>
<p>现在就可以直接<code>ssh user@node1</code>来访问node1主机了，第一次会提示yes or no，直接回车即可</p>
<p><code>ssh-copy-id -i user@node1</code>就是将本机的公钥插入到远程主机node1的用户user的<code>authorized_keys</code>文件中<br>所以也可以手动通过scp将自己的公钥复制到远程主机，然后再将其手机复制到远程主机<code>authorized_keys</code>文件的结尾</p>
<p>如果需要反向访问，就需要从远程主机上进行相同的操作</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>ssh</tag>
      </tags>
  </entry>
  <entry>
    <title>Python多版本管理工具pyenv及环境隔离工具virtualenv</title>
    <url>/2017/03/06/python-pyenv-virtualenv/</url>
    <content><![CDATA[<p>Python可以使用pyenv管理并切换同一系统下的多个python解释器版本，pyenv支持非常多的python版本，也包括各大知名python的衍生版，如anaconda。而virtualenv可以为每个文件夹指定一个特定的python环境，各文件夹的python环境独立，共用一个统一的python基础版本，可以用于隔离不同项目的包环境，及包版本。当然pyenv也支持为不同的文件夹指定不同的python版本，但不同文件夹下的同一个python版本共用环境，所以pyenv与virtualenv结合使用，便可以实现任意版本下的环境隔离随意切换，pyenv自带virtualenv插件。<br>可以简单理解如下：</p>
<ul>
<li>pyenv 实现Python版本管理</li>
<li>virtualenv 实现Python环境隔离</li>
</ul>
<span id="more"></span>
<p>我的系统环境为Ubuntu16.04.2</p>
<h2 id="安装pyenv"><a href="#安装pyenv" class="headerlink" title="安装pyenv"></a>安装pyenv</h2><h3 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h3><p>其实pyenv是个脚本，并不需要安装它的依赖，但pyenv安装的python为通过下载相应的python源码，然后进行编译，所以需要安装相应的编译依赖：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install -y make build-essential libssl-dev zlib1g-dev libbz2-dev \</span><br><span class="line">libreadline-dev libsqlite3-dev wget curl llvm libncurses5-dev libncursesw5-dev \</span><br><span class="line">xz-utils tk-dev</span><br></pre></td></tr></table></figure>

<h3 id="pyenv安装"><a href="#pyenv安装" class="headerlink" title="pyenv安装"></a>pyenv安装</h3><p>官方提供了自动安装脚本来安装pyenv，直接运行即可：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -L https://raw.githubusercontent.com/pyenv/pyenv-installer/master/bin/pyenv-installer | bash</span><br></pre></td></tr></table></figure>
<p>pyenv会被安装在用户根目录的<code>~/.pyenv</code>路径，以后通过pyenv安装的所以python版本也都将在该目录中。上述命令会在用户的<code>.bashrc</code>中添加以下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># pyenv</span><br><span class="line">export PYENV_ROOT=&quot;$HOME/.pyenv&quot;</span><br><span class="line">export PATH=&quot;$PYENV_ROOT/bin:$PATH&quot;</span><br><span class="line">eval &quot;$(pyenv init -)&quot;</span><br><span class="line">eval &quot;$(pyenv virtualenv-init -)&quot;</span><br></pre></td></tr></table></figure>

<p>卸载pyenv也只需要删除目录<code>~/.pyenv</code>以及相应的<code>.bashrc</code>中的内容即可</p>
<p>更新pyenv的命令为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pyenv update</span><br></pre></td></tr></table></figure>

<p>安装完成之后通过<code>pyenv --version</code>，查看其版本</p>
<h2 id="pyenv使用"><a href="#pyenv使用" class="headerlink" title="pyenv使用"></a>pyenv使用</h2><p>pyenv的核心命令，以及常用的核心命令用法如下：<br><strong>pyenv commands</strong><br>查看pyenv所支持的所有命令：</p>
<p><strong>pyenv version</strong><br>查看当前激活的python版本及相关信息<br>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ pyenv version</span><br><span class="line">3.6.1 (set by /home/blueyi/tpyenv/.python-version)</span><br></pre></td></tr></table></figure>

<p><strong>pyenv versions</strong><br>查看系统中的所有python版本，当前使用的版本使用*标记<br>输出如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ pyenv versions</span><br><span class="line">  system</span><br><span class="line">  2.7.13</span><br><span class="line">* 3.6.1 (set by /home/blueyi/tpyenv/.python-version)</span><br></pre></td></tr></table></figure>

<p><strong>pyenv which <command></strong><br>查看指定python的完全路径<br>如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ pyenv which python3</span><br><span class="line">/home/blueyi/.pyenv/versions/3.6.1/bin/python3</span><br></pre></td></tr></table></figure>
<p>注意command必须是shell命令</p>
<p><strong>pyenv whence [–path] <command></strong><br>列出包含给定命令的所有python版本<br>如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ pyenv whence pip</span><br><span class="line">2.7.13</span><br><span class="line">3.6.1</span><br></pre></td></tr></table></figure>

<p><strong>pyenv install</strong><br>安装指定版本的python<br>该命令后面可以跟一些参数，或者版本号，可以通过以下命令查看所有支持的python版本：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pyenv install -l|--list</span><br></pre></td></tr></table></figure>
<p>安装python3.6.1：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pyenv install 3.6.1 -v</span><br></pre></td></tr></table></figure>
<p>安装miniconda3-4.3.11：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pyenv install miniconda3-4.3.11</span><br></pre></td></tr></table></figure>
<p>加上参数<code>-v</code>，用于显示详细安装过程<br>安装完成之后可以通过以下命令重建shims，以便让pyenv能够找到相应的版本及包，通过安装新版本的python以及包之后都应该运行一次：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pyenv rehash</span><br></pre></td></tr></table></figure>
<p>安装完成之后可以通过上面的<code>pyenv versions</code>来查看系统中的所有python版本<br>安装的python在路径<code>~/.pyenv/versions/</code>中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ls ~/.pyenv/versions/</span><br><span class="line">2.7.13  3.6.1</span><br></pre></td></tr></table></figure>

<p><strong>pyenv uninstall [-f|–force] <version></strong><br>卸载指定的版本</p>
<p><strong>pyenv local</strong><br>为当前目录设置指定的python版本，可以创建一个文件夹，在其中测试：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pyenv local 3.6.1</span><br></pre></td></tr></table></figure>
<p>该命令会在当前文件夹下创建文件<code>.python-version</code>，并将相应的版本号写入其中，该版本号将覆盖全局版本。<br>如果local后面不跟版本号，则会显示当前局部版本信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">pyenv <span class="built_in">local</span></span></span><br><span class="line">3.6.1</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> .python-version</span></span><br><span class="line">3.6.1</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">python --version</span></span><br><span class="line">Python 3.6.1</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">pyenv versions</span></span><br><span class="line">  system</span><br><span class="line">  2.7.13</span><br><span class="line">* 3.6.1 (set by /home/blueyi/tpyenv/.python-version)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">pyenv global</span></span><br><span class="line">system</span><br></pre></td></tr></table></figure>
<p>从上述命令的输出中可以看出，我的当前目录python版本被设置为了3.6.1，而全局的python版本使用的是系统自带的版本（2.7.12），同时我又安装了2.7.13版本。<br>取消当前的局部版本设置：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pyenv local --unset</span><br></pre></td></tr></table></figure>
<p>local后面也可以接多个版本号，优先级按命令后面的顺序排列（摘自官方文档）：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">pyenv <span class="built_in">local</span> 2.7.6 3.3.3</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">pyenv versions</span></span><br><span class="line">  system</span><br><span class="line">* 2.7.6 (set by /Users/yyuu/path/to/project/.python-version)</span><br><span class="line">* 3.3.3 (set by /Users/yyuu/path/to/project/.python-version)</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">python --version</span></span><br><span class="line">Python 2.7.6</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">python2.7 --version</span></span><br><span class="line">Python 2.7.6</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">python3.3 --version</span></span><br><span class="line">Python 3.3.3</span><br></pre></td></tr></table></figure>

<p><strong>pyenv global</strong><br>与local命令类似，只是它用于设置全局的python版本，该版本号存储在文件<code>~/.pyenv/version</code>中，该版本会被局部版本号或者环境变量<code>PYENV_VERSION</code>指定的版本号覆盖。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">python --version</span></span><br><span class="line">Python 2.7.12</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">pyenv global 2.7.13</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">python --version</span></span><br><span class="line">Python 2.7.13</span><br></pre></td></tr></table></figure>
<p>global后面不接版本号只显示当前的全局版本</p>
<p>global后面也可以接多个版本，与local功能类似：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">pyenv global 2.7.6 3.3.3</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">pyenv versions</span></span><br><span class="line">  system</span><br><span class="line">* 2.7.6 (set by /Users/yyuu/.pyenv/version)</span><br><span class="line">* 3.3.3 (set by /Users/yyuu/.pyenv/version)</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">python --version</span></span><br><span class="line">Python 2.7.6</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">python2.7 --version</span></span><br><span class="line">Python 2.7.6</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">python3.3 --version</span></span><br><span class="line">Python 3.3.3</span><br></pre></td></tr></table></figure>

<p><strong>pyenv shell</strong><br>通过设置环境变量<code>PYENV_VERSION</code>来指定当前shell环境的python版本，该版本会覆盖局部版本和全局版本。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pyenv shell pypy-2.2.1</span><br></pre></td></tr></table></figure>
<p>相当于：<code>export PYENV_VERSION=pypy-2.2.1</code></p>
<p>取消当前shell环境设置的python版本：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pyenv shell --unset</span><br></pre></td></tr></table></figure>
<p>同样可以为shell命令指定多个版本号：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">pyenv shell 2.7.6 3.3.3</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">pyenv versions</span></span><br><span class="line">  system</span><br><span class="line">* 2.7.6 (set by PYENV_VERSION environment variable)</span><br><span class="line">* 3.3.3 (set by PYENV_VERSION environment variable)</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">python --version</span></span><br><span class="line">Python 2.7.6</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">python2.7 --version</span></span><br><span class="line">Python 2.7.6</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">python3.3 --version</span></span><br><span class="line">Python 3.3.3</span><br></pre></td></tr></table></figure>

<h2 id="virtualenv使用"><a href="#virtualenv使用" class="headerlink" title="virtualenv使用"></a>virtualenv使用</h2><p>pyenv将virtualenv以一个插件的形式包含在pyenv中，pyenv的插件路径为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> ~/.pyenv/plugins/</span></span><br><span class="line">pyenv-doctor  pyenv-installer  pyenv-update  pyenv-virtualenv  pyenv-which-ext  python-build</span><br></pre></td></tr></table></figure>
<p>此处只简单介绍virtualenv用于python环境隔离的用法，更多virtualenv功能可以参见其官方文档。<br>virtualenv的使用方法为首先创建虚拟环境，然后激活虚拟环境。<br><strong>创建虚拟环境</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pyenv virtualenv [-f|--force] [VIRTUALENV_OPTIONS] [version] &lt;virtualenv-name&gt;</span><br></pre></td></tr></table></figure>
<p>例如创建一个以python2.7.13为基础版，名为mypy2.7.13的虚拟环境：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pyenv virtualenv 2.7.13 mypy2.7.13</span><br></pre></td></tr></table></figure>
<p>如果不指定版本，默认使用当前环境的python版本</p>
<p><strong>列出当前所有的虚拟环境</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ pyenv virtualenvs</span><br><span class="line">  2.7.13/envs/mypy2.7.13 (created from /home/blueyi/.pyenv/versions/2.7.13)</span><br><span class="line">  mypy2.7.13 (created from /home/blueyi/.pyenv/versions/2.7.13)</span><br></pre></td></tr></table></figure>
<p>也可以通过<code>pyenv versions</code>来查看：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ pyenv versions</span><br><span class="line">* system (set by /home/blueyi/.pyenv/version)</span><br><span class="line">  2.7.13</span><br><span class="line">  2.7.13/envs/mypy2.7.13</span><br><span class="line">  3.5.0</span><br><span class="line">  3.6.1</span><br><span class="line">  mypy2.7.13</span><br></pre></td></tr></table></figure>
<p>所以也可以为指定文件夹通过<code>pyenv local</code>来指定其版本为当前的虚拟环境</p>
<p><strong>激活指定的虚拟环境</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ pyenv activate mypy2.7.13</span><br></pre></td></tr></table></figure>
<p>激活之后，terminal的前面会有<code>(mypy2.7.13)</code>标识，此时通过pip安装包，以及相关的操作都只会修改该虚拟环境，对原python环境不会有任何影响。激活之后，直到手动退出该虚拟环境，或该shell之前都有效。而如果通过<code>pyenv local</code>指定局部环境为该虚拟环境的话，退出该文件夹即失效，再次进入又会自动生效。</p>
<p><strong>退出当前虚拟环境</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pyenv deactivate</span><br></pre></td></tr></table></figure>

<p><strong>删除指定的虚拟环境</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pyenv uninstall mypy2.7.13</span><br></pre></td></tr></table></figure>

<p>pyenv配合其插件pyenv-virtualenv用于开发及测试，非常方便，再也不用怕环境被搞乱了。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>1.<a href="https://github.com/pyenv/pyenv">pyenv</a><br>2.<a href="https://github.com/pyenv/pyenv/wiki">pyenv wiki</a><br>3.<a href="https://github.com/pypa/virtualenv">virtualenv</a><br>4.<a href="https://virtualenv.pypa.io">https://virtualenv.pypa.io</a></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>VMware配置linux guest中的shared folder</title>
    <url>/2017/03/02/vmware-shared-folder/</url>
    <content><![CDATA[<p>由于virtualbox和vagrant最近升级win10之后总是出各种状况，所以想换成vmware来进行跨平台linux开发环境的搭建。但在windows下的VMware添加共享文件夹之后在Linux系统中总是无法找到挂载后的目录，手动挂载后会出现protocol error等错误。其实解决方法很简单。</p>
<span id="more"></span>

<p>我使用的环境是Ubuntu16.04，最小化安装的Server版本。</p>
<h2 id="安装open-vm-tools"><a href="#安装open-vm-tools" class="headerlink" title="安装open-vm-tools"></a>安装open-vm-tools</h2><p>安装完虚拟机之后发现自动安装了open-vm-tools，这是与vmtools对应的开源版本，也是实现文件夹共享的关键，所以安装完成虚拟机系统之后首先检查确认已经安装了open-vm-tools，不需要（一定不要）安装VMware自带的vmtools。如果VMware提示你更新VMware Tools，不要更新。<br>也不需要安装open-vm-tools-dkms</p>
<h2 id="关闭虚拟机并添加shared-folder"><a href="#关闭虚拟机并添加shared-folder" class="headerlink" title="关闭虚拟机并添加shared folder"></a>关闭虚拟机并添加shared folder</h2><p>如果你之前已经手动添加过共享文件夹，依然需要在关机状态下手动删除并再次添加，记得选中总是启用。</p>
<h2 id="手动挂载共享文件夹"><a href="#手动挂载共享文件夹" class="headerlink" title="手动挂载共享文件夹"></a>手动挂载共享文件夹</h2><p>通过以下命令挂载共享文件夹：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo vmhgfs-fuse -o allow_other -o auto_unmount -o uid=1000 -o gid=1000 .host:/shared_folder /mnt/shared_folder</span><br></pre></td></tr></table></figure>
<p>其中<code>shared_folder</code>为你添加的共享文件夹名字，<code>/mnt/shared_folder</code>为虚拟机中的共享文件夹挂载路径，需要手动创建。<br>如果想要挂载所有共享文件夹到同一个目录，可以如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo vmhgfs-fuse -o allow_other -o auto_unmount -o uid=1000 -o gid=1000 .host:/ /mnt/shared_folder</span><br></pre></td></tr></table></figure>

<p>挂载完之后就可以查看到你的共享文件夹了。<br>如果觉得每次输入挂载命令太长，可以放到脚本中，如果想要开机自动挂载，看下面。</p>
<h2 id="开机自动挂载共享文件夹"><a href="#开机自动挂载共享文件夹" class="headerlink" title="开机自动挂载共享文件夹"></a>开机自动挂载共享文件夹</h2><p>在<code>/etc/fstab</code>文件的最后添加如下内容实现将所有共享文件夹自动挂载到目录<code>/vmshare</code>，记得自己需要提前手动创建目录<code>/vmshare</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.host:/  /vmshare  fuse.vmhgfs-fuse allow_other,uid=1000,gid=1000,auto_unmount,defaults 0 0</span><br></pre></td></tr></table></figure>

<p>这样开机之后所有你添加的共享文件夹，都会以子文件夹的形式挂载在目录<code>/vmshare</code>中，配合pycharm就可以实现在Windows下开发，调试和运行在linux环境中，只需要在pycharm中配置远程解释器和目录映射即可。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu 16.04下编译ffmpeg支持CUDA下的cuvid vnenc和NPP</title>
    <url>/2017/03/01/ubuntu-compile-ffmpeg-with-cuvid-nvenc-npp/</url>
    <content><![CDATA[<p>FFmpeg可以用来处理音视频的编解码，通过对GPU硬解码的支持，可以加速编解码，但需要手动编译FFmpeg时加入对GPU的支持。这里参考Nvidia官网和FFmpeg官网文档进行编译FFmpeg的编译。 编译ffmpeg时启用CUVID，其中包括NVENCODE API和NVDECODE API，ffmpeg中通过nvenc来来提供对Nvidia显卡的支持，同时添加NPP支持来增强编解码性能。</p>
<span id="more"></span>
<h1 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h1><p>我的硬件环境为ubuntu 16.04.1 x64 服务器版的最小化系统，具体参数如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DISTRIB_ID=Ubuntu</span><br><span class="line">DISTRIB_RELEASE=16.04</span><br><span class="line">DISTRIB_CODENAME=xenial</span><br><span class="line">DISTRIB_DESCRIPTION=&quot;Ubuntu 16.04.1 LTS&quot;</span><br></pre></td></tr></table></figure>
<p>首先确定已经安装好了CUDA 8，如果还没有安装CUDA 8环境可以参考这里安装<a href="http://notes.maxwi.com/2017/02/26/ubuntu-cuda8-env-set/">http://notes.maxwi.com/2017/02/26/ubuntu-cuda8-env-set/</a><br>我的显卡信息如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Device 0: &quot;GeForce GTX 1080&quot;</span><br><span class="line">  CUDA Driver Version / Runtime Version          8.0 / 8.0</span><br><span class="line">  CUDA Capability Major/Minor version number:    6.1</span><br><span class="line">  Total amount of global memory:                 8112 MBytes (8506179584 bytes)</span><br><span class="line">  (20) Multiprocessors, (128) CUDA Cores/MP:     2560 CUDA Cores</span><br><span class="line">  GPU Max Clock rate:                            1734 MHz (1.73 GHz)</span><br><span class="line">  Memory Clock rate:                             5005 Mhz</span><br><span class="line">  Memory Bus Width:                              256-bit</span><br><span class="line">  L2 Cache Size:                                 2097152 bytes</span><br><span class="line">  Maximum Texture Dimension Size (x,y,z)         1D=(131072), 2D=(131072, 65536), 3D=(16384, 16384, 16384)</span><br><span class="line">  Maximum Layered 1D Texture Size, (num) layers  1D=(32768), 2048 layers</span><br><span class="line">  Maximum Layered 2D Texture Size, (num) layers  2D=(32768, 32768), 2048 layers</span><br><span class="line">  Total amount of constant memory:               65536 bytes</span><br><span class="line">  Total amount of shared memory per block:       49152 bytes</span><br><span class="line">  Total number of registers available per block: 65536</span><br><span class="line">  Warp size:                                     32</span><br><span class="line">  Maximum number of threads per multiprocessor:  2048</span><br><span class="line">  Maximum number of threads per block:           1024</span><br><span class="line">  Max dimension size of a thread block (x,y,z): (1024, 1024, 64)</span><br><span class="line">  Max dimension size of a grid size    (x,y,z): (2147483647, 65535, 65535)</span><br><span class="line">  Maximum memory pitch:                          2147483647 bytes</span><br><span class="line">  Texture alignment:                             512 bytes</span><br><span class="line">  Concurrent copy and kernel execution:          Yes with 2 copy engine(s)</span><br><span class="line">  Run time limit on kernels:                     Yes</span><br><span class="line">  Integrated GPU sharing Host Memory:            No</span><br><span class="line">  Support host page-locked memory mapping:       Yes</span><br><span class="line">  Alignment requirement for Surfaces:            Yes</span><br><span class="line">  Device has ECC support:                        Disabled</span><br><span class="line">  Device supports Unified Addressing (UVA):      Yes</span><br><span class="line">  Device PCI Domain ID / Bus ID / location ID:   0 / 3 / 0</span><br><span class="line">  Compute Mode:</span><br><span class="line">     &lt; Default (multiple host threads can use ::cudaSetDevice() with device simultaneously) &gt;</span><br><span class="line"></span><br><span class="line">deviceQuery, CUDA Driver = CUDART, CUDA Driver Version = 8.0, CUDA Runtime Version = 8.0, NumDevs = 1, Device0 = GeForce GTX 1080</span><br></pre></td></tr></table></figure>

<h1 id="安装编译FFmpeg所需要的依赖："><a href="#安装编译FFmpeg所需要的依赖：" class="headerlink" title="安装编译FFmpeg所需要的依赖："></a>安装编译FFmpeg所需要的依赖：</h1><h2 id="基本依赖"><a href="#基本依赖" class="headerlink" title="基本依赖"></a>基本依赖</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get -y install autoconf automake build-essential libass-dev libfreetype6-dev \</span><br><span class="line">  libsdl2-dev libtheora-dev libtool libva-dev libvdpau-dev libvorbis-dev libxcb1-dev libxcb-shm0-dev \</span><br><span class="line">  libxcb-xfixes0-dev pkg-config texinfo zlib1g-dev</span><br></pre></td></tr></table></figure>
<p>如果是服务器系统，即没有桌面环境的话可以不安装ffplay和x11grab的依赖: libsdl2-dev libva-dev libvdpau-dev libxcb1-dev libxcb-shm0-dev libxcb-xfixes0-dev<br>在用户根目录下创建文件夹<code>ffmpeg_sources</code>，<code>ffmpeg_build</code>和<code>bin</code>以备用，其中约定：</p>
<ul>
<li>ffmpeg_sources里面放所有编译所需要的源码文件，该文件夹在编译之后可以被删除</li>
<li>ffmpeg_build里面存放编译文件，包括头文件、库文件和文档，该文件夹在编译之后可以被删除，但建议保留</li>
<li>bin存放编译后的二进制程序文件，不能被删除<br>当然这些文件夹都可以自定义存放位置<h2 id="安装yasm"><a href="#安装yasm" class="headerlink" title="安装yasm"></a>安装yasm</h2>如果系统中的yasm版本号大于1.2.0，可以直接通过系统源来安装<br>查看yasm版本等信息：<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apt-cache show yasm</span><br></pre></td></tr></table></figure>
我这里显示版本为1.3，可以直接通过系统源安装：<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install yasm</span><br></pre></td></tr></table></figure>
或者手动编译安装：<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd ~/ffmpeg_sources</span><br><span class="line">wget http://www.tortall.net/projects/yasm/releases/yasm-1.3.0.tar.gz</span><br><span class="line">tar xzvf yasm-1.3.0.tar.gz</span><br><span class="line">cd yasm-1.3.0</span><br><span class="line">./configure --prefix=&quot;$HOME/ffmpeg_build&quot; --bindir=&quot;$HOME/bin&quot;</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure></li>
<li><em>以下安装的所有依赖包都是可选的，需要在FFmpeg编译是添加相应的启用选项，所以可以根据自己需要来安装*</em><h2 id="安装libx264"><a href="#安装libx264" class="headerlink" title="安装libx264"></a>安装libx264</h2>类似上面查看yasm版本号一样，需要<code>libx264-dev</code>的版本号大于118<br>我这里显示是148，所以可以直接安装：<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install libx264-dev</span><br></pre></td></tr></table></figure>
或者编译安装：<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd ~/ffmpeg_sources</span><br><span class="line">wget http://download.videolan.org/pub/x264/snapshots/last_x264.tar.bz2</span><br><span class="line">tar xjvf last_x264.tar.bz2</span><br><span class="line">cd x264-snapshot*</span><br><span class="line">PATH=&quot;$HOME/bin:$PATH&quot; ./configure --prefix=&quot;$HOME/ffmpeg_build&quot; --bindir=&quot;$HOME/bin&quot; --enable-static --disable-opencl</span><br><span class="line">PATH=&quot;$HOME/bin:$PATH&quot; make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>
<h2 id="安装libx265"><a href="#安装libx265" class="headerlink" title="安装libx265"></a>安装libx265</h2>与上面安装方法一样，需要其版本号大于68，我这里源里面版本号是79，直接安装<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install libx265-dev</span><br></pre></td></tr></table></figure>
或者编译安装：<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install cmake mercurial</span><br><span class="line">cd ~/ffmpeg_sources</span><br><span class="line">hg clone https://bitbucket.org/multicoreware/x265</span><br><span class="line">cd ~/ffmpeg_sources/x265/build/linux</span><br><span class="line">PATH=&quot;$HOME/bin:$PATH&quot; cmake -G &quot;Unix Makefiles&quot; -DCMAKE_INSTALL_PREFIX=&quot;$HOME/ffmpeg_build&quot; -DENABLE_SHARED:bool=off ../../source</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="安装libvpx"><a href="#安装libvpx" class="headerlink" title="安装libvpx"></a>安装libvpx</h2><p>要求libvpx-dev版本号大于0.9.7，我这里显示的版本号提1.5.0，直接安装：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install libvpx-dev</span><br></pre></td></tr></table></figure>
<p>或者编译安装：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd ~/ffmpeg_sources</span><br><span class="line">wget http://storage.googleapis.com/downloads.webmproject.org/releases/webm/libvpx-1.6.1.tar.bz2</span><br><span class="line">tar xjvf libvpx-1.6.1.tar.bz2</span><br><span class="line">cd libvpx-1.6.1</span><br><span class="line">PATH=&quot;$HOME/bin:$PATH&quot; ./configure --prefix=&quot;$HOME/ffmpeg_build&quot; --disable-examples --disable-unit-tests</span><br><span class="line">PATH=&quot;$HOME/bin:$PATH&quot; make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>

<p><strong>下面是一些音频相关的包，如果只是做视频图像相关，可以不安装</strong></p>
<h2 id="安装libfdk-aac"><a href="#安装libfdk-aac" class="headerlink" title="安装libfdk-aac"></a>安装libfdk-aac</h2><p>这个没有要求版本号，只要系统有libfdk-aac-dev就可以直接安装：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install libfdk-aac-dev</span><br></pre></td></tr></table></figure>
<p>或者编译安装：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd ~/ffmpeg_sources</span><br><span class="line">wget -O fdk-aac.tar.gz https://github.com/mstorsjo/fdk-aac/tarball/master</span><br><span class="line">tar xzvf fdk-aac.tar.gz</span><br><span class="line">cd mstorsjo-fdk-aac*</span><br><span class="line">autoreconf -fiv</span><br><span class="line">./configure --prefix=&quot;$HOME/ffmpeg_build&quot; --disable-shared</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>
<h2 id="安装libmp3lam"><a href="#安装libmp3lam" class="headerlink" title="安装libmp3lam"></a>安装libmp3lam</h2><p>要求版本号大于3.98.3，直接安装：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install libmp3lame-dev</span><br></pre></td></tr></table></figure>
<p>或者编译安装：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install nasm</span><br><span class="line">cd ~/ffmpeg_sources</span><br><span class="line">wget http://downloads.sourceforge.net/project/lame/lame/3.99/lame-3.99.5.tar.gz</span><br><span class="line">tar xzvf lame-3.99.5.tar.gz</span><br><span class="line">cd lame-3.99.5</span><br><span class="line">./configure --prefix=&quot;$HOME/ffmpeg_build&quot; --enable-nasm --disable-shared</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>
<h2 id="安装libopus"><a href="#安装libopus" class="headerlink" title="安装libopus"></a>安装libopus</h2><p>要求libopus-dev版本号大于1.1，我这里版本号是1.1.2，直接安装：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install libopus-dev</span><br></pre></td></tr></table></figure>
<p>或者编译安装：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd ~/ffmpeg_sources</span><br><span class="line">wget http://downloads.xiph.org/releases/opus/opus-1.1.4.tar.gz</span><br><span class="line">tar xzvf opus-1.1.4.tar.gz</span><br><span class="line">cd opus-1.1.4</span><br><span class="line">./configure --prefix=&quot;$HOME/ffmpeg_build&quot; --disable-shared</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>
<p><strong>至此ffmpeg所需要的依赖已经安装完成，下面配置nvcuvid</strong></p>
<h1 id="配置NVENC并下载ffmpeg"><a href="#配置NVENC并下载ffmpeg" class="headerlink" title="配置NVENC并下载ffmpeg"></a>配置NVENC并下载ffmpeg</h1><p>安装NVENC的依赖：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get -y install glew-utils libglew-dbg libglew-dev libglew1.13 \</span><br><span class="line">libglewmx-dev libglewmx-dbg freeglut3 freeglut3-dev freeglut3-dbg libghc-glut-dev \</span><br><span class="line">libghc-glut-doc libghc-glut-prof libalut-dev libxmu-dev libxmu-headers libxmu6 \</span><br><span class="line">libxmu6-dbg libxmuu-dev libxmuu1 libxmuu1-dbg </span><br></pre></td></tr></table></figure>

<p><strong>下载ffmpeg</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd ~/ffmpeg_sources</span><br><span class="line">wget http://ffmpeg.org/releases/ffmpeg-snapshot.tar.bz2</span><br><span class="line">tar xjvf ffmpeg-snapshot.tar.bz2</span><br></pre></td></tr></table></figure>
<p>或者通过git下载最新的版本：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd ~/ffmpeg_sources</span><br><span class="line">git clone https://github.com/FFmpeg/FFmpeg ffmpeg -b master</span><br></pre></td></tr></table></figure>
<p>这个时候目录结构应该是这样的（如果上面的其他依赖包都没有通过编译安装的话）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ffmpeg_sources/</span><br><span class="line">├── ffmpeg</span><br><span class="line">└── ffmpeg-snapshot.tar.bz2</span><br></pre></td></tr></table></figure>
<p><strong>下载Nvidia Video Codec SDK</strong><br>由于Nvidia的下载需要较验用户，所以可能还需要先注册账号才能下载，下载后重命名为nv_sdk.zip并上传到~/ffmpeg_sources目录即可<br>下载地址是：<a href="https://developer.nvidia.com/nvidia-video-codec-sdk#Download">https://developer.nvidia.com/nvidia-video-codec-sdk#Download</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd ~/ffmpeg_sources</span><br><span class="line">wget -O nv_sdk.zip http://developer.download.nvidia.com/designworks/video-codec-sdk/secure/7.1/01/Video_Codec_SDK_7.1.9.zip?autho=1488251582_076cae8f68a8a091cd5a6f9405967dab&amp;file=Video_Codec_SDK_7.1.9.zip</span><br></pre></td></tr></table></figure>
<p>解压nv_sdk.zip并将其中的头文件拷贝到系统头文件夹<code>/usr/include/</code>，然后修改sdk文件夹为nv_sdk，后面编译要用：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">unzip nv_sdk.zip</span><br><span class="line">sudo cp -r Video_Codec_SDK_7.1.9/Samples/common/inc/* /usr/include/ </span><br><span class="line">mv Video_Codec_SDK_7.1.9 nv_sdk</span><br></pre></td></tr></table></figure>
<h1 id="编译ffmpeg与cuvid-cuda-npp以及nvenc"><a href="#编译ffmpeg与cuvid-cuda-npp以及nvenc" class="headerlink" title="编译ffmpeg与cuvid, cuda, npp以及nvenc"></a>编译ffmpeg与cuvid, cuda, npp以及nvenc</h1><p>现在的目录结构如下（可以忽略根目录下的2个压缩包）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ffmpeg_sources</span><br><span class="line">├── ffmpeg</span><br><span class="line">│   ├── arch.mak</span><br><span class="line">│   ├── Changelog</span><br><span class="line">│   ├── cmdutils.c</span><br><span class="line">│   ├── cmdutils_common_opts.h</span><br><span class="line">│   ├── cmdutils.h</span><br><span class="line">│   ├── cmdutils_opencl.c</span><br><span class="line">│   ├── common.mak</span><br><span class="line">│   ├── compat</span><br><span class="line">│   ├── configure</span><br><span class="line">│   ├── CONTRIBUTING.md</span><br><span class="line">│   ├── COPYING.GPLv2</span><br><span class="line">│   ├── COPYING.GPLv3</span><br><span class="line">│   ├── COPYING.LGPLv2.1</span><br><span class="line">│   ├── COPYING.LGPLv3</span><br><span class="line">│   ├── CREDITS</span><br><span class="line">│   ├── doc</span><br><span class="line">│   ├── ffmpeg.c</span><br><span class="line">│   ├── ffmpeg_cuvid.c</span><br><span class="line">│   ├── ffmpeg_dxva2.c</span><br><span class="line">│   ├── ffmpeg_filter.c</span><br><span class="line">│   ├── ffmpeg.h</span><br><span class="line">│   ├── ffmpeg_opt.c</span><br><span class="line">│   ├── ffmpeg_qsv.c</span><br><span class="line">│   ├── ffmpeg_vaapi.c</span><br><span class="line">│   ├── ffmpeg_vdpau.c</span><br><span class="line">│   ├── ffmpeg_videotoolbox.c</span><br><span class="line">│   ├── ffplay.c</span><br><span class="line">│   ├── ffprobe.c</span><br><span class="line">│   ├── ffserver.c</span><br><span class="line">│   ├── ffserver_config.c</span><br><span class="line">│   ├── ffserver_config.h</span><br><span class="line">│   ├── INSTALL.md</span><br><span class="line">│   ├── libavcodec</span><br><span class="line">│   ├── libavdevice</span><br><span class="line">│   ├── libavfilter</span><br><span class="line">│   ├── libavformat</span><br><span class="line">│   ├── libavresample</span><br><span class="line">│   ├── libavutil</span><br><span class="line">│   ├── libpostproc</span><br><span class="line">│   ├── library.mak</span><br><span class="line">│   ├── libswresample</span><br><span class="line">│   ├── libswscale</span><br><span class="line">│   ├── LICENSE.md</span><br><span class="line">│   ├── MAINTAINERS</span><br><span class="line">│   ├── Makefile</span><br><span class="line">│   ├── presets</span><br><span class="line">│   ├── README.md</span><br><span class="line">│   ├── RELEASE</span><br><span class="line">│   ├── tests</span><br><span class="line">│   ├── tools</span><br><span class="line">│   ├── VERSION</span><br><span class="line">│   └── version.sh</span><br><span class="line">├── ffmpeg-snapshot.tar.bz2</span><br><span class="line">├── nv_sdk</span><br><span class="line">│   ├── doc</span><br><span class="line">│   ├── LicenseAgreement.pdf</span><br><span class="line">│   ├── ReadMe.txt</span><br><span class="line">│   ├── Release_notes.txt</span><br><span class="line">│   └── Samples</span><br><span class="line">└── nv_sdk.zip</span><br></pre></td></tr></table></figure>

<p>编译命令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd ~/ffmpeg_sources/ffmpeg</span><br><span class="line">PATH=&quot;$HOME/bin:$PATH&quot; PKG_CONFIG_PATH=&quot;$HOME/ffmpeg_build/lib/pkgconfig&quot;  ./configure \</span><br><span class="line">    --prefix=&quot;$HOME/ffmpeg_build&quot; \</span><br><span class="line">    --pkg-config-flags=&quot;--static&quot; \</span><br><span class="line">    --extra-cflags=&quot;-I$HOME/ffmpeg_build/include&quot; \</span><br><span class="line">    --extra-ldflags=&quot;-L$HOME/ffmpeg_build/lib&quot; \</span><br><span class="line">    --bindir=&quot;$HOME/bin&quot; \</span><br><span class="line">    --enable-gpl \</span><br><span class="line">    --enable-libass \</span><br><span class="line">    --enable-libfdk-aac \</span><br><span class="line">    --enable-libfreetype \</span><br><span class="line">    --enable-libmp3lame \</span><br><span class="line">    --enable-libopus \</span><br><span class="line">    --enable-libtheora \</span><br><span class="line">    --enable-libvorbis \</span><br><span class="line">    --enable-libvpx \</span><br><span class="line">    --enable-libx264 \</span><br><span class="line">    --enable-libx265 \</span><br><span class="line">    --enable-nonfree \</span><br><span class="line">    --extra-cflags=-I../nv_sdk \</span><br><span class="line">    --extra-ldflags=-L../nv_sdk \</span><br><span class="line">    --extra-cflags=&quot;-I/usr/local/cuda/include/&quot; \</span><br><span class="line">    --extra-ldflags=-L/usr/local/cuda/lib64 \</span><br><span class="line">    --disable-shared \</span><br><span class="line">    --enable-nvenc \</span><br><span class="line">    --enable-cuda \</span><br><span class="line">    --enable-cuvid \</span><br><span class="line">    --enable-libnpp </span><br><span class="line">PATH=&quot;$HOME/bin:$PATH&quot; make -j$(nproc)</span><br><span class="line">make -j$(nproc) install</span><br><span class="line">make -j$(nproc) distclean</span><br><span class="line">hash -r</span><br></pre></td></tr></table></figure>
<p>编译完成之后的文件在目录<code>~/bin</code>下面，将其添加到path路径之后即可直接调用：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo &#x27;export PATH=~/bin:$PATH&#x27; &gt;&gt; ~/.bashrc</span><br><span class="line">source ~/.bashrc</span><br></pre></td></tr></table></figure>

<p>将编译好的ffmpeg库加入到系统动态库搜索路径中：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo &#x27;export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$HOME/ffmpeg_build/lib&#x27; &gt;&gt; ~/.bashrc</span><br><span class="line">sudo ldconfig</span><br></pre></td></tr></table></figure>
<p>不过好像make安装之后会自动添加库路径，可以通过以下命令查看所有库：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo ldconfig -v</span><br></pre></td></tr></table></figure>

<p>bin目录下的文件结构：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bin/</span><br><span class="line">├── ffmpeg</span><br><span class="line">├── ffplay</span><br><span class="line">├── ffprobe</span><br><span class="line">└── ffserver</span><br></pre></td></tr></table></figure>
<p>ffmpeg_build目录下的文件结构：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ffmpeg_build/</span><br><span class="line">├── bin</span><br><span class="line">├── include</span><br><span class="line">├── lib</span><br><span class="line">└── share</span><br></pre></td></tr></table></figure>

<p>为了能够使用<code>man ffmpeg</code>等ffmpeg相关的man手册，可以执行以下语句：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo &quot;MANPATH_MAP $HOME/bin $HOME/ffmpeg_build/share/man&quot; &gt;&gt; ~/.manpath</span><br></pre></td></tr></table></figure>

<h1 id="测试FFmpeg与GPU的硬解码"><a href="#测试FFmpeg与GPU的硬解码" class="headerlink" title="测试FFmpeg与GPU的硬解码"></a>测试FFmpeg与GPU的硬解码</h1><p>测试ffplay播放视频（假定输入文件都已经存在）：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ffplay input.avi</span><br></pre></td></tr></table></figure>
<p>测试ffmpeg转码：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ffmpeg -i input.avi output.mp4</span><br></pre></td></tr></table></figure>
<p>测试采用GPU进行解码加速转码：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ffmpeg -i input.avi -c:v h264_nvenc -preset default output_2.mp4</span><br></pre></td></tr></table></figure>
<p>同时使用CUVID,NVENC和NPP进行加速转码：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ffmpeg -hwaccel_device 0 -hwaccel cuvid -c:v h264_cuvid -i input.mp4 -vf scale_npp=-1:720 -c:v h264_nvenc -preset slow output.mkv</span><br></pre></td></tr></table></figure>
<p>转码过程中可以看到后面有个倍速，使用GPU明显比不使用速度要快</p>
<p>查看ffmpeg支持的cuvid的解码格式：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ffmpeg -decoders | grep cuvid</span><br></pre></td></tr></table></figure>
<p>我这里的输出为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ffmpeg version N-83691-g7f62368 Copyright (c) 2000-2017 the FFmpeg developers</span><br><span class="line">  built with gcc 5.4.0 (Ubuntu 5.4.0-6ubuntu1~16.04.4) 20160609</span><br><span class="line">  configuration: --prefix=/home/dutoeserver/ffmpeg_build --pkg-config-flags=--static --extra-cflags=-I/home/dutoeserver/ffmpeg_build/include --extra-ldflags=-L/home/dutoeserver/ffmpeg_build/lib --bindir=/home/dutoeserver/bin --enable-gpl --enable-libass --enable-libfdk-aac --enable-libfreetype --enable-libmp3lame --enable-libopus --enable-libtheora --enable-libvorbis --enable-libvpx --enable-libx264 --enable-libx265 --enable-nonfree --extra-cflags=-I../nv_sdk --extra-ldflags=-L../nv_sdk --extra-cflags=-I/usr/local/cuda/include/ --extra-ldflags=-L/usr/local/cuda/lib64 --disable-shared --enable-nvenc --enable-cuda --enable-cuvid --enable-libnpp</span><br><span class="line">  libavutil      55. 47.100 / 55. 47.100</span><br><span class="line">  libavcodec     57. 81.100 / 57. 81.100</span><br><span class="line">  libavformat    57. 66.102 / 57. 66.102</span><br><span class="line">  libavdevice    57.  3.100 / 57.  3.100</span><br><span class="line">  libavfilter     6. 74.100 /  6. 74.100</span><br><span class="line">  libswscale      4.  3.101 /  4.  3.101</span><br><span class="line">  libswresample   2.  4.100 /  2.  4.100</span><br><span class="line">  libpostproc    54.  2.100 / 54.  2.100</span><br><span class="line"> V..... h264_cuvid           Nvidia CUVID H264 decoder (codec h264)</span><br><span class="line"> V..... hevc_cuvid           Nvidia CUVID HEVC decoder (codec hevc)</span><br><span class="line"> V..... mjpeg_cuvid          Nvidia CUVID MJPEG decoder (codec mjpeg)</span><br><span class="line"> V..... mpeg1_cuvid          Nvidia CUVID MPEG1VIDEO decoder (codec mpeg1video)</span><br><span class="line"> V..... mpeg2_cuvid          Nvidia CUVID MPEG2VIDEO decoder (codec mpeg2video)</span><br><span class="line"> V..... mpeg4_cuvid          Nvidia CUVID MPEG4 decoder (codec mpeg4)</span><br><span class="line"> V..... vc1_cuvid            Nvidia CUVID VC1 decoder (codec vc1)</span><br><span class="line"> V..... vp8_cuvid            Nvidia CUVID VP8 decoder (codec vp8)</span><br><span class="line"> V..... vp9_cuvid            Nvidia CUVID VP9 decoder (codec vp9)</span><br></pre></td></tr></table></figure>
<p>不使用grep过滤的话会显示所有支持的解码格式</p>
<p>通过以下选项查看ffmpeg支持硬件加速方式：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ffmpeg -hwaccels</span><br></pre></td></tr></table></figure>
<p>我这里的输出为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ffmpeg version N-83691-g7f62368 Copyright (c) 2000-2017 the FFmpeg developers</span><br><span class="line">  built with gcc 5.4.0 (Ubuntu 5.4.0-6ubuntu1~16.04.4) 20160609</span><br><span class="line">  configuration: --prefix=/home/dutoeserver/ffmpeg_build --pkg-config-flags=--static --extra-cflags=-I/home/dutoeserver/ffmpeg_build/include --extra-ldflags=-L/home/dutoeserver/ffmpeg_build/lib --bindir=/home/dutoeserver/bin --enable-gpl --enable-libass --enable-libfdk-aac --enable-libfreetype --enable-libmp3lame --enable-libopus --enable-libtheora --enable-libvorbis --enable-libvpx --enable-libx264 --enable-libx265 --enable-nonfree --extra-cflags=-I../nv_sdk --extra-ldflags=-L../nv_sdk --extra-cflags=-I/usr/local/cuda/include/ --extra-ldflags=-L/usr/local/cuda/lib64 --disable-shared --enable-nvenc --enable-cuda --enable-cuvid --enable-libnpp</span><br><span class="line">  libavutil      55. 47.100 / 55. 47.100</span><br><span class="line">  libavcodec     57. 81.100 / 57. 81.100</span><br><span class="line">  libavformat    57. 66.102 / 57. 66.102</span><br><span class="line">  libavdevice    57.  3.100 / 57.  3.100</span><br><span class="line">  libavfilter     6. 74.100 /  6. 74.100</span><br><span class="line">  libswscale      4.  3.101 /  4.  3.101</span><br><span class="line">  libswresample   2.  4.100 /  2.  4.100</span><br><span class="line">  libpostproc    54.  2.100 / 54.  2.100</span><br><span class="line">Hardware acceleration methods:</span><br><span class="line">vdpau</span><br><span class="line">vaapi</span><br><span class="line">cuvid</span><br></pre></td></tr></table></figure>

<h1 id="卸载ffmpeg"><a href="#卸载ffmpeg" class="headerlink" title="卸载ffmpeg"></a>卸载ffmpeg</h1><p>卸载刚刚编译安装的ffmpeg命令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rm -rf ~/ffmpeg_build ~/ffmpeg_sources ~/bin/&#123;ffmpeg,ffprobe,ffplay,ffserver,vsyasm,x264,x265,yasm,ytasm&#125;</span><br><span class="line">sudo apt-get autoremove autoconf automake build-essential cmake libass-dev libfreetype6-dev \</span><br><span class="line">  libmp3lame-dev libopus-dev libsdl2-dev libtheora-dev libtool libva-dev libvdpau-dev \</span><br><span class="line">  libvorbis-dev libvpx-dev libx264-dev libxcb1-dev libxcb-shm0-dev ibxcb-xfixes0-dev mercurial texinfo zlib1g-dev</span><br><span class="line">sed -i &#x27;/ffmpeg_build/c\&#x27; ~/.manpath</span><br><span class="line">hash -r</span><br></pre></td></tr></table></figure>

<p>可能遇到的错误：<br><strong>ERROR: x265 not found using pkg-config</strong><br>按照上面的x265编译安装方法重新编译，而不是直接使用系统源中自带的包安装<br><strong>ERROR: libnpp not found</strong><br>添加编译参数<code>--extra-cflags=&quot;-I/usr/local/cuda/include/&quot;    --extra-ldflags=-L/usr/local/cuda/lib64 \</code>，并且要在<code>--enable-libnpp</code>之前的位置</p>
<p>参考：<br>1.<a href="https://trac.ffmpeg.org/wiki/CompilationGuide/Generic">https://trac.ffmpeg.org/wiki/CompilationGuide/Generic</a><br>2.<a href="https://trac.ffmpeg.org/wiki/CompilationGuide/Ubuntu">https://trac.ffmpeg.org/wiki/CompilationGuide/Ubuntu</a><br>3.<a href="https://developer.nvidia.com/nvidia-video-codec-sdk">https://developer.nvidia.com/nvidia-video-codec-sdk</a><br>4.<a href="https://developer.nvidia.com/ffmpeg">https://developer.nvidia.com/ffmpeg</a><br>5.<a href="https://gist.github.com/Brainiarc7/988473b79fd5c8f0db54b92ebb47387a">https://gist.github.com/Brainiarc7/988473b79fd5c8f0db54b92ebb47387a</a></p>
]]></content>
      <categories>
        <category>ffmpeg</category>
      </categories>
      <tags>
        <tag>CUDA</tag>
        <tag>Linux</tag>
        <tag>ffmpeg</tag>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu 16.04下编译OpenCV 2.4.13支持FFmpeg以及CUDA 8加速图像处理</title>
    <url>/2017/03/01/ubuntu-compile-opencv2-with-cuda-and-ffmpeg/</url>
    <content><![CDATA[<p>Ubuntu 16.04下手动编译OpenCV 2.4.13，并提供对FFmpeg以及CUDA 8的支持来使用GPU加速视频图像处理。<br>考虑到大数据处理系统spark的需要，这里也同时加入opencv对java的支持。</p>
<span id="more"></span>
<p>系统为ubuntu 16.04.1 x64服务器版的最小化系统，具体参数如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DISTRIB_ID=Ubuntu</span><br><span class="line">DISTRIB_RELEASE=16.04</span><br><span class="line">DISTRIB_CODENAME=xenial</span><br><span class="line">DISTRIB_DESCRIPTION=&quot;Ubuntu 16.04.1 LTS&quot;</span><br></pre></td></tr></table></figure>
<p>假定已经安装好了CUDA 8，如果还没有安装CUDA 8环境可以参考这里安装<a href="http://notes.maxwi.com/2017/02/26/ubuntu-cuda8-env-set/">http://notes.maxwi.com/2017/02/26/ubuntu-cuda8-env-set/</a><br>也需要提前安装好FFmpeg并将其二进制放到环境变量中，如果还没有编译安装好FFmpeg对GPU解码的支持，可以参考这里<a href="http://notes.maxwi.com/2017/03/01/ubuntu-compile-ffmpeg-with-cuvid-nvenc-npp/">http://notes.maxwi.com/2017/03/01/ubuntu-compile-ffmpeg-with-cuvid-nvenc-npp/</a> </p>
<h1 id="安装OpenCV依赖包"><a href="#安装OpenCV依赖包" class="headerlink" title="安装OpenCV依赖包"></a>安装OpenCV依赖包</h1><p>官方要求的必装包：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install build-essential cmake git libgtk2.0-dev pkg-config libavcodec-dev libavformat-dev libswscale-dev</span><br></pre></td></tr></table></figure>
<p>上面的git如果采用zip方式安装可以不需要，但如果是通过zip方式安装则需要安装上unzip用于解压</p>
<p>官方推荐的可选包：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install  python-dev python-numpy libtbb2 libtbb-dev libjpeg-dev libpng-dev libtiff-dev libjasper-dev libdc1394-22-dev</span><br></pre></td></tr></table></figure>
<p>添加对OpenGL的支持所需要的包：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install freeglut3-dev mesa-common-dev  libgtkglext1 libgtkglext1-dev</span><br></pre></td></tr></table></figure>

<p>其他一些推荐包，包括视频编解码所需要的开发包等：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install checkinstall yasm libgstreamer0.10-dev libgstreamer-plugins-base0.10-dev libv4l-dev libtbb-dev libqt4-dev libgtk2.0-dev libmp3lame-dev libtheora-dev libvorbis-dev libxvidcore-dev x264 v4l-utils</span><br></pre></td></tr></table></figure>
<p>我这里把这些包全部安装上</p>
<h1 id="验证OpenGL的配置"><a href="#验证OpenGL的配置" class="headerlink" title="验证OpenGL的配置"></a>验证OpenGL的配置</h1><p>如果不需要OpenGL可以跳过此步<br>保存如下代码，并命名为testgl.c：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GL/glut.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Drawing funciton</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">//Background color</span></span><br><span class="line">  <span class="built_in">glClearColor</span>(<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">  <span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT );</span><br><span class="line">  <span class="comment">//Draw order</span></span><br><span class="line">  <span class="built_in">glFlush</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Main program</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">glutInit</span>(&amp;argc, argv);</span><br><span class="line">  <span class="comment">//Simple buffer</span></span><br><span class="line">  <span class="built_in">glutInitDisplayMode</span>(GLUT_SINGLE | GLUT_RGB );</span><br><span class="line">  <span class="built_in">glutInitWindowPosition</span>(<span class="number">50</span>,<span class="number">25</span>);</span><br><span class="line">  <span class="built_in">glutInitWindowSize</span>(<span class="number">500</span>,<span class="number">250</span>);</span><br><span class="line">  <span class="built_in">glutCreateWindow</span>(<span class="string">&quot;Green window&quot;</span>);</span><br><span class="line">  <span class="comment">//Call to the drawing function</span></span><br><span class="line">  <span class="built_in">glutDisplayFunc</span>(draw);</span><br><span class="line">  <span class="built_in">glutMainLoop</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc testgl.c -o testgl -lGL -lGLU -lglut</span><br></pre></td></tr></table></figure>
<p>如果编译通过，则表示OpenGl安装成功，运行的话需要有桌面环境，可以通过如下代码为服务器系统安装桌面环境用于测试：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt install ubuntu-desktop</span><br></pre></td></tr></table></figure>
<p>如果需要远程通过VNC在windows上连接ubuntu，可以打开ubuntu上的vino，也就是那个desktop sharing，设置允许远程连接，再在命令行中执行以下语句即可（这些操作要求ubuntu有桌面环境）：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gsettings set org.gnome.Vino require-encryption false</span><br></pre></td></tr></table></figure>

<p><strong>实际测试代码性能时，为了避免由于桌面占用GPU/CPU影响系统性能，可能使用以下命令禁用桌面</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo systemctl disable lightdm.service</span><br></pre></td></tr></table></figure>
<p>需要启用桌面时使用以下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo systemctl disable lightdm.service</span><br></pre></td></tr></table></figure>


<h1 id="编译OpenCV"><a href="#编译OpenCV" class="headerlink" title="编译OpenCV"></a>编译OpenCV</h1><p>下载OpenCV，可以通过git获取官方最新的版本，然后切换到自己所需要的2.4.13进行编译：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/opencv/opencv.git </span><br><span class="line">cd opencv</span><br><span class="line">git checkout 2.4.13.2</span><br></pre></td></tr></table></figure>
<p>或者直接通过wget下载官方最新2.4版的包并解压（记得提前安装unzip）：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://github.com/Itseez/opencv/archive/2.4.13.zip</span><br><span class="line">unzip 2.4.13</span><br></pre></td></tr></table></figure>
<p>为了避免由于OpenCV版对最新CUDA的不兼容，这里选技通过git仓库安装<br>进入到解压后的OpenCV根目录，创建一个build文件夹，然后进入build文件后执行以下编译代码，注意编译选项上包含了CUDA的支持，NVCUVID的支持，OpenGL的支持，以及对ffmpeg的支持。<br>cmake选项：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cmake \</span><br><span class="line">    -D CMAKE_BUILD_TYPE=RELEASE \</span><br><span class="line">    -D CMAKE_INSTALL_PREFIX=/usr/local \</span><br><span class="line">    -D WITH_CUDA=ON \</span><br><span class="line">    -D WITH_CUBLAS=ON \</span><br><span class="line">    -D CUDA_FAST_MATH=ON \</span><br><span class="line">    -D WITH_CUFFT=ON \</span><br><span class="line">    -D WITH_NVCUVID=ON \</span><br><span class="line">    -D WITH_V4L=ON \</span><br><span class="line">    -D WITH_LIBV4L=ON \</span><br><span class="line">    -D WITH_OPENGL=ON \</span><br><span class="line">    -D WITH_FFMPEG=ON \</span><br><span class="line">    -D INSTALL_C_EXAMPLES=ON \</span><br><span class="line">    -D BUILD_EXAMPLES=ON \</span><br><span class="line">    ..</span><br></pre></td></tr></table></figure>
<p>更多cmake选项可以查看OpenCV源码目录下的CMakeLists.txt文件内容。<br><em>如果需要添加对java的支持，需要添加选项<code>-D BUILD_SHARED_LIBS=OFF \</code></em><br>如果你之前的CUDA、支持CUDA、NVCUVID、NVENC的FFmpeg以及opengl编译安装的都没有问题的话，输出应该如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">--     Linker flags (Release):</span><br><span class="line">--     Linker flags (Debug):</span><br><span class="line">--     ccache:                      NO</span><br><span class="line">--     Precompiled headers:         YES</span><br><span class="line">-- </span><br><span class="line">--   OpenCV modules:</span><br><span class="line">--     To be built:                 core flann imgproc highgui features2d calib3d ml video legacy objdetect photo gpu ocl nonfree contrib python stitching superres ts videostab</span><br><span class="line">--     Disabled:                    world</span><br><span class="line">--     Disabled by dependency:      -</span><br><span class="line">--     Unavailable:                 androidcamera dynamicuda java viz</span><br><span class="line">-- </span><br><span class="line">--   GUI: </span><br><span class="line">--     QT:                          NO</span><br><span class="line">--     GTK+ 2.x:                    YES (ver 2.24.30)</span><br><span class="line">--     GThread :                    YES (ver 2.48.2)</span><br><span class="line">--     GtkGlExt:                    YES (ver 1.2.0)</span><br><span class="line">--     OpenGL support:              YES (/usr/lib/x86_64-linux-gnu/libGLU.so /usr/lib/x86_64-linux-gnu/libGL.so)</span><br><span class="line">--     VTK support:                 NO</span><br><span class="line">-- </span><br><span class="line">--   Media I/O: </span><br><span class="line">--     ZLib:                        /usr/lib/x86_64-linux-gnu/libz.so (ver 1.2.8)</span><br><span class="line">--     JPEG:                        /usr/lib/x86_64-linux-gnu/libjpeg.so (ver )</span><br><span class="line">--     PNG:                         /usr/lib/x86_64-linux-gnu/libpng.so (ver 1.2.54)</span><br><span class="line">--     TIFF:                        /usr/lib/x86_64-linux-gnu/libtiff.so (ver 42 - 4.0.6)</span><br><span class="line">--     JPEG 2000:                   /usr/lib/x86_64-linux-gnu/libjasper.so (ver 1.900.1)</span><br><span class="line">--     OpenEXR:                     /usr/lib/x86_64-linux-gnu/libImath.so /usr/lib/x86_64-linux-gnu/libIlmImf.so /usr/lib/x86_64-linux-gnu/libIex.so /usr/lib/x86_64-linux-gnu/libHalf.so /usr/lib/x86_64-linux-gnu/libIlmThread.so (ver 2.2.0)</span><br><span class="line">-- </span><br><span class="line">--   Video I/O:</span><br><span class="line">--     DC1394 1.x:                  NO</span><br><span class="line">--     DC1394 2.x:                  YES (ver 2.2.4)</span><br><span class="line">--     FFMPEG:                      YES</span><br><span class="line">--       avcodec:                   YES (ver 56.60.100)</span><br><span class="line">--       avformat:                  YES (ver 56.40.101)</span><br><span class="line">--       avutil:                    YES (ver 54.31.100)</span><br><span class="line">--       swscale:                   YES (ver 3.1.101)</span><br><span class="line">--       avresample:                NO</span><br><span class="line">--     GStreamer:                   </span><br><span class="line">--       base:                      YES (ver 0.10.36)</span><br><span class="line">--       video:                     YES (ver 0.10.36)</span><br><span class="line">--       app:                       YES (ver 0.10.36)</span><br><span class="line">--       riff:                      YES (ver 0.10.36)</span><br><span class="line">--       pbutils:                   YES (ver 0.10.36)</span><br><span class="line">--     OpenNI:                      NO</span><br><span class="line">--     OpenNI PrimeSensor Modules:  NO</span><br><span class="line">--     PvAPI:                       NO</span><br><span class="line">--     GigEVisionSDK:               NO</span><br><span class="line">--     UniCap:                      NO</span><br><span class="line">--     UniCap ucil:                 NO</span><br><span class="line">--     V4L/V4L2:                    Using libv4l1 (ver 1.10.0) / libv4l2 (ver 1.10.0)</span><br><span class="line">--     XIMEA:                       NO</span><br><span class="line">--     Xine:                        NO</span><br><span class="line">-- </span><br><span class="line">--   Other third-party libraries:</span><br><span class="line">--     Use IPP:                     NO</span><br><span class="line">--     Use Eigen:                   NO</span><br><span class="line">--     Use TBB:                     NO</span><br><span class="line">--     Use OpenMP:                  NO</span><br><span class="line">--     Use GCD                      NO</span><br><span class="line">--     Use Concurrency              NO</span><br><span class="line">--     Use C=:                      NO</span><br><span class="line">--     Use Cuda:                    YES (ver 8.0)</span><br><span class="line">--     Use OpenCL:                  YES</span><br><span class="line">-- </span><br><span class="line">--   NVIDIA CUDA</span><br><span class="line">--     Use CUFFT:                   YES</span><br><span class="line">--     Use CUBLAS:                  YES</span><br><span class="line">--     USE NVCUVID:                 YES</span><br><span class="line">--     NVIDIA GPU arch:             20 21 30 35</span><br><span class="line">--     NVIDIA PTX archs:            30</span><br><span class="line">--     Use fast math:               YES</span><br><span class="line">--     Tiny gpu module:             NO</span><br><span class="line">-- </span><br><span class="line">--   OpenCL:</span><br><span class="line">--     Version:                     dynamic</span><br><span class="line">--     Include path:                /home/dutoeserver/OpenCV/opencv_git/3rdparty/include/opencl/1.2</span><br><span class="line">--     Use AMD FFT:                 NO</span><br><span class="line">--     Use AMD BLAS:                NO</span><br><span class="line">-- </span><br><span class="line">--   Python:</span><br><span class="line">--     Interpreter:                 /usr/bin/python2 (ver 2.7.12)</span><br><span class="line">--     Libraries:                   /usr/lib/x86_64-linux-gnu/libpython2.7.so (ver 2.7.12)</span><br><span class="line">--     numpy:                       /usr/lib/python2.7/dist-packages/numpy/core/include (ver 1.11.0)</span><br><span class="line">--     packages path:               lib/python2.7/dist-packages</span><br><span class="line">-- </span><br><span class="line">--   Java:</span><br><span class="line">--     ant:                         NO</span><br><span class="line">--     JNI:                         NO</span><br><span class="line">--     Java tests:                  NO</span><br><span class="line">-- </span><br><span class="line">--   Documentation:</span><br><span class="line">--     Build Documentation:         NO</span><br><span class="line">--     Sphinx:                      NO</span><br><span class="line">--     PdfLaTeX compiler:           NO</span><br><span class="line">--     Doxygen:                     NO</span><br><span class="line">-- </span><br><span class="line">--   Tests and samples:</span><br><span class="line">--     Tests:                       YES</span><br><span class="line">--     Performance tests:           YES</span><br><span class="line">--     C/C++ Examples:              YES</span><br><span class="line">-- </span><br><span class="line">--   Install path:                  /usr/local</span><br><span class="line">-- </span><br><span class="line">--   cvconfig.h is in:              /home/dutoeserver/OpenCV/opencv_git/build</span><br><span class="line">-- -----------------------------------------------------------------</span><br><span class="line">-- </span><br><span class="line">-- Configuring done</span><br><span class="line">-- Generating done</span><br><span class="line">-- Build files have been written to: /home/dutoeserver/OpenCV/opencv_git/build</span><br></pre></td></tr></table></figure>
<p>从中可以看到我们所添加的编译选项后面都有YES<br>下面使用make进行编译：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">make -j $(($(nproc) + 1))</span><br></pre></td></tr></table></figure>
<p>然后遍是漫长的编译过程，如果没有问题的话，编译会顺利进行。<br>然后使用make进行安装并配置环境：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo make install</span><br><span class="line">sudo /bin/bash -c &#x27;echo &quot;/usr/local/lib&quot; &gt; /etc/ld.so.conf.d/opencv.conf&#x27;</span><br><span class="line">sudo ldconfig</span><br></pre></td></tr></table></figure>
<p>建议上述安装完成之后重启一次系统</p>
<p><strong>可以将上面<code>sudo make install</code>部分换成<code>sudo checkinstall</code>，这样安装完成之后checkinstall会在当前目录生成一个相应的deb，可以二次安装，也可以用sudo dpkg -r xx.deb来卸载</strong><br>更多checkinstall的用法可以参见IBM的一篇文章：<a href="http://www.ibm.com/developerworks/cn/linux/l-cn-checkinstall/">http://www.ibm.com/developerworks/cn/linux/l-cn-checkinstall/</a></p>
<h1 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h1><p>找到OpenCV源代码文件夹下的<code>samples/gpu</code><br>里面有很多gpu的示例代码，这里以其中的hog.cpp为例，它的功能就是利用方向梯度直方图（Histogram of oriented gradient）进行目标检测<br>将该代码单独拷贝到一个文件中，并在该文件夹下创建<code>CMakeLists.txt</code>，内容如下：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">2.8</span>)</span><br><span class="line"><span class="keyword">project</span>(HOG)</span><br><span class="line"><span class="keyword">find_package</span>(OpenCV REQUIRED)</span><br><span class="line"><span class="keyword">add_executable</span>(hog hog.cpp)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(hog <span class="variable">$&#123;OpenCV_LIBS&#125;</span>)</span><br></pre></td></tr></table></figure>
<p>然后执行编译：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir build</span><br><span class="line">cd build</span><br><span class="line">cmake -D CUDA_USE_STATIC_CUDA_RUNTIME=OFF ..</span><br><span class="line">make</span><br></pre></td></tr></table></figure>
<p>如果环境配置没有问题的话，build文件下就会生成可执行的程序hog，可以通过<code>hog --help</code>查看帮助，下面使用hog来播放视频，或者也可以直接接摄像头：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./hog --video ~/input.mp4</span><br></pre></td></tr></table></figure>
<p>输出结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Device 0:  &quot;GeForce GTX 1080&quot;  8112Mb, sm_61, Driver/Runtime ver.8.0/8.0</span><br><span class="line"></span><br><span class="line">Controls:</span><br><span class="line">	ESC - exit</span><br><span class="line">	m - change mode GPU &lt;-&gt; CPU</span><br><span class="line">	g - convert image to gray or not</span><br><span class="line">	1/q - increase/decrease HOG scale</span><br><span class="line">	2/w - increase/decrease levels count</span><br><span class="line">	3/e - increase/decrease HOG group threshold</span><br><span class="line">	4/r - increase/decrease hit threshold</span><br><span class="line"></span><br><span class="line">Scale: 1.05</span><br><span class="line">Group threshold: 8</span><br><span class="line">Levels number: 13</span><br><span class="line">Win width: 48</span><br><span class="line">Win stride: (8, 8)</span><br><span class="line">Hit threshold: 1.4</span><br><span class="line">Gamma correction: 1</span><br></pre></td></tr></table></figure>
<p>可以通过m键来切换使用CPU mode或者CUDA mode。<br>可以打开nvidia-setting来查看CUDA mode下GPU的占用情况</p>
<h1 id="可能出现的错误"><a href="#可能出现的错误" class="headerlink" title="可能出现的错误"></a>可能出现的错误</h1><p><strong>如果出现NVCUVID后面是NO，而CUDA后面是YES</strong><br><strong>如果出现NVCUVID后面是NO，而CUDA后面是YES</strong><br>这种情况下将无法使用CUDA编解码功能，这是由于cmake在查找库的时候采用的路径是<code>/usr/lib</code>以及<code>/usr/lib/nvidia-current</code>路径，而实际上我的nvidia显卡驱动安装路径为<code>/usr/lib/nvidia-378</code>，所以导致无法找到这个路径。<br>PS：为了解决这个问题，查看了opencv的cmake中的相关代码后才发现，但在些之前搜索了很久，也乱试了很久都无果，所以一定要有根据的解决问题，还不是盲目地去试。<br>解决：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo ln -s /usr/lib/nvidia-378/libnvcuvid.so /usr/lib/libnvcuvid.so</span><br><span class="line">sudo ln -s /usr/lib/nvidia-378/libnvcuvid.so.1 /usr/lib/libnvcuvid.so.1</span><br></pre></td></tr></table></figure>
<p><strong>记得修改成你自己的nvidia驱动安装路径</strong></p>
<p><strong>如果FFmpeg没有YES</strong><br>可能是你的FFmpeg编译后没有将其添加到环境变量中。</p>
<p><strong>cannot find -lopencv_dep_cudart</strong><br>错误详情：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/usr/bin/ld: cannot find -lopencv_dep_cudart</span><br><span class="line">collect2: error: ld returned 1 exit status</span><br><span class="line">CMakeFiles/hog.dir/build.make:120: recipe for target &#x27;hog&#x27; failed</span><br><span class="line">make[2]: *** [hog] Error 1</span><br><span class="line">CMakeFiles/Makefile2:67: recipe for target &#x27;CMakeFiles/hog.dir/all&#x27; failed</span><br><span class="line">make[1]: *** [CMakeFiles/hog.dir/all] Error 2</span><br><span class="line">Makefile:83: recipe for target &#x27;all&#x27; failed</span><br><span class="line">make: *** [all] Error 2</span><br></pre></td></tr></table></figure>
<p>添加cmake编译选项来解决：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cmake -D CUDA_USE_STATIC_CUDA_RUNTIME=OFF ..</span><br></pre></td></tr></table></figure>

<p><strong>Exception in thread “main” java.lang.NoClassDefFoundError: org/opencv/core/Core</strong><br>如果需要配置java调用opencv，需要修改如下配置文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export CLASSPATH=.:$JAVA_HOME/lib:$JRE_HOME/lib:/usr/local/share/OpenCV/java/opencv-2413.jar</span><br><span class="line">export LD_LIBRARY_PATH=/usr/local/lib/:/usr/lib/:/usr/local/share/OpenCV/java:$LD_LIBRARY_PATH</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>OpenCV</category>
      </categories>
      <tags>
        <tag>CUDA</tag>
        <tag>Linux</tag>
        <tag>ffmpeg</tag>
        <tag>OpenCV</tag>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu 16.04下CUDA8环境配置的2种方法</title>
    <url>/2017/02/26/ubuntu-cuda8-env-set/</url>
    <content><![CDATA[<p>系统为ubuntu 16.04.1 x64，具体参数如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DISTRIB_ID=Ubuntu</span><br><span class="line">DISTRIB_RELEASE=16.04</span><br><span class="line">DISTRIB_CODENAME=xenial</span><br><span class="line">DISTRIB_DESCRIPTION=&quot;Ubuntu 16.04.1 LTS&quot;</span><br></pre></td></tr></table></figure>
<p>系统为Ubuntu 64位服务器版的最小化系统<br>安装Nvidia官网最新版本的CUDA 8(2016.12.19)<br>下面分别使用Nvidia官方手册中使用deb源的方式安装，和根据Nvidia提供的二进制包配合双显卡技术的方式安装。前者更新更方便，后者针对双显卡最方便。服务器系统推荐使用第一种方式安装，笔记本建议使用第二种方式，因为可以实现双显卡，集显更省电。<br>如果只是为了玩游戏需要配置Ubuntu下的Nvidia和intel双显卡，也可以直接跳到双显卡切换的配置部分</p>
<span id="more"></span>

<h1 id="根据nvidia官方手册安装"><a href="#根据nvidia官方手册安装" class="headerlink" title="根据nvidia官方手册安装"></a>根据nvidia官方手册安装</h1><p>该安装方法由于是在服务器系统下测试，并没有桌面环境，所以不保证安装配置完成之后依然能进入桌面环境。</p>
<h2 id="安装准备"><a href="#安装准备" class="headerlink" title="安装准备"></a>安装准备</h2><h3 id="验证NVIDIA显卡"><a href="#验证NVIDIA显卡" class="headerlink" title="验证NVIDIA显卡"></a>验证NVIDIA显卡</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">lspci | grep -i nvidia</span></span><br></pre></td></tr></table></figure>
<p>看看是否有nvidia的显卡</p>
<h3 id="查看linux系统信息"><a href="#查看linux系统信息" class="headerlink" title="查看linux系统信息"></a>查看linux系统信息</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">uname</span> -m &amp;&amp; <span class="built_in">cat</span> /etc/*release</span></span><br></pre></td></tr></table></figure>
<p>确保你的系统在nvidia官方的cuda支持列表中</p>
<h3 id="安装gcc及g"><a href="#安装gcc及g" class="headerlink" title="安装gcc及g++"></a>安装gcc及g++</h3><p>就是安装C++开发环境，因为CUDA是基于C/C++开发的，当然现在也支持很多其他语言</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo apt-get install gcc g++</span></span><br></pre></td></tr></table></figure>

<h3 id="安装linux-kernel-header及开发包"><a href="#安装linux-kernel-header及开发包" class="headerlink" title="安装linux kernel header及开发包"></a>安装linux kernel header及开发包</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo apt-get install linux-headers-$(<span class="built_in">uname</span> -r)</span></span><br></pre></td></tr></table></figure>
<p>为了避免出现头文件相关的问题，推荐安装上build-essential：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo apt-get install build-essential</span></span><br></pre></td></tr></table></figure>

<h2 id="下载并安装CUDA"><a href="#下载并安装CUDA" class="headerlink" title="下载并安装CUDA"></a>下载并安装CUDA</h2><p>下载CUDA：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">wget --no-check-certificate https://developer.nvidia.com/compute/cuda/8.0/prod/local_installers/cuda-repo-ubuntu1604-8-0-local_8.0.44-1_amd64-deb</span></span><br></pre></td></tr></table></figure>
<p>通过以下命令安装cuda源：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo dpkg -i cuda-repo-ubuntu1604-8-0-local_8.0.44-1_amd64-deb</span></span><br></pre></td></tr></table></figure>
<p>如果是下载的local版本，实际上会在本地增加一个local源，指定为cuda的解压路径，如果是网络源，实际上会添加以下源：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">deb http://developer.download.nvidia.com/compute/cuda/repos/ubuntu1604/x86_64 /</span><br></pre></td></tr></table></figure>

<p>更新包缓存：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo apt-get update</span></span><br></pre></td></tr></table></figure>

<p>安装CUDA：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo apt-get install cuda</span></span><br></pre></td></tr></table></figure>

<h2 id="设置环境变量"><a href="#设置环境变量" class="headerlink" title="设置环境变量"></a>设置环境变量</h2><p>在自己的.bashrc的最后添加以下代码</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export PATH=/usr/local/cuda-8.0/bin$&#123;PATH:+:$&#123;PATH&#125;&#125;</span><br><span class="line">export LD_LIBRARY_PATH=/usr/local/cuda-8.0/lib64$&#123;LD_LIBRARY_PATH:+:$&#123;LD_LIBRARY_PATH&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>使用环境变量设置立即生效：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">source</span> ~/.bashrc</span></span><br></pre></td></tr></table></figure>

<h2 id="安装官方示例并验证环境"><a href="#安装官方示例并验证环境" class="headerlink" title="安装官方示例并验证环境"></a>安装官方示例并验证环境</h2><p>在些之前最后重启一下系统，以使驱动生效。<br>查看驱动等信息是否正常：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> /proc/driver/nvidia/version</span></span><br></pre></td></tr></table></figure>
<p>我这里的输出如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NVRM version: NVIDIA UNIX x86_64 Kernel Module  367.57  Mon Oct  3 20:37:01 PDT 2016</span><br><span class="line">GCC version:  gcc version 5.4.0 20160609 (Ubuntu 5.4.0-6ubuntu1~16.04.4)</span><br></pre></td></tr></table></figure>

<p>如果上面的环境变量已经配置完成，则可以使用以下命令安装官方示例到用户根目录：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cuda-install-samples-8.0.sh  ~</span></span><br></pre></td></tr></table></figure>

<p>进入刚安装的CUDA官方示例文件夹NVIDIA_CUDA-8.0_Samples运行make进行示例的编译。<br>如果没有问题的话，稍后会编译成功，编译完成之后会在目录<code>NVIDIA_CUDA-8.0_Samples/bin/x86_64/linux/release</code>中生成deviceQuery<br>运行查询输出</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./deviceQuery</span></span><br></pre></td></tr></table></figure>
<p>我这里的输出结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./deviceQuery Starting...</span><br><span class="line"></span><br><span class="line"> CUDA Device Query (Runtime API) version (CUDART static linking)</span><br><span class="line"></span><br><span class="line">Detected 1 CUDA Capable device(s)</span><br><span class="line"></span><br><span class="line">Device 0: &quot;GeForce GTX 1080&quot;</span><br><span class="line">  CUDA Driver Version / Runtime Version          8.0 / 8.0</span><br><span class="line">  CUDA Capability Major/Minor version number:    6.1</span><br><span class="line">  Total amount of global memory:                 8112 MBytes (8506179584 bytes)</span><br><span class="line">  (20) Multiprocessors, (128) CUDA Cores/MP:     2560 CUDA Cores</span><br><span class="line">  GPU Max Clock rate:                            1734 MHz (1.73 GHz)</span><br><span class="line">  Memory Clock rate:                             5005 Mhz</span><br><span class="line">  Memory Bus Width:                              256-bit</span><br><span class="line">  L2 Cache Size:                                 2097152 bytes</span><br><span class="line">  Maximum Texture Dimension Size (x,y,z)         1D=(131072), 2D=(131072, 65536), 3D=(16384, 16384, 16384)</span><br><span class="line">  Maximum Layered 1D Texture Size, (num) layers  1D=(32768), 2048 layers</span><br><span class="line">  Maximum Layered 2D Texture Size, (num) layers  2D=(32768, 32768), 2048 layers</span><br><span class="line">  Total amount of constant memory:               65536 bytes</span><br><span class="line">  Total amount of shared memory per block:       49152 bytes</span><br><span class="line">  Total number of registers available per block: 65536</span><br><span class="line">  Warp size:                                     32</span><br><span class="line">  Maximum number of threads per multiprocessor:  2048</span><br><span class="line">  Maximum number of threads per block:           1024</span><br><span class="line">  Max dimension size of a thread block (x,y,z): (1024, 1024, 64)</span><br><span class="line">  Max dimension size of a grid size    (x,y,z): (2147483647, 65535, 65535)</span><br><span class="line">  Maximum memory pitch:                          2147483647 bytes</span><br><span class="line">  Texture alignment:                             512 bytes</span><br><span class="line">  Concurrent copy and kernel execution:          Yes with 2 copy engine(s)</span><br><span class="line">  Run time limit on kernels:                     No</span><br><span class="line">  Integrated GPU sharing Host Memory:            No</span><br><span class="line">  Support host page-locked memory mapping:       Yes</span><br><span class="line">  Alignment requirement for Surfaces:            Yes</span><br><span class="line">  Device has ECC support:                        Disabled</span><br><span class="line">  Device supports Unified Addressing (UVA):      Yes</span><br><span class="line">  Device PCI Domain ID / Bus ID / location ID:   0 / 3 / 0</span><br><span class="line">  Compute Mode:</span><br><span class="line">     &lt; Default (multiple host threads can use ::cudaSetDevice() with device simultaneously) &gt;</span><br><span class="line"></span><br><span class="line">deviceQuery, CUDA Driver = CUDART, CUDA Driver Version = 8.0, CUDA Runtime Version = 8.0, NumDevs = 1, Device0 = GeForce GTX 1080</span><br><span class="line">Result = PASS</span><br></pre></td></tr></table></figure>
<p>只要最后输出中显示结果为PASS即表示安装完成</p>
<h1 id="手动配置CUDA环境"><a href="#手动配置CUDA环境" class="headerlink" title="手动配置CUDA环境"></a>手动配置CUDA环境</h1><h2 id="安装显卡驱动并配置双显卡"><a href="#安装显卡驱动并配置双显卡" class="headerlink" title="安装显卡驱动并配置双显卡"></a>安装显卡驱动并配置双显卡</h2><p>对于桌面系统肯定希望安装nvidia显卡之后不会影响之前系统的正常使用，例如笔记本自带的intel显卡，和nvidia的显卡，此时可以通过bumblebee进行管理来切换双显卡。<br>可以通过ppa进行bumblebee安装。为了能够安装最新的nvidia显卡驱动，这里同样可以使用ppa来进行安装最新的显卡驱动。<br>首先删除系统中已经有的相关软件包：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get purge nvidia* bumblebee* nouveau*</span><br></pre></td></tr></table></figure>

<h3 id="安装Nvidia显卡驱动"><a href="#安装Nvidia显卡驱动" class="headerlink" title="安装Nvidia显卡驱动"></a>安装Nvidia显卡驱动</h3><p>安装显卡ppa并更新缓存：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo add-apt-repository ppa:graphics-drivers/ppa</span><br><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure>
<p>可以添加后只更新一次缓存。</p>
<p>然后自己去nvidia官方查询你自己的显卡对应的linux下最新版本驱动的版本号，然后按如下替换安装nvidia显卡驱动所需要的包（可以通过Tab键补全的方式来安装最新版本的驱动）：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt install nvidia-375 nvidia-prime</span><br></pre></td></tr></table></figure>
<p>或者通过以下命令查看系统中所有可以安装的驱动：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo ubuntu-drivers list</span><br></pre></td></tr></table></figure>

<p>然后运行以下命令生成nvidia的配置文件（有些系统可能并不需要）：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo nvidia-xconfig </span><br></pre></td></tr></table></figure>

<p>重启系统，如果安装成功，此时使用的应该就是nvidia的显卡。可以运行<code>glxgears</code>来查看fps，如果提示没有该命令，就需要多安装一个包：<code>sudo apt-get install mesa-utils</code><br>也可以通过命令：<code>glxinfo | head</code>查看当前启用的是不是nvidia显卡<br>或者直接打开设置中的关于也可以查看当前使用的显卡<br>运行以下命令打开nvidia显卡配置程序：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo nvidia-settings</span><br></pre></td></tr></table></figure>
<p>如果不考虑双显卡切换的问题，到这里就可以直接跳到CUDA安装部分了<br>如果执行上述命令有如下提示：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">** Message: PRIME: No offloading required. Abort</span><br><span class="line">** Message: PRIME: is it supported? no</span><br></pre></td></tr></table></figure>
<p>说明你的显卡不支持Nvidia的prime技术，或者说你显卡当前的驱动还不支持该技术，这样的话后面的双显卡切换就可以直接跳过了。</p>
<h3 id="配置双显卡驱动切换"><a href="#配置双显卡驱动切换" class="headerlink" title="配置双显卡驱动切换"></a>配置双显卡驱动切换</h3><p>安装bumblebee的ppa并更新缓存：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo add-apt-repository ppa:bumblebee/stable</span><br><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure>

<p>执行以下命令安装bumblebee以及相关包：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install primus nvidia-profiler nvidia-visual-profiler nvidia-prime nvidia-prime-applet bumblebee-nvidia</span><br></pre></td></tr></table></figure>
<p>重启系统之后应该就可以看到状态栏里面有个显卡切换的图标了</p>
<p>如果上述命令在更新包缓存时出现404，并且安装<code>nvidia-prime-applet</code>时提示无法找到该包，则可以在<code>/etc/apt/source.list.d/</code>中删除刚添加的这个源，换成以下源并安装他的prime-indicator：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo add-apt-repository ppa:nilarimogard/webupd8</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install prime-indicator-plus</span><br></pre></td></tr></table></figure>

<p>如果<code>nvidia-settings</code>运行之后提示支持prime，也可以直接在这个里面的<code>PRIME Profiles</code>进行显卡的切换，而不需要再安装那个indicator</p>
<h2 id="安装cuda"><a href="#安装cuda" class="headerlink" title="安装cuda"></a>安装cuda</h2><p>安装cuda之前需要进行c++环境的安装，参见前面的内容<br>从官方下载cuda的二进制runfile文件，之所以使用这个文件安装也是为了避免安装的驱动破坏了之前已经配置好的驱动</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://developer.nvidia.com/compute/cuda/8.0/prod/local_installers/cuda_8.0.44_linux-run</span><br></pre></td></tr></table></figure>
<p>然后执行以下命令进行安装：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo sh cuda_8.0.44_linux.run</span><br></pre></td></tr></table></figure>
<p>注意安装过程中不要安装显卡驱动，其他根据需要按提示操作即可。<br>安装完成之后记得配置环境变量，跟上面一样，增加如下内容到.bashrc的最后：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export PATH=/usr/local/cuda-8.0/bin$&#123;PATH:+:$&#123;PATH&#125;&#125;</span><br><span class="line">export LD_LIBRARY_PATH=/usr/local/cuda-8.0/lib64$&#123;LD_LIBRARY_PATH:+:$&#123;LD_LIBRARY_PATH&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>然后：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">source ~/.bashrc</span><br></pre></td></tr></table></figure>
<p>不过runfile的官方安装结束之后会提示增加libs到ld.so.conf中。可以添加如下文件：<br><code>/etc/ld.so.conf.d/cuda.conf</code>，内容为<code>/usr/local/cuda-8.0/lib64</code>，然后运行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo ldconfig</span><br></pre></td></tr></table></figure>
<p>至此CUDA的显卡都已经安装完成，通过显卡切换程序将显卡切换为Nvidia显卡之后，即可像上面的验证过程一样，验证CUDA是否正常运行</p>
<h1 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h1><h2 id="sbin-ldconfig-real-usr-lib-nvidia-384-libEGL-so-1-is-not-a-symbolic-link"><a href="#sbin-ldconfig-real-usr-lib-nvidia-384-libEGL-so-1-is-not-a-symbolic-link" class="headerlink" title="/sbin/ldconfig.real: /usr/lib/nvidia-384/libEGL.so.1 is not a symbolic link"></a>/sbin/ldconfig.real: /usr/lib/nvidia-384/libEGL.so.1 is not a symbolic link</h2><p>解决方法是手动创建一个符号链接，或者使用root权限执行以下命令来进行：<br>然后再次手动运行<code>sudo ldconfig</code>，发现已经没有那个错误提示了</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#! /bin/sh</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># find the file in /usr/lib</span></span><br><span class="line">LIBEGL=`find /usr/lib/nvidia* -name libEGL.so.\* | egrep <span class="string">&quot;[0-9][0-9]*\.[0-9][0-9]*$&quot;</span>`</span><br><span class="line">LIBEGL_LINK=`<span class="built_in">echo</span> <span class="variable">$LIBEGL</span> | sed <span class="string">&#x27;s/[0-9][0-9]*\.[0-9][0-9]*$/1/&#x27;</span>`</span><br><span class="line"><span class="built_in">printf</span> <span class="string">&quot;\n\nThe following commands will be executed:\n+++++++++++++++++++++++++++++++++++++++\n&quot;</span></span><br><span class="line"><span class="built_in">printf</span> <span class="string">&quot;mv <span class="variable">$LIBEGL_LINK</span> <span class="variable">$&#123;LIBEGL_LINK&#125;</span>.orig\nln -s <span class="variable">$LIBEGL</span> <span class="variable">$LIBEGL_LINK</span>\n\n&quot;</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">true</span>; <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">read</span> -p <span class="string">&quot;Do you wish to perform these commands?  &quot;</span> yn</span><br><span class="line">    <span class="keyword">case</span> <span class="variable">$yn</span> <span class="keyword">in</span></span><br><span class="line">        [Yy]* ) <span class="built_in">mv</span> <span class="variable">$LIBEGL_LINK</span> <span class="variable">$&#123;LIBEGL_LINK&#125;</span>.orig; <span class="built_in">ln</span> -s <span class="variable">$LIBEGL</span> <span class="variable">$LIBEGL_LINK</span> ; <span class="built_in">break</span>;;</span><br><span class="line">        [Nn]* ) <span class="built_in">break</span>;;</span><br><span class="line">        * ) <span class="built_in">echo</span> <span class="string">&quot;Please answer yes or no.&quot;</span>;;</span><br><span class="line">    <span class="keyword">esac</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># find the file in /usr/lib32</span></span><br><span class="line">LIBEGL=`find /usr/lib32/nvidia* -name libEGL.so.\* | egrep <span class="string">&quot;[0-9][0-9]*\.[0-9][0-9]*$&quot;</span>`</span><br><span class="line">LIBEGL_LINK=`<span class="built_in">echo</span> <span class="variable">$LIBEGL</span> | sed <span class="string">&#x27;s/[0-9][0-9]*\.[0-9][0-9]*$/1/&#x27;</span>`</span><br><span class="line"><span class="built_in">printf</span> <span class="string">&quot;\n\nThe following commands will be executed:\n+++++++++++++++++++++++++++++++++++++++\n&quot;</span></span><br><span class="line"><span class="built_in">printf</span> <span class="string">&quot;mv <span class="variable">$LIBEGL_LINK</span> <span class="variable">$&#123;LIBEGL_LINK&#125;</span>.orig\nln -s <span class="variable">$LIBEGL</span> <span class="variable">$LIBEGL_LINK</span>\n\n&quot;</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">true</span>; <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">read</span> -p <span class="string">&quot;Do you wish to perform these commands?  &quot;</span> yn</span><br><span class="line">    <span class="keyword">case</span> <span class="variable">$yn</span> <span class="keyword">in</span></span><br><span class="line">        [Yy]* ) <span class="built_in">mv</span> <span class="variable">$LIBEGL_LINK</span> <span class="variable">$&#123;LIBEGL_LINK&#125;</span>.orig; <span class="built_in">ln</span> -s <span class="variable">$LIBEGL</span> <span class="variable">$LIBEGL_LINK</span> ; <span class="built_in">break</span>;;</span><br><span class="line">        [Nn]* ) <span class="built_in">break</span>;;</span><br><span class="line">        * ) <span class="built_in">echo</span> <span class="string">&quot;Please answer yes or no.&quot;</span>;;</span><br><span class="line">    <span class="keyword">esac</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>CUDA</category>
      </categories>
      <tags>
        <tag>CUDA</tag>
        <tag>Linux</tag>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux实用工具总结之UFW</title>
    <url>/2017/01/19/linux-command-tools-ufw/</url>
    <content><![CDATA[<p>UFW，即Uncomplicated Firewall，是基于iptables实现的防火墙管理工具，所以实际上UFW修改的是iptables的规则。之所以不直接使用iptables，而要通过UFW进行管理是因为iptables的规则对于新手入门来说有点难，UFW做了很好的包装。</p>
<span id="more"></span>
<p>本文测试环境为Ubuntu 16.04，其他系统可做参考。</p>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>Ubuntu系统默认已经安装了UFW，如果没有ufw，可以手动安装：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo apt-get update</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo apt-get install ufw</span></span><br></pre></td></tr></table></figure>

<h1 id="基础配置"><a href="#基础配置" class="headerlink" title="基础配置"></a>基础配置</h1><h2 id="允许UFW管理IPV6"><a href="#允许UFW管理IPV6" class="headerlink" title="允许UFW管理IPV6"></a>允许UFW管理IPV6</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/default/ufw</span><br></pre></td></tr></table></figure>
<p>确保你的IPV6选项为yes即可：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">IPV6=yes</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h2 id="设置默认规则"><a href="#设置默认规则" class="headerlink" title="设置默认规则"></a>设置默认规则</h2><p>UFW默认情况下允许所有的出站连接，拒绝所有的入站连接，所以这里首先将UFW设置为默认规则：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo ufw default deny incoming</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo ufw default allow outgoing</span></span><br></pre></td></tr></table></figure>
<p><code>ufw default</code>也允许使用<code>reject</code>参数</p>
<h2 id="允许SSH连接"><a href="#允许SSH连接" class="headerlink" title="允许SSH连接"></a>允许SSH连接</h2><p>一旦启用UFW之后，如果没有允许SSH连接，将无法再通过SSH远程访问主机，所以在开启防火墙之后要确认SSH连接已经设置为允许：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo ufw allow ssh</span></span><br></pre></td></tr></table></figure>
<p>这里创建一条规则，允许ssh连接，其实是允许22端口的连接，等价于：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo ufw allow 22</span></span><br></pre></td></tr></table></figure>
<p>UFW通过<code>/etc/services</code>知道ssh服务使用的默认端口为22，如果你的SSH服务使用的端口不是22，则应该修改为相应 的端口号。</p>
<h2 id="查看防火墙状态"><a href="#查看防火墙状态" class="headerlink" title="查看防火墙状态"></a>查看防火墙状态</h2><p>通过以下命令查看防火墙状态：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo ufw status verbose</span></span><br></pre></td></tr></table></figure>
<p>也可以不带verbose，当防火墙处于关闭状态时只会显示<code>inactive</code><br>可以查看刚刚添加的防火墙规则：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo ufw show added</span></span><br></pre></td></tr></table></figure>
<p>show后面还可以跟其他几项参数，可以通过man手册查看<code>REPORTS</code></p>
<h1 id="启用-禁用UFW"><a href="#启用-禁用UFW" class="headerlink" title="启用/禁用UFW"></a>启用/禁用UFW</h1><p>启用UFW命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo ufw <span class="built_in">enable</span></span></span><br></pre></td></tr></table></figure>
<p>该命令默认会将UFW设置为开机启动，如果发现重启后UFW并没有自动启动，可以手动设置UFW服务开机自动启动：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo systemctl start ufw</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo systemctl <span class="built_in">enable</span> ufw</span></span><br></pre></td></tr></table></figure>

<p>记得查看防火墙当前的状态：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo ufw status</span></span><br><span class="line">Status: active</span><br><span class="line"></span><br><span class="line">To                         Action      From</span><br><span class="line">--                         ------      ----</span><br><span class="line">22                         ALLOW       Anywhere</span><br><span class="line">22 (v6)                    ALLOW       Anywhere (v6) </span><br></pre></td></tr></table></figure>


<p>禁用UFW：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo ufw <span class="built_in">disable</span></span></span><br></pre></td></tr></table></figure>
<p>该命令会禁用防火墙并关闭其开机自动启动</p>
<h1 id="启用-禁用防火墙日志"><a href="#启用-禁用防火墙日志" class="headerlink" title="启用/禁用防火墙日志"></a>启用/禁用防火墙日志</h1><p>启用防火墙日志：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo ufw logging on</span></span><br></pre></td></tr></table></figure>
<p>可以指定日志级别<code>sudo ufw logging low|medium|high</code><br>日志文件在<code>/var/log/ufw.log</code><br>内容形如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Sep 16 15:08:14 &lt;hostname&gt; kernel: [UFW BLOCK] IN=eth0 OUT= MAC=00:00:00:00:00:00:00:00:00:00:00:00:00:00 SRC=123.45.67.89 DST=987.65.43.21 LEN=40 TOS=0x00 PREC=0x00 TTL=249 ID=8475 PROTO=TCP SPT=48247 DPT=22 WINDOW=1024 RES=0x00 SYN URGP=0</span><br></pre></td></tr></table></figure>
<p>其中前面列出了主机防火墙日志的日期、时间、主机名，后面的内容意思是：</p>
<ul>
<li>[UFW BLOCK]：表示事件描述的开始以及是何种事件。在此例中，它表示阻止了连接。</li>
<li>IN：如果它包含一个值，那么代表该事件是传入事件</li>
<li>OUT：如果它包含一个值，那么代表事件是传出事件</li>
<li>MAC：目的地和源 MAC 地址的组合</li>
<li>SRC：IP数据包的源IP</li>
<li>DST：目的地的IP</li>
<li>LEN：数据包长度</li>
<li>TTL：数据 TTL，或称为time to live。</li>
<li>PROTO：数据包的协议</li>
<li>SPT：数据包的源端口</li>
<li>DPT：目标端口</li>
<li>WINDOW：发送方可以接收的数据包的大小</li>
<li>SYN URGP：指示是否需要三次握手。 0 表示不需要。</li>
</ul>
<p>禁用防火墙日志：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo ufw logging off</span></span><br></pre></td></tr></table></figure>

<h1 id="允许连接"><a href="#允许连接" class="headerlink" title="允许连接"></a>允许连接</h1><p>默认情况下ufw的allow不加in允许连接是指允许入站连接，如果要指定允许出站，可以加上out，如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo ufw allow in port #允许port入站</span><br><span class="line">$ sudo ufw allow out port #允许port出站</span><br></pre></td></tr></table></figure>
<h2 id="允许指定端口的所有连接协议"><a href="#允许指定端口的所有连接协议" class="headerlink" title="允许指定端口的所有连接协议"></a>允许指定端口的所有连接协议</h2><p>通过刚才设置ssh的规则，可以知道直接allow就是允许连接<br>允许HTTP 80端口的所有连接：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo ufw allow http</span></span><br></pre></td></tr></table></figure>
<p>等价于：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo ufw allow 80</span></span><br></pre></td></tr></table></figure>
<p>同样可以允许https的连接：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo ufw allow https</span></span><br></pre></td></tr></table></figure>
<p>等价于：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo ufw allow 443</span></span><br></pre></td></tr></table></figure>
<h2 id="允许指定端口的指定协议连接"><a href="#允许指定端口的指定协议连接" class="headerlink" title="允许指定端口的指定协议连接"></a>允许指定端口的指定协议连接</h2><p>FTP默认端口为21，连接协议为tcp，那么可以这样：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo ufw allow ftp</span></span><br></pre></td></tr></table></figure>
<p>等价于：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo ufw allow 21/tcp</span></span><br></pre></td></tr></table></figure>

<h2 id="允许指定范围内的端口的指定协议的连接"><a href="#允许指定范围内的端口的指定协议的连接" class="headerlink" title="允许指定范围内的端口的指定协议的连接"></a>允许指定范围内的端口的指定协议的连接</h2><p>例如，X11的连接端口范围是6000-6007：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo ufw allow 6000:6007/tcp</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo ufw allow 6000:6007/udp</span></span><br></pre></td></tr></table></figure>

<h2 id="允许指定IP的连接"><a href="#允许指定IP的连接" class="headerlink" title="允许指定IP的连接"></a>允许指定IP的连接</h2><p>通过查看防火墙状态可以看出有个From：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo ufw status</span></span><br><span class="line">Status: active</span><br><span class="line"></span><br><span class="line">To                         Action      From</span><br><span class="line">--                         ------      ----</span><br><span class="line">22                         ALLOW       Anywhere                  </span><br><span class="line">21/tcp                     ALLOW       Anywhere                  </span><br><span class="line">22 (v6)                    ALLOW       Anywhere (v6)             </span><br><span class="line">21/tcp (v6)                ALLOW       Anywhere (v6)  </span><br></pre></td></tr></table></figure>
<p>默认情况是相应端口允许所有IP的连接，可以通过后跟from指定允许某IP的所有连接：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo ufw allow from 15.15.15.51</span></span><br></pre></td></tr></table></figure>
<p>允许15.15.15.51的所有入站连接，命令后面跟<code>to any port 22</code>允许端口22的所有连接：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo ufw allow from 15.15.15.51 to any port 22</span></span><br></pre></td></tr></table></figure>

<h2 id="允许子网的连接"><a href="#允许子网的连接" class="headerlink" title="允许子网的连接"></a>允许子网的连接</h2><p>如果要允许IP段<code>15.15.15.1</code>到<code>15.15.15.254</code>的所有连接：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo ufw allow from 15.15.15.0/24</span></span><br></pre></td></tr></table></figure>
<p>并指定连接端口：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo ufw allow from 15.15.15.0/24 to any port 22</span></span><br></pre></td></tr></table></figure>

<h2 id="指定允许通过某个网卡的连接"><a href="#指定允许通过某个网卡的连接" class="headerlink" title="指定允许通过某个网卡的连接"></a>指定允许通过某个网卡的连接</h2><p>通过命令中加入<code>allow in on</code>即可<br>首先查看系统中的所有网卡：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ip addr</span></span><br></pre></td></tr></table></figure>
<p>或者：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ifconfig</span></span><br></pre></td></tr></table></figure>
<p>假设这里允许eth0的80端口连接：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo ufw allow <span class="keyword">in</span> on eth0 to any port 80</span></span><br></pre></td></tr></table></figure>

<h2 id="允许出站连接"><a href="#允许出站连接" class="headerlink" title="允许出站连接"></a>允许出站连接</h2><p>允许相应端口的出站连接，直接allow后面跟out即可：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo ufw allow out 34</span></span><br></pre></td></tr></table></figure>

<h1 id="拒绝连接"><a href="#拒绝连接" class="headerlink" title="拒绝连接"></a>拒绝连接</h1><p>与允许连接一样，只需要将相应的allow换成<code>deny</code>即可，如拒绝http端口的所有连接：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo ufw deny http</span></span><br></pre></td></tr></table></figure>
<p>等价于：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo ufw deny 80</span></span><br></pre></td></tr></table></figure>

<p>拒绝指定ip的连接：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo ufw deny from 15.15.15.51</span></span><br></pre></td></tr></table></figure>

<h1 id="删除规则"><a href="#删除规则" class="headerlink" title="删除规则"></a>删除规则</h1><p>UFW有两种方式删除防火墙规则，既可以通过规则号删除，也可以通过实际规则删除，通过规则号删除更容易。</p>
<h2 id="通过规则号删除"><a href="#通过规则号删除" class="headerlink" title="通过规则号删除"></a>通过规则号删除</h2><p>首先查看所有规则的规则号：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo ufw status numbered</span></span><br><span class="line">Status: active</span><br><span class="line"></span><br><span class="line">     To                         Action      From</span><br><span class="line">     --                         ------      ----</span><br><span class="line">[ 1] 22                         ALLOW IN    Anywhere                  </span><br><span class="line">[ 2] 21/tcp                     ALLOW IN    Anywhere                  </span><br><span class="line">[ 3] 34                         ALLOW IN    Anywhere                  </span><br><span class="line">[ 4] 34                         ALLOW OUT   Anywhere                   (out)</span><br><span class="line">[ 5] 22                         ALLOW OUT   15.15.15.51                (out)</span><br><span class="line">[ 6] 22 (v6)                    ALLOW IN    Anywhere (v6)             </span><br><span class="line">[ 7] 21/tcp (v6)                ALLOW IN    Anywhere (v6)             </span><br><span class="line">[ 8] 34 (v6)                    ALLOW IN    Anywhere (v6)             </span><br><span class="line">[ 9] 34 (v6)                    ALLOW OUT   Anywhere (v6)              (out)</span><br></pre></td></tr></table></figure>
<p>然后直接delete即可，例如删除ftp(21)的连接规则：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo ufw delete 2</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo ufw delete 7</span></span><br></pre></td></tr></table></figure>
<p>因为即有ipv6，又有ipv4，所以需要删除2个</p>
<h2 id="通过规则删除"><a href="#通过规则删除" class="headerlink" title="通过规则删除"></a>通过规则删除</h2><p>删除<code>allow http</code>规则：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo ufw delete allow http</span></span><br></pre></td></tr></table></figure>
<p>等价于：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo ufw delete allow 80</span></span><br></pre></td></tr></table></figure>


<h1 id="重置防火墙规则"><a href="#重置防火墙规则" class="headerlink" title="重置防火墙规则"></a>重置防火墙规则</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo ufw reset</span><br></pre></td></tr></table></figure>
<p>该命令将禁用UFW，并且删除所有已经定义的规则，不过默认该命令会对已经设置的规则进行备份</p>
<h1 id="备份-还原规则"><a href="#备份-还原规则" class="headerlink" title="备份/还原规则"></a>备份/还原规则</h1><p>UFW的所有规则文件都在路径<code>/etc/ufw/</code>，其中<code>before.rules</code>规则为UFW在运行用户自定义的规则之前运行的规则，相应的<code>before6.rules</code>对应IPV6。<code>after.rules</code>为UFW启用用户自定义规则之后运行的规则。<code>user.rules</code>即为用户自定义的规则。<br><code>/etc/default/ufw</code>文件为UFW的配置文件。<br>所以可以通过直接备份这些配置文件的方式来备份防火墙规则，需要备份的文件有：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/etc/ufw/*.rules</span><br><span class="line">/lib/ufw/*.rules</span><br><span class="line">/etc/default/ufw  # 这个配置文件如果没有修改过，可以不备份</span><br></pre></td></tr></table></figure>
<p>修改配置文件之后通过以下命令重新加载配置文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo ufw reload</span></span><br></pre></td></tr></table></figure>

<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="批量禁止IP"><a href="#批量禁止IP" class="headerlink" title="批量禁止IP"></a>批量禁止IP</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="keyword">while</span> <span class="built_in">read</span> line; <span class="keyword">do</span> sudo ufw deny from <span class="variable">$line</span>; <span class="keyword">done</span> &lt; file.txt</span></span><br></pre></td></tr></table></figure>
<p>file.txt里面是一个需要禁止的IP列表</p>
<p>参考：<br>1.<a href="https://www.digitalocean.com/community/tutorials/how-to-set-up-a-firewall-with-ufw-on-ubuntu-16-04">How To Set Up a Firewall with UFW on Ubuntu</a><br>2.<a href="https://wiki.ubuntu.com/UncomplicatedFirewall">UncomplicatedFirewall</a><br>3.<a href="https://www.linode.com/docs/security/firewalls/configure-firewall-with-ufw">How to Configure a Firewall with UFW</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>UFW</tag>
        <tag>iptables</tag>
      </tags>
  </entry>
  <entry>
    <title>CMake简单教程</title>
    <url>/2016/12/23/cmake-tutorial/</url>
    <content><![CDATA[<p>依然是首先给出参考网站，感觉还是让看到的人，直接去看原作会更快，以免疏漏不是我所关注的重要内容：<br>CMake官网：<a href="https://cmake.org/">https://cmake.org/</a>，官网有个tutorial<br>另一个CMake Turorial：<a href="https://www.johnlamp.net/cmake-tutorial.html">https://www.johnlamp.net/cmake-tutorial.html</a><br>CMake by Example：<a href="http://mirkokiefer.com/blog/2013/03/cmake-by-example/">http://mirkokiefer.com/blog/2013/03/cmake-by-example/</a><br>CMake官方WIKI：<a href="https://cmake.org/Wiki/CMake">https://cmake.org/Wiki/CMake</a></p>
<p>首先要搞清楚出cmake是一个跨平台的项目管理工具，用来生成其他项目构建工具所需要的规则文件。例如gnu的make可以根据makefile文件中定义的规则来对C/C++项目进行编译、链接等（较多地用于c/c++项目），qmake可以根据pro文件中定义的规则对qt项目进行构建，而VS则可以根据VS的项目属性文件对其管理项目调用自身的编译器进行编译。那么这些编译文件就可以用cmake来生成，cmake可以根据CMakeLists.txt中定义的规则来生成相应的项目构建平台所需要的规则文件。以make来举例，make可以通过makefile中定义的规则调用c++编译器对项目进行编译并链接并生成可执行文件，相当于项目的编译等构建工作依然由各编译器来完成，而具体如何编译（例如使用的头文件在哪，链接的库去哪找等）则由make根据makefile中定义的规则来调用g++进行编译，而项目构建工具make所需要的makefile则由cmake来生成。makefile可以手动来写，但当项目非常大时，makefile可能会很复杂，此时就可以通过cmake根据MakeLists.txt来自动生成makefile。而假如该项目还要转移到win平台下，又需要使用VS来进行对该项目编译，则CMake可以根据MakeLists.txt来生成VS的项目属性文件（通常后缀是解决方案.suo、项目.vcxproj），然后即可使用VS直接打开解决方案文件</p>
<span id="more"></span>

<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>Windows直接官网下载后安装即可，记得添加到PATH，linux下安装包<code>cmake</code>即可，ubuntu下推荐一个包<code>cmake-curses-gui</code>，提示供一个curses接口，通过ccmake来调用，red hat系统cmake中就包含了ccmake。</p>
]]></content>
      <categories>
        <category>Notes</category>
      </categories>
      <tags>
        <tag>CMake</tag>
        <tag>make</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenCV学习小记</title>
    <url>/2016/12/06/opencv-study-notes/</url>
    <content><![CDATA[<p>本文不会像其他笔记那样详细讲解每一个步骤和问题，最近太忙，没有太多时间，突击学习一下，记录下遇到的一些问题，但依然会像其他笔记一样授之以渔。仅针对C++，OpenCV2，假如你没学习过官方提供详细支持的编程语言，例如C/C++/python，建议还是先学一门编程语言再来学习OpenCV吧。看到网上有教程竟然讲OpenCV时还讲起了C语言。<br>强烈推荐参考官方手册，官方的doc简直太棒了：<a href="http://opencv.org/documentation.html">http://opencv.org/documentation.html</a>，即能下载PDF，又能在线查看，还有详细的tutorial，以下多数问题的解决来源于查看官方的Reference Manual：<a href="http://docs.opencv.org/2.4/opencv2refman.pdf">http://docs.opencv.org/2.4/opencv2refman.pdf</a></p>
<span id="more"></span>

<h2 id="关于环境配置"><a href="#关于环境配置" class="headerlink" title="关于环境配置"></a>关于环境配置</h2><p>环境配置参见这里<a href="/2016/12/05/opencv-windows-env/" title="Windows下OpenCV与VS开发环境配置">Windows下OpenCV与VS开发环境配置</a></p>
<h2 id="一些入门常用函数"><a href="#一些入门常用函数" class="headerlink" title="一些入门常用函数"></a>一些入门常用函数</h2><p>2.图像操作及用户界面的几个函数原型及作用（highgui.hpp）：<br><strong>imread：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Mat <span class="title">imread</span><span class="params">(<span class="type">const</span> string&amp; filename, <span class="type">int</span> flags=<span class="number">1</span> )</span></span></span><br></pre></td></tr></table></figure>
<p>用于从文件filename读取图像并在内存中存储为Mat类型，flags用于指宝载入图像使用的色彩类型，如rgb、灰度等</p>
<p><strong>imshow：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">imshow</span><span class="params">(<span class="type">const</span> string&amp; winname, InputArray mat)</span></span></span><br></pre></td></tr></table></figure>
<p>在指定的窗口中显示图像mat，由winname指定窗口名称（即窗口标题），如果没有使用namedWindow创建窗口，则新建一个。InputArray类型是一个接口类，可以是Mat、Mat_<T>、Mat_&lt;T, m, n&gt;、vector<T>、vector&lt;vector<T>&gt;、vector<Mat>类型</p>
<p><strong>imwrite：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">imwrite</span><span class="params">(<span class="type">const</span> string&amp; filename, InputArray img, <span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; params=vector&lt;<span class="type">int</span>&gt;() )</span></span></span><br></pre></td></tr></table></figure>
<p>将图像img保存于指定的文件filname中，最后一个参数于用指定保存的图片格式，如jPEG、PNG等，当不指定最后一个参数时，函数会自动根据finlname中的文件后缀来确定存储格式</p>
<p><strong>createTrackbar：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">createTrackbar</span><span class="params">(<span class="type">const</span> string&amp; trackbarname, <span class="type">const</span> string&amp; winname, <span class="type">int</span>* value, <span class="type">int</span> count, TrackbarCallback onChange=<span class="number">0</span>, <span class="type">void</span>* userdata=<span class="number">0</span>)</span></span></span><br></pre></td></tr></table></figure>
<p>创建一个名为trackbarname的滑动条，并将其依附到指定的名为winname的窗口上。第三个参数value用于指定滑动指针的位置，需要是个整型指针变量（因为这个变量会在调节滑动条是发生变化，所以需要是个指针变量）；第四个参数count就用来指定滑动条最大可以滑动到多少，例如int value = 50,count = 100，则表示程序运行时滑动指针指向50的位置，最大可以滑动的位置是100。第五个可选参数onChange是一个形如<code>void Foo(int,void*);</code>的回调函数，即当滑动条的value变化时就调用该函数，该回调函数中的第一个参数是滑动条的当前值，即value，第二个参数与createTrackbar的最后一个参数userdata一样，可用于在不使用全局变量的情况下向回调函数传递数据来处理滑动条事件，暂时没有使用过。官方提供的一个使用示例在：opencv_source_code/samples/cpp/connected_components.cpp<br>注意：该函数创建的滑动条在窗口的顶端，水平放置，且无法改变，如果想改变它的位置，可以通过Qt的GUI来实现</p>
<p><strong>getTrackbarPos：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">getTrackbarPos</span><span class="params">(<span class="type">const</span> string&amp; trackbarname, <span class="type">const</span> string&amp; winname)</span></span></span><br></pre></td></tr></table></figure>
<p>返回滑动条的当前位置，其实也就是上面那个函数的value的当前值。</p>
<p><strong>moveWindow</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">moveWindow</span><span class="params">(<span class="type">const</span> string&amp; winname, <span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br></pre></td></tr></table></figure>
<p>移动名为winname的窗口</p>
<p><strong>destroyWindow：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">destroyWindow</span><span class="params">(<span class="type">const</span> string&amp; winname)</span></span></span><br></pre></td></tr></table></figure>
<p>销毁给定名称的窗体，释放内存</p>
<p><strong>destroyAllWindows：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">destroyAllWindows</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
<p>销毁所有打开着的HighGUI窗体，并释放内存<br>这两个函数在小程序时可以省略，因为程序结束运行时会自动被操作系统回收。但对于大程序，应该手动去释放不需要的窗体内存，特别是需要长期运行的程序，以防止内存泄露。</p>
<p><strong>waitKey：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">waitKey</span><span class="params">(<span class="type">int</span> delay=<span class="number">0</span>)</span></span></span><br></pre></td></tr></table></figure>
<p>等待按键按下，当延时delay毫秒后依然没有按下，停止等待。如果delay为0或负数时表示一直等待，直到键被按下并返回键值，如果delay时间结束时依然没有键被按下返回-1，该函数可用于函数窗口被关闭，类似C中的getchar()</p>
<p><strong>如何使imshow的显示窗口能够调整大小？</strong><br>对于高分辨率的图像，很容易显示太大，导致不方便查看，其实只需要在调用imshow之前使用namedWindow创建一个WINDOW_NORMAL的窗体即可，该窗体（官方称为placeholder）可用于放image和trackbar，如果已经有了一个同名的窗体，则该函数调用什么也不干。如果在调用imshow之前已经创建了一个同名window，则imshow会将显示内容置于该window中，如果没有，则imshow会默认创建一个参数为WINDOW_AUTOSIZE的窗体，结合上面的其他图像存取函数举例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/core/core.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/highgui/highgui.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"></span><br><span class="line">Mat img;</span><br><span class="line"></span><br><span class="line"><span class="comment">//滑动条的回调函数，用于根据滑动条的当前值修改窗口大小</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">resizeWin</span><span class="params">(<span class="type">int</span> size, <span class="type">void</span>*)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">resizeWindow</span>(<span class="string">&quot;rCat&quot;</span>, size, size);   <span class="comment">//将名为rCat的窗口的宽和高都调整为size的值</span></span><br><span class="line">    <span class="built_in">imshow</span>(<span class="string">&quot;rCat&quot;</span>, img);   <span class="comment">//在名为rCat的窗口中显示img中的图像</span></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">getTrackbarPos</span>(<span class="string">&quot;TrackBar&quot;</span>, <span class="string">&quot;rCat&quot;</span>) &lt;&lt; std::endl;   <span class="comment">//输出名为rCat窗口中的TrackBar滑动条指针所指向的当前值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> winSize = <span class="number">80</span>;  <span class="comment">//定义滑动条指针变量及初始值</span></span><br><span class="line">    img = <span class="built_in">imread</span>(<span class="string">&quot;F:\\cat.jpg&quot;</span>, <span class="number">2</span> | <span class="number">4</span>);  <span class="comment">//cat.jpg是一张高清图像</span></span><br><span class="line">    <span class="keyword">if</span>(img.<span class="built_in">empty</span>())                      <span class="comment">//确保图像打开成功</span></span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt;  <span class="string">&quot;Could not open or find the image&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">namedWindow</span>(<span class="string">&quot;Cat&quot;</span>, WINDOW_NORMAL);  <span class="comment">//创建一个名为Cat的窗体，窗口模式设置为NORMAL</span></span><br><span class="line">    <span class="built_in">imshow</span>(<span class="string">&quot;Cat&quot;</span>, img); <span class="comment">//已经有了名为Cat的窗体，imshow将直接在其中显示img的内容，且是普通窗体，所以imshow显示的内容可以通过鼠标调整大小</span></span><br><span class="line"> </span><br><span class="line">    <span class="built_in">namedWindow</span>(<span class="string">&quot;rCat&quot;</span>, WINDOW_NORMAL);  <span class="comment">//再创建一个名为rCat的窗体，窗口模式设置为NORMAL</span></span><br><span class="line">    <span class="built_in">createTrackbar</span>(<span class="string">&quot;TrackBar&quot;</span>, <span class="string">&quot;rCat&quot;</span>, &amp;winSize, <span class="number">1024</span>, resizeWin);  <span class="comment">//在名为rCat的窗口上创建一个名为TrackBar的滑动条，滑动条的初始大小为</span></span><br><span class="line">                                                                    <span class="comment">//为winSize的初始值80，最大值为1024，当winSize改变时，调用回调函数resizeWin</span></span><br><span class="line">    <span class="built_in">resizeWin</span>(winSize, <span class="number">0</span>);  <span class="comment">//回调函数显示结果，如果没有这句，将在程序刚启动时窗口不显示任何内容，但调节滑动条之后就会有了，因为回调函数中设置了显示函数</span></span><br><span class="line">    <span class="built_in">imwrite</span>(<span class="string">&quot;hcat-copy.png&quot;</span>, img);  <span class="comment">//将img中的图像内容写入文件hcat-copy.png，存储格式为png</span></span><br><span class="line">    <span class="built_in">waitKey</span>(<span class="number">0</span>);  <span class="comment">//等待键被按下</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>播放一个视频</strong><br>播放视频其实就是读取视频中一帧帧的图像，并将其显示出来，同时将处理后的视频保存，直接看代码吧：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">cv::VideoCapture <span class="title">vcap</span><span class="params">(<span class="string">&quot;F:\\bunny.avi&quot;</span>)</span></span>;  <span class="comment">//创建一个视频对象，可以来源于视频、图像序列或像机</span></span><br><span class="line"><span class="comment">//    cv::VideoCapture vcap(0);  //表示从默认相机创建一个视频对象vcap</span></span><br><span class="line">    <span class="keyword">if</span> (!vcap.<span class="built_in">isOpened</span>()) &#123; <span class="comment">//确定文件正常打开</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Video or camera open failed!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">        cv::VideoWriter outputVideo;</span><br><span class="line">        <span class="type">int</span> ex = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(vcap.<span class="built_in">get</span>(CV_CAP_PROP_FOURCC));     <span class="comment">// Get Codec Type- Int form</span></span><br><span class="line">        cv::Size S = cv::<span class="built_in">Size</span>((<span class="type">int</span>)vcap.<span class="built_in">get</span>(CV_CAP_PROP_FRAME_WIDTH),    <span class="comment">// Acquire input size</span></span><br><span class="line">        (<span class="type">int</span>)vcap.<span class="built_in">get</span>(CV_CAP_PROP_FRAME_HEIGHT));</span><br><span class="line">        outputVideo.<span class="built_in">open</span>(<span class="string">&quot;F:\\bunny_edge.avi&quot;</span>, ex, vcap.<span class="built_in">get</span>(CV_CAP_PROP_FPS), S, <span class="literal">false</span>);</span><br><span class="line">    cv::Mat edges;  <span class="comment">//创建一个Mat对象存储图像</span></span><br><span class="line">    cv::<span class="built_in">namedWindow</span>(<span class="string">&quot;Edges&quot;</span>, <span class="number">1</span>);  <span class="comment">//创建一个名为Edges的窗口</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        cv::Mat frame;</span><br><span class="line">        vcap &gt;&gt; frame;   <span class="comment">//将视频中的一帧读入到frame中</span></span><br><span class="line">        cv::<span class="built_in">cvtColor</span>(frame, edges, CV_BGR2GRAY);  <span class="comment">//调用灰度化函数处理图像，并存储到edges中</span></span><br><span class="line">        cv::<span class="built_in">GaussianBlur</span>(edges, edges, cv::<span class="built_in">Size</span>(<span class="number">7</span>, <span class="number">7</span>), <span class="number">1.5</span>, <span class="number">1.5</span>);  <span class="comment">//调用高斯模糊函数处理edges中的图像信息</span></span><br><span class="line">        cv::<span class="built_in">Canny</span>(edges, edges, <span class="number">0</span>, <span class="number">30</span>, <span class="number">3</span>);  <span class="comment">//调用边缘检测函数来处理edges中图像</span></span><br><span class="line">                cv::<span class="built_in">imshow</span>(<span class="string">&quot;Edges&quot;</span>, edges);  <span class="comment">//将edges中的图像显示到名为Edges的窗口中</span></span><br><span class="line">                outputVideo &lt;&lt; edges;</span><br><span class="line">        <span class="keyword">if</span> (cv::<span class="built_in">waitKey</span>(<span class="number">30</span>) &gt;= <span class="number">0</span>) <span class="keyword">break</span>;  <span class="comment">//延迟30秒后进行一下一帧图像的处理</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>D:\opencv\sources\samples</code>目录下有很多好玩的实例</p>
<h2 id="核心模块"><a href="#核心模块" class="headerlink" title="核心模块"></a>核心模块</h2><p>库的使用，基本的像素操作方法</p>
<h3 id="常用的数据类型和函数"><a href="#常用的数据类型和函数" class="headerlink" title="常用的数据类型和函数"></a>常用的数据类型和函数</h3><p>OpenCV中的所有数据类型可以在这里查看：<a href="http://docs.opencv.org/2.4.13/modules/core/doc/core.html">http://docs.opencv.org/2.4.13/modules/core/doc/core.html</a><br>1.Mat是Opencv中非常重要的数据类型，它是个很复杂的类型，即可以用于操作二维的图像方阵，又可以作为普通的矩阵类来使用，并且具有自动管理内存的功能，通过上面将视频数据写入到Mat类对象可以看出它应该是被重载了很多的操作符的。所以实际上可以通过一个VideoCapture对象对它进行<code>&gt;&gt;</code>操作，也可以通过cout对它<code>&lt;&lt;</code>操作。<br>Mat类共有24个构造函数，可见其功能的丰富程度，下面几个常用的构造方式：<br><strong>直接构造</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Mat <span class="title">img</span><span class="params">(<span class="number">300</span>, <span class="number">400</span>, CV_8UC3, Scalar(<span class="number">122</span>, <span class="number">33</span>, <span class="number">104</span>))</span></span>;  <span class="comment">//构造一个300行400列的Mat对象</span></span><br><span class="line">    <span class="built_in">imshow</span>(<span class="string">&quot;Picture&quot;</span>, img);</span><br><span class="line"></span><br><span class="line">    <span class="function">Mat <span class="title">img1</span><span class="params">(<span class="number">3</span>, <span class="number">4</span>, CV_8UC3, Scalar(<span class="number">122</span>, <span class="number">33</span>, <span class="number">104</span>))</span></span>;</span><br><span class="line">    std::cout &lt;&lt; img1 &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">destroyWindow</span>(<span class="string">&quot;Picture&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Mat img1(3, 4, CV_8UC3, Scalar(122, 33, 104));</code><br>表示构造一个名为img1的二维矩阵对象，该对象由3行4列的Scalar对象构成，可以把这里的Scalar当成是一个vector，其中的三个值分别对应BGR的三个值122,33,104。这三个值构成的颜色刚好是VS2013的LOG颜色。上面第三个参数CV_8UC3是定义好的宏，用于指定RGB的存储属性，意义分别是CV_[The number of bits per item][Signed or Unsigned][Type Prefix]C[The channel number]，例子中的意思就是每个像素点使用3通道的8位无符号数字表示（由后面的Scalar来填充）。所以上面的程序运行会输出一个高300像素，宽400像素VS2013的LOGO颜色的纯色框。并且会在命令行中输出3行4列的122,33,104：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[122, 33, 104, 122, 33, 104, 122, 33, 104, 122, 33, 104;</span><br><span class="line">  122, 33, 104, 122, 33, 104, 122, 33, 104, 122, 33, 104;</span><br><span class="line">  122, 33, 104, 122, 33, 104, 122, 33, 104, 122, 33, 104]</span><br></pre></td></tr></table></figure>

<p>虽然Mat也可以构造为多维的矩阵，但由于imshow和<code>&lt;&lt;</code>运算符只能用于2维或2维以下的Mat对象，所以这里不做解释，可以自行查看这里<a href="http://docs.opencv.org/3.0-last-rst/doc/tutorials/core/mat_the_basic_image_container/mat_the_basic_image_container.html#matthebasicimagecontainer">http://docs.opencv.org/3.0-last-rst/doc/tutorials/core/mat_the_basic_image_container/mat_the_basic_image_container.html#matthebasicimagecontainer</a></p>
<p>2.通过randu可以使用随机颜色填充Mat对象：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Mat img = <span class="built_in">Mat</span>(<span class="number">300</span>, <span class="number">400</span>, CV_8UC3);</span><br><span class="line"><span class="built_in">randu</span>(img, Scalar::<span class="built_in">all</span>(<span class="number">0</span>), Scalar::<span class="built_in">all</span>(<span class="number">255</span>));  <span class="comment">//表示填充值从0到255</span></span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;Picture&quot;</span>, img);</span><br></pre></td></tr></table></figure>

<p><strong>通过create函数构造</strong><br>3.可以通过调用create(nrows, ncols, type)来进行构造指定size和类型的Mat对象：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Mat <span class="title">M</span><span class="params">(<span class="number">7</span>, <span class="number">7</span>, CV_32FC2, Scalar(<span class="number">1</span>, <span class="number">3</span>))</span></span>;  <span class="comment">//创建一个7x7的矩阵</span></span><br><span class="line">M.<span class="built_in">create</span>(<span class="number">100</span>, <span class="number">50</span>, <span class="built_in">CV8UC</span>(<span class="number">15</span>));  <span class="comment">//改变其大小和类型，源矩阵会被释放</span></span><br><span class="line">Mat N;</span><br><span class="line">N.<span class="built_in">create</span>(M.<span class="built_in">size</span>(), M.<span class="built_in">type</span>());  <span class="comment">//将N改变为与M一样的大小和类型</span></span><br></pre></td></tr></table></figure>

<p><strong>创建一个多维矩阵</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建一个100x100x100的8-bit矩阵</span></span><br><span class="line"><span class="type">int</span> sz[] = &#123;<span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>&#125;; </span><br><span class="line"><span class="function">Mat <span class="title">cube</span><span class="params">(<span class="number">3</span>, sz, CV_8U, Scalar::all(<span class="number">0</span>))</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>通过copy函数从一个Mat对象的指定行或列构造另一个对象</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// add the 5-th row, multiplied by 3 to the 3rd row</span></span><br><span class="line">M.<span class="built_in">row</span>(<span class="number">3</span>) = M.<span class="built_in">row</span>(<span class="number">3</span>) + M.<span class="built_in">row</span>(<span class="number">5</span>)*<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// now copy the 7-th column to the 1-st column</span></span><br><span class="line"><span class="comment">// M.col(1) = M.col(7); // this will not work</span></span><br><span class="line">Mat M1 = M.<span class="built_in">col</span>(<span class="number">1</span>);</span><br><span class="line">M.<span class="built_in">col</span>(<span class="number">7</span>).<span class="built_in">copyTo</span>(M1);</span><br><span class="line"></span><br><span class="line"><span class="comment">// create a new 320x240 image</span></span><br><span class="line"><span class="function">Mat <span class="title">img</span><span class="params">(Size(<span class="number">320</span>,<span class="number">240</span>),CV_8UC3)</span></span>;</span><br><span class="line"><span class="comment">// select a ROI</span></span><br><span class="line"><span class="function">Mat <span class="title">roi</span><span class="params">(img, Rect(<span class="number">10</span>,<span class="number">10</span>,<span class="number">100</span>,<span class="number">100</span>))</span></span>;</span><br><span class="line"><span class="comment">// fill the ROI with (0,255,0) (which is green in RGB space);</span></span><br><span class="line"><span class="comment">// the original 320x240 image will be modified</span></span><br><span class="line">roi = <span class="built_in">Scalar</span>(<span class="number">0</span>,<span class="number">255</span>,<span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p><strong>通过数组创建</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//两种情况</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">process_video_frame</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span>* pixels,</span></span></span><br><span class="line"><span class="params"><span class="function">                         <span class="type">int</span> width, <span class="type">int</span> height, <span class="type">int</span> step)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Mat <span class="title">img</span><span class="params">(height, width, CV_8UC3, pixels, step)</span></span>;</span><br><span class="line">    <span class="built_in">GaussianBlur</span>(img, img, <span class="built_in">Size</span>(<span class="number">7</span>,<span class="number">7</span>), <span class="number">1.5</span>, <span class="number">1.5</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//另一种情况</span></span><br><span class="line"><span class="type">double</span> m[<span class="number">3</span>][<span class="number">3</span>] = &#123;&#123;a, b, c&#125;, &#123;d, e, f&#125;, &#123;g, h, i&#125;&#125;;</span><br><span class="line">Mat M = <span class="built_in">Mat</span>(<span class="number">3</span>, <span class="number">3</span>, CV_64F, m).<span class="built_in">inv</span>();</span><br></pre></td></tr></table></figure>

<p><strong>通过一个逗号分隔的初始化列表创建</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// create a 3x3 double-precision identity matrix</span></span><br><span class="line">Mat M = (<span class="built_in">Mat_</span>&lt;<span class="type">double</span>&gt;(<span class="number">3</span>,<span class="number">3</span>) &lt;&lt; <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, </span><br><span class="line">                  <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, </span><br><span class="line">                  <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p><strong>MATLAB风格的zeros(),ones(), eye()函数来初始化</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// create a double-precision identity martix and add it to M.</span></span><br><span class="line">M += Mat::<span class="built_in">eye</span>(M.rows, M.cols, CV_64F);</span><br></pre></td></tr></table></figure>

<p>3.opencv内建了多种Mat对象的输出格式，还内建了其他一些支持<code>&lt;&lt;</code>输出的数据类型，官方下面这个例子很全，可以运行查看效果：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*  For description look into the help() function. */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;opencv2/core/core.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">help</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout</span><br><span class="line">        &lt;&lt; <span class="string">&quot;\n--------------------------------------------------------------------------&quot;</span> &lt;&lt; std::endl</span><br><span class="line">        &lt;&lt; <span class="string">&quot;This program shows how to create matrices(cv::Mat) in OpenCV and its serial&quot;</span></span><br><span class="line">        &lt;&lt; <span class="string">&quot; out capabilities&quot;</span> &lt;&lt; std::endl</span><br><span class="line">        &lt;&lt; <span class="string">&quot;That is, cv::Mat M(...); M.create and std::cout &lt;&lt; M. &quot;</span> &lt;&lt; std::endl</span><br><span class="line">        &lt;&lt; <span class="string">&quot;Shows how output can be formated to OpenCV, python, numpy, csv and C styles.&quot;</span> &lt;&lt; std::endl</span><br><span class="line">        &lt;&lt; <span class="string">&quot;Usage:&quot;</span> &lt;&lt; std::endl</span><br><span class="line">        &lt;&lt; <span class="string">&quot;./cvout_sample&quot;</span> &lt;&lt; std::endl</span><br><span class="line">        &lt;&lt; <span class="string">&quot;--------------------------------------------------------------------------&quot;</span> &lt;&lt; std::endl</span><br><span class="line">        &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span>, <span class="type">char</span>**)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">help</span>();</span><br><span class="line">    <span class="comment">// create by using the constructor</span></span><br><span class="line">    <span class="function">Mat <span class="title">M</span><span class="params">(<span class="number">2</span>, <span class="number">2</span>, CV_8UC3, Scalar(<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>))</span></span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;M = &quot;</span> &lt;&lt; std::endl &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; M &lt;&lt; std::endl &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// create by using the create function()</span></span><br><span class="line">    M.<span class="built_in">create</span>(<span class="number">4</span>, <span class="number">4</span>, <span class="built_in">CV_8UC</span>(<span class="number">2</span>));</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;M = &quot;</span> &lt;&lt; std::endl &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; M &lt;&lt; std::endl &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// create multidimensional matrices</span></span><br><span class="line">    <span class="type">int</span> sz[<span class="number">3</span>] = &#123; <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span> &#125;;</span><br><span class="line">    <span class="function">Mat <span class="title">L</span><span class="params">(<span class="number">3</span>, sz, CV_8UC(<span class="number">1</span>), Scalar::all(<span class="number">0</span>))</span></span>;</span><br><span class="line">    <span class="comment">// Cannot print via operator &lt;&lt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create using MATLAB style eye, ones or zero matrix</span></span><br><span class="line">    Mat E = Mat::<span class="built_in">eye</span>(<span class="number">4</span>, <span class="number">4</span>, CV_64F);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;E = &quot;</span> &lt;&lt; std::endl &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; E &lt;&lt; std::endl &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    Mat O = Mat::<span class="built_in">ones</span>(<span class="number">2</span>, <span class="number">2</span>, CV_32F);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;O = &quot;</span> &lt;&lt; std::endl &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; O &lt;&lt; std::endl &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    Mat Z = Mat::<span class="built_in">zeros</span>(<span class="number">3</span>, <span class="number">3</span>, CV_8UC1);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Z = &quot;</span> &lt;&lt; std::endl &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; Z &lt;&lt; std::endl &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// create a 3x3 double-precision identity matrix</span></span><br><span class="line">    Mat C = (<span class="built_in">Mat_</span>&lt;<span class="type">double</span>&gt;(<span class="number">3</span>, <span class="number">3</span>) &lt;&lt; <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">5</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;C = &quot;</span> &lt;&lt; std::endl &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; C &lt;&lt; std::endl &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    Mat RowClone = C.<span class="built_in">row</span>(<span class="number">1</span>).<span class="built_in">clone</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;RowClone = &quot;</span> &lt;&lt; std::endl &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; RowClone &lt;&lt; std::endl &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Fill a matrix with random values</span></span><br><span class="line">    Mat R = <span class="built_in">Mat</span>(<span class="number">3</span>, <span class="number">2</span>, CV_8UC3);</span><br><span class="line">    <span class="built_in">randu</span>(R, Scalar::<span class="built_in">all</span>(<span class="number">0</span>), Scalar::<span class="built_in">all</span>(<span class="number">255</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Demonstrate the output formating options</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;R (default) = &quot;</span> &lt;&lt; std::endl &lt;&lt; R &lt;&lt; std::endl &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;R (python)  = &quot;</span> &lt;&lt; std::endl &lt;&lt; format(R, <span class="string">&quot;python&quot;</span>) &lt;&lt; std::endl &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;R (numpy)   = &quot;</span> &lt;&lt; std::endl &lt;&lt; format(R, <span class="string">&quot;numpy&quot;</span>) &lt;&lt; std::endl &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;R (csv)     = &quot;</span> &lt;&lt; std::endl &lt;&lt; format(R, <span class="string">&quot;csv&quot;</span>) &lt;&lt; std::endl &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;R (c)       = &quot;</span> &lt;&lt; std::endl &lt;&lt; format(R, <span class="string">&quot;c&quot;</span>) &lt;&lt; std::endl &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="function">Point2f <span class="title">P</span><span class="params">(<span class="number">5</span>, <span class="number">1</span>)</span></span>;  <span class="comment">//2维点，每一维度由float类型表示</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Point (2D) = &quot;</span> &lt;&lt; P &lt;&lt; std::endl &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="function">Point3f <span class="title">P3f</span><span class="params">(<span class="number">2</span>, <span class="number">6</span>, <span class="number">7</span>)</span></span>;  <span class="comment">//3维点</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Point (3D) = &quot;</span> &lt;&lt; P3f &lt;&lt; std::endl &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">float</span>&gt; v;</span><br><span class="line">    v.<span class="built_in">push_back</span>((<span class="type">float</span>)CV_PI);   v.<span class="built_in">push_back</span>(<span class="number">2</span>);    v.<span class="built_in">push_back</span>(<span class="number">3.01f</span>);</span><br><span class="line">  <span class="comment">//下面使用一个包含3个元素的vector构造Mat对象并输出</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Vector of floats via Mat = &quot;</span> &lt;&lt; <span class="built_in">Mat</span>(v) &lt;&lt; std::endl &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//输出以二维点为元素的vector</span></span><br><span class="line">    <span class="function">vector&lt;Point2f&gt; <span class="title">vPoints</span><span class="params">(<span class="number">20</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; vPoints.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        vPoints[i] = <span class="built_in">Point2f</span>((<span class="type">float</span>)(i * <span class="number">5</span>), (<span class="type">float</span>)(i % <span class="number">7</span>));</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;A vector of 2D Points = &quot;</span> &lt;&lt; vPoints &lt;&lt; std::endl &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4.Point类用于表示点，<code>Point_&lt;int&gt;</code>、<code>Point2i</code>、<code>Point</code>三个一样都表示以int为基础元素类型的点，而<code>Point_&lt;float&gt;</code>和<code>Point2f</code>表示以float为基础数据类型的二维上的点：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Point <span class="title">p</span><span class="params">(<span class="number">3</span>, <span class="number">4</span>)</span></span>;</span><br><span class="line"><span class="function">Point2f <span class="title">pf</span><span class="params">(<span class="number">3.14</span>, <span class="number">4.13</span>)</span></span>;</span><br><span class="line">p.x = <span class="number">5</span>;</span><br><span class="line">p.y = <span class="number">6</span>;</span><br></pre></td></tr></table></figure>

<p>5.Scalar类可用于表示颜色，它是一个含有4个元素的vector，当用于表示RGB时最后一个元素可以省略，RGB在Scalar中的顺序实际是BGR，即三个元素分量分别对应蓝、绿、红。与.NET中的颜色表示一样。上面的例子中已经使用过了</p>
<p>6.尺寸类Size，有2个参数分别可用于表示二维矩阵的宽、高尺寸，同样具有Size2d，表示以double为基础数据类型，感觉跟Point很像，源码定义也确实在一起。：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Size <span class="title">si</span><span class="params">(<span class="number">3</span>, <span class="number">4</span>)</span></span>;</span><br><span class="line"><span class="function">Size2d <span class="title">sd</span><span class="params">(<span class="number">3.14</span>, <span class="number">4.13</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p>7.矩形类Rect，Rect类有4个成员变量用于表示一个矩形的起点坐标(x, y)和尺寸(width, height)，还包括了一些很有用的成员函数，如rec.size()返回Size、area()返回面积、contains(Point)判断点是否在矩形内、inside(Rect)判断另一个矩形是否在该矩形内、tl()返回左上角点坐标、br()返回右下角点坐标。<br>还被重载了一些非常有用的操作符：</p>
<ul>
<li>rect = rect + point  //平移矩形</li>
<li>rect = rect - point</li>
<li>rect = rect + size  //缩放矩形</li>
<li>rect = rect - size</li>
<li>rect += point, rect -= point, rect += size, rect -= size (简化版操作符)</li>
<li>rect = rect1 &amp; rect2 求2个矩形的交集</li>
<li>rect = rect1 | rect2 返回包含两个矩形的最小矩形</li>
<li>rect &amp;= rect1, rect |= rect1  //简化版操作符</li>
<li>rect == rect1, rect != rect1 比较两个矩形</li>
</ul>
<p>8.颜色空间转换函数cvtColor()，前面已经用过它来转RGB到灰度图。它还可以实现HSV、HSI等色彩模式的转换，函数原型为：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">cvtColor</span><span class="params">(InputArray src, OutputArray dst, <span class="type">int</span> code, <span class="type">int</span> dstCn=<span class="number">0</span>)</span></span></span><br></pre></td></tr></table></figure>
<p>第三个参数是颜色空间转换标识符、第四个参数为目标图像的通道数，0表示取源图像的通道数。</p>
<h3 id="图像表示"><a href="#图像表示" class="headerlink" title="图像表示"></a>图像表示</h3><p>1.opencv中的Mat图像以二维矩阵的形式存储，为了效率，有时候会将整个图像在内存中以连续的一行存储，可以通过Mat的成员函数isContinuous()为判断是否为连接存储，如果是，则所有数据在内存中将只以一行的形式存储。<br>内存中像素在每行中的存储与通道数相关，例如如果是3通道8位无符号，则每个像素应由3个8位无符号组成，即每行中的数字列数实际应该为图像像素列数乘以3。<br>Mat的一些成员变量或函数：</p>
<ul>
<li>mat.rows 获取总行数，即图片以像素为单位的高度</li>
<li>mat.cols 获取总列数，即图片以像素为单位的宽度</li>
<li>mat.channels() 获取图像的通道数</li>
<li>mat.data 获取图像矩阵的第一行且为第一列的指针，如果返回为空，则表示输入的图像有问题，可以用来判断输入图像是否生效</li>
<li>mat.ptr<uchar>(i) 获取图像第i行的uchar类型的元素指针</li>
<li>mat.clone()  返回对象副本</li>
</ul>
<p>Mat类实现由两部分数据组成：矩阵头（包含矩阵尺寸、存储方法、存储地址等信息）和一个指向存储所有像素值的矩阵的指针。Mat的拷贝构造函数只是拷贝Mat对象的信息头和矩阵指针，而不复制矩阵本身，因为矩阵本身存储的数量量太大。当需要Mat副本时，应该使得cone函数获得副本。</p>
<p><strong>2.缩减像素数</strong><br>图像当以8位来表示一个单通道的像素点时，可以有2^8=256种色彩值，为了提高处理效率，实际上不需要那么丰富的色彩。此时可以将图像映射为较少色彩值的图像，一般的映射方法为，如果以10为一个颜色值步长的话，可以将0-9全部用0来表示，10-19用10来表示，20-29用20来表示，依次类推。这个步长越大，图像中的颜色值将越少。<br>可以利用除法的自动截余特性来方便的实现，例如原的来颜色值为old，新值<code>new = (old / step ) * step</code>，step为颜色值的跨度步长。然后遍历所有像素，全部这样转换一遍就获得了缩减之后的图像，转换后由于色彩较少，会有点水彩画的感觉。<br>但为了提高效率，由于8位一共也就256个值，可以提前建个表，然后当需要转换时从这个表里面读即可，例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> step = <span class="number">10</span>;</span><br><span class="line">uchar table[<span class="number">256</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">256</span>; ++i)</span><br><span class="line">  table[i] = (i / step) * step;</span><br></pre></td></tr></table></figure>
<p>这样table里面将是一个缩减后的表，1-9的位置都是0，10-19的位置都是1，依次。。。<br>当我有个数字26想知道转换后的值是多少时，直接读table[26]的值即可，这样就不用所有图像的每个像素都要进行一次计算了。</p>
<p>而opencv中提供了一个名为LUT的函数，可以直接根据表来实现将一个Mat对象转换为缩减后的Mat对象的功能<br>LUT的函数原型为：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">cv::LUT</span><span class="params">( cv::InputArray src, cv::InputArray lut, cv::OutputArray dst)</span></span>;</span><br></pre></td></tr></table></figure>
<p>下面分别使用普通方式和LUT方式实现图像缩减，推荐使用LUT函数，效率更高</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">scanImageAndReduce</span><span class="params">(Mat &amp;src, uchar *tab)</span></span>;  <span class="comment">//手动进行缩减</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Mat img = <span class="built_in">imread</span>(<span class="string">&quot;F:\\cat.jpg&quot;</span>);</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> divideWidth = <span class="number">60</span>;  <span class="comment">//设定缩减位宽</span></span><br><span class="line">    uchar table[<span class="number">256</span>];  <span class="comment">//用于创建一个缩减后的表，以后的颜色取值可以直接从这个表里面取</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">256</span>; ++i) &#123;</span><br><span class="line">        table[i] = (uchar)divideWidth * (i / divideWidth);  <span class="comment">//利用除法的截余特性，即(61/60)*60=1，而(59/60)*60=0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Mat img_reduce;  <span class="comment">//用于存放缩减后的图像</span></span><br><span class="line">    <span class="function">Mat <span class="title">lookUpTable</span><span class="params">(<span class="number">1</span>, <span class="number">256</span>, CV_8U)</span></span>;  <span class="comment">//创建一个1行，256列的Mat对象，其中每个像素用1个通道的8位无符号类型表示</span></span><br><span class="line"></span><br><span class="line">    uchar *p = lookUpTable.<span class="built_in">ptr</span>();   <span class="comment">//将原来的table复制到lookUpTable中</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">256</span>; ++i)</span><br><span class="line">        p[i] = table[i];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">LUT</span>(img, lookUpTable, img_reduce);  <span class="comment">//LUT函数用于将源图像img，按表lookUpTable转换为缩减后的图像img_reduce</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">imshow</span>(<span class="string">&quot;Original image&quot;</span>, img);</span><br><span class="line">    <span class="built_in">imshow</span>(<span class="string">&quot;Reduced image by LUT&quot;</span>, img_reduce);  <span class="comment">//显示用LUT缩减后的图像</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//LUT函数实现的功能与如下函数类似</span></span><br><span class="line">    Mat img_reduce2 = img.<span class="built_in">clone</span>();  <span class="comment">//复制源图像</span></span><br><span class="line">    <span class="built_in">scanImageAndReduce</span>(img_reduce2, table);</span><br><span class="line">    <span class="built_in">imshow</span>(<span class="string">&quot;Reduced image by manual&quot;</span>, img_reduce2);  <span class="comment">//显示手动缩减后的图像</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">scanImageAndReduce</span><span class="params">(Mat &amp;src, uchar *tab)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> channel = src.<span class="built_in">channels</span>();  <span class="comment">//获取源图像的通道数</span></span><br><span class="line">    <span class="type">int</span> nRow = src.rows;  <span class="comment">//获取源图像的行数和列数，即图像的实际像素高和宽</span></span><br><span class="line">    <span class="type">int</span> nCol = src.cols * channel;  <span class="comment">//通道数乘以图像的列数即为矩阵中每行的总元素数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (src.<span class="built_in">isContinuous</span>()) &#123;   <span class="comment">//判断图像是否为连续存储的，即所有元素是否都在一行上，为遍历估准备</span></span><br><span class="line">        nCol *= nRow;</span><br><span class="line">        nRow = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    uchar *p;  //用于存放从Mat对象中获取的行指针</span></span><br><span class="line"><span class="comment">    for (int i = 0; i &lt; nRow; ++i) &#123;</span></span><br><span class="line"><span class="comment">        p = src.ptr&lt;uchar&gt;(i);</span></span><br><span class="line"><span class="comment">        for (int j = 0; j &lt; nCol; ++j)   //遍历各列数值，并将其替换为tab表中指定的值</span></span><br><span class="line"><span class="comment">            p[j] = tab[p[j]];</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//或者直接使用Mat对象的data，data会返回指向矩阵的第一行、第一列的指针。</span></span><br><span class="line">    <span class="comment">//如果该指针为空，则表示输入对象无效</span></span><br><span class="line">    uchar *p2 = src.data;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nCol * nRow; ++i)</span><br><span class="line">        *p2++ = tab[*p2];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>3.统计时间的两个函数，当然C++自带的也可以，举例说明：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> t = <span class="built_in">getTickCount</span>();  <span class="comment">//获取当前CPU走过的时钟周期数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// some method</span></span><br><span class="line"></span><br><span class="line"><span class="type">double</span> time0 = ((<span class="type">double</span>)<span class="built_in">getTickCount</span>() - t) / <span class="built_in">getTickFrequency</span>();  <span class="comment">//两个时间周期数之差再除以一秒钟CPU所走的时钟周期数，得到时差</span></span><br><span class="line">std::cout &lt;&lt; time0 * <span class="number">1000</span> &lt;&lt; <span class="string">&quot; ms&quot;</span> &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>

<p><strong>根据每个像素的邻居像素值来修改当前像素实现锐化</strong><br>原理如下图：<br><img data-src="mask-filter2D.png" alt=""></p>
<p>官方示例代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/core/core.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/highgui/highgui.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/imgproc/imgproc.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"></span><br><span class="line"><span class="comment">//手动增加掩膜的锐化函数，其实就是将图像中的每一个像素根据他的邻居像素值来进行计算，从而得到一个新的像素</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Sharpen</span><span class="params">(<span class="type">const</span> Mat&amp; myImage, Mat&amp; Result)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* filename = <span class="string">&quot;F:\\cat.jpg&quot;</span>;</span><br><span class="line"></span><br><span class="line">    Mat I, J, K;  <span class="comment">//创建三个Mat对象，I用于存储源图像，J用于存储手动处理的图像，K存储通过内置函数filter2D处理的图像</span></span><br><span class="line"></span><br><span class="line">    I = <span class="built_in">imread</span>(filename);</span><br><span class="line">    <span class="keyword">if</span> (!I.data) &#123;  <span class="comment">//确保图像载入成功</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Error load image&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">namedWindow</span>(<span class="string">&quot;Input&quot;</span>, WINDOW_AUTOSIZE);</span><br><span class="line">    <span class="built_in">namedWindow</span>(<span class="string">&quot;Output by Sharpen&quot;</span>, WINDOW_AUTOSIZE);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">imshow</span>(<span class="string">&quot;Input&quot;</span>, I);</span><br><span class="line">    <span class="type">double</span> t = (<span class="type">double</span>)<span class="built_in">getTickCount</span>();  <span class="comment">//通过2次计时来看看手动写的函数跟使用内置的filter2D哪个速度更快</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">Sharpen</span>(I, J);</span><br><span class="line"></span><br><span class="line">    t = ((<span class="type">double</span>)<span class="built_in">getTickCount</span>() - t) / <span class="built_in">getTickFrequency</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Hand written function times passed in seconds: &quot;</span> &lt;&lt; t &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">imshow</span>(<span class="string">&quot;Output by Sharpen&quot;</span>, J);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过Mat_构造函数来从一个逗号分隔的数字创建一个3x3的Mat对象</span></span><br><span class="line">    Mat kern = (<span class="built_in">Mat_</span>&lt;<span class="type">char</span>&gt;(<span class="number">3</span>, <span class="number">3</span>) &lt;&lt; <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>,    </span><br><span class="line">                                    <span class="number">-1</span>, <span class="number">5</span>, <span class="number">-1</span>,</span><br><span class="line">                                    <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    t = (<span class="type">double</span>)<span class="built_in">getTickCount</span>();</span><br><span class="line">    <span class="built_in">filter2D</span>(I, K, I.<span class="built_in">depth</span>(), kern);  <span class="comment">//调用filter2D，将I中的每个像素与kern相乘，并将结果存放在K中</span></span><br><span class="line">    t = ((<span class="type">double</span>)<span class="built_in">getTickCount</span>() - t) / <span class="built_in">getTickFrequency</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Built-in filter2D time passed in seconds:      &quot;</span> &lt;&lt; t &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">namedWindow</span>(<span class="string">&quot;Output by fliter2D&quot;</span>, WINDOW_AUTOSIZE);</span><br><span class="line">    <span class="built_in">imshow</span>(<span class="string">&quot;Output by fliter2D&quot;</span>, K);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Sharpen</span><span class="params">(<span class="type">const</span> Mat&amp; myImage, Mat&amp; Result)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">CV_Assert</span>(myImage.<span class="built_in">depth</span>() == CV_8U);  <span class="comment">// accept only uchar images</span></span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> nChannels = myImage.<span class="built_in">channels</span>();  <span class="comment">//读取通道数</span></span><br><span class="line">    Result.<span class="built_in">create</span>(myImage.<span class="built_in">size</span>(), myImage.<span class="built_in">type</span>());  <span class="comment">//通过Mat的create将Result调整与源图像同样大小的类型</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; myImage.rows - <span class="number">1</span>; ++j)    <span class="comment">//对除了边缘行和列之外的所有像素进行处理</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">const</span> uchar* previous = myImage.<span class="built_in">ptr</span>&lt;uchar&gt;(j - <span class="number">1</span>);  <span class="comment">//源图像的当前行的上一行</span></span><br><span class="line">        <span class="type">const</span> uchar* current = myImage.<span class="built_in">ptr</span>&lt;uchar&gt;(j);</span><br><span class="line">        <span class="type">const</span> uchar* next = myImage.<span class="built_in">ptr</span>&lt;uchar&gt;(j + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        uchar* output = Result.<span class="built_in">ptr</span>&lt;uchar&gt;(j);  <span class="comment">//指向结果图像的当前行</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = nChannels; i &lt; nChannels*(myImage.cols - <span class="number">1</span>); ++i)  <span class="comment">//修改当前行中的每一列，注意多通道时需要通过channel来定位邻居像素位置</span></span><br><span class="line">        &#123;</span><br><span class="line">            *output++ = <span class="built_in">saturate_cast</span>&lt;uchar&gt;(<span class="number">5</span> * current[i]</span><br><span class="line">                - current[i - nChannels] - current[i + nChannels] - previous[i] - next[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置边缘像素为黑色</span></span><br><span class="line">    Result.<span class="built_in">row</span>(<span class="number">0</span>).<span class="built_in">setTo</span>(<span class="built_in">Scalar</span>(<span class="number">0</span>));</span><br><span class="line">    Result.<span class="built_in">row</span>(Result.rows - <span class="number">1</span>).<span class="built_in">setTo</span>(<span class="built_in">Scalar</span>(<span class="number">0</span>));</span><br><span class="line">    Result.<span class="built_in">col</span>(<span class="number">0</span>).<span class="built_in">setTo</span>(<span class="built_in">Scalar</span>(<span class="number">0</span>));</span><br><span class="line">    Result.<span class="built_in">col</span>(Result.cols - <span class="number">1</span>).<span class="built_in">setTo</span>(<span class="built_in">Scalar</span>(<span class="number">0</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过上面的运行结果，明显内建函数速度要快很多</p>
<p>其中<code>int Mat::depth() cont</code>返回对象的位深度，例如16-bit signed的图像返回的就是CV_16S。所有位深度的对应信息如下：</p>
<ul>
<li>CV_8U - 8-bit unsigned integers ( 0..255 )</li>
<li>CV_8S - 8-bit signed integers ( -128..127 )</li>
<li>CV_16U - 16-bit unsigned integers ( 0..65535 )</li>
<li>CV_16S - 16-bit signed integers ( -32768..32767 )</li>
<li>CV_32S - 32-bit signed integers ( -2147483648..2147483647 )</li>
<li>CV_32F - 32-bit floating-point numbers ( -FLT_MAX..FLT_MAX, INF, NAN )</li>
<li>CV_64F - 64-bit floating-point numbers ( -DBL_MAX..DBL_MAX, INF, NAN )</li>
</ul>
<p><strong>4.读写感兴趣区域ROI</strong><br>ROI也即是Region of interest，即针对一副图像中的感兴趣区域进行操作。<br>由于Mat对象的拷贝构造函数实际上拷贝的是指针，所以可以很方便地从源图像获取感兴趣获取的矩阵到新的Mat对象，而该新的Mat对象实际上关联的是源图像的像素矩阵。有2种方法获取ROI区域，其实就是Mat的两个构造函数：<br>原型：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Mat::<span class="built_in">Mat</span>(<span class="type">const</span> Mat&amp; m, <span class="type">const</span> Range&amp; rowRange, <span class="type">const</span> Range&amp; colRange=Range::<span class="built_in">all</span>() )</span><br><span class="line">Mat::<span class="built_in">Mat</span>(<span class="type">const</span> Mat&amp; m, <span class="type">const</span> Rect&amp; roi)</span><br></pre></td></tr></table></figure>

<p>举例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Mat srcImg;  <span class="comment">//认为源图像srcImg已经载入了图像</span></span><br><span class="line"></span><br><span class="line">Mat imgROI = <span class="built_in">srcImg</span>(<span class="built_in">Rect</span>(<span class="number">100</span>, <span class="number">80</span>, ncols, nrows));  <span class="comment">//ROI区域为以(80, 100)为起点的ncols x nrows大小的矩阵</span></span><br><span class="line"></span><br><span class="line">Mat imgROI2 = <span class="built_in">srcImg</span>(<span class="built_in">Range</span>(<span class="number">100</span>, <span class="number">100</span> + nrows), <span class="built_in">Range</span>(<span class="number">80</span>, <span class="number">80</span> + ncols));  <span class="comment">//通过提供行和列的范围来指定</span></span><br></pre></td></tr></table></figure>

<p>使用举例，通过copyTo()函数将一个图像拷贝到另一个图像，copyTo()有一个重载可以附加一个mask来实现隐现效果：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/core/core.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/highgui/highgui.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* srcFileName = <span class="string">&quot;F:\\cat.jpg&quot;</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* logoFileName = <span class="string">&quot;F:\\mini.jpg&quot;</span>;</span><br><span class="line"></span><br><span class="line">    Mat srcImg = <span class="built_in">imread</span>(srcFileName);</span><br><span class="line">    Mat logoImg = <span class="built_in">imread</span>(logoFileName);  </span><br><span class="line">    <span class="keyword">if</span> (!srcImg.data || !logoImg.data)    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;File load error \n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建感兴趣区域，实现上像素矩阵依然是srcImg中的像素值</span></span><br><span class="line">    Mat roiImg = <span class="built_in">srcImg</span>(<span class="built_in">Rect</span>(srcImg.rows / <span class="number">2</span>, srcImg.cols / <span class="number">2</span>, logoImg.cols, logoImg.rows));  </span><br><span class="line"></span><br><span class="line">    <span class="comment">//copyTo的第二个可选参数mask必须为CV_8U类型的图像，并非只能是单通道的灰度图</span></span><br><span class="line">    logoImg.<span class="built_in">copyTo</span>(roiImg, logoImg);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">imshow</span>(<span class="string">&quot;ROI mask picture&quot;</span>, srcImg);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>5.addWeighted线性混合两张图像</strong><br>官方示例：<a href="http://docs.opencv.org/3.0-last-rst/doc/tutorials/core/adding_images/adding_images.html">http://docs.opencv.org/3.0-last-rst/doc/tutorials/core/adding_images/adding_images.html</a><br>split()和merge()函数可以实现通道的与合并 </p>
<p><strong>6.调整图像对比度与亮度</strong><br>可以用如下方法初始化一个新Mat对象的所有像素内存为0：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Mat new_image = Mat::<span class="built_in">zeros</span>( image.<span class="built_in">size</span>(), image.<span class="built_in">type</span>() );  <span class="comment">//image为源图像</span></span><br></pre></td></tr></table></figure>

<p>官方示例：<a href="http://docs.opencv.org/3.0-last-rst/doc/tutorials/core/basic_linear_transform/basic_linear_transform.html">http://docs.opencv.org/3.0-last-rst/doc/tutorials/core/basic_linear_transform/basic_linear_transform.html</a><br>注意其中访问每个像素用的语法：<code>new_image.at&lt;Vec3b&gt;(y, x)[c]</code>，其中y是行，x是列，Vec3b就是一个含有3个uchar的vector：<code>typedef Vec&lt;uchar, 3&gt; Vec3b</code>，c表示R、G或B，取值0、1或2。<br>opencv内建了<code>saturate_cast&lt;type&gt;(value)</code>将value强制转换为有效的type类型的值</p>
<p><strong>7.离散傅里叶变换DFT</strong><br>DFT即Discrete Fourier Transform，该变换在图像处理中的应用可以做到图像增强与图像去噪、图像分割中的边缘检测、图像特征提取以及图像压缩等。<br>OpenCV中提供了dft()函数，可以对一维或二维浮点数数组进行正向或反向离散傅里叶变换，可以用于计算两个二维实矩阵的卷积。<br><a href="http://docs.opencv.org/3.0-last-rst/doc/tutorials/core/discrete_fourier_transform/discrete_fourier_transform.html">http://docs.opencv.org/3.0-last-rst/doc/tutorials/core/discrete_fourier_transform/discrete_fourier_transform.html</a></p>
<p><strong>8.OpenCV内建对xml和yaml的解析</strong><br>还是官方文档：<br><a href="http://docs.opencv.org/3.0-last-rst/doc/tutorials/core/file_input_output_with_xml_yml/file_input_output_with_xml_yml.html">http://docs.opencv.org/3.0-last-rst/doc/tutorials/core/file_input_output_with_xml_yml/file_input_output_with_xml_yml.html</a><br><a href="http://docs.opencv.org/2.4.13/modules/core/doc/xml_yaml_persistence.html">http://docs.opencv.org/2.4.13/modules/core/doc/xml_yaml_persistence.html</a></p>
<p><strong>9.内建多种图形绘制</strong><br><a href="http://docs.opencv.org/3.0-last-rst/doc/tutorials/core/basic_geometric_drawing/basic_geometric_drawing.html">http://docs.opencv.org/3.0-last-rst/doc/tutorials/core/basic_geometric_drawing/basic_geometric_drawing.html</a><br><strong>直线函数line</strong><br>函数原型如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">line</span><span class="params">(Mat&amp; img, Point pt1, Point pt2, <span class="type">const</span> Scalar&amp; color, <span class="type">int</span> thickness=<span class="number">1</span>, <span class="type">int</span> lineType=<span class="number">8</span>, <span class="type">int</span> shift=<span class="number">0</span>)</span></span></span><br></pre></td></tr></table></figure>
<p>thickness就是线宽，lineType就是线的结构，8表示当斜线时两个像素角相连就认为其已经相连了，如果是4则是两个像素有一整条边相连时才算相连。<br>画箭头可以用<code>arrowedLine</code></p>
<p><strong>圆circle</strong><br>函数原型：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">circle</span><span class="params">(Mat&amp; img, Point center, <span class="type">int</span> radius, <span class="type">const</span> Scalar&amp; color, <span class="type">int</span> thickness=<span class="number">1</span>, <span class="type">int</span> lineType=<span class="number">8</span>, <span class="type">int</span> shift=<span class="number">0</span>)</span></span></span><br></pre></td></tr></table></figure>

<p><strong>椭圆函数elipse</strong><br>函数原型：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ellipse</span><span class="params">(Mat&amp; img, Point center, Size axes, <span class="type">double</span> angle, <span class="type">double</span> startAngle, <span class="type">double</span> endAngle, <span class="type">const</span> Scalar&amp; color, <span class="type">int</span> thickness=<span class="number">1</span>, <span class="type">int</span> lineType=<span class="number">8</span>, <span class="type">int</span> shift=<span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ellipse</span><span class="params">(Mat&amp; img, <span class="type">const</span> RotatedRect&amp; box, <span class="type">const</span> Scalar&amp; color, <span class="type">int</span> thickness=<span class="number">1</span>, <span class="type">int</span> line- Type=<span class="number">8</span>)</span></span></span><br></pre></td></tr></table></figure>

<p><strong>矩形函数rectangle</strong><br>函数原型：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">rectangle</span><span class="params">(Mat&amp; img, Point pt1, Point pt2, <span class="type">const</span> Scalar&amp; color, <span class="type">int</span> thickness=<span class="number">1</span>, <span class="type">int</span> lineType=<span class="number">8</span>, <span class="type">int</span> shift=<span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">rectangle</span><span class="params">(Mat&amp; img, Rect rec, <span class="type">const</span> Scalar&amp; color, <span class="type">int</span> thickness=<span class="number">1</span>, <span class="type">int</span> lineType=<span class="number">8</span>, <span class="type">int</span> shift=<span class="number">0</span>)</span></span></span><br></pre></td></tr></table></figure>
<p>画填充的多边形用fillPoly</p>
<p>举例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/core.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/highgui.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> backWidth = <span class="number">400</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//定义一个基本图像作为绘图背景</span></span><br><span class="line">    Mat backImg = Mat::<span class="built_in">zeros</span>(backWidth, backWidth, CV_8UC3);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设定所绘线的宽度和类型</span></span><br><span class="line">    <span class="type">int</span> thickness = <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> lineType = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> radius = <span class="number">100</span>;  <span class="comment">//圆半径</span></span><br><span class="line">    Point start = <span class="built_in">Point</span>(backWidth / <span class="number">2</span> - radius, backWidth / <span class="number">2</span> - radius); <span class="comment">//矩形起点</span></span><br><span class="line">    Point end = <span class="built_in">Point</span>(backWidth / <span class="number">2</span> + radius, backWidth / <span class="number">2</span> + radius); <span class="comment">//矩形终点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//画矩形</span></span><br><span class="line">    <span class="built_in">rectangle</span>(backImg, start, end, <span class="built_in">Scalar</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>), thickness, lineType);</span><br><span class="line">    <span class="comment">//画内接圆</span></span><br><span class="line">    <span class="built_in">circle</span>(backImg, <span class="built_in">Point</span>(backWidth / <span class="number">2</span>, backWidth / <span class="number">2</span>), radius, <span class="built_in">Scalar</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>), thickness);</span><br><span class="line">    <span class="comment">//画两条直径</span></span><br><span class="line">    <span class="built_in">line</span>(backImg, start + <span class="built_in">Point</span>(<span class="number">0</span>, radius), end - <span class="built_in">Point</span>(<span class="number">0</span>, radius), <span class="built_in">Scalar</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>), thickness);</span><br><span class="line">    <span class="built_in">line</span>(backImg, start + <span class="built_in">Point</span>(radius, <span class="number">0</span>), end - <span class="built_in">Point</span>(radius, <span class="number">0</span>), <span class="built_in">Scalar</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>), thickness);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">imshow</span>(<span class="string">&quot;Draw&quot;</span>, backImg);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>RNG可以实现产生随机数，putText将窗口中显示文字</strong><br><a href="http://docs.opencv.org/3.0-last-rst/doc/tutorials/core/random_generator_and_text/random_generator_and_text.html">http://docs.opencv.org/3.0-last-rst/doc/tutorials/core/random_generator_and_text/random_generator_and_text.html</a><br>RNG就是个随机数生成器类，与C++11中的随机数生成器类类似，下面给出这个比较常用的RNG::uniform函数的原型：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">RNG::uniform</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">RNG::uniform</span><span class="params">(<span class="type">float</span> a, <span class="type">float</span> b)</span></span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">RNG::uniform</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> b)</span></span></span><br></pre></td></tr></table></figure>

<p><strong>putText显示文字</strong><br>原型：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">putText</span><span class="params">(Mat&amp; img, <span class="type">const</span> string&amp; text, Point org, <span class="type">int</span> fontFace, <span class="type">double</span> fontScale, Scalar color, <span class="type">int</span> thickness=<span class="number">1</span>, <span class="type">int</span> lineType=<span class="number">8</span>, <span class="type">bool</span> bottomLeftOrigin=<span class="literal">false</span> )</span></span></span><br></pre></td></tr></table></figure>
<p>getTextSize可以返回字符串的大小：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Size <span class="title">getTextSize</span><span class="params">(<span class="type">const</span> string&amp; text, <span class="type">int</span> fontFace, <span class="type">double</span> fontScale, <span class="type">int</span> thickness, <span class="type">int</span>* baseLine)</span></span></span><br></pre></td></tr></table></figure>

<p>举例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将上例中的图像线条变成彩色并显示文字</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/core.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/highgui.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> backWidth = <span class="number">400</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回随机的颜色</span></span><br><span class="line"><span class="function"><span class="type">static</span> Scalar <span class="title">randomColor</span><span class="params">(RNG&amp; rng)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> icolor = (<span class="type">unsigned</span>)rng;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Scalar</span>(icolor &amp; <span class="number">255</span>, (icolor &gt;&gt; <span class="number">8</span>) &amp; <span class="number">255</span>, (icolor &gt;&gt; <span class="number">16</span>) &amp; <span class="number">255</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//定义一个基本图像作为绘图背景</span></span><br><span class="line">    Mat backImg = Mat::<span class="built_in">zeros</span>(backWidth, backWidth, CV_8UC3);</span><br><span class="line"></span><br><span class="line">    <span class="function">RNG <span class="title">rng</span><span class="params">(<span class="number">0xFFFFFFFF</span>)</span></span>;  <span class="comment">//创建一个RNG对象</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//设定所绘线的宽度和类型</span></span><br><span class="line">    <span class="type">int</span> thickness = <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> lineType = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> radius = <span class="number">100</span>;  <span class="comment">//圆半径</span></span><br><span class="line">    Point start = <span class="built_in">Point</span>(backWidth / <span class="number">2</span> - radius, backWidth / <span class="number">2</span> - radius); <span class="comment">//矩形起点</span></span><br><span class="line">    Point end = <span class="built_in">Point</span>(backWidth / <span class="number">2</span> + radius, backWidth / <span class="number">2</span> + radius); <span class="comment">//矩形终点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//画矩形</span></span><br><span class="line">    <span class="built_in">rectangle</span>(backImg, start, end, <span class="built_in">randomColor</span>(rng), thickness, lineType);</span><br><span class="line">    <span class="comment">//画内接圆</span></span><br><span class="line">    <span class="built_in">circle</span>(backImg, <span class="built_in">Point</span>(backWidth / <span class="number">2</span>, backWidth / <span class="number">2</span>), radius, <span class="built_in">randomColor</span>(rng), thickness);</span><br><span class="line">    <span class="comment">//画两条直径</span></span><br><span class="line">    <span class="built_in">line</span>(backImg, start + <span class="built_in">Point</span>(<span class="number">0</span>, radius), end - <span class="built_in">Point</span>(<span class="number">0</span>, radius), <span class="built_in">randomColor</span>(rng), thickness);</span><br><span class="line">    <span class="built_in">line</span>(backImg, start + <span class="built_in">Point</span>(radius, <span class="number">0</span>), end - <span class="built_in">Point</span>(radius, <span class="number">0</span>), <span class="built_in">randomColor</span>(rng), thickness);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义随机文字的位置</span></span><br><span class="line">    Point org;</span><br><span class="line">    org.x = rng.<span class="built_in">uniform</span>(<span class="number">10</span>, backWidth / <span class="number">2</span>);</span><br><span class="line">    org.y = rng.<span class="built_in">uniform</span>(backWidth / <span class="number">2</span>, backWidth - <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//画字体</span></span><br><span class="line">    <span class="built_in">putText</span>(backImg, <span class="string">&quot;Maxwi.com&quot;</span>, org, rng.<span class="built_in">uniform</span>(<span class="number">0</span>, <span class="number">8</span>), rng.<span class="built_in">uniform</span>(<span class="number">0</span>, <span class="number">100</span>) * <span class="number">0.05</span> + <span class="number">0.1</span>, <span class="built_in">randomColor</span>(rng), rng.<span class="built_in">uniform</span>(<span class="number">1</span>, <span class="number">10</span>), lineType);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">imshow</span>(<span class="string">&quot;Draw&quot;</span>, backImg);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="imgproc组件"><a href="#imgproc组件" class="headerlink" title="imgproc组件"></a>imgproc组件</h2><p>手动图像处理功能。包括图像的基本处理、变换、轮廓提取、图像分割与修复、直方图与匹配<br><a href="http://docs.opencv.org/3.0-last-rst/doc/tutorials/imgproc/table_of_content_imgproc/table_of_content_imgproc.html">http://docs.opencv.org/3.0-last-rst/doc/tutorials/imgproc/table_of_content_imgproc/table_of_content_imgproc.html</a><br><strong>平滑处理(smoothing)</strong><br>可以用来对图像降噪，当然也可以模糊图像，是一批带有blur的函数，常用的有以下几个：</p>
<ul>
<li>方框滤波：boxFilter()</li>
<li>均值滤波（领域平均滤波）：blur()，其实是基本的方框滤波</li>
<li>高斯滤波：GaussianBlur()</li>
<li>中值滤波：medianBlur()</li>
<li>双边滤波：bilateraFilter()</li>
</ul>
<p>举例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;opencv2/imgproc/imgproc.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;opencv2/highgui/highgui.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;opencv2/features2d/features2d.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Global Variables</span></span><br><span class="line"><span class="type">int</span> DELAY_BLUR = <span class="number">500</span>;</span><br><span class="line"><span class="type">int</span> MAX_KERNEL_LENGTH = <span class="number">31</span>;</span><br><span class="line"></span><br><span class="line">Mat src;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Function headers</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">display_dst</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* winname, <span class="type">const</span> Mat&amp; img, <span class="type">int</span> delay, <span class="type">int</span> i)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* function main</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Mat dst_blur, dst_ga, dst_me, dst_bi;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Load the source image</span></span><br><span class="line">    src = <span class="built_in">imread</span>(<span class="string">&quot;F:\\lena.jpg&quot;</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">imshow</span>(<span class="string">&quot;Original&quot;</span>, src);</span><br><span class="line"></span><br><span class="line">    dst_blur = src.<span class="built_in">clone</span>();</span><br><span class="line">    dst_ga = src.<span class="built_in">clone</span>();</span><br><span class="line">    dst_me = src.<span class="built_in">clone</span>();</span><br><span class="line">    dst_bi = src.<span class="built_in">clone</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; MAX_KERNEL_LENGTH; i = i + <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">blur</span>(src, dst_blur, <span class="built_in">Size</span>(i, i), <span class="built_in">Point</span>(<span class="number">-1</span>, <span class="number">-1</span>));</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">display_dst</span>(<span class="string">&quot;blur&quot;</span>, dst_blur, DELAY_BLUR, i) != <span class="number">0</span>) &#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; MAX_KERNEL_LENGTH; i = i + <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">GaussianBlur</span>(src, dst_ga, <span class="built_in">Size</span>(i, i), <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">display_dst</span>(<span class="string">&quot;GaussianBlur&quot;</span>, dst_ga, DELAY_BLUR, i) != <span class="number">0</span>) &#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; MAX_KERNEL_LENGTH; i = i + <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">medianBlur</span>(src, dst_me, i);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">display_dst</span>(<span class="string">&quot;medianBlur&quot;</span>, dst_me, DELAY_BLUR, i) != <span class="number">0</span>) &#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; MAX_KERNEL_LENGTH; i = i + <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">bilateralFilter</span>(src, dst_bi, i, i * <span class="number">2</span>, i / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">display_dst</span>(<span class="string">&quot;bilateralFilter&quot;</span>, dst_bi, DELAY_BLUR, i) != <span class="number">0</span>) &#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* @function display_dst</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">display_dst</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* winname, <span class="type">const</span> Mat&amp; img, <span class="type">int</span> delay, <span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">imshow</span>(winname, img);</span><br><span class="line">    <span class="keyword">if</span> (i &lt; MAX_KERNEL_LENGTH)</span><br><span class="line">        <span class="built_in">waitKey</span>(delay);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h2 id="highgui组件"><a href="#highgui组件" class="headerlink" title="highgui组件"></a>highgui组件</h2><p>读写图像及视频文件、如何使用内建的用户界面库<br><a href="http://docs.opencv.org/3.0-last-rst/doc/tutorials/highgui/table_of_content_highgui/table_of_content_highgui.html">http://docs.opencv.org/3.0-last-rst/doc/tutorials/highgui/table_of_content_highgui/table_of_content_highgui.html</a></p>
<h2 id="calib3d组件"><a href="#calib3d组件" class="headerlink" title="calib3d组件"></a>calib3d组件</h2><p>相机校正及三维信息重建<br><a href="http://docs.opencv.org/3.0-last-rst/doc/tutorials/calib3d/table_of_content_calib3d/table_of_content_calib3d.html">http://docs.opencv.org/3.0-last-rst/doc/tutorials/calib3d/table_of_content_calib3d/table_of_content_calib3d.html</a></p>
<h2 id="feature2d组件"><a href="#feature2d组件" class="headerlink" title="feature2d组件"></a>feature2d组件</h2><p>主要用于触点检测，边缘检测等<br><a href="http://docs.opencv.org/3.0-last-rst/doc/tutorials/features2d/table_of_content_features2d/table_of_content_features2d.html">http://docs.opencv.org/3.0-last-rst/doc/tutorials/features2d/table_of_content_features2d/table_of_content_features2d.html</a></p>
<h2 id="video组件"><a href="#video组件" class="headerlink" title="video组件"></a>video组件</h2><p>主要用于对视频流的处理算法，可以进行运动提取、目标跟踪等<br><a href="http://docs.opencv.org/3.0-last-rst/doc/tutorials/video/table_of_content_video/table_of_content_video.html">http://docs.opencv.org/3.0-last-rst/doc/tutorials/video/table_of_content_video/table_of_content_video.html</a></p>
<h2 id="objdetect组件"><a href="#objdetect组件" class="headerlink" title="objdetect组件"></a>objdetect组件</h2><p>进行目标检测<br><a href="http://docs.opencv.org/3.0-last-rst/doc/tutorials/objdetect/table_of_content_objdetect/table_of_content_objdetect.html">http://docs.opencv.org/3.0-last-rst/doc/tutorials/objdetect/table_of_content_objdetect/table_of_content_objdetect.html</a></p>
<h2 id="ml组件：Machine-Learning"><a href="#ml组件：Machine-Learning" class="headerlink" title="ml组件：Machine Learning"></a>ml组件：Machine Learning</h2><p>opencv在机器学习中的使用<br><a href="http://docs.opencv.org/3.0-last-rst/doc/tutorials/ml/table_of_content_ml/table_of_content_ml.html">http://docs.opencv.org/3.0-last-rst/doc/tutorials/ml/table_of_content_ml/table_of_content_ml.html</a></p>
<h2 id="photo组件"><a href="#photo组件" class="headerlink" title="photo组件"></a>photo组件</h2><p>使用opencv进行高级图像处理<br><a href="http://docs.opencv.org/3.0-last-rst/doc/tutorials/photo/table_of_content_photo/table_of_content_photo.html">http://docs.opencv.org/3.0-last-rst/doc/tutorials/photo/table_of_content_photo/table_of_content_photo.html</a></p>
<h2 id="gpu模块"><a href="#gpu模块" class="headerlink" title="gpu模块"></a>gpu模块</h2><p>使用GPU加速计算机视觉<br><a href="http://docs.opencv.org/3.0-last-rst/doc/tutorials/gpu/table_of_content_gpu/table_of_content_gpu.html">http://docs.opencv.org/3.0-last-rst/doc/tutorials/gpu/table_of_content_gpu/table_of_content_gpu.html</a></p>
<h2 id="opencv在iOS中的应用"><a href="#opencv在iOS中的应用" class="headerlink" title="opencv在iOS中的应用"></a>opencv在iOS中的应用</h2><p><a href="http://docs.opencv.org/3.0-last-rst/doc/tutorials/ios/table_of_content_ios/table_of_content_ios.html">http://docs.opencv.org/3.0-last-rst/doc/tutorials/ios/table_of_content_ios/table_of_content_ios.html</a></p>
<h2 id="OpenCV-Viz模块"><a href="#OpenCV-Viz模块" class="headerlink" title="OpenCV Viz模块"></a>OpenCV Viz模块</h2><p>3D虚拟空间模块<br><a href="http://docs.opencv.org/3.0-last-rst/doc/tutorials/viz/table_of_content_viz/table_of_content_viz.html">http://docs.opencv.org/3.0-last-rst/doc/tutorials/viz/table_of_content_viz/table_of_content_viz.html</a></p>
]]></content>
      <categories>
        <category>OpenCV</category>
      </categories>
      <tags>
        <tag>OpenCV</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows下OpenCV与VS开发环境配置</title>
    <url>/2016/12/05/opencv-windows-env/</url>
    <content><![CDATA[<h2 id="关于环境配置"><a href="#关于环境配置" class="headerlink" title="关于环境配置"></a>关于环境配置</h2><p>网上有一大堆这样那样的方法，官方有详细且简单的教程，为什么要舍近求远呢，甚至有些书上还义正言辞地认为自己的配置方法非常好，其实他自己都不清楚为什么需要那些步骤，官方教程的windows配置方法：<a href="http://docs.opencv.org/3.0-last-rst/doc/tutorials/introduction/windows_install/windows_install.html">http://docs.opencv.org/3.0-last-rst/doc/tutorials/introduction/windows_install/windows_install.html</a></p>
<span id="more"></span>

<p>整理简化点，步骤如下：</p>
<h2 id="下载并安装"><a href="#下载并安装" class="headerlink" title="下载并安装"></a>下载并安装</h2><p>官网下载地址：<a href="http://opencv.org/downloads.html">http://opencv.org/downloads.html</a><br>双击下载下来的EXE文件后自解压到某一目录下，我是直接放D盘根目录了，即：<code>D:\opencv</code>，解压之后opencv会将整个源代码，即编译好的支持VS不同版本及不同位数二进制一并放在了这个目录，我们稍后只需要根据自己的系统需要来选择不同的版本即可，这里的版本不是指版本号，而是X64还是X86，VS2013还是VS2010</p>
<h2 id="设置环境变量"><a href="#设置环境变量" class="headerlink" title="设置环境变量"></a>设置环境变量</h2><p><strong>新建系统环境变量OPENCV_DIR：</strong><br>我安装的是2.4.13版本，并且系统是64位win10下的VS2013，所以我需要使用的是支持x64的VS2013的opencv，那么实际上我需要使用的opencv的根目录就是<code>D:\opencv\build\x64\vc12</code>，vc12即对应VS2013，关于VS的对应关系如下：</p>
<ul>
<li>vc14: Visual Studio 2015</li>
<li>vc12: Visual Studio 2013</li>
<li>vc11: Visual Studio 2012</li>
<li>vc10: Visual Studio 2010</li>
</ul>
<p>在系统属性-高级系统设置-环境变量-系统环境变量中新建一个名为OPENCV_DIR，值为<code>D:\opencv\build\x64\vc12</code>的系统环境变量用于后面需要引用opencv目录的地方使用环境变量来引用，方便以后更改opencv安装位置时只需要修改环境变量即可。值根据你的安装位置和需要的版本来自己修改，x64系统支持x86，所以如果想使用x86，也可以<br>或者可以直接使用命令来处理，需要管理员权限：<code>setx -m OPENCV_DIR D:\opencv\build\x64\vc12</code></p>
<p><strong>追加PATH环境变量：</strong><br>为了使系统可以找到opencv的动态连接库和可执行程序，需要将我们所需要的opencv的bin目录加入到PATH环境变量中，WIN10系统直接双击PATH然后新建，输入<code>%OPENCV_DIR%\bin</code>保存即可，win7则需要在PATH变量的最后办输入<code>;%OPENCV_DIR%\bin</code>保存，注意不要落下那个分号。其实配置过JAVA环境变量的应该这些都非常容易</p>
<h2 id="配置VS的项目属性"><a href="#配置VS的项目属性" class="headerlink" title="配置VS的项目属性"></a>配置VS的项目属性</h2><p>配置VS的项目属性其实就是告诉VS这个巨牛的IDE：去哪找opencv的头文件和去哪找opencv的动态连接库。由于为了调试方便，所以opencv的链接库在设计时有个debug版和普通版（即release版），所以可以在VS里面创建这两个版本的编译选项。<br>由于这些设置需要在用户属性页（即解决方案中的各项目属性）中设置，所以首先需要新建一个项目，然后在项目的属性页中设置。<br>其实也可以在项目属性页中直接设置所有项目所需要使用的库和头文件路径，但考虑到有可能还会需要有其他语言的项目，所以还是直接在所需要的类型语言下的项目下设置更合理。</p>
<p><strong>新建项目</strong><br>打开VS2013-新建项目，选择Visual C++下的Win32控制台应用程序，记得输入你的项目名称和解决方案名称，选为空项目。</p>
<p><strong>增加x64平台的debug和release的配置属性</strong><br>由于默认是32位，所以首先增加64的平台支持<br>点击菜单中的视图-属性管理器，会显示出来当前项目的属性管理器页面，展开后发现里面已经有了Win32平台下的Debug和Release，假如你是x86平台，可以跳过这步，直接配置win32下的对应属性即可。双击属性管理器窗口中你的项目名称即可打开项目属性页，点击左侧的配置属性激活配置管理器，在配置选项中可以看到显示的Win32处理活动状态。点击配置配置管理器，在活动解决方案平台下点击win32，即可新建x64平台，创建新的项目平台之后在属性管理器窗口中便可看见x64平台对应的Debug和Release版本。</p>
<p><strong>Opencv属性页</strong><br>我们可以直接双击属性管理器中的Debug|x64来修改项目属性页，也可以新建一个项目属性表，便于以后使用，也以免搞混乱项目属性。在总的属性页中的修改会默认被继承到以后新建的其他项目中，所以网上提到的一劳永逸的方法，并不是好方法。<br>下面新建debug下的项目属性表：<br>右单击Debug|x64添加新项目属性表，可以看到右键里面有个添加现有表，所以新建之后保存那个属性表文件就可以随意携带和添加了。新建属性表名称输入：OpenCV_x64_Debug，然后就可以在属性管理器中看见了，双击它来配置属性。由于我们使用的opencv的开发是C++项目，所以在C/C++选项中设置，网上有方法在VC++目录下设置，也可以，但不推荐。<br>点击C/C++中的常规，附加包含目录右边小箭头点编辑，新建一行，输入：<code>$(OPENCV_DIR)\..\..\include</code>确定即可，记得你已经提前配置好了OPENCV_DIR环境变量。<br>点击链接器中的常规，同样的方法在附加库目录中添加新行，内容为<code>$(OPENCV_DIR)\lib</code><br>点击链接器中的输入，编辑添加附加依赖项。由于我们现在配置的是debug版本，所以在链接时要求VS输入我们debug版本的opencv链接库。按我之前的配置情况下，我所需要的所有链接库都在目录<code>D:\opencv\build\x64\vc12\lib</code>中，里面所有lib文件名中点前面带d结尾的都是debug版本的，不带d结尾的是release，所以我们把所有带d结尾的完整文件名，一行一个输入即可。这里提供一个方法批量提取带d的文件名文本：<br>在lib目录下右单击，打开命令行，输入<code>dir /b &gt; t.txt</code>，将所有文件名一行一个输出到t.txt中。假如电脑上有vim，用vim打开，首先删除不是以lib结尾的行，然后输入<code>:g /.*\d\./d</code>，剩下的19行就是我们需要的内容，复制出来粘贴到VS那个附加依赖项中即可。如果需要的是release版本的内容，把刚才的命令换成<code>:g /.*\dd\./d</code>即可。<br>获取到的debug版本的库如下，如果觉得上面的过程麻烦，直接复制这个，把我安装的2413换成你的版本号去掉点就可以了：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">opencv_calib3d2413d.lib</span><br><span class="line">opencv_contrib2413d.lib</span><br><span class="line">opencv_core2413d.lib</span><br><span class="line">opencv_features2d2413d.lib</span><br><span class="line">opencv_flann2413d.lib</span><br><span class="line">opencv_gpu2413d.lib</span><br><span class="line">opencv_highgui2413d.lib</span><br><span class="line">opencv_imgproc2413d.lib</span><br><span class="line">opencv_legacy2413d.lib</span><br><span class="line">opencv_ml2413d.lib</span><br><span class="line">opencv_nonfree2413d.lib</span><br><span class="line">opencv_objdetect2413d.lib</span><br><span class="line">opencv_ocl2413d.lib</span><br><span class="line">opencv_photo2413d.lib</span><br><span class="line">opencv_stitching2413d.lib</span><br><span class="line">opencv_superres2413d.lib</span><br><span class="line">opencv_ts2413d.lib</span><br><span class="line">opencv_video2413d.lib</span><br><span class="line">opencv_videostab2413d.lib</span><br></pre></td></tr></table></figure>

<p>应用-确定即可完成保存，然后在属性管理器窗口中右键我们刚新建的配置点击保存，在项目文件夹中会看到名为<code>OpenCV_x64_Debug.props</code>的文件，该文件即可在以后其他的项目中加载来省去我们的配置过程。当然如果你刚才不是通过新建而是直接修改的属性，会在你以后新建项目时永久生效。<br>release版本的步骤完全一样，只是把那库改成不带d的版本即可。<br>下面给出release版本的库文件名列表：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">opencv_calib3d2413.lib</span><br><span class="line">opencv_contrib2413.lib</span><br><span class="line">opencv_core2413.lib</span><br><span class="line">opencv_features2d2413.lib</span><br><span class="line">opencv_flann2413.lib</span><br><span class="line">opencv_gpu2413.lib</span><br><span class="line">opencv_highgui2413.lib</span><br><span class="line">opencv_imgproc2413.lib</span><br><span class="line">opencv_legacy2413.lib</span><br><span class="line">opencv_ml2413.lib</span><br><span class="line">opencv_nonfree2413.lib</span><br><span class="line">opencv_objdetect2413.lib</span><br><span class="line">opencv_ocl2413.lib</span><br><span class="line">opencv_photo2413.lib</span><br><span class="line">opencv_stitching2413.lib</span><br><span class="line">opencv_superres2413.lib</span><br><span class="line">opencv_ts2413.lib</span><br><span class="line">opencv_video2413.lib</span><br><span class="line">opencv_videostab2413.lib</span><br></pre></td></tr></table></figure>

<h2 id="验证环境"><a href="#验证环境" class="headerlink" title="验证环境"></a>验证环境</h2><p>切换到解决方案资源管理器，右单击新建项选择C++文件，输入文件名并添加。输入如下源代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/core.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/highgui.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    Mat image;</span><br><span class="line">    image = <span class="built_in">imread</span>(<span class="string">&quot;F:\\cat.jpg&quot;</span>, IMREAD_COLOR); <span class="comment">// Read the file，注意换成你自己的图片文件路径</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (image.<span class="built_in">empty</span>()) <span class="comment">// Check for invalid input</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Could not open or find the image&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">namedWindow</span>(<span class="string">&quot;Display window&quot;</span>, WINDOW_AUTOSIZE); <span class="comment">// Create a window for display.</span></span><br><span class="line">    <span class="built_in">imshow</span>(<span class="string">&quot;Display window&quot;</span>, image); <span class="comment">// Show our image inside it.</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">waitKey</span>(<span class="number">0</span>); <span class="comment">// Wait for a keystroke in the window</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调试中选择开始执行不调试，或者直接ctrl+F5，确定生成，如果出现了你指定的图片，则表示环境配置成功<br>可以在VS上方选择解决方案配置Debug还是Release，以及在平台中选择x64还是Win32</p>
<p>到这里你应该明白VS的项目属性管理的作用和处理方法了，如果想开发32位版的程序，只需要类似的方法添加32位版本的属性并修改之前设置的环境变量即可。甚至可以直接修改32位版的属性时指定绝对路径，而无需修改环境变量。</p>
<p>从上面的代码也可以看出opencv编程其实就是包括上opencv的头文件，然后调用相应的函数即可，剩下的就完全是C++了。<br><code>opencv2/opencv.hpp</code>中包含了几乎所有opencv库的重要头文件，所以直接只包含这一个头文件即可引入几乎整个opencv的库。</p>
]]></content>
      <categories>
        <category>OpenCV</category>
      </categories>
      <tags>
        <tag>OpenCV</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu Server/Debian下的KVM虚拟机创建及管理详解</title>
    <url>/2016/11/29/kvm-create-and-manage/</url>
    <content><![CDATA[<p>网上关于KVM的简单使用教程有很多，但通常都是通过桌面的方式进行管理和使用，而且大部分教程中都忽略了很多重要的细节，且应用场景都较为简单。本文提供的教程主要用于有多人需要大量的虚拟机使用需求，要能够让大家非常方便地随时创建和删除虚拟机，支持通过SSH进行连接，同时支持通过VNC进行远程虚拟机桌面的连接（安装虚拟机系统时肯定需要，当然服务器带桌面例外）。当然如果使用OpenStack会方便很多，但毕竟Openstack配置非常复杂，其实采用KVM的初衷就是为了将来迁移到Openstack做个过度。</p>
<span id="more"></span>
<pre><code>假如你不幸看到本文，觉得本文太长，第一次看的时候可以跳过一些内容，我会在文注明，如果你在实践过程中遇到一些问题，建议你多看几遍，也许会有新的发现。强烈推荐多参考官方man手册，本文使用的测试环境主要是Ubuntu16.04和Debian 8，在Ubuntu14.04上的一些问题都有说明。看完本文后你将收获：
* 配置KVM虚拟机环境，即可支持通过桌面的方式安装虚拟机，又支持纯命令行
* 配置非root用户创建KVM虚拟机
* 配置虚拟机通过桥接连网，并解决很多人没有提到的桥接后导致本地网络异常的问题
* 远程VNC连接虚拟机并安装系统
* 虚拟机克隆
* 虚拟机系统镜像制作及布署
* 无需进入虚拟机的情况下获取到虚拟通过DHCP获得的IP
* 虚拟机日常管理命令</code></pre><p>本文参考的国内外资料非常多，基本重要的内容都涵盖进来了，所以虽然有点长，但很有意义</p>
<h2 id="关于KVM"><a href="#关于KVM" class="headerlink" title="关于KVM"></a>关于KVM</h2><p>KVM全称是基于内核的虚拟机（Kernel-based Virtual Machine），它是Linux的一个内核模块，该内核模块使得Linux变成了一个Hypervisor。KVM 本身不执行任何硬件模拟，需要客户空间程序通过/dev/kvm接口设置一个客户机虚拟服务器的地址空间，向它提供模拟的I/O，并将它的视频显示映射回宿主的显示屏，目前这个客户空间程序是QEMU，从QEMU的角度看，QEMU使用了KVM模块的虚拟化功能，来为自己的虚拟机提供硬件虚拟化加速。所以后面讲到的虚拟机的创建和管理过程其实就是qemu与kvm的配合调用过程，而libvirt又是一个C语言实现的虚拟机管理工具集，即由它提供的API来实现对qemu和kvm的这些管理过程，所以下面会大量涉及到libvirt提供的工具。由于KVM要求CPU支持，比如英特尔的VT或ADM-V，有些主板会在主板中默认禁用CPU的虚拟化支持，所以最好先进入BIOS中确认自己的CPU虚拟化功能处于开启状态。</p>
<h2 id="验证主机是否支持硬件虚拟化"><a href="#验证主机是否支持硬件虚拟化" class="headerlink" title="验证主机是否支持硬件虚拟化"></a>验证主机是否支持硬件虚拟化</h2><h3 id="方法1：通过命令验证"><a href="#方法1：通过命令验证" class="headerlink" title="方法1：通过命令验证"></a>方法1：通过命令验证</h3><p>首先运行如下命令：<br><code>egrep -c ‘(svm|vmx)’ /proc/cpuinfo</code><br>该命令会统计cpuinfo文件中svm和vmx出现的次数。其中svm是ADM的ADM-V虚拟化技术标识，全称secure virtual machine，vmx是Intel的硬件虚拟化技术VT-x，标识是vmx，全称为virtual machine extension。如果返回的是数字0，则表示你的机器不支持KVM或者bios中没有开启硬件虚拟化。</p>
<h3 id="方法2：通过软件验证"><a href="#方法2：通过软件验证" class="headerlink" title="方法2：通过软件验证"></a>方法2：通过软件验证</h3><p>安装cpu-checker之后通过运行kvm-ok来验证：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo apt-get install cpu-checker</span></span><br><span class="line">kvm-ok</span><br><span class="line">INFO: /dev/kvm exists</span><br><span class="line">KVM acceleration can be used</span><br></pre></td></tr></table></figure>
<p>默认情况下，下面运行的命令后面的输出都会直接在命令后面贴出，不带$符的地方表示命令输出结果，#后面接注释。<br>出现上述提示表示机器也支持kvm虚拟化，如果你的提示如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">INFO: Your CPU does not support KVM extensions</span><br><span class="line">INFO: For more detailed results, you should run this as root</span><br><span class="line">HINT:   sudo /usr/sbin/kvm-ok</span><br></pre></td></tr></table></figure>
<p>不好意思，表示你的机器不支持KVM，可以进入bios之后查看是不是CPU虚拟化功能没有开启。</p>
<h2 id="安装KVM相关依赖"><a href="#安装KVM相关依赖" class="headerlink" title="安装KVM相关依赖"></a>安装KVM相关依赖</h2><p>为了便于管理和使用KVM虚拟机，需要安装如下软件，后面需要用到的其他软件会再提示单独安装：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo apt-get install kvm qemu-kvm libvirt-bin virtinst bridge-utils</span></span><br></pre></td></tr></table></figure>
<p>它们的作用分别为：</p>
<ul>
<li>kvm: KVM的内核，通常linux系统自带</li>
<li>qemu-kvm: KVM的设备模拟器，实际上kvm只是负责加速，qemu才是虚拟机管理器</li>
<li>libvirt-bin: libvirt库，虚拟机命令行管理工具，包含很多实用工具，如后面需要大量使用的virsh。（安装之后会生成一个名为virbr0的网桥）</li>
<li>virtinst: 虚拟机创建（virt-install）和克隆工具（vrit-clone）等</li>
<li>birdge-utils: 用于桥接网卡的工具，如命令brctl）<br>如果有图形化桌面，推荐安装virt-manager，这个工具可以非常方便地图形化管理虚拟机，就像常见的virtualbox/vmware界面那样，可以通过点点鼠标来完成虚拟机的管理。</li>
</ul>
<p>KVM管理工具的一些注解及一些实用工具</p>
<ul>
<li>libvirt：操作和管理KVM虚机的虚拟化API，使用C语言编写，可以由Python,Ruby, Perl, PHP, Java等语言调用。可以操作包括KVM，vmware，XEN，Hyper-v, LXC，virtualbox等 Hypervisor。</li>
<li>virsh：基于libvirt的命令行工具，后面需要大量使用</li>
<li>virt-v2v：虚机格式迁移工具，该工具与virt-sysprep都包含在包libguestfs-tools中，后面布署中会用到</li>
<li>virt-install：创建KVM虚机的命令行工具</li>
<li>virt-viewer：连接到虚拟机屏幕的工具，需要主机有桌面环境，该工具需要单独安装sudo apt-get install virt-viewer</li>
<li>virt-clone：虚机克隆工具</li>
<li>virt-top：类似于linux系统下的top命令，可以显示所有虚拟机CPU、内存等使用情况，该工具需要单独安装sudo apt-get install virt-top</li>
</ul>
<h2 id="设置网络"><a href="#设置网络" class="headerlink" title="设置网络"></a>设置网络</h2><p>这里是最容易卡住人的地方，特别是桥接网络设置，如果你没有让虚拟机通过网卡DHCP分配独立IP以及从其他机器访问虚拟机的需求，可以直接使用NAT方式上网，暂时跳过桥接方式，有需要时再来看。<br>让虚拟上网的方式主要有两种，默认情况下使用NAT方式，即虚拟机利用主机的ip进行上网，对外网来说主机和虚拟机只显示一个ip；另一种方式是Bridge方式，即将虚拟机桥接到host机器的网卡上，guest（虚拟机）和host（实机）机器都通过bridge上网，对外显示不同的ip，相当于虚拟机网络和主机网络是平等的，都由路由器来分配（如果是通过dhcp动态由路由分配ip的话），当然也可以手动配置静态路由。下面分别讲解配置步骤</p>
<h3 id="NAT网络"><a href="#NAT网络" class="headerlink" title="NAT网络"></a>NAT网络</h3><p>想快事体验虚拟机安装之后的样子，可以先跳过网络设置<br>NAT即Network Address Translation，网络地址转换，其实就是将IP数据报头中的IP地址转换为另一个IP地址的过程，主要用于实现私有网络访问公共网络的功能，我们这里也只是利用NAT来实现虚拟机共享主机的网络。<br>KVM虚拟机环境安装之后会有个默认的网络设备称为’default’，该网络实际上桥接在虚拟网卡virbr0上，这个虚拟网卡是在安装libvirt-bin时自动创建的，该虚拟网卡通过NAT方式管理连接，可通过如下命令查看：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo virsh net-list --all</span></span><br><span class="line"> Name                 State      Autostart     Persistent</span><br><span class="line">----------------------------------------------------------</span><br><span class="line"> default              active     yes           yes</span><br></pre></td></tr></table></figure>
<p>可以看到我们有一个default网络<br>假如不小心通过brctl（用于管理桥接网络的工具）删除了default网络，可以通过重新加载预置的XML文件来恢复：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo virsh net-define /usr/share/libvirt/networks/default.xml  <span class="comment">#重新定义网络</span></span></span><br><span class="line">Network default defined from /usr/share/libvirt/networks/default.xml</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo virsh net-autostart default  <span class="comment">#设置default开机自动启动</span></span></span><br><span class="line">Network default marked as autostarted</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo virsh net-start default  <span class="comment">#启动网络default</span></span></span><br><span class="line">Network default started</span><br></pre></td></tr></table></figure>

<p>查看default网络信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo virsh net-info default</span></span><br><span class="line">Name:           default</span><br><span class="line">UUID:           1d8b5c10-54ed-4408-85b0-e6c3c722320b</span><br><span class="line">Active:         yes</span><br><span class="line">Persistent:     yes</span><br><span class="line">Autostart:      yes</span><br><span class="line">Bridge:         virbr0</span><br></pre></td></tr></table></figure>
<p>从输出中可以看到它桥接自网卡virbr0。</p>
<p>查看virbr0的信息：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">brctl show virbr0</span></span><br><span class="line">bridge name     bridge id               STP enabled     interfaces</span><br><span class="line">virbr0          8000.5254006842c2       yes             virbr0-nic</span><br></pre></td></tr></table></figure>

<p>通过brctl可以查看所有桥接网卡信息：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo brctl show</span></span><br><span class="line">bridge name     bridge id               STP enabled     interfaces</span><br><span class="line">br0             8000.4ccc6a695b5e       no              eno1</span><br><span class="line">                                                        vnet0</span><br><span class="line">virbr0          8000.5254006842c2       yes             virbr0-nic</span><br></pre></td></tr></table></figure>
<p>你电脑没有做过桥接的话可能没有br0和vnet0，可能你会发现，为什么有时候我没用sudo，有时候用了，其他brctl命令几乎都不需要sudo权限。</p>
<p>可以将default网络参数dump到XML文件中，意义就是可以用该文件为虚拟机创建网络设备，比如上面的virsh net-define命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo virsh net-dumpxml default &gt; default.xml</span></span><br></pre></td></tr></table></figure>
<p>default.xml文件内容形如：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">network</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>default<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">uuid</span>&gt;</span>1d8b5c10-54ed-4408-85b0-e6c3c722320b<span class="tag">&lt;/<span class="name">uuid</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">forward</span> <span class="attr">mode</span>=<span class="string">&#x27;nat&#x27;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">nat</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">port</span> <span class="attr">start</span>=<span class="string">&#x27;1024&#x27;</span> <span class="attr">end</span>=<span class="string">&#x27;65535&#x27;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">nat</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">forward</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">bridge</span> <span class="attr">name</span>=<span class="string">&#x27;virbr0&#x27;</span> <span class="attr">stp</span>=<span class="string">&#x27;on&#x27;</span> <span class="attr">delay</span>=<span class="string">&#x27;0&#x27;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mac</span> <span class="attr">address</span>=<span class="string">&#x27;52:54:00:68:42:c2&#x27;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ip</span> <span class="attr">address</span>=<span class="string">&#x27;192.168.122.1&#x27;</span> <span class="attr">netmask</span>=<span class="string">&#x27;255.255.255.0&#x27;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dhcp</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">range</span> <span class="attr">start</span>=<span class="string">&#x27;192.168.122.2&#x27;</span> <span class="attr">end</span>=<span class="string">&#x27;192.168.122.254&#x27;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dhcp</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ip</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">network</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>从图中可以看到default网络设置为虚拟机分配IP的范围是192.168.122.2 ~ 254以及端口范围<br>NAT模式下虚拟主机可以连外网，但外界无法访问该虚拟主机，其实如果你使用NAT方式上网，可以直接不用做任何设置就可以让虚拟机上网。这些命令是为了后面设置桥接网格时有个基础，如果遇到问题也好知道从哪里下手查找问题。</p>
<h3 id="Bridge网络"><a href="#Bridge网络" class="headerlink" title="Bridge网络"></a>Bridge网络</h3><p>Bridge方式即虚拟网桥的网络连接方式，通过这种方式可以让客户机和子网里的其他机器互相通信。虚拟机可以成为网络中具有独立IP的主机，相当于一台与物理机处于同等网络环境中主机。桥接网络（也称物理设备共享），原理就是创建一个桥接接口br0，在物理网卡和虚拟网络接口之间传递数据，此时实际上是将物理网卡置为混杂格式，以便让网卡可以侦听多个IP，虚拟机网卡桥接在物理网卡上获得独立IP。<br>大致如下图：<br><img data-src="bridge.png" alt="bridge"><br>配置过程如下：</p>
<p>1.首先备份网络配置，以便出错时恢复：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo <span class="built_in">cp</span> /etc/network/interfaces /etc/network/interfaces.bakup</span></span><br></pre></td></tr></table></figure>
<p>2.编辑网络配置，将eth0映射到br0，这里假设你电脑的物理网卡名称为eth0，注意不要随意修改网卡名称，如果你的网卡配置文件中auto后面的那个就是你的网卡名，只需要将下面的eth0换成你自己的网卡名就可以了：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo vi /etc/network/interfaces</span></span><br></pre></td></tr></table></figure>
<p>假如原有的网卡是eth0，且通过dhcp自动获取ip（即电脑连接路由器自动上网），注释或删除掉其他所有eth0相关的设置，其他内容不变，在文件最后添加如下内容：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">auto br0</span><br><span class="line">iface br0 inet dhcp        </span><br><span class="line">bridge_ports eth0        </span><br><span class="line">bridge_stp off        </span><br><span class="line">bridge_fd 0        </span><br><span class="line">bridge_maxwait 0</span><br></pre></td></tr></table></figure>

<p>如果原有eth0是手动配置的静态ip，则修改配置类似如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">auto br0</span><br><span class="line">iface br0 inet static        </span><br><span class="line">address 10.18.44.26        </span><br><span class="line">netmask 255.255.255.192        </span><br><span class="line">gateway 10.18.44.1        </span><br><span class="line">dns-nameservers 10.0.80.11 10.0.80.12        </span><br><span class="line">bridge_ports eth0        </span><br><span class="line">bridge_stp off</span><br><span class="line">bridge_fd 0</span><br><span class="line">bridge_maxwait 0</span><br></pre></td></tr></table></figure>
<p>ip信息换成你自己的IP信息就可以了，关于注释中的那2句，从国外网站看到的，由于我是DHCP，不清楚是否有用，没有测试。<br>发现上面的内容中其实就是添加了四句内容，其中bridge_ports很明显后面跟的是你的物理网卡，也就是要桥接的网卡，如果你有多个网卡想要桥接，可以以豆号分隔多个网卡名。<br>关于上面其他三个选项的解释，怕解释不清楚，直接放上原话，忘了在哪看到的，可能是SOF：</p>
<ul>
<li>bridge_stp off is a setting for spanning tree. If you have a possibility for network looks, you may want to turn this on.</li>
<li>bridge_fd 0 turns off all forwarding delay.  If you do not know what this is, you probably do not need it.</li>
<li>bridge_maxwait 0 is how long the system will wait for the Ethernet ports to come up. Zero is no wait.<br>更多关于桥接的这些配置内容，可以自己man bridge，里面有各个参数的详细说明。<br>重启网络：<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo systemctl restart networking</span></span><br></pre></td></tr></table></figure>
如果是ubuntu14.04及之前系统，或者debian中不是以systemd管理，则使用命令：<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo /etc/init.d/networking restart</span></span><br></pre></td></tr></table></figure>
如果网络重启失败，查看是不是配置文件有问题<br>如果确定配置文件没有问题，可以尝试使用ifconfig命令重启网卡试试<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo ifconfig eth0 down</span> </span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo ifconfig eth0 up</span></span><br></pre></td></tr></table></figure>
如果该命令也失败，或不能运行，就直接重启系统试试</li>
</ul>
<p>现在通过brctl命令查看网络桥接情况，里面会多一个br0：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo brctl show</span></span><br><span class="line">bridge name     bridge id               STP enabled     interfaces</span><br><span class="line">br0             8000.4ccc6a695b5e       no              eno1</span><br><span class="line">                                                        vnet0</span><br><span class="line">virbr0          8000.5254006842c2       yes             virbr0-nic</span><br></pre></td></tr></table></figure>

<p>关键在下面<br>通过ifconfig命令查看网络情况：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ifconfig</span></span><br></pre></td></tr></table></figure>
<p>输出信息太多，我就不贴出了，关键查看br0是否有ip地址，且ip为你之前物理网卡的ip，而且这个时候你的物理网卡应该没有ip了，主机通过br0上网。<br>如果你运行ifconfig提示查无些命令，安装net-tools就可以了，或者使用ip命令，新系统中一般变成了ip命令。<br>插播一张不错的图：<br><img data-src="ip-ifconfig.jpg" alt=""></p>
<p>通过ip命令查看网络情况：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo ip a show <span class="comment">#查看网络</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo ip r <span class="comment">#查看路由信息</span></span></span><br></pre></td></tr></table></figure>

<p>测试主机是否可以正常上网：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ping -c 4 baidu.com  <span class="comment">#ping外网试试</span></span></span><br></pre></td></tr></table></figure>
<p><strong>ifconfig查看如果br0中有ip，而eth0中没有ip，并且电脑能ping能外网，则表示设置成功。如果出现了eth0中依然有ip的情况，可以尝试重启电脑试。如果依然主机不能上网，或者说物理网卡上通过ifconfig还有ip，就将上面代码中的bridge_stp off改成on再重启电脑试试，如果依然有问题，就注释掉试试，同样每次修改完网卡信息之后都需要重启网络服务，如果网络服务重启有问题，重启电脑是最简单的解决方法。</strong><br>桥接网络这里我遇到很多问题，各种偶然问题，如果你也遇到了，可以尝试认真查看以下内容：</p>
<ul>
<li>man手册: man bridge-utils-interfaces</li>
<li>debian官方的Bridging Network Connections: <a href="https://wiki.debian.org/BridgeNetworkConnections">https://wiki.debian.org/BridgeNetworkConnections</a></li>
<li>ubuntu官方的Bridging Ethernet Connections (as of Ubuntu 16.04): <a href="https://help.ubuntu.com/community/NetworkConnectionBridge">https://help.ubuntu.com/community/NetworkConnectionBridge</a></li>
<li>KVM官方的Networking: <a href="https://help.ubuntu.com/community/KVM/Networking">https://help.ubuntu.com/community/KVM/Networking</a></li>
</ul>
<p>我尝试3台电脑，现在都是按上面的配置来的，可能重启网卡后依然有问题，但直接重启电脑就都可以了。网上有教程说如果是桌面系统的话需要停止网络管理服务，我这里在桌面版系统上测试过，可以不用管系统的网络管理服务。如果你那里有问题，可以查看这里停止网络管理服务试试：<br><a href="http://xmodulo.com/disable-network-manager-linux.html">http://xmodulo.com/disable-network-manager-linux.html</a></p>
<p>以后的所有虚拟机网络里面都设置为桥接模式，并使用br0就可以了，所有虚拟机都会通过路由器的DHCP获得一个独立的ip<br><strong>其他相关内容</strong><br>安装完bridge-utils之后，直接修改网络配置文件interfaces文件就可以了，不需要像有些教程中说还要手动通过brctl创建br0，然后再修改，那样反而会导致各种奇葩问题。<br>如果你真得通过brctl进行了一些br0的增删操作，可以自行man一下手册，删掉br0，然后修改好网络配置文件后直接重启电脑，然后查看br0的状态，如果删除时出现问题，提示无法删除，需要停止网络服务或者直接通过ifconfig停掉网络设备试试。</p>
<h2 id="创建虚拟机"><a href="#创建虚拟机" class="headerlink" title="创建虚拟机"></a>创建虚拟机</h2><p>可以有多种方式创建虚拟机，下面分别讲解<br>为了使非root用户也能够直接通过virsh命令管理虚拟机，需要将普通用户加入用户组kvm和libvirt。命令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo adduser &lt;youruser&gt; kvm</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo adduser &lt;youruser&gt; libvirtd</span></span><br></pre></td></tr></table></figure>
<p>重新装入更新后的群组成员信息，如下所示。看到要求输入密码的提示后，输入你的登录密码。或者重启生效</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">exec</span> su -l <span class="variable">$USER</span></span></span><br></pre></td></tr></table></figure>

<p>使用非root用户应该已经可以查看所有虚拟主机列表了：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">virsh list --all</span></span><br><span class="line">Id    Name                           State</span><br><span class="line">----------------------------------------------------</span><br><span class="line"> 2     wyl-node2                      running</span><br><span class="line"> -     csh-node1                      shut off</span><br><span class="line"> -     csh-node2                      shut off</span><br><span class="line"> -     csh-node3                      shut off</span><br><span class="line"> -     ubuntuServer-4g-original       shut off</span><br><span class="line"> -     ubuntuServer1604-original      shut off</span><br><span class="line"> -     wyl-node1                      shut off</span><br></pre></td></tr></table></figure>

<p>libvirt默认将qemu:///session给非root用户，所以也可以使用下面的方式查看虚拟机列表，就是增加了一个–connect qemu:///system参数</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">virsh --connect qemu:///system list --all</span></span><br></pre></td></tr></table></figure>
<p>可以通过修改变量LIBVIRT_DEFAULT_URI来修改这个默认设置，查看：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> <span class="variable">$LIBVIRT_DEFAULT_URI</span></span></span><br></pre></td></tr></table></figure>

<h3 id="使用virsh-install创建虚拟机"><a href="#使用virsh-install创建虚拟机" class="headerlink" title="使用virsh-install创建虚拟机"></a>使用virsh-install创建虚拟机</h3><p>这也是本文讨论的KVM创建的主要方式<br>下面是一些libvrit管理的虚拟机默认的位置：</p>
<ul>
<li>libvirt默认文件夹（几乎所有KVM相关的管理和配置文件都在该文件夹）: /var/lib/libvirt/</li>
<li>默认用户安装系统的ISO镜像文件夹，该文件夹可以手动指定: /var/lib/libvirt/boot/</li>
<li>虚拟机的默认磁盘所在的文件夹，该文件夹可以手动指定: /var/lib/libvirt/images/</li>
<li>Libvirt存放LVM/LXC/qemu的配置文件夹: /etc/libvirt/<br>为了确认KVM模块已经加载，可以运行以下命令加载：<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo modprobe kvm</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo modprobe kvm-amd <span class="comment"># for AMD CPUs</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo modprobe kvm-intel <span class="comment"># for Intel CPUs</span></span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>类似地如果需要使用虚拟网卡tun设备，则进行tun设置加载命令为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo modprobe tun</span></span><br></pre></td></tr></table></figure>

<p>下面使用virt-install命令创建虚拟机，虚拟机信息为：系统是Centos7，1GB RAM， 1 CPU core，20GB硬盘，磁盘格式设置为raw，使用默认的NAT方式连接网络：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">virt-install \</span></span><br><span class="line"><span class="language-bash">--virt-type=kvm \</span></span><br><span class="line"><span class="language-bash">--name=Centos7 \</span></span><br><span class="line"><span class="language-bash">--ram=1024 \</span></span><br><span class="line"><span class="language-bash">--vcpus=1 \</span></span><br><span class="line"><span class="language-bash">--os-variant=rhel7 \</span></span><br><span class="line"><span class="language-bash">--hvm \</span></span><br><span class="line"><span class="language-bash">--cdrom=/home/vhost/CentOS-7-x86_64-Minimal-1511.iso \</span></span><br><span class="line"><span class="language-bash">--network network=default,model=virtio \</span></span><br><span class="line"><span class="language-bash">--graphics vnc,listen=0.0.0.0 \</span></span><br><span class="line"><span class="language-bash">--disk path=/home/vhost/centos7.img,size=20,bus=virtio,format=raw</span></span><br></pre></td></tr></table></figure>
<p>下面是各参数的意义：</p>
<ul>
<li>–virt-type=kvm: 使用KVM作为虚拟机监视器</li>
<li>–name=Centos7: 虚拟机实例的名字，每个虚拟机的名字都不能一样，不能有空格</li>
<li>–ram=1024: 指定虚拟机内存大小，单位是Mb</li>
<li>–vcpus=1: 为虚拟机指定分配的虚拟CPU核数</li>
<li>–os-variant=rhel7: 指定虚拟机系统所属系列以优化虚拟机参数，可以通过命令<code>osinfo-query os</code> 来显示所有支持的系统列表，osinfo-query在包libosinfo-bin中 <code>sudo apt-get install libosinfo-bin</code></li>
<li>–hvm: 启用全虚拟化，KVM虚拟机支持全虚拟化，属于优化性参数</li>
<li>–cdrom=/home/vhost/CentOS-7-x86_64-Minimal-1511.iso: 指定作为虚拟机光驱内容的设备或文件，可以是主机的CDROM或者iso文件。</li>
<li>–network network=default,model=virtio: 将虚拟机连接到主机网络，此处连接到一个名为defalut的虚拟网络（即让虚拟机使用NAT模式上网），网卡模式设置为virtio。如果使用桥接模式，则只需要改参数为–network=bridge=br0,model=virtio即可。</li>
<li>–graphics vnc: 设置虚拟机的console并将其输出到VNC，这样就可以通过VNC来连接虚拟机了。同时可以指定vnc的端口和监听范围以及密码: –vncport=5910 –vnclisten=0.0.0.0。默认情况下端口为从5900开始的第一个空闲端口，监听范围为本机127.0.0.1，修改为0.0.0.0以使外网主机可以连接。后面会讲对于只支持SSH协议的情况下，如何通过SSH隧道连接，所以是否设置为0.0.0.0没有影响，但能设置为0.0.0.0的话，还是设置为0.0.0.0，毕竟直接通过VNC连接更加方便。这些参数也可以在/etc/libvirt/qemu.conf中修改，以使其对所有虚拟机生效，VNC默认连接没有密码。VNC可以理解为linux下的远程桌面</li>
<li>–disk path=/home/vhost/centos7.img,size=20,bus=virtio,format=raw:  指定虚拟机所使用的存储路径，大小为20G，disk bus类型为virtio，磁盘格式为raw，如果不指定fortmat，则默认格式即为raw。</li>
</ul>
<p>网络和磁盘建议都设置为virtio，virtio即启动优化的虚拟机专用IO驱动，性能更好。<br>磁盘格式使用qcow2更好，因为qcow2格式即QEMU支持的QEMU Copy On Write磁盘格式，是优化后的磁盘格式，支持快照，并且是使用多少占用多少空间。例如你分配了20G大小，如果是raw格式，则立即占用20G，而qcow2则是从很小开始，用多少，占用多少。之前有些人说qcow2性能不如raw，这两种格式可以使用qemu-img进行转换，qemu-img在包qemu-utils中。</p>
<p>等待命令执行完成之后，虚拟机就会直接运行，可以通过以下方式查看：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">virsh list</span></span><br></pre></td></tr></table></figure>
<p>或者：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">virsh --connect qemu:///system list</span></span><br></pre></td></tr></table></figure>
<p>后面默认都是使用virsh不带–connect的方式管理虚拟机，因为前面已经添加过用户组了，所以不用多输入那些参数。<br>此时可以通过VNC连接到该虚拟机来进行系统安装了，可以直接跳到后面的VNC连接处查看方法。假如你的系统带有桌面，并且安装了virt-viewer，系统应该会自动启动并显示虚拟机系统安装界面。如果没有可以手动通过vrit-manager来进行查看，或者手动在命令行中输入<code>virt-viewer &lt;host-name&gt;</code>打开虚拟机界面，进行系统安装。</p>
<p>以配置ubuntu 16.04系统再举一例，内存2G，CPU为2核，只是网络改为bridge方式，磁盘格式改为qcow2，如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">virt-install \</span><br><span class="line">--virt-type=kvm \</span><br><span class="line">--name=ubuntuServer1604-2g-original \</span><br><span class="line">--ram=2048 \</span><br><span class="line">--vcpus=2 \</span><br><span class="line">--os-variant=ubuntu16.04 \</span><br><span class="line">--hvm \</span><br><span class="line">--cdrom=/home/vhost/iso/ubuntuServer1604.iso \</span><br><span class="line">--network=bridge=br0,model=virtio \</span><br><span class="line">--graphics vnc,listen=0.0.0.0 \</span><br><span class="line">--disk path=/home/vhost/image/ubuntuServer1604-2g-original.qcow2,size=20,bus=virtio,format=qcow2</span><br></pre></td></tr></table></figure>

<p>如果你按照上面的方式遇到错误提示：ERROR  Format cannot be specified for unmanaged storage.是因为你指向的磁盘文件所有硬盘分区没有指定为libvirt的存储池，将你想要存放的虚拟机路径所在目录加入pool管理即可，默认情况下/var/lib/libvirt/images是在pool中的。 请参见下面的 <strong>为KVM增加storage pool</strong><br>ubuntu14.10系统下的virt-install命令在安装时有时候指定的磁盘文件会出现错误ERROR    cannot stat file ‘/home/youruser/vhost/image/win7.qcow2’: No such file or directory<br>没有发现什么原因，感觉有几率性的会出现，如果出现了这样的情况，那就手动使用qemu-create创建，然后在path那里指定路径，注意使用已经磁盘文件时不要指定size选项，size选项表示让virt-install自动创建指定大小的磁盘文件。感觉ubuntu16.04下的libvirt更稳定</p>
<h3 id="通过XML文件创建虚拟机"><a href="#通过XML文件创建虚拟机" class="headerlink" title="通过XML文件创建虚拟机"></a>通过XML文件创建虚拟机</h3><p>这个方法与virt-install的方式其实是一样的，只是这个是通过配置文件来创建<br>当需要将已有的虚拟机信息转储为xml文件时，可以使用以下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">virsh dumpxml centos7 &gt; centos7.xml</span></span><br></pre></td></tr></table></figure>

<p>当需要从一个xml文件创建虚拟机时，可以使用命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">virsh create centos7.xml</span></span><br></pre></td></tr></table></figure>

<p>但首先必须先创建所需要使用的磁盘文件，磁盘创建使用qemu-img命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">qemu-img create -f qcow2 /home/vhost/image/centos7.qcow2 10G</span></span><br></pre></td></tr></table></figure>
<p>上面的命令在文件夹下/home/vhost/image/下创建一个名为centos7.qcow2的硬盘文件，格式为qcow2，大小为10G。这里的格式并不是指虚拟机系统中的硬盘格式，虚拟机系统中的硬盘格式可以根据需要进行格式化即可。这里的格式是指虚拟机管理系统组织磁盘文件的格式。</p>
<p>其实xml文件中指定了通过上面virt-install创建虚拟机的参数，当然如果你已经有了一个磁盘文件需要启动，即可以通过qemu-system来启动，也可以通过创建一个这样的xml文件来启动。例如当你需要迁移虚拟机的时候就可以先导出其配置文件为xml，然后将配置文件和磁盘文件一起都迁移之后通过virsh create定义并启动虚拟机，只需要修改里面的磁盘路径即可。<br>内容通常如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">domain</span> <span class="attr">type</span>=<span class="string">&#x27;kvm&#x27;</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>centos7<span class="tag">&lt;/<span class="name">name</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">uuid</span>&gt;</span>be785b58-b734-11e6-b934-bfcf72a9abbf<span class="tag">&lt;/<span class="name">uuid</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">memory</span> <span class="attr">unit</span>=<span class="string">&#x27;KiB&#x27;</span>&gt;</span>2097152<span class="tag">&lt;/<span class="name">memory</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">currentMemory</span> <span class="attr">unit</span>=<span class="string">&#x27;KiB&#x27;</span>&gt;</span>2097152<span class="tag">&lt;/<span class="name">currentMemory</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">vcpu</span> <span class="attr">placement</span>=<span class="string">&#x27;static&#x27;</span>&gt;</span>2<span class="tag">&lt;/<span class="name">vcpu</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">os</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">type</span> <span class="attr">arch</span>=<span class="string">&#x27;x86_64&#x27;</span> <span class="attr">mechine</span>=<span class="string">&#x27;rhel7&#x27;</span>&gt;</span>hvm<span class="tag">&lt;/<span class="name">type</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">boot</span> <span class="attr">dev</span>=<span class="string">&#x27;cdrom&#x27;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">os</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">features</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">acpi</span>/&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">features</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">clock</span> <span class="attr">offset</span>=<span class="string">&#x27;utc&#x27;</span>/&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">on_poweroff</span>&gt;</span>destroy<span class="tag">&lt;/<span class="name">on_poweroff</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">on_reboot</span>&gt;</span>restart<span class="tag">&lt;/<span class="name">on_reboot</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">on_crash</span>&gt;</span>destroy<span class="tag">&lt;/<span class="name">on_crash</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">devices</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">emulator</span>&gt;</span>/usr/bin/kvm<span class="tag">&lt;/<span class="name">emulator</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">disk</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">device</span>=<span class="string">&quot;disk&quot;</span>&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">driver</span> <span class="attr">name</span>=<span class="string">&quot;qemu&quot;</span> <span class="attr">type</span>=<span class="string">&quot;qcow2&quot;</span>/&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">source</span> <span class="attr">file</span>=<span class="string">&quot;/home/blueyi/vhost/image/centos7.qcow2&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">target</span> <span class="attr">dev</span>=<span class="string">&quot;vda&quot;</span> <span class="attr">bus</span>=<span class="string">&quot;virtio&quot;</span>/&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">address</span> <span class="attr">type</span>=<span class="string">&quot;pci&quot;</span> <span class="attr">domain</span>=<span class="string">&quot;0x0000&quot;</span> <span class="attr">bus</span>=<span class="string">&quot;0x00&quot;</span> <span class="attr">slot</span>=<span class="string">&quot;0x04&quot;</span> <span class="attr">function</span>=<span class="string">&quot;0x0&quot;</span>/&gt;</span> </span><br><span class="line">        <span class="tag">&lt;/<span class="name">disk</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">disk</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">device</span>=<span class="string">&quot;cdrom&quot;</span>&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">driver</span> <span class="attr">name</span>=<span class="string">&quot;qemu&quot;</span> <span class="attr">type</span>=<span class="string">&quot;raw&quot;</span>/&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">source</span> <span class="attr">file</span>=<span class="string">&quot;/home/blueyi/vhost/iso/CentOS-7-x86_64-Minimal-1511.iso&quot;</span>/&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">target</span> <span class="attr">dev</span>=<span class="string">&quot;hdc&quot;</span> <span class="attr">bus</span>=<span class="string">&quot;ide&quot;</span>/&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">readonly</span>/&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">address</span> <span class="attr">type</span>=<span class="string">&quot;drive&quot;</span> <span class="attr">controller</span>=<span class="string">&quot;0&quot;</span> <span class="attr">bus</span>=<span class="string">&quot;1&quot;</span> <span class="attr">target</span>=<span class="string">&quot;0&quot;</span> <span class="attr">unit</span>=<span class="string">&quot;0&quot;</span>/&gt;</span> </span><br><span class="line">        <span class="tag">&lt;/<span class="name">disk</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">controller</span> <span class="attr">type</span>=<span class="string">&quot;ide&quot;</span> <span class="attr">index</span>=<span class="string">&quot;0&quot;</span>&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">address</span> <span class="attr">type</span>=<span class="string">&quot;pci&quot;</span> <span class="attr">domain</span>=<span class="string">&quot;0x0000&quot;</span> <span class="attr">bus</span>=<span class="string">&quot;0x00&quot;</span> <span class="attr">slot</span>=<span class="string">&quot;0x01&quot;</span> <span class="attr">function</span>=<span class="string">&quot;0x1&quot;</span>/&gt;</span> </span><br><span class="line">        <span class="tag">&lt;/<span class="name">controller</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">interface</span> <span class="attr">type</span>=<span class="string">&#x27;bridge&#x27;</span>&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">mac</span> <span class="attr">address</span>=<span class="string">&#x27;52:54:aa:fa:f0:5a&#x27;</span>/&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">source</span> <span class="attr">bridge</span>=<span class="string">&#x27;br0&#x27;</span>/&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">model</span> <span class="attr">type</span>=<span class="string">&#x27;virtio&#x27;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">interface</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&#x27;mouse&#x27;</span> <span class="attr">bus</span>=<span class="string">&#x27;ps2&#x27;</span>/&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&#x27;keyboard&#x27;</span> <span class="attr">bus</span>=<span class="string">&#x27;ps2&#x27;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">graphics</span> <span class="attr">type</span>=<span class="string">&#x27;vnc&#x27;</span> <span class="attr">port</span>=<span class="string">&#x27;-1&#x27;</span> <span class="attr">autoport</span>=<span class="string">&quot;yes&quot;</span> <span class="attr">listen</span>=<span class="string">&#x27;0.0.0.0&#x27;</span>/&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">devices</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">domain</span>&gt;</span> </span><br></pre></td></tr></table></figure>
<p>上面的xml文件内容指定创建的虚拟机为centos 7系统，2G内存，磁盘是通过qemu-img提前创建好的，所以这里不需要指定其大小。网络连接是通过网桥br0进行连接，vnc监听所有连接，以便可以通过外网直接使用VNC连接，假如你的VNC只能监听127.0.0.1，那么可以通过建立SSH隧道的方式进行VNC的远程连接。为了远程可以直接连接VNC，建议直接监听0.0.0.0，这样就可以在远程直接通过你的主机IP号后跟端口号的方式进行VNC连接了。当然通过SSH隧道连接更安全，毕竟SSH是加密协议</p>
<p>每一台虚拟机应该指定一个唯一的uuid，可以通过命令行工具uuid来生成一个随机的uuid，如果系统中没有uuid工具，可以通过命令安装：<code>sudo apt-get install uuid</code>，然后输入uuid就会生成一个随机的uuid号。<br>利用这种方式创建的虚拟机在运行之后默认启动项是cdrom，即你指定的系统映像，所以在安装完之后需要通过编辑掉配置文件中的boot选项中的启动方式为hd，否则启动系统后还是会从cdrom启动。这个时候系统刚安装好应该没有acpi服务，也就无法通过virsh shutdown关闭系统，可能通过<code>virsh destroy centos7</code>来强制关闭并undefine系统。然后编辑掉配置文件中的启动选项之后再次通过<code>virsh create centos7.xml</code>创建并启动系统即可。<br>如果想第一时间体验系统安装过程，可以直接跳过下面的xml内容解析，进入VNC连接系统步骤，当然如果你的宿主主机有桌面系统，可以直接使用virt-manager进行安装系统。</p>
<p><em>插一句，如果你的centos虚拟安装完成之后无法连网，查看是不是网卡没有设置为开机自动启动。我测试中发现centos7安装完系统之后网卡并不会开机自动启动。可以通过编辑cd /etc/sysconfig/network-scripts/ifcfg-eth0来将最后的ONBOOT修改为YES，将其设置为开机自动启动，然后重启系统，这里假设你的网卡名为eth0，可以通过ip a show命令来查看。或者手动启动网络服务service network restart</em><br>下面是xml文件的解析：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">domain</span> <span class="attr">type</span>=<span class="string">&#x27;kvm&#x27;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>centos7<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  #由字母和数字组成，不能包含空格 </span><br><span class="line">  <span class="tag">&lt;<span class="name">uuid</span>&gt;</span>b9dcdd92-9b9b-14d6-3938-1982a9746a12<span class="tag">&lt;/<span class="name">uuid</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">memory</span> <span class="attr">unit</span>=<span class="string">&#x27;KiB&#x27;</span>&gt;</span>2097152<span class="tag">&lt;/<span class="name">memory</span>&gt;</span></span><br><span class="line">　#由字母和数字组成，不能包含空格，表示在不reboot guest的情况下，guest可以使用的最大内存</span><br><span class="line">  <span class="tag">&lt;<span class="name">currentMemory</span> <span class="attr">unit</span>=<span class="string">&#x27;KiB&#x27;</span>&gt;</span>2097152<span class="tag">&lt;/<span class="name">currentMemory</span>&gt;</span></span><br><span class="line">  #guest启动时内存，可以通过virsh setmem来调整，但不能大于最大可用内存</span><br><span class="line">  <span class="tag">&lt;<span class="name">vcpu</span> <span class="attr">placement</span>=<span class="string">&#x27;static&#x27;</span>&gt;</span>1<span class="tag">&lt;/<span class="name">vcpu</span>&gt;</span> </span><br><span class="line">  #分配的虚拟CPU个数</span><br><span class="line">  <span class="tag">&lt;<span class="name">os</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">type</span> <span class="attr">arch</span>=<span class="string">&#x27;x86_64&#x27;</span> <span class="attr">machine</span>=<span class="string">&#x27;rhel7&#x27;</span>&gt;</span>hvm<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">    #type 表示全虚拟化还是半虚拟化，hvm表示全虚拟化 ，arch表示架构，machine指系统类型</span><br><span class="line">    <span class="tag">&lt;<span class="name">boot</span> <span class="attr">dev</span>=<span class="string">&#x27;hd&#x27;</span>/&gt;</span></span><br><span class="line">　　#boot 怎么启动的，如&quot;fd&quot;表示从文件启动, &quot;hd&quot;从硬盘启动, &quot;cdrom&quot;从光驱启动 和 &quot;network&quot;从网络启动 </span><br><span class="line">    #可以重复多行，指定不同的值，作为一个启动设备列表。第一次需要安装系统，应该使用cdrom</span><br><span class="line">  <span class="tag">&lt;/<span class="name">os</span>&gt;</span></span><br><span class="line">  #处理器特性 </span><br><span class="line">  <span class="tag">&lt;<span class="name">features</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">acpi</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">apic</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">pae</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">features</span>&gt;</span>　</span><br><span class="line">  #时钟，localtime表示使用本地时间</span><br><span class="line">  <span class="tag">&lt;<span class="name">clock</span> <span class="attr">offset</span>=<span class="string">&#x27;localtime&#x27;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">timer</span> <span class="attr">name</span>=<span class="string">&#x27;pit&#x27;</span> <span class="attr">tickpolicy</span>=<span class="string">&#x27;delay&#x27;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">timer</span> <span class="attr">name</span>=<span class="string">&#x27;rtc&#x27;</span> <span class="attr">tickpolicy</span>=<span class="string">&#x27;catchup&#x27;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">clock</span>&gt;</span></span><br><span class="line">  #定义了kvm环境中的power off, reboot或crash时的默认动作分别是什么</span><br><span class="line">  <span class="tag">&lt;<span class="name">on_poweroff</span>&gt;</span>destroy<span class="tag">&lt;/<span class="name">on_poweroff</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">on_reboot</span>&gt;</span>restart<span class="tag">&lt;/<span class="name">on_reboot</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">on_crash</span>&gt;</span>restart<span class="tag">&lt;/<span class="name">on_crash</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">devices</span>&gt;</span></span><br><span class="line">#Guest需要的设备</span><br><span class="line">   <span class="tag">&lt;<span class="name">emulator</span>&gt;</span>/usr/bin/kvm-spice<span class="tag">&lt;/<span class="name">emulator</span>&gt;</span></span><br><span class="line">   #kvm的路径，debian系的系统下通常是<span class="tag">&lt;<span class="name">emulator</span>&gt;</span>/usr/bin/kvm<span class="tag">&lt;/<span class="name">emulator</span>&gt;</span></span><br><span class="line">   #其实ubuntu系统下这个kvm-spice是链接到kvm的</span><br><span class="line">    <span class="tag">&lt;<span class="name">disk</span> <span class="attr">type</span>=<span class="string">&#x27;file&#x27;</span> <span class="attr">device</span>=<span class="string">&#x27;disk&#x27;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">driver</span> <span class="attr">name</span>=<span class="string">&#x27;qemu&#x27;</span> <span class="attr">type</span>=<span class="string">&#x27;qcow2&#x27;</span>/&gt;</span></span><br><span class="line">      #目的镜像路径 在这个例子中，在guest中显示为IDE设备。 该文件使用qemu-img命令创建，通常kvm image默认目录为/var/lib/libvirt/images/</span><br><span class="line">      <span class="tag">&lt;<span class="name">source</span> <span class="attr">file</span>=<span class="string">&#x27;/home/vhost/image/centos7.qcow2&#x27;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">seclabel</span> <span class="attr">model</span>=<span class="string">&#x27;selinux&#x27;</span> <span class="attr">relabel</span>=<span class="string">&#x27;no&#x27;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">target</span> <span class="attr">dev</span>=<span class="string">&#x27;hda&#x27;</span> <span class="attr">bus</span>=<span class="string">&#x27;ide&#x27;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">alias</span> <span class="attr">name</span>=<span class="string">&#x27;ide0-0-0&#x27;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">address</span> <span class="attr">type</span>=<span class="string">&#x27;drive&#x27;</span> <span class="attr">controller</span>=<span class="string">&#x27;0&#x27;</span> <span class="attr">bus</span>=<span class="string">&#x27;0&#x27;</span> <span class="attr">target</span>=<span class="string">&#x27;0&#x27;</span> <span class="attr">unit</span>=<span class="string">&#x27;0&#x27;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">disk</span>&gt;</span></span><br><span class="line">    #可以定义多个硬盘，默认情况下硬盘和网卡都采用默认配置，即网卡工作在模拟的rtl8139网卡下，速度为100M全双工，硬盘是ide模式。而采用</span><br><span class="line">    #virtio驱动后网卡工作在1000M模式下，硬盘工作在SCSI模式下。上面我们使用的命令创建的方式都采用的是virtio模式</span><br><span class="line">    <span class="tag">&lt;<span class="name">disk</span> <span class="attr">type</span>=<span class="string">&#x27;file&#x27;</span> <span class="attr">device</span>=<span class="string">&#x27;disk&#x27;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">driver</span> <span class="attr">name</span>=<span class="string">&#x27;qemu&#x27;</span> <span class="attr">type</span>=<span class="string">&#x27;raw&#x27;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">source</span> <span class="attr">file</span>=<span class="string">&#x27;/home/vhost/image/data.img&#x27;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">target</span> <span class="attr">dev</span>=<span class="string">&#x27;vda&#x27;</span> <span class="attr">bus</span>=<span class="string">&#x27;virtio&#x27;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">disk</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">disk</span> <span class="attr">type</span>=<span class="string">&#x27;file&#x27;</span> <span class="attr">device</span>=<span class="string">&#x27;cdrom&#x27;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">driver</span> <span class="attr">name</span>=<span class="string">&#x27;qemu&#x27;</span> <span class="attr">type</span>=<span class="string">&#x27;raw&#x27;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">source</span> <span class="attr">file</span>=<span class="string">&#x27;/home/template_make/CentOS7.iso&#x27;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">target</span> <span class="attr">dev</span>=<span class="string">&#x27;hdc&#x27;</span> <span class="attr">bus</span>=<span class="string">&#x27;ide&#x27;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">readonly</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">alias</span> <span class="attr">name</span>=<span class="string">&#x27;ide0-1-0&#x27;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">address</span> <span class="attr">type</span>=<span class="string">&#x27;drive&#x27;</span> <span class="attr">controller</span>=<span class="string">&#x27;0&#x27;</span> <span class="attr">bus</span>=<span class="string">&#x27;1&#x27;</span> <span class="attr">target</span>=<span class="string">&#x27;0&#x27;</span> <span class="attr">unit</span>=<span class="string">&#x27;0&#x27;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">disk</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">controller</span> <span class="attr">type</span>=<span class="string">&#x27;usb&#x27;</span> <span class="attr">index</span>=<span class="string">&#x27;0&#x27;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">alias</span> <span class="attr">name</span>=<span class="string">&#x27;usb0&#x27;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">address</span> <span class="attr">type</span>=<span class="string">&#x27;pci&#x27;</span> <span class="attr">domain</span>=<span class="string">&#x27;0x0000&#x27;</span> <span class="attr">bus</span>=<span class="string">&#x27;0x00&#x27;</span> <span class="attr">slot</span>=<span class="string">&#x27;0x01&#x27;</span> <span class="attr">function</span>=<span class="string">&#x27;0x2&#x27;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">controller</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">controller</span> <span class="attr">type</span>=<span class="string">&#x27;ide&#x27;</span> <span class="attr">index</span>=<span class="string">&#x27;0&#x27;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">alias</span> <span class="attr">name</span>=<span class="string">&#x27;ide0&#x27;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">address</span> <span class="attr">type</span>=<span class="string">&#x27;pci&#x27;</span> <span class="attr">domain</span>=<span class="string">&#x27;0x0000&#x27;</span> <span class="attr">bus</span>=<span class="string">&#x27;0x00&#x27;</span> <span class="attr">slot</span>=<span class="string">&#x27;0x01&#x27;</span> <span class="attr">function</span>=<span class="string">&#x27;0x1&#x27;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">controller</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">interface</span> <span class="attr">type</span>=<span class="string">&#x27;bridge&#x27;</span>&gt;</span></span><br><span class="line">    #虚拟机网络连接方式，使用网桥是注意要保证每个mac地址唯一，如果省略mac则会随机生成。</span><br><span class="line">    #target中为指定的网桥tun设备，名称通常为vnetx（x为0，1，2...）</span><br><span class="line">      <span class="tag">&lt;<span class="name">mac</span> <span class="attr">address</span>=<span class="string">&#x27;52:54:00:78:f9:5a&#x27;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">source</span> <span class="attr">bridge</span>=<span class="string">&#x27;br0&#x27;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">target</span> <span class="attr">dev</span>=<span class="string">&#x27;vnet0&#x27;</span>/&gt;</span></span><br><span class="line">      ## 使用virtio： 采用普通的驱动，即硬盘和网卡都采用默认配置情况下，硬盘是 ide 模式， 而网卡工作在 模拟的rtl 8139 网卡下，速度为100M 全双工。 采用 virtio 驱动后，网卡工作在 1000M 的模式下，硬盘工作是SCSI模式下</span><br><span class="line">      <span class="tag">&lt;<span class="name">model</span> <span class="attr">type</span>=<span class="string">&#x27;virtio&#x27;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">alias</span> <span class="attr">name</span>=<span class="string">&#x27;net0&#x27;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">address</span> <span class="attr">type</span>=<span class="string">&#x27;pci&#x27;</span> <span class="attr">domain</span>=<span class="string">&#x27;0x0000&#x27;</span> <span class="attr">bus</span>=<span class="string">&#x27;0x00&#x27;</span> <span class="attr">slot</span>=<span class="string">&#x27;0x03&#x27;</span> <span class="attr">function</span>=<span class="string">&#x27;0x0&#x27;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">interface</span>&gt;</span></span><br><span class="line">    # 如果使用默认的NAT模式，则如下：</span><br><span class="line">    <span class="tag">&lt;<span class="name">interface</span> <span class="attr">type</span>=<span class="string">&#x27;network&#x27;</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">source</span> <span class="attr">network</span>=<span class="string">&#x27;default&#x27;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mac</span> <span class="attr">address</span>=<span class="string">&quot;3B:6E:01:69:3A:11&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">interface</span>&gt;</span></span><br><span class="line">    #NAT模式下默认分配192.168.122.x/24的地址，也可以手动指定。网关为192.168.122.1</span><br><span class="line">    #输入设备</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&#x27;mouse&#x27;</span> <span class="attr">bus</span>=<span class="string">&#x27;ps2&#x27;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&#x27;tablet&#x27;</span> <span class="attr">bus</span>=<span class="string">&#x27;usb&#x27;</span>/&gt;</span></span><br><span class="line">    #下面定义与guset交互的图形设备，下面这里使用vnc协议，listen为所有地址，port为-1时表示自动分配端口号</span><br><span class="line">    #vnc方式登录，端口号自动分配 可以通过virsh vncdisplay <span class="tag">&lt;<span class="name">KVM</span> <span class="attr">Guest</span> <span class="attr">Name</span>&gt;</span>来查询</span><br><span class="line">    <span class="tag">&lt;<span class="name">graphics</span> <span class="attr">type</span>=<span class="string">&#x27;vnc&#x27;</span> <span class="attr">port</span>=<span class="string">&#x27;-1&#x27;</span> <span class="attr">autoport</span>=<span class="string">&#x27;yes&#x27;</span> <span class="attr">listen</span>=<span class="string">&#x27;0.0.0.0&#x27;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">listen</span> <span class="attr">type</span>=<span class="string">&#x27;address&#x27;</span> <span class="attr">address</span>=<span class="string">&#x27;0.0.0.0&#x27;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">graphics</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">video</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">model</span> <span class="attr">type</span>=<span class="string">&#x27;cirrus&#x27;</span> <span class="attr">vram</span>=<span class="string">&#x27;9216&#x27;</span> <span class="attr">heads</span>=<span class="string">&#x27;1&#x27;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">alias</span> <span class="attr">name</span>=<span class="string">&#x27;video0&#x27;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">address</span> <span class="attr">type</span>=<span class="string">&#x27;pci&#x27;</span> <span class="attr">domain</span>=<span class="string">&#x27;0x0000&#x27;</span> <span class="attr">bus</span>=<span class="string">&#x27;0x00&#x27;</span> <span class="attr">slot</span>=<span class="string">&#x27;0x02&#x27;</span> <span class="attr">function</span>=<span class="string">&#x27;0x0&#x27;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">memballoon</span> <span class="attr">model</span>=<span class="string">&#x27;virtio&#x27;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">alias</span> <span class="attr">name</span>=<span class="string">&#x27;balloon0&#x27;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">address</span> <span class="attr">type</span>=<span class="string">&#x27;pci&#x27;</span> <span class="attr">domain</span>=<span class="string">&#x27;0x0000&#x27;</span> <span class="attr">bus</span>=<span class="string">&#x27;0x00&#x27;</span> <span class="attr">slot</span>=<span class="string">&#x27;0x04&#x27;</span> <span class="attr">function</span>=<span class="string">&#x27;0x0&#x27;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">memballoon</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">devices</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">seclabel</span> <span class="attr">type</span>=<span class="string">&#x27;dynamic&#x27;</span> <span class="attr">model</span>=<span class="string">&#x27;selinux&#x27;</span> <span class="attr">relabel</span>=<span class="string">&#x27;yes&#x27;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span>&gt;</span>unconfined_u:system_r:svirt_t:s0:c362,c396<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">imagelabel</span>&gt;</span>unconfined_u:object_r:svirt_image_t:s0:c362,c396<span class="tag">&lt;/<span class="name">imagelabel</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">seclabel</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">domain</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="通过virt-manager创建虚拟机"><a href="#通过virt-manager创建虚拟机" class="headerlink" title="通过virt-manager创建虚拟机"></a>通过virt-manager创建虚拟机</h3><p>这个只能用于已经有了桌面系统的情况下，，运行virt-manager即可，这种方式的虚拟机的创建过程与virtualbox类似，点点鼠标，按提示操作即可。</p>
<h3 id="使用qemu-img和qemu-kvm命令行方式安装"><a href="#使用qemu-img和qemu-kvm命令行方式安装" class="headerlink" title="使用qemu-img和qemu-kvm命令行方式安装"></a>使用qemu-img和qemu-kvm命令行方式安装</h3><p>这种方式创建的虚拟机好像性能有点差，可能还会有一些其他问题，没有深度测试，非redhat系统不推荐使用该方式。<br>（1）创建一个空的qcow2格式的镜像文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">qemu-img create -f qcow2 centos7.qcow2 10G</span></span><br></pre></td></tr></table></figure>

<p>（2）启动一个虚机，将系统安装盘挂到 cdrom，安装操作系统，分1G内存，当然如果需要x86系统，则替换下面的命令为qemu-system-i386</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">qemu-system-x86_64 -hda centos7.qcow2 -m 1024 -boot d -cdrom /home/vhost/centos7.iso</span></span><br></pre></td></tr></table></figure>
<p>所以如果你的磁盘文件中已经有了系统，可以使用该命令直接启动系统</p>
<p>（3）现在你就拥有了一个带操作系统的镜像文件。你可以以它为模板创建新的镜像文件。使用模板的好处是，它会被设置为只读所以可以免于破坏。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">qemu-img create -b centos7.qcow2 -f qcow2 centos7-clone.qcow2</span></span><br></pre></td></tr></table></figure>
<p>其实就是从上面已经安装好的磁盘文件中复制为一块新的磁盘文件，这样原有的磁盘中系统就不会被破坏了，后面会讲如何使用封装好的系统进行克隆、布署</p>
<p>（4）你可以在新的镜像文件上启动虚机了</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">qemu-kvm -hda centos7.qcow2 -m 1024</span></span><br></pre></td></tr></table></figure>

<p>还是推荐使用第一或第二种方式创建虚拟机，并且virsh管理虚拟机非常方便，后面通过一系列脚本来实现自动化的根据已经封装好的镜像创建和布署虚拟机。</p>
<h2 id="VNC连接虚拟机"><a href="#VNC连接虚拟机" class="headerlink" title="VNC连接虚拟机"></a>VNC连接虚拟机</h2><p>当使用命令模式创建完虚拟机之后需要使用VNC来连接虚拟机才能进行系统安装等配置，比如安装SSH服务等，运行以下命令查看vnc信息，下面分配介绍两种方式通过VNC连接：</p>
<h3 id="直接通过VNC-viewer连接"><a href="#直接通过VNC-viewer连接" class="headerlink" title="直接通过VNC viewer连接"></a>直接通过VNC viewer连接</h3><p>如果要使用VNC直接进行连接，需要在刚才创建虚拟机时指定VNC监听为0.0.0.0，即监听所有连接。否则请直接看下面的使用SSH隧道连接的方式。</p>
<h4 id="查看VNC端口号"><a href="#查看VNC端口号" class="headerlink" title="查看VNC端口号"></a>查看VNC端口号</h4><p>首先查看VNC监听的端口号，只有虚拟机运行期间才会有针对虚拟机的VNC监听端口：<br><strong>通过将虚拟运行期间的配置文件dumpxml出来后，使用grep输出的方式查看：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">virsh dumpxml centos7 | grep vnc</span></span><br><span class="line">&lt;graphics type=&#x27;vnc&#x27; port=&#x27;5901&#x27; autoport=&#x27;yes&#x27; listen=&#x27;127.0.0.1&#x27;&gt;</span><br></pre></td></tr></table></figure>
<p>输出中会包含有vnc所监听的端口号，通常是5901，我这里就是5901，从这里可以看出我这里监听ip是本地。</p>
<p><strong>通过virsh命令查看：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">virsh vncdisplay centos7</span></span><br></pre></td></tr></table></figure>
<p>如果显示结果为127.0.0.1:1，则表示端口为5901，因为vnc端口默认是从5900开始分</p>
<p><strong>通过查看系统网络监听的方式查看：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">netstat -nap | grep qemu</span></span><br></pre></td></tr></table></figure>
<p>如果grep qemu没有，试试grep kvm，或者直接grep 590，因为默认VNC从5900开始监听。这种方式最不直观，当有多台虚拟机是，无法区分哪一台的端口号是多少。</p>
<h4 id="通过VNC-viewer连接"><a href="#通过VNC-viewer连接" class="headerlink" title="通过VNC viewer连接"></a>通过VNC viewer连接</h4><p>如果宿主主机有桌面环境并且你的虚拟机在配置时VNC监听ip设置为本地，此时可以直接在宿主机（即你安装KVM的主机）通过VNC客户端连接，在VNC客户端中输入127.0.0.1:5901即可，这里假设虚拟机是通过5901端口连接，这种情况要求你安装KVM的环境必须要有桌面环境，其实有了桌面环境就不需要这样了，直接通过virt-manager就可以直接管理了。VNC客户端可以通过VNC官方下载安装，或者直接使用系统中的<code>vncviewer 127.0.0.1:5901</code>连接，vncviewer在包gvncviewer中。</p>
<p>如果配置虚拟机时的VNC监听IP设置为0.0.0.0，那么就可以通过外部网络（指可以通过你宿主主机IP访问宿主主机的网络，通常是同一路由器下的子网）使用宿主主机的IP与虚拟机被监听的VNC端口进行连接。<br>也可以通过修改/etc/libvirt/qemu.conf中的vnc_listen=”0.0.0.0”来使其监听所有IP，否则只监听本地端口，也就只能从服务器本地登录指定虚拟机。同样里面可以修改vnc_password，当然也可以在安装时指定这些参数，或者在相应的xml配置文件中修改。默认情况下/etc/libvirt/qemu.conf中的配置是注释掉的，一旦将其注释取消，则会覆盖通过虚拟机进行的设置。</p>
<p>如果是Windows系统则直接从REALVNC官方网站 <a href="https://www.realvnc.com/download/viewer/下载VNC">https://www.realvnc.com/download/viewer/下载VNC</a> viewer安装，然后打开VNC viewer输入&lt;宿主主机ip&gt;:<vnc port>进行连接即可。<br>如果连接时闪退，可以尝试将VNC的File-&gt;Preference-&gt;Expert-&gt;ColorLevel中的Value值修改为full，保存后再次连接虚拟机即可</p>
<h3 id="使用SSH隧道通过VNC连接"><a href="#使用SSH隧道通过VNC连接" class="headerlink" title="使用SSH隧道通过VNC连接"></a>使用SSH隧道通过VNC连接</h3><p>下面说说对于没有桌面环境的服务器系统且无法使用VNC或者考虑到安全连接的情况下，如何通过SSH隧道的方式加密连接，来让VNC走SSH隧道进行远程连接安装系统（因为有了系统后就可以安装SSH服务了嘛）。因为 VNC支持通过ssh协议建立连接。首先确定你的服务器可以正常通过SSH进行连接访问，然后在需要连接KVM的电脑上使用ssh建立隧道。假如你的宿主主机连SSH连接都不可用，肯定不可能的了。<br><strong>Linux系统建立SSH隧道并连接</strong><br>如果你是linux系统，非常方便，直接使用以下命令建立隧道即可：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ssh foobar@192.168.1.102 -L 5901:127.0.0.1:5900</span></span><br></pre></td></tr></table></figure>
<p>这里ssh <a href="mailto:foobar@192.168.1.102">foobar@192.168.1.102</a>，表示建立ssh连接到KVM虚拟机192.168.1.102，-L表示启动端口转发， 5901:127.0.0.1:5900 表示建立隧道转发本地127.0.0.1的5901端口的访问到远程的5900端口，这里假设你需要访问的KVM虚拟机的VNC监听端口是5900.<br>运行这条命令之前还要确保你本地的5901端口在闲置，可能通过：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo netstat -nap | grep 5901</span><br></pre></td></tr></table></figure>
<p>来查看，如果返回结果为空，则表示5901端口没有被占用，然后通过localhost:5901/127.0.0.1:5901来使用VNC客户端连接你的KVM虚拟主机进行系统安装。哪台电脑需要连接那个KVM虚拟机，就在哪台电脑上建立SSH隧道即可。</p>
<p><strong>Windows系统建立SSH隧道并通过VNC连接</strong><br>如果你需要连接KVM虚拟机的电脑是windows，则可以通过putty建立tunnel，然后打开VNC客户端连接，putty如何建立SSH隧道：<br>打开putty，Host name中输入服务器IP，端口默认22。点开左侧的SSH选项，点击Tunnels，source port中输入你想使用的本地端口，Destination中输入你需要建立隧道的本地IP和远程虚拟机的VNC监听端口，点击Add后，Open即可，此时需要输入服务器用户和密码（dutoeserver）。这样就建立好了SSH隧道。如果有多台虚拟机，则通过add一次可以添加多个监听隧道。如我有虚拟机3台，分别端口为5901、5902、5903，则我可以Source port中填写5901，然后Destination中填写127.0.0.1:5901，点击Add，其他两个端口类似添加。最后点击Open即可。<br>通过putty建立好SSH隧道之后不要关闭putty窗口，然后再打开VNC<br>viewer，输入127.0.0.1:5901即可连接5901对应的虚拟机，可以根据不同的VNC端口同时连接多个虚拟机。</p>
<p>有些windows下的ssh软件支持像linux那样直接通过一行命令创建SSH隧道，例如mobaXterm</p>
<h2 id="KVM虚拟机常用管理命令"><a href="#KVM虚拟机常用管理命令" class="headerlink" title="KVM虚拟机常用管理命令"></a>KVM虚拟机常用管理命令</h2><p>KVM虚拟机默认配置文件位置: /etc/libvirt/qemu/，该目录下存放了所有创建过的虚拟机配置文件。</p>
<p>查看virt-install所有支持的OS参数列表：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">osinfo-query os</span> </span><br></pre></td></tr></table></figure>

<p>查看正在运行的虚拟主机列表：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">virsh list</span></span><br></pre></td></tr></table></figure>

<p>查看所有虚拟机列表：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">virsh list --all</span></span><br></pre></td></tr></table></figure>

<p>查看虚拟机信息：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">virsh dominfo centos7</span></span><br></pre></td></tr></table></figure>

<p>启动虚拟主机：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">virsh start centos7</span></span><br></pre></td></tr></table></figure>

<p>关闭一个名为centos7的虚拟机：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">virsh shutdown centos7</span></span><br></pre></td></tr></table></figure>
<p>由于virsh实际上不能对虚拟机进行关机，只有虚拟机配置了acpid服务之后才能通过virsh进行关机，配置命令为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo chkconfig acpid on</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo service acpid restart</span></span><br></pre></td></tr></table></figure>
<p>注意这是指在虚拟机中配置该服务</p>
<p>暂停/挂起虚拟主机：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">virsh <span class="built_in">suspend</span> centos7</span></span><br></pre></td></tr></table></figure>
<p>恢复暂停状态的虚拟机：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">virsh resume centos7</span></span><br></pre></td></tr></table></figure>

<p>软重启（安全重启，相当于在虚拟机内部点击重启选项）虚拟机：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">virsh reboot centos7</span></span><br></pre></td></tr></table></figure>

<p>硬重启虚拟机（不安全，有可能数据丢失，相当于强制按主机上的重启按钮）：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">virsh reset centos7</span></span><br></pre></td></tr></table></figure>

<p>设置虚拟机随着宿主主机开机自动启动：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">virsh autostart centos7</span></span><br></pre></td></tr></table></figure>
<p>开机自动启动的虚拟机配置文件会自动在目录/etc/libvirt/qemu/autostart/目录下生成。<br>用开机自动启动：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">virsh autostart --<span class="built_in">disable</span> centos7</span></span><br></pre></td></tr></table></figure>

<p>移除虚拟机定义，即从虚拟机列表中移除虚拟机：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">virsh undefine centos7</span></span><br></pre></td></tr></table></figure>
<p>该命令只是删除/etc/libvirt/qemu/目录下名为centos7.xml的配置文件，并不会删除虚拟机磁盘文件</p>
<p>通过虚拟机配置文件重新定义虚拟机：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">virsh define centos7.xml</span></span><br></pre></td></tr></table></figure>

<p>强制关闭虚拟机电源：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">virsh destroy centos7</span></span><br></pre></td></tr></table></figure>

<p>编辑虚拟机配置文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">virsh edit centos7</span></span><br></pre></td></tr></table></figure>
<p>该命令会调用本地编辑器编辑虚拟机配置文件，虽然也可以手动使用vim去编辑/etc/libvirt/qemu/centos7.xml下的虚拟机配置文件，但不建议，最好还是通过virsh edit调用编辑器来编辑虚拟机配置文件</p>
<p>查看virsh的所有命令或指定的命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">virsh --<span class="built_in">help</span></span></span><br></pre></td></tr></table></figure>
<p>可以配合grep来查看某个选项相关的所有相关指令，例如我想查看跟开机有关的所有相关指令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">virsh --<span class="built_in">help</span> | grep start</span></span><br></pre></td></tr></table></figure>
<p>如果想看到详情，最好还是看man手册：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">man virsh</span><br></pre></td></tr></table></figure>

<p>查看当前主机上hypervisor的连接路径：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">virsh uri</span></span><br></pre></td></tr></table></figure>

<p>创建虚拟机硬盘（格式为qcow2，该格式创建后不会立即占用10G空间，而是在使用中动态增长；也可以是raw格式，会立即分配空间。大小为10G）：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">qemu-img create -f qcow2 test.qcow2 10G</span></span><br></pre></td></tr></table></figure>

<p>查看磁盘信息：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">qemu-img info test.img</span></span><br></pre></td></tr></table></figure>

<p>qcow2格式文件的快照管理命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">创建快照：qemu-img snapshot -c &lt;标签&gt; test.qcow2</span><br><span class="line">恢复快照：qemu-img snapshot -a &lt;标签&gt; test.qcow2</span><br><span class="line">删除快照：qemu-img snapshot -d &lt;标签&gt; test.qcow2</span><br></pre></td></tr></table></figure>

<p>进入virsh管理程序：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">virsh</span></span><br></pre></td></tr></table></figure>
<p>出现virsh提示符后，你就可以使用任何virsh命令了。</p>
<p>上面的命令对应的非root管理用户命令，即没有将当前用户组加入到管理组，且没有root权限的用户，可以通过加入–connect qemu:///system的方式实现虚拟机的管理，如创建和移除虚拟机的命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">virsh --connect qemu:///system create centos7.xml</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">virsh --connect qemu:///system destroy centos7.xml</span></span><br></pre></td></tr></table></figure>
<p>感觉还是设置好用户组之后直接使用virsh管理KVM虚拟机更加方便</p>
<h2 id="KVM虚拟机克隆"><a href="#KVM虚拟机克隆" class="headerlink" title="KVM虚拟机克隆"></a>KVM虚拟机克隆</h2><p>即可以使用virt-clone命令来进行虚拟机的克隆，也可以通过手动拷贝磁盘文件及原虚拟机的配置文件来完成克隆，注意如果使用拷贝的方式需要手动修改克隆后的虚拟机的host名称、mac信息以及配置文件中的uuid和名称，否则会冲突，当然克隆生成的虚拟机中的hostname也是一样的，同样建议修改国，但virt-clone会自动随机生成uuid、mac等信息。<br>通过virt-clone命令克隆命令如下，克隆虚拟机时需要确保被克隆的虚拟机处于关闭或者挂起状态。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">virt-clone --original=vm-to-clone \</span><br><span class="line">               --name=cloned-vm \</span><br><span class="line">               --file=/home/vm/cloned-vm.img </span><br></pre></td></tr></table></figure>
<ul>
<li><p>–original后面需要是被克隆的虚拟机名，–name后面是你克隆后的虚拟机名，–file后面是克隆虚拟机的磁盘映像需要存放的位置，可以使用-o,-n,-f来简写，当原虚拟机有多个硬盘文件时，后面需要跟多个–file。注意virt-clone无法指定静态网络参数</p>
</li>
<li><p>virt-clone还可以指定uuid，mac等信息，省略的信息表示由virt自动生成。</p>
</li>
<li><p>virt-clone后面也可以只接–original参数，然后再接个–auto-clone参数，就是由virt-clone自动进行克隆：<br>自动克隆之后的输出如下：</p>
<pre><code>Original name        : MyVM
Generated clone name : MyVM-clone

Original disk path   : /home/user/foobar.img
Generated disk path  : /home/user/foobar-clone.img</code></pre></li>
</ul>
<p>也可以通过man virt-clone查看更详细的参数，</p>
<p>如果需要手动克隆，其实就是复制一份导出的原虚拟机配置文件到xml，将修改其中需要修改的内容，然后复制一份原虚拟机的磁盘映像文件，并在xml文件中修改相应文件，再使用virsh define定义新虚拟机的配置文件即可。<br>其实vrit-clone的克隆也就是复制一份原虚拟机的磁盘及配置文件,然后会在克隆时修改配置文件中的mac地址,其他原虚拟机中的所有内容都不会变化,因为virt-clone并不会修改虚拟机内容.如果想创建一个不包含个人信息及网络配置的虚拟机镜像,则需要使用virt-sysprep进行虚拟机部署镜像制作.</p>
<h2 id="KVM虚拟机布署"><a href="#KVM虚拟机布署" class="headerlink" title="KVM虚拟机布署"></a>KVM虚拟机布署</h2><p>虚拟机布署主要3步：创建虚拟机并安装系统和所需要的配置、清除虚拟机中的一些个人信息和不需要的缓存信息、克隆虚拟机。<br>vrit-sysprep可用于清除虚拟机磁盘镜像中的一些不需要的内容，并且可以修改虚拟机磁盘文件中的一些信息，所以可用于封闭虚拟机。<br>virt-sysprep包含在包libguestfs-tools,可以通过以下命令安装</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo apt-get install libguestfs-tools</span></span><br></pre></td></tr></table></figure>
<p>virt-sysprep可以重置虚拟机,包括清除SSH key,清除网络信息及MAC地址,清除用户账户.virt-sysprep还可以定制化虚拟机，包含SSH key，用户，logo等．<br>可以通过<code>virt-sysprep --list-operations</code>来查看virt-sysprep在封装时会清除掉哪些信息，列表中带有*的表示默认会被清除掉的信息，如下：</p>
<ul>
<li>abrt-data * Remove the crash data generated by ABRT</li>
<li>bash-history * Remove the bash history in the guest</li>
<li>blkid-tab * Remove blkid tab in the guest</li>
<li>ca-certificates   Remove CA certificates in the guest</li>
<li>crash-data * Remove the crash data generated by kexec-tools</li>
<li>cron-spool * Remove user at-jobs and cron-jobs</li>
<li>customize * Customize the guest</li>
<li>dhcp-client-state * Remove DHCP client leases</li>
<li>dhcp-server-state * Remove DHCP server leases</li>
<li>dovecot-data * Remove Dovecot (mail server) data</li>
<li>firewall-rules   Remove the firewall rules</li>
<li>flag-reconfiguration   Flag the system for reconfiguration</li>
<li>fs-uuids   Change filesystem UUIDs</li>
<li>kerberos-data   Remove Kerberos data in the guest</li>
<li>logfiles * Remove many log files from the guest</li>
<li>lvm-uuids * Change LVM2 PV and VG UUIDs</li>
<li>machine-id * Remove the local machine ID</li>
<li>mail-spool * Remove email from the local mail spool directory</li>
<li>net-hostname * Remove HOSTNAME in network interface configuration</li>
<li>net-hwaddr * Remove HWADDR (hard-coded MAC address) configuration</li>
<li>pacct-log * Remove the process accounting log files</li>
<li>package-manager-cache * Remove package manager cache</li>
<li>pam-data * Remove the PAM data in the guest</li>
<li>puppet-data-log * Remove the data and log files of puppet</li>
<li>rh-subscription-manager * Remove the RH subscription manager files</li>
<li>rhn-systemid * Remove the RHN system ID</li>
<li>rpm-db * Remove host-specific RPM database files</li>
<li>samba-db-log * Remove the database and log files of Samba</li>
<li>script * Run arbitrary scripts against the guest</li>
<li>smolt-uuid * Remove the Smolt hardware UUID</li>
<li>ssh-hostkeys * Remove the SSH host keys in the guest</li>
<li>ssh-userdir * Remove “.ssh” directories in the guest</li>
<li>sssd-db-log * Remove the database and log files of sssd</li>
<li>tmp-files * Remove temporary files</li>
<li>udev-persistent-net * Remove udev persistent net rules</li>
<li>user-account   Remove the user accounts in the guest</li>
<li>utmp * Remove the utmp file</li>
<li>yum-uuid * Remove the yum UUID</li>
</ul>
<p>Ubuntu 14.04系统下的该工具支持的清除列表要少一些，并且不支持下面要用到的–operations选项。</p>
<p>可以通过参数–enable/–operations选项后面跟逗号分隔的列表来指定你需要清除的选项．<br>通常我们只需要使用<code>virt-sysprep -d &lt;vm-host-name&gt;</code><br><vm-host-name>是你virsh管理的虚拟机的名字，也可以是你虚拟机的uuid，如果你是直接针对磁盘文件，则使用-a参数后面跟上一个或多个硬盘文件即可．<br>官方建议该工具的使用不要通过root用户进行，如果你在使用时出现的问题，可以尝试使用root权限运行试试．<br>我常用的命令为：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">virt-sysprep -d ubuntuServer-original   #先清除私有化的配置</span><br><span class="line">virt-clone --original=ubuntuServer-original \  #克隆</span><br><span class="line">               --name=myubuntu-1 \</span><br><span class="line">               --file=/home/vm/myubuntu-1.qcow2</span><br><span class="line">sudo virt-sysprep -d test --hostname mytest --operations defaults,-ssh-hostkeys  #布署</span><br><span class="line">virsh start myubuntu-1  #启动</span><br></pre></td></tr></table></figure>
<p>更详细的信息可以参见官方文档<a href="http://libguestfs.org/virt-sysprep.1.html#">http://libguestfs.org/virt-sysprep.1.html#</a></p>
<h2 id="批量KVM虚拟机管理脚本"><a href="#批量KVM虚拟机管理脚本" class="headerlink" title="批量KVM虚拟机管理脚本"></a>批量KVM虚拟机管理脚本</h2><p>下面是为了方便日常多用户使用和管理写的python脚本函数（python只是草草地看了语法，水平有限，忘谅解），可以自由组合各函数功能成为单独的命令，也可以到github去查看：<a href="https://github.com/blueyi/kvmManage">https://github.com/blueyi/kvmManage</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#! /usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># vim:fenc=utf-8</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Copyright © 2016 blueyi &lt;blueyi@blueyi-ubuntu&gt;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Distributed under terms of the MIT license.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Some function and const value</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">image_path = <span class="string">&#x27;/mnt/data/vhost/image/&#x27;</span></span><br><span class="line">iso_path = <span class="string">&#x27;/mnt/data/vhost/iso/&#x27;</span></span><br><span class="line">template_kvm = <span class="string">&#x27;ubuntuServer1604-original&#x27;</span></span><br><span class="line">sub_ip = <span class="string">&#x27;192.168.1.0&#x27;</span></span><br><span class="line">addDisk_path = <span class="string">&#x27;/mnt/data/addDisk/&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">itoa = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;f&#x27;</span>, <span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;i&#x27;</span>, <span class="string">&#x27;j&#x27;</span>, <span class="string">&#x27;k&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># print some important string</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">welcome_print</span>(<span class="params">msg</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;*&#x27;</span> * <span class="number">70</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;   &lt;&lt;&lt; &#x27;</span> + msg + <span class="string">&#x27; &gt;&gt;&gt;&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;*&#x27;</span> * <span class="number">70</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># run an shell command in subprocess</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">run_cmd_reout</span>(<span class="params">tcall_cmd, goOnRun = <span class="literal">False</span>, isOutPut = <span class="literal">True</span>, jumpErr = <span class="literal">False</span>, isReturnCode = <span class="literal">False</span></span>):</span><br><span class="line">    p = subprocess.Popen(tcall_cmd, shell=<span class="literal">True</span>, stdout=subprocess.PIPE, executable=<span class="string">&#x27;/bin/bash&#x27;</span>)</span><br><span class="line">    toutput = p.communicate()[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">if</span> p.returncode != <span class="number">0</span> <span class="keyword">and</span> <span class="keyword">not</span> jumpErr:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;&lt;&lt;&lt; &#x27;</span> + tcall_cmd + <span class="string">&#x27; &gt;&gt;&gt; run failed!&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> goOnRun :</span><br><span class="line">            sys.exit(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">if</span> isOutPut :</span><br><span class="line">        <span class="built_in">print</span>(toutput)</span><br><span class="line">    <span class="keyword">if</span> isReturnCode :</span><br><span class="line">        <span class="keyword">return</span> p.returncode</span><br><span class="line">    <span class="keyword">else</span> :</span><br><span class="line">        <span class="keyword">return</span> toutput</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># get total domain name list</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hostNameList</span>():</span><br><span class="line">    list_cmd = <span class="string">&#x27;virsh list --all&#x27;</span></span><br><span class="line">    list_out = run_cmd_reout(list_cmd, goOnRun=<span class="literal">True</span>, isOutPut=<span class="literal">False</span>, jumpErr=<span class="literal">True</span>, isReturnCode=<span class="literal">False</span>)</span><br><span class="line">    host_list = []</span><br><span class="line">    cont = <span class="number">2</span></span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> list_out.strip().split(<span class="string">&#x27;\n&#x27;</span>):</span><br><span class="line">        <span class="keyword">if</span> cont &gt; <span class="number">0</span>:</span><br><span class="line">            cont = cont - <span class="number">1</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        host = line.split()[<span class="number">1</span>]</span><br><span class="line">        host_list.append(host)</span><br><span class="line">    <span class="keyword">return</span> host_list</span><br><span class="line"></span><br><span class="line"><span class="comment"># Is specified KVM exist</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">isVMExist</span>(<span class="params">host_name</span>) :</span><br><span class="line">    <span class="keyword">return</span> (host_name <span class="keyword">in</span> hostNameList())</span><br><span class="line"></span><br><span class="line"><span class="comment"># Is specified KVM running</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">isVMRunning</span>(<span class="params">host_name</span>) :</span><br><span class="line">    is_run_cmd = <span class="string">&#x27;virsh domstate &#x27;</span> + host_name</span><br><span class="line">    <span class="keyword">return</span> isVMExist(host_name) <span class="keyword">and</span> (run_cmd_reout(is_run_cmd, goOnRun=<span class="literal">True</span>, isOutPut=<span class="literal">False</span>, jumpErr=<span class="literal">True</span>).strip() == <span class="string">&#x27;running&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># list all kvm exist</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">listAllKVM</span>() :</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;All virtual machine list in the following&#x27;</span>)</span><br><span class="line">    run_cmd_reout(<span class="string">&#x27;virsh list --all&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># create disk</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">createDisk</span>(<span class="params">path, size</span>) :</span><br><span class="line">    create_disk_cmd = <span class="string">&#x27;qemu-img create -f qcow2 &#x27;</span> + path + <span class="string">&#x27; &#x27;</span> + <span class="built_in">str</span>(size) + <span class="string">&#x27;G&#x27;</span></span><br><span class="line">    run_cmd_reout(create_disk_cmd)</span><br><span class="line"></span><br><span class="line"><span class="comment"># get image detail info</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">imgDetailInfo</span>(<span class="params">path</span>) :</span><br><span class="line">    img_info_cmd = <span class="string">&#x27;sudo qemu-img info &#x27;</span> + path</span><br><span class="line">    run_cmd_reout(img_info_cmd)</span><br><span class="line"></span><br><span class="line"><span class="comment"># get image info</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">imgInfo</span>(<span class="params">path</span>) :</span><br><span class="line">    img_info_cmd = <span class="string">&#x27;ls -sh &#x27;</span> + path</span><br><span class="line">    run_cmd_reout(img_info_cmd)</span><br><span class="line"></span><br><span class="line"><span class="comment"># attach disk to vm</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">addDisk</span>(<span class="params">host_name, size</span>) :</span><br><span class="line">    tistr = time.strftime(<span class="string">&#x27;%Y%m%d%H%M%S&#x27;</span>)</span><br><span class="line">    disk_path = addDisk_path + host_name + <span class="string">&#x27;-&#x27;</span> + <span class="built_in">str</span>(tistr) + <span class="string">&#x27;.qcow2&#x27;</span></span><br><span class="line">    createDisk(disk_path , size)</span><br><span class="line">    adddisk_cmd = <span class="string">&#x27;virsh attach-disk &#x27;</span> + host_name + <span class="string">&#x27; --source &#x27;</span> + disk_path + <span class="string">&#x27; --target vd&#x27;</span> + itoa[<span class="built_in">int</span>(tistr) % <span class="number">10</span>] + <span class="string">&#x27; --subdriver qcow2 --targetbus virtio --persistent&#x27;</span></span><br><span class="line">    run_cmd_reout(adddisk_cmd)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Get disk list of kvm</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getDiskList</span>(<span class="params">host_name</span>) :</span><br><span class="line">    disk_list_cmd = <span class="string">&#x27;virsh domblklist &#x27;</span> + host_name</span><br><span class="line">    output = run_cmd_reout(disk_list_cmd, jumpErr=<span class="literal">True</span>, goOnRun=<span class="literal">True</span>)</span><br><span class="line">    tlist = output.split()</span><br><span class="line">    disk_list = []</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> tlist :</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;/&#x27;</span> <span class="keyword">in</span> line <span class="keyword">and</span> (<span class="string">&#x27;.qcow2&#x27;</span> <span class="keyword">in</span> line <span class="keyword">or</span> <span class="string">&#x27;.img&#x27;</span> <span class="keyword">in</span> line) :</span><br><span class="line">            disk_list.append(line)</span><br><span class="line">    <span class="keyword">return</span> disk_list</span><br><span class="line"></span><br><span class="line"><span class="comment"># Get disk info of kvm</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getDiskInfo</span>(<span class="params">host_name, detail = <span class="literal">False</span></span>) :</span><br><span class="line">    <span class="keyword">for</span> disk <span class="keyword">in</span> getDiskList(host_name) :</span><br><span class="line">        <span class="keyword">if</span> detail :</span><br><span class="line">            imgDetailInfo(disk)</span><br><span class="line">        <span class="keyword">else</span> :</span><br><span class="line">            imgInfo(disk)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Get VNC port</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getVNCPort</span>(<span class="params">host_name</span>) :</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> isVMRunning(host_name) :</span><br><span class="line">        <span class="keyword">return</span> host_name + <span class="string">&#x27; Not Running!&#x27;</span></span><br><span class="line">    vnc_display_cmd = <span class="string">&#x27;virsh vncdisplay &#x27;</span> + host_name</span><br><span class="line">    vnc_reout = run_cmd_reout(vnc_display_cmd, goOnRun=<span class="literal">True</span>, isOutPut=<span class="literal">False</span>, jumpErr=<span class="literal">True</span>)</span><br><span class="line">    vnc_port = <span class="number">5900</span> + <span class="built_in">int</span>(vnc_reout[(vnc_reout.find(<span class="string">&#x27;:&#x27;</span>) + <span class="number">1</span>) : ])</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">str</span>(vnc_port)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Get MAC address</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getMAC</span>(<span class="params">host_name</span>) :</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> isVMExist(host_name) :</span><br><span class="line">        <span class="keyword">return</span> host_name + <span class="string">&#x27; Not Exist!&#x27;</span></span><br><span class="line">    get_mac_cmd = <span class="string">&quot;virsh dumpxml &quot;</span> + host_name + <span class="string">&quot; | grep &#x27;mac address&#x27; | cut -c 21-37&quot;</span></span><br><span class="line">    <span class="keyword">return</span> run_cmd_reout(get_mac_cmd, goOnRun=<span class="literal">True</span>, isOutPut=<span class="literal">False</span>).strip()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Get ip address</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getIP</span>(<span class="params">host_name</span>) :</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> isVMRunning(host_name) :</span><br><span class="line">        <span class="keyword">return</span> host_name + <span class="string">&#x27; Not Running!&#x27;</span></span><br><span class="line">    host_mac = getMAC(host_name)</span><br><span class="line"></span><br><span class="line">    arp_ip = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    start_time = <span class="built_in">int</span>(time.time())</span><br><span class="line">    <span class="comment"># wait for kvm start finish</span></span><br><span class="line">    <span class="keyword">while</span> (arp_ip == <span class="string">&#x27;&#x27;</span> <span class="keyword">and</span> <span class="built_in">int</span>(time.time()) - start_time &lt; <span class="number">20</span>):</span><br><span class="line">        nmap_cmd = <span class="string">&#x27;nmap -sP --host-timeout 15s &#x27;</span> + sub_ip + <span class="string">&#x27;/24&#x27;</span></span><br><span class="line">        run_cmd_reout(nmap_cmd, goOnRun=<span class="literal">True</span>, isOutPut=<span class="literal">False</span>)</span><br><span class="line">        arp_ip_cmd = <span class="string">&quot;arp -an | grep &#x27;&quot;</span>  + host_mac + <span class="string">&quot;&#x27;&quot;</span></span><br><span class="line">        arp_ip = run_cmd_reout(arp_ip_cmd, goOnRun=<span class="literal">True</span>, isOutPut=<span class="literal">False</span>, jumpErr=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(arp_ip) == <span class="number">0</span> :</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;Get &#x27;</span> + host_name + <span class="string">&#x27; ip address failed! MAC:&#x27;</span> + host_mac</span><br><span class="line">    <span class="keyword">else</span> :</span><br><span class="line">        <span class="keyword">return</span> arp_ip[arp_ip.find(<span class="string">&#x27;(&#x27;</span>) + <span class="number">1</span> : arp_ip.find(<span class="string">&#x27;)&#x27;</span>)]</span><br><span class="line"></span><br><span class="line"><span class="comment"># get specified KVM info, mac, ip and vnc port</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getVMInfo</span>(<span class="params">host_name, isdetail=<span class="literal">False</span></span>) :</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> isVMExist(host_name) :</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;&lt;&lt;&lt; &#x27;</span> + host_name + <span class="string">&#x27; Not Exist! &gt;&gt;&gt;&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;------&#x27;</span> + host_name + <span class="string">&#x27; infomation------&#x27;</span>)</span><br><span class="line">    host_info_cmd = <span class="string">&#x27;virsh dominfo &#x27;</span> + host_name</span><br><span class="line">    run_cmd_reout(host_info_cmd)</span><br><span class="line">    getDiskInfo(host_name, isdetail)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;MAC address: \n&#x27;</span> + getMAC(host_name))</span><br><span class="line">    welcome_print(host_name + <span class="string">&#x27; IP: &#x27;</span> + getIP(host_name) + <span class="string">&#x27;, VNC port: &#x27;</span> + getVNCPort(host_name) +  <span class="string">&#x27; enjoy it!&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Start kvm</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">startVM</span>(<span class="params">host_name</span>) :</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> isVMExist(host_name) :</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;&lt;&lt;&lt; &#x27;</span> + host_name + <span class="string">&#x27; Not Exist! &gt;&gt;&gt;&#x27;</span>)</span><br><span class="line">        listAllKVM()</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">if</span> isVMRunning(host_name) :</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;&lt;&lt;&lt; &#x27;</span> + host_name + <span class="string">&#x27; has Running! &gt;&gt;&gt;&#x27;</span>)</span><br><span class="line">        listAllKVM()</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    start_cmd = <span class="string">&#x27;virsh start &#x27;</span> + host_name</span><br><span class="line">    run_cmd_reout(start_cmd)</span><br><span class="line">    getVMInfo(host_name)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Shutdown kvm</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">shutdownVM</span>(<span class="params">host_name, isforce=<span class="literal">False</span></span>) :</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> isVMExist(host_name) :</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;&lt;&lt;&lt; &#x27;</span> + host_name + <span class="string">&#x27; Not Exist! &gt;&gt;&gt;&#x27;</span>)</span><br><span class="line">        listAllKVM()</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> isVMRunning(host_name) :</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;&lt;&lt;&lt; &#x27;</span> + host_name + <span class="string">&#x27; Not Running! &gt;&gt;&gt;&#x27;</span>)</span><br><span class="line">        listAllKVM()</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    shutdown_cmd = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> isforce :</span><br><span class="line">        shutdown_cmd = <span class="string">&#x27;virsh destroy &#x27;</span> + host_name</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        shutdown_cmd = <span class="string">&#x27;virsh shutdown &#x27;</span> + host_name</span><br><span class="line">    run_cmd_reout(shutdown_cmd)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Set specified KVM to autostart when boot</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">autostartVM</span>(<span class="params">host_name</span>) :</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> isVMExist(host_name) :</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;&lt;&lt;&lt; &#x27;</span> + host_name + <span class="string">&#x27; Not Exist! &gt;&gt;&gt;&#x27;</span>)</span><br><span class="line">        listAllKVM()</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    autostart_cmd = <span class="string">&#x27;virsh autostart &#x27;</span> + host_name</span><br><span class="line">    run_cmd_reout(autostart_cmd)</span><br><span class="line">    <span class="comment"># list all kvm exist status</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Autostart virtual machine list in the following&#x27;</span>)</span><br><span class="line">    run_cmd_reout(<span class="string">&#x27;virsh list --autostart --all&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># disable autostart kvm</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">disableAutostartVM</span>(<span class="params">host_name</span>) :</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> isVMExist(host_name) :</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;&lt;&lt;&lt; &#x27;</span> + host_name + <span class="string">&#x27; Not Exist! &gt;&gt;&gt;&#x27;</span>)</span><br><span class="line">        listAllKVM()</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    autostart_cmd = <span class="string">&#x27;virsh autostart --disable &#x27;</span> + host_name</span><br><span class="line">    run_cmd_reout(autostart_cmd)</span><br><span class="line">    <span class="comment"># list all kvm exist status</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Autostart virtual machine list in the following&#x27;</span>)</span><br><span class="line">    run_cmd_reout(<span class="string">&#x27;virsh list --autostart --all&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Clone kvm from template</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cloneVM</span>(<span class="params">host_name, template</span>) :</span><br><span class="line">    <span class="keyword">if</span> isVMRunning(template) :</span><br><span class="line">        <span class="built_in">print</span>(template + <span class="string">&#x27; must to be shutdown to be clone!&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    clone_cmd = <span class="string">&#x27;virt-clone --force --original=&#x27;</span> + template + <span class="string">&#x27; --name=&#x27;</span> + host_name + <span class="string">&#x27; --file=&#x27;</span> + image_path + host_name + <span class="string">&#x27;.qcow2&#x27;</span></span><br><span class="line">    run_cmd_reout(clone_cmd)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Sysprep kvm</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sysprepVM</span>(<span class="params">new_host_name, old_host_name, miniClear = <span class="literal">False</span></span>) :</span><br><span class="line">    <span class="keyword">if</span> isVMRunning(old_host_name) :</span><br><span class="line">        <span class="built_in">print</span>(old_host_name + <span class="string">&#x27; must to be shutdown to be clone!&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    sysprep_cmd = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> miniClear :</span><br><span class="line">        sysprep_cmd = <span class="string">&#x27;sudo virt-sysprep -d &#x27;</span> + old_host_name + <span class="string">&#x27; --hostname &#x27;</span> + new_host_name + <span class="string">&#x27; --operations customize,dhcp-client-state,dhcp-server-state,machine-id,net-hostname,net-hwaddr&#x27;</span></span><br><span class="line">    <span class="keyword">else</span> :</span><br><span class="line">        sysprep_cmd = <span class="string">&#x27;sudo virt-sysprep -d &#x27;</span> + old_host_name + <span class="string">&#x27; --hostname &#x27;</span> + new_host_name + <span class="string">&#x27; --operations defaults,-ssh-hostkeys&#x27;</span></span><br><span class="line">    run_cmd_reout(sysprep_cmd)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Remove specified vm define</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">undefineVM</span>(<span class="params">host_name, isforce=<span class="literal">False</span></span>) :</span><br><span class="line">    <span class="keyword">if</span> isVMRunning(host_name) :</span><br><span class="line">        shutdownVM(host_name)</span><br><span class="line">    <span class="keyword">if</span> isforce :</span><br><span class="line">        run_cmd_reout(<span class="string">&#x27;virsh destroy &#x27;</span> + host_name)</span><br><span class="line">    undefine_cmd = <span class="string">&#x27;virsh undefine &#x27;</span> + host_name</span><br><span class="line">    run_cmd_reout(undefine_cmd, goOnRun=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Delete specified vm from disk</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">deleteVM</span>(<span class="params">host_name, isforce=<span class="literal">False</span></span>) :</span><br><span class="line">    <span class="keyword">for</span> path <span class="keyword">in</span> getDiskList(host_name) :</span><br><span class="line">        <span class="keyword">if</span> path[<span class="built_in">len</span>(path) - <span class="number">4</span> :] != <span class="string">&#x27;.ISO&#x27;</span> <span class="keyword">or</span> path[<span class="built_in">len</span>(path) - <span class="number">4</span> :] != <span class="string">&#x27;.iso&#x27;</span> :</span><br><span class="line">            delete_cmd = <span class="string">&#x27;sudo rm -rf &#x27;</span> + path</span><br><span class="line">            run_cmd_reout(delete_cmd)</span><br><span class="line">    undefineVM(host_name, isforce)</span><br><span class="line">    <span class="keyword">return</span> (host_name <span class="keyword">not</span> <span class="keyword">in</span> hostNameList())</span><br><span class="line"></span><br><span class="line"><span class="comment"># attach interface to vm</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">addInterface</span>(<span class="params">host_name</span>) :</span><br><span class="line">    addif_cmd = <span class="string">&#x27;virsh attach-interface &#x27;</span> + host_name + <span class="string">&#x27; --type bridge --source br0 --model virtio --persistent&#x27;</span></span><br><span class="line">    run_cmd_reout(addif_cmd)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Originally create kvm from iso image</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">createVM</span>(<span class="params">host_name, ram, vcpu, disk, os_type, iso</span>) :</span><br><span class="line">    <span class="keyword">if</span> isVMExist(host_name) :</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;&lt;&lt;&lt; &#x27;</span> + host_name + <span class="string">&#x27; has exist!&#x27;</span> + <span class="string">&#x27;&gt;&gt;&gt;&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    create_cmd = <span class="string">&#x27;virt-install \</span></span><br><span class="line"><span class="string">            --virt-type=kvm \</span></span><br><span class="line"><span class="string">            --name=&#x27;</span> + host_name + <span class="string">&#x27; \</span></span><br><span class="line"><span class="string">            --ram=&#x27;</span> + <span class="built_in">str</span>(ram) + <span class="string">&#x27; \</span></span><br><span class="line"><span class="string">            --vcpus=&#x27;</span> + <span class="built_in">str</span>(vcpu) + <span class="string">&#x27; \</span></span><br><span class="line"><span class="string">            --os-variant=&#x27;</span> + os_type + <span class="string">&#x27; \</span></span><br><span class="line"><span class="string">            --hvm \</span></span><br><span class="line"><span class="string">            --noautoconsole \</span></span><br><span class="line"><span class="string">            --cdrom=&#x27;</span> + iso + <span class="string">&#x27; \</span></span><br><span class="line"><span class="string">            --network=bridge=br0,model=virtio \</span></span><br><span class="line"><span class="string">            --graphics vnc,listen=0.0.0.0 \</span></span><br><span class="line"><span class="string">            --disk path=&#x27;</span> + image_path + host_name + <span class="string">&#x27;.qcow2,size=&#x27;</span> + <span class="built_in">str</span>(disk) + <span class="string">&#x27;,bus=virtio,format=qcow2&#x27;</span></span><br><span class="line">    run_cmd_reout(create_cmd)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># get key, value of dict from file, # as the comment</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getKeyValue</span>(<span class="params">file_name, sep=<span class="string">&#x27;=&#x27;</span></span>):</span><br><span class="line">    arg_dict = &#123;&#125;</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(file_name, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> text:</span><br><span class="line">        <span class="keyword">for</span> tline <span class="keyword">in</span> text:</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(tline.strip()) != <span class="number">0</span> <span class="keyword">and</span> tline[<span class="number">0</span>] != <span class="string">&#x27;#&#x27;</span>:</span><br><span class="line">                tlink = tline.strip().split(<span class="string">&#x27;#&#x27;</span>)[<span class="number">0</span>].split(sep)</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">len</span>(tlink) &gt; <span class="number">1</span>:</span><br><span class="line">                    arg_dict[tlink[<span class="number">0</span>].strip()] = tlink[<span class="number">1</span>].strip()</span><br><span class="line">    <span class="keyword">return</span> arg_dict</span><br></pre></td></tr></table></figure>

<h2 id="其他遇到的问题"><a href="#其他遇到的问题" class="headerlink" title="其他遇到的问题"></a>其他遇到的问题</h2><p><strong>如何获取通过桥接的DHCP为KVM自动分配的IP</strong><br>创建完虚拟机之后，启动虚拟机，然后通过nmap进行同一子网下的ping扫描，nmap需要手动安装，此时会建立arp缓存，然后通过<code>arp -an</code>查看缓存中的ip与mac的对应关系获得KVM虚拟机IP即可。虚拟机的MAC地址可以通过virsh dumpxml中获得。</p>
<p>通过虚拟机配置文件获得虚拟机的MAC地址：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">virsh dumpxml vm-name|grep <span class="string">&#x27;mac address&#x27;</span>| <span class="built_in">cut</span> -c 21-37`</span></span><br></pre></td></tr></table></figure>

<p>安装nmap：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo apt-get install nmap</span></span><br></pre></td></tr></table></figure>

<p>使用nmap扫描同一子网下的所有ip：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">nmap -sP 192.168.1.0/24</span></span><br></pre></td></tr></table></figure>
<p>通过查询arp缓存，找到MAC地址对应的虚拟机IP：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">arp -an | grep hostmac</span></span><br></pre></td></tr></table></figure>
<p>上面的脚本中都详细的代码实现</p>
<p><strong>可能引起本机git无法正常使用的问题</strong><br>桥接网卡后发现git无法使用，错误提示类似这样：nutls_handshake() failed GIT repository，重新编译一下git就可以了，参见这里：<a href="http://devopscube.com/gnutls-handshake-failed-aws-codecommit/">http://devopscube.com/gnutls-handshake-failed-aws-codecommit/</a></p>
<p><strong>如何为KVM虚拟机增加网卡</strong><br>使用virsh attach-interface命令可以为虚拟机testbr动态永久增加一个virtio驱动的bridge网卡：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">virsh attach-interface testbr --<span class="built_in">type</span> bridge --<span class="built_in">source</span> br0 --model virtio --persistent</span></span><br></pre></td></tr></table></figure>
<p>如果不加最后一下参加–persistent，就只在当前虚拟机状态下生效，重启后会消失</p>
<p>通过以下命令查看虚拟机所具有的网卡及相应的mac：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">virsh domiflist testbr</span></span><br></pre></td></tr></table></figure>

<p>增加网卡后在虚拟机里通过以下命令查看所有网络设备：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ifconfig -a</span></span><br></pre></td></tr></table></figure>
<p>输出中会多出一个网络设备就是你刚刚新增加的，默认情况下它并没有启动<br>可以通过修改<code>/etc/network/interfaces</code>，在其中照着原有的网卡追加新网卡的信息后重启网络设备即可<br>例如我增加的新网卡名称为ens7，我的网络配置文件修改如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">This file describes the network interfaces available on your system</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">and how to activate them. For more information, see interfaces(5).</span></span><br><span class="line"></span><br><span class="line">source /etc/network/interfaces.d/*</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">The loopback network interface</span></span><br><span class="line">auto lo</span><br><span class="line">iface lo inet loopback</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">The primary network interface</span></span><br><span class="line">auto ens3</span><br><span class="line">iface ens3 inet dhcp</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">The primary network interface</span></span><br><span class="line">auto ens7</span><br><span class="line">iface ens7 inet dhcp</span><br></pre></td></tr></table></figure>
<p>然后重启网络服务：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo systemctl restart networking.service</span></span><br></pre></td></tr></table></figure>

<p>再来查看已经启用的网络设备会发现多了一块网卡，并且有了IP：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ifconfig</span></span><br></pre></td></tr></table></figure>

<p>以下命令永久删除一个指定mac地址的网卡：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">virsh detach-interface testbr --<span class="built_in">type</span> bridge --mac 52:54:00:74:39:e4 --persistent</span></span><br></pre></td></tr></table></figure>
<p>同样–persistent具有控制是否永久生效的效果</p>
<p><strong>如何为KVM虚拟机增加一块硬盘</strong><br>查看当前KVM虚拟机所有的磁盘信息：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">virsh domblklist testbr --details</span></span><br><span class="line">Type       Device     Target     Source</span><br><span class="line">------------------------------------------------</span><br><span class="line">file       disk       vda        /home/blueyi/vhost/image/testbr.qcow2</span><br><span class="line">file       disk       vdb        /mnt/data/addDisk/testbr-1.qcow2</span><br><span class="line">file       cdrom      hda        -</span><br></pre></td></tr></table></figure>

<p>查看某一块磁盘的大小等信息：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">qemu-img info /mnt/data/addDisk/testbr-1.qcow2</span></span><br><span class="line">image: /mnt/data/addDisk/testbr-1.qcow2</span><br><span class="line">file format: qcow2</span><br><span class="line">virtual size: 10G (10737418240 bytes)</span><br><span class="line">disk size: 196K</span><br><span class="line">cluster_size: 65536</span><br><span class="line">Format specific information:</span><br><span class="line">    compat: 1.1</span><br><span class="line">    lazy refcounts: false</span><br><span class="line">    refcount bits: 16</span><br><span class="line">    corrupt: false</span><br></pre></td></tr></table></figure>

<p>创建一块新的磁盘10G大小，格式为qcow2，后面将其增加给某个虚拟机：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">qemu-img create -f qcow2 testbr-1.qcow2 10G</span></span><br><span class="line">Formatting &#x27;testbr-1.qcow2&#x27;, fmt=qcow2 size=10737418240 encryption=off cluster_size=65536 lazy_refcounts=off refcount_bits=16</span><br></pre></td></tr></table></figure>

<p>将刚刚创建的磁盘追加给虚拟机testbr，在虚拟机中其设备名称为vdb：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">virsh attach-disk testbr --<span class="built_in">source</span> /mnt/data/addDisk/testbr-1.qcow2 --target vdb --subdriver qcow2 --targetbus virtio --persistent</span></span><br><span class="line">Disk attached successfully</span><br></pre></td></tr></table></figure>

<p>移除虚拟机上的某个磁盘：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">virsh detach-disk testbr vdb --persistent</span></span><br><span class="line">Disk detached successfully</span><br></pre></td></tr></table></figure>

<p>剩下的就是进虚拟机里面进行格式化挂载了</p>
<p><strong>为虚拟机最小化安装桌面</strong><br>安装ubuntu自带的unity桌面：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo apt-get install --no-install-recommends ubuntu-desktop</span></span><br></pre></td></tr></table></figure>

<p>如果需要使用ubuntu桌面版中带的那个terminal和system-monitor，安装如下2个包：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo apt-get intall gnome-terminal gnome-system-monitor</span></span><br></pre></td></tr></table></figure>

<p>如果需要安装轻量级的xfce桌面：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo apt-get install --no-install-recommends xfce4</span></span><br></pre></td></tr></table></figure>
<p>然后同理安装所需要的其他桌面组件，只不过是以xfce4开头的</p>
<p>gnome系桌面的命令行注销：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gnome-session-quit --no-prompt</span></span><br></pre></td></tr></table></figure>

<p>xfce4系注销命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">xfce4-session-quit -l</span></span><br></pre></td></tr></table></figure>

<p><strong>为KVM增加storage pool</strong><br>如果你按照上面的方式遇到错误提示：ERROR  Format cannot be specified for unmanaged storage.是因为你指向的磁盘文件所有硬盘分区没有指定为libvirt的存储池，将你想要存放的虚拟机路径所在目录加入pool管理即可，默认情况下/var/lib/libvirt/images是在pool中的。<br>假如我现在想将我的虚拟机磁盘文件放在/home/blueyi/vhost/image目录下，那么我需要首先定义一个pool：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">virsh pool-define-as --name vhost-image --<span class="built_in">type</span> <span class="built_in">dir</span> --target /home/blueyi/vhost/image</span></span><br><span class="line">Pool vhost-image marked as autostarted</span><br></pre></td></tr></table></figure>
<p>上面的命令表示定义一个名为vhost-image的pool，指定目录/home/blueyi/vhost/image</p>
<p>然后启动这个pool就可以使用它了：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">virsh pool-start vhost-image</span></span><br><span class="line">Pool vhost-image started</span><br></pre></td></tr></table></figure>

<p>现在再执行virt-install就不会再报那个Format cannot be specified for unmanaged storage的错误了，其实还一种方法就是直接不使用后面那个format参数，这样会自动创建一个raw格式的文件作为虚拟机硬盘文件。</p>
<p>添加开机后自动启动这个pool：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">virsh pool-autostart vhost-image</span></span><br><span class="line">Pool vhost-image marked as autostarted</span><br></pre></td></tr></table></figure>

<p>查看机器中的所有pool列表：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">virsh pool-list --all</span></span><br><span class="line"> Name                 State      Autostart </span><br><span class="line">-------------------------------------------</span><br><span class="line"> default              active     yes       </span><br><span class="line"> vhost-image          inactive   no  </span><br></pre></td></tr></table></figure>

<p>查看某一个pool的信息：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">virsh pool-info vhost-image</span></span><br><span class="line">Name:           vhost-image</span><br><span class="line">UUID:           ce7b6f65-889e-456d-b70b-46422247099e</span><br><span class="line">State:          running</span><br><span class="line">Persistent:     yes</span><br><span class="line">Autostart:      no</span><br><span class="line">Capacity:       49.54 GiB</span><br><span class="line">Allocation:     29.68 GiB</span><br><span class="line">Available:      19.86 GiB</span><br></pre></td></tr></table></figure>

<p>查看某一个pool的配置详情：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">$ virsh pool-dumpxml vhost-image</span><br><span class="line"><span class="tag">&lt;<span class="name">pool</span> <span class="attr">type</span>=<span class="string">&#x27;dir&#x27;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>vhost-image<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">uuid</span>&gt;</span>ce7b6f65-889e-456d-b70b-46422247099e<span class="tag">&lt;/<span class="name">uuid</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">capacity</span> <span class="attr">unit</span>=<span class="string">&#x27;bytes&#x27;</span>&gt;</span>53189636096<span class="tag">&lt;/<span class="name">capacity</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">allocation</span> <span class="attr">unit</span>=<span class="string">&#x27;bytes&#x27;</span>&gt;</span>31866744832<span class="tag">&lt;/<span class="name">allocation</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">available</span> <span class="attr">unit</span>=<span class="string">&#x27;bytes&#x27;</span>&gt;</span>21322891264<span class="tag">&lt;/<span class="name">available</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">source</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">target</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">path</span>&gt;</span>/home/blueyi/vhost/image<span class="tag">&lt;/<span class="name">path</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">permissions</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">mode</span>&gt;</span>0711<span class="tag">&lt;/<span class="name">mode</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">owner</span>&gt;</span>-1<span class="tag">&lt;/<span class="name">owner</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">group</span>&gt;</span>-1<span class="tag">&lt;/<span class="name">group</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">permissions</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">pool</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>当然也可以将pool的xml文件导出，然后通过xml文件定义或启动一个pool<br>更多详情可以通过<code>man virt-install</code>查看pool相关内容。</p>
<p><strong>virt-install安装后虚拟机处于pause状态，且无法resume</strong><br>查看libvirtd服务有如下错误提示：<code>internal error: unable to execute QEMU command &#39;cont&#39;: Resetting the Virtual</code><br>请一定认真查看当前准备安装的虚拟机配置文件是否有问题，例如我当时把内存设置成了1M，误以为是1GB，结果出这个错误。刚开始以为宿主的KVM没有配好，后来才发现是虚拟机安装命令输入错误</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>KVM</tag>
        <tag>OpenStack</tag>
      </tags>
  </entry>
  <entry>
    <title>Java学习笔记之面向对象</title>
    <url>/2016/11/03/java-study-notes-oop/</url>
    <content><![CDATA[<p>主要是记录Java中与C++不同的地方，快速浏览，参考书是《Java核心技术 卷I》<br>Java 8 SE API：<a href="https://docs.oracle.com/javase/8/docs/api/">https://docs.oracle.com/javase/8/docs/api/</a></p>
<span id="more"></span>
<p>1.Java中，任何对象变量的值都是对存储在另外一个地方的一个对象的引用，也就是说Java中的对象实现上并不包含其对象本身，而只是指向一个别处的对象，类似于C++中的对象指针，与C++中的引用不同，C++中引用不能被赋值，创建时必须初始化。如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Date birthday;   <span class="comment">//java</span></span><br></pre></td></tr></table></figure>
<p>类似于C++中的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Date *birthday;  <span class="comment">//c++</span></span><br></pre></td></tr></table></figure>
<p>而java中的对象可以只创建不初始化，而在创建后使用new进行初始化，或者将其赋值为null。当然不初始化之类的变量无法使用。</p>
<h2 id="Java内置类"><a href="#Java内置类" class="headerlink" title="Java内置类"></a>Java内置类</h2><p>2.Java类库中包含了大量实用的类，例如表示日期和时间的GregorianCalendar类（java.util.GregorianCalendar）。Date类表示一个特定的时间，即用距离一个固定时间（纪元 1970,01,01,00:00:00）的毫秒数表示。而GregorianCalendar类是用日历表示时间，一个<code>new GregorianCalendar()</code>对象表示对象构造时的日期和时间，或者表示某个特定的日期：<code>new GregorianCalendar(1999,11,31);//表示12月，因为月份从0开始</code>，或者使用常量并将其存储在对象变量中：<code>GregorianCalendar deadline = new GregorianCalendar(1999, Calendar.DECEMBER, 32, 23, 59, 59);</code></p>
<p>3.GregorianCalendar类中包含了大量用于操作日期和时间的函数，其中get方法和set方法是最常用的，分别用于获取和设置其对象中的相应时间值，包括年、月、日，而Calendar类中定义了一些日期相关的常量，可用于表达希望从GregorianCalendar对象中的项，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">GregorianCalendar</span> <span class="variable">now</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GregorianCalendar</span>();</span><br><span class="line"><span class="type">int</span> <span class="variable">month</span> <span class="operator">=</span> now.get(Calendar.MONTH);  <span class="comment">//获取月份</span></span><br><span class="line"><span class="type">int</span> <span class="variable">weekday</span> <span class="operator">=</span> now.get(Calendar.DAY_OF_WEEK);  <span class="comment">//获取周天</span></span><br><span class="line"><span class="comment">//使用set</span></span><br><span class="line">now.set(Calendar.YEAR, <span class="number">2016</span>);</span><br><span class="line">now.set(Calendar.MONTH, Calendar.APRIL);</span><br><span class="line">now.set(Calendar.DAY_OF_MONTH, <span class="number">15</span>);</span><br><span class="line"><span class="comment">//使用add来为日期增加天数</span></span><br><span class="line">now.add(Calendar.MONTH, <span class="number">6</span>);  <span class="comment">//当时日期向后移6个月，可以是负数，表示前移</span></span><br></pre></td></tr></table></figure>

<p>java中类似get仅访问实例域而不进行修改的方法称为访问器方法（accessor method），类似set的对实例域做出修改的方法称为更改器方法（mutator method）。类似C++中带有const后缀的方法是访问器方法，默认为更改器方法。但java中这两类方法语法上没有明显区别。通过的习惯是访问器方法名前面加上前缀get，更改器方法前面加上前缀set，例如</p>
<p>4.GregorianCalendar类的getTime方法和setTime方法，可以用来获得和设置日历对象所表示的时间点，利用它们可以实现Date类内容与GregorianCalendar类的转换，因为Date类不知道如何操作日历。例如，假定已知年、月、日并希望创建一个包含这个时间值的Date对象，就可以先创建一个GregorianCalendar对象，然后调用getTime方法获得Date对象时间：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//通过年、月、日创建Date对象</span></span><br><span class="line"><span class="type">GregorianCalendar</span> <span class="variable">calendar</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GregorianCalendar</span>(year, month, day);</span><br><span class="line"><span class="type">Date</span> <span class="variable">time</span> <span class="operator">=</span> clanedar.getTime();</span><br><span class="line"><span class="comment">//获取Date对象中的年、月、日</span></span><br><span class="line">calendar.setTime(time);</span><br><span class="line"><span class="type">int</span> <span class="variable">year</span> <span class="operator">=</span> calendar.get(Calendar.YEAR);</span><br></pre></td></tr></table></figure>

<p>5.下面这个例子将打印输出当前月的日历，支持指定以周几为一周的第一天，并在当前日期后面加个*号标记：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;  <span class="comment">//用于输出及时间相关类</span></span><br><span class="line"><span class="keyword">import</span> java.text.DateFormatSymbols;  <span class="comment">//用于获取时间格式的字符串表示形式</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CalendarTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//Locale.setDefault(Locale.CHINA);  //设置地区为中国，这样会以星期-、星期二...的方式显示</span></span><br><span class="line">        <span class="comment">//创建当前日期</span></span><br><span class="line">        <span class="type">GregorianCalendar</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GregorianCalendar</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">today</span> <span class="operator">=</span> d.get(Calendar.DAY_OF_MONTH);</span><br><span class="line">        <span class="type">int</span> <span class="variable">month</span> <span class="operator">=</span> d.get(Calendar.MONTH);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将日期设置为当月的第一天，并获取这一天为周几</span></span><br><span class="line">        d.set(Calendar.DAY_OF_MONTH, <span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">weekday</span> <span class="operator">=</span> d.get(Calendar.DAY_OF_WEEK);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//获取当前时区下每周的第一天为周几</span></span><br><span class="line">        <span class="comment">//int firstDayOfWeek = d.getFirstDayOfWeek();  //根据地区设定</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">firstDayOfWeek</span> <span class="operator">=</span> <span class="number">2</span>;  <span class="comment">//强制修改为周一为第一天</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//确定打印日历的第一行所需要的缩进</span></span><br><span class="line">        <span class="comment">//通过将当前日期减-1，直到当前日期为本周的第一天停止</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">indent</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (weekday != firstDayOfWeek)</span><br><span class="line">        &#123;</span><br><span class="line">            indent++;</span><br><span class="line">            d.add(Calendar.DAY_OF_MONTH, -<span class="number">1</span>);</span><br><span class="line">            weekday = d.get(Calendar.DAY_OF_WEEK);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//打印第一行的周名称</span></span><br><span class="line">        <span class="comment">//此时d中存储的周日期即为本周的第一天，所以通过将其日期加1，逐个打印即可</span></span><br><span class="line">        String[] weekdayNames = <span class="keyword">new</span> <span class="title class_">DateFormatSymbols</span>().getShortWeekdays();  <span class="comment">//获取一周的每天的缩写</span></span><br><span class="line">        <span class="keyword">do</span> </span><br><span class="line">        &#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;%4s&quot;</span>, weekdayNames[weekday]);   <span class="comment">//每个周名称占4个字符空间</span></span><br><span class="line">            d.add(Calendar.DAY_OF_MONTH, <span class="number">1</span>);</span><br><span class="line">            weekday = d.get(Calendar.DAY_OF_WEEK);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (weekday != firstDayOfWeek);</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="comment">//打印日期</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; indent; ++i)</span><br><span class="line">            System.out.print(<span class="string">&quot;    &quot;</span>);</span><br><span class="line">        d.set(Calendar.DAY_OF_MONTH, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">day</span> <span class="operator">=</span> d.get(Calendar.DAY_OF_MONTH);</span><br><span class="line">            System.out.printf(<span class="string">&quot;%3d&quot;</span>, day);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//将当前日期后面使用*标记</span></span><br><span class="line">            <span class="keyword">if</span> (day == today) System.out.print(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span> System.out.print(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//将日期指向下一天</span></span><br><span class="line">            d.add(Calendar.DAY_OF_MONTH, <span class="number">1</span>);</span><br><span class="line">            weekday = d.get(Calendar.DAY_OF_WEEK);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//新的一周开始时换行</span></span><br><span class="line">            <span class="keyword">if</span> (weekday == firstDayOfWeek) System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (d.get(Calendar.MONTH) == month);  <span class="comment">//当月份变成下个月时退出循环</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//如果最后当前d中的日期不是一周的第一天，则需要换行</span></span><br><span class="line">        <span class="keyword">if</span> (weekday != firstDayOfWeek) System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>6.java.util.GregorianCalendar的API中包含大量日期时间相关的方法，java.text.DateFormatSymbols包的API中包含很多关于日期的字符串表示形式，如获得当前地区的星期几或月份的名称缩写等：<code>String[] getShortWeekdays(); String[] getShortMonths()</code></p>
<h2 id="自定义类"><a href="#自定义类" class="headerlink" title="自定义类"></a>自定义类</h2><p>1.java中文件名必须与public修饰的类名相同，一个文件中只能有一个public类，但可以有任意数目非公有类。如果将2个类放在不同的文件中，且公有类使用了另一个类，例如文件名都有前缀Employ，则可以这样编译：<code>javac Employ*.java</code>。或者直接使用javac编译那个公有类，当时java编译器发现这个类引用了另一个类时，会去查找其class文件，如果没有找到，或者发现其java文件较已有的class文件版本新，java编译器就会自动地重新编译这个文件。使用java解释器运行时，只需指定带有main方法的公有类的class文件即可。<br>当一个文件中有两个不同的类的时候，编译之后会生成两个类名的class文件，将带有main方法的class传递给java解释器运行即可。如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmployeeTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Employee</span> <span class="variable">blueyi</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="string">&quot;blueyi&quot;</span>, <span class="number">27</span>);</span><br><span class="line">        System.out.println(blueyi.getName() + <span class="string">&quot; : &quot;</span> + blueyi.getAge());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Employee</span><span class="params">(String n, <span class="type">int</span> a)</span>  <span class="comment">//构造函数</span></span><br><span class="line">    &#123;</span><br><span class="line">        name = n;</span><br><span class="line">        age = a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">       <span class="keyword">return</span> name; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">       <span class="keyword">return</span> age; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译之后将会有一个EmployeeTest.class文件和Employee.class文件</p>
<p>2.Java构造器的工作方式与C++一样，但java中的对象都是在堆中构造的，所以必须与new操作符一起使用。不能在构造器中定义与实例域重名的局部变量。</p>
<p>3.java中类方法的第一个参数也是隐的this，但这个this是类对象，而不是指针。java的所有类方法都必须在类的内部定义，而不能像C++那个类外定义。</p>
<p>4.不要编写返回引用可变对象的访问器方法，由于java中返回的对象默认是引用，所以使用访问器返回的引用会修改原私有数据，可以通过返回克隆的方法进行数据域的拷贝，这样就可以保护原对象中的私有数据：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span> Date <span class="title function_">getHireDay</span><span class="params">()</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> hireDay.clone();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法可以访问所属类的所有对象的私有数据</p>
<p>5.final实例域，可以使用final修鉓类中的实例域，被final修饰的数据必须在构造器中设置，并且在后面的操作中不能对它修改，final修饰符大都应用于基本（primitive）类型域，或不可变（immutable）类的域，如String类，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>6.java中的static作用与C++中的类似，表示属于类且不属于类对象的变量和方法。由于static方法没有隐式的this对象，所以不能方法对象的非static方法及数据，但可以访问该类的其他static域。static方法调用与C++不同的是直接使用.运算符，而不是::，如：<code>Math.pow</code></p>
<p>7.可以通过为每一个类添加一个main方法用于单元测试该类的功能，例如StaticTest类名与文件名相同，其中又包含了一个名为Employee的类，例如两个类中都有main方法，那么运行：<code>java Employee</code>和java StaticTest将执行两个不同的main方法。</p>
<p>8.java中的函数参数传递方式都是按值调用。只是当传递的是对象的时候，传递的是对象的引用的拷贝（即实际上还是按值传递），所以可以通过方法修改对象，但却不能修改基本数据类型的参数。实际上C++中当向函数传递一个指针的时候传递也是指针的拷贝。总结来说java中的方法参数使用情况：</p>
<ul>
<li>一个方法不能修改一个基本数据类型的参数（即数值型和布尔型）。</li>
<li>一个方法可以改变一个对象参数的状态。（即可以通过方法修改对象中的参数）</li>
<li>一个方法不能让对象参数引用一个新的对象。（即不能通过向方法传递2个对象来交换它们）</li>
</ul>
<p>9.Java支持函数重载，如果类的域没有在构造器中显式地赋予初值，则会被自动地赋为默认值：数值为0、布尔值为false、对象引用为null。但同样建议要手动进行初始值初始化。</p>
<p>10.只有当类没有提供任何构造函数时，编译器才会提供一个默认的无参数构造函数。如果提供了一个有参数的构造函数，则此时不会提供无参数的构造函数，调用new创建对象调用无参数数构造器时就会在编译时报错。</p>
<p>11.Java中会在执行构造器之前，先执行赋值操作，所以可以通过下面的方式对域进行初始化：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> nextId;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> assignId();</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">assignId</span><span class="params">()</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> nextId;</span><br><span class="line">    nextId++;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>12.构造器的实例域在命名时可以加上前缀来区分，或者实例域使用原名字，而通过在构造器的内部使用this来引用类变量的方式赋值：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Employee</span><span class="params">(String aName, <span class="type">double</span> aSalary)</span></span><br><span class="line">&#123;</span><br><span class="line">  name = aName;</span><br><span class="line">  salary = aSalary;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Employee</span><span class="params">(String name, <span class="type">double</span> salary)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="built_in">this</span>.salary = salary;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>13.可以通过this在一个构造器中调用另一个构造器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Employ</span><span class="params">(<span class="type">double</span> s)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//call Employee(String, double)</span></span><br><span class="line">  <span class="built_in">this</span>(<span class="string">&quot;Employee #&quot;</span> + nextId, s);</span><br><span class="line">  nextId++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>14.除了可以通过在构造器在设置值和在声明中赋值来进行初始化数据域外，还可以通过初始化块（initialization block）来构造类的对象，只要构造类的对象，这些初始化块就会被执行。如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Employee</span><br><span class="line">&#123;</span><br><span class="line">  private static nextId;</span><br><span class="line">  private int id;</span><br><span class="line">  private String name;</span><br><span class="line">  // object initialization block</span><br><span class="line">  &#123;</span><br><span class="line">    id = nextId;</span><br><span class="line">    nextId++;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public Employee(String n, int i)</span><br><span class="line">  &#123;</span><br><span class="line">    name = n;</span><br><span class="line">    id = i;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>15.初始化数据域有多种途径，调用顺序如下：</p>
<ul>
<li>所有数据域被初始化为默认值：0、false或null</li>
<li>按照在类声明中出现的次序，依次执行所有域初始化语句和初始化块</li>
<li>如果构造器第一行调用了第二个构造器，则执行第二个构造器的主体</li>
<li>执行这个构造器的主体</li>
</ul>
<p>16.也可以将初始化块标记为静态域，在类的第一次加载的时候，将进行静态域的初始化：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hello</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">static</span></span><br><span class="line">  &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Hello, World&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行这段程序将打印输出Hello, World，而无需main方法。</p>
<p>17.java中有垃圾回收来自动处理内存回收问题，而无需析构函数，但可以添加finalize方法，finalize方法将在垃圾回收器清除对象之前调用。</p>
<h2 id="包"><a href="#包" class="headerlink" title="包"></a>包</h2><p>java中使用包（package）将类组织起来，标准的java类库分布在多个包中，包括java.lang、java.util和java.net等，都具有一个层次结构。使用包主要是确保类名的唯一性，Sun公司建议将公司的互联网域名以逆序的形式作为包名，并且对于不同的项目使用不同的子包。例如我的域名maxwi.com，逆序就是com.maxwi，如果笔记作为一个包就是com.maxwi.notes。有点类似于C++中的命名空间</p>
<h3 id="类的导入"><a href="#类的导入" class="headerlink" title="类的导入"></a>类的导入</h3><p>1.一个类可以使用所属包中的所有类，以及其他包中的公有类（public class），有两种方式使用另一包中的公有类，一种是使用完整的包名，如：<code>java.util.Date today = new java.util.Date();</code>，另一种是使用import，impot即可以一次导入一个特定的类，也可以导入整个包，import应该位于源文件的顶部，但位于package语句的后面：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*; <span class="comment">//导入java.util包中的所有的类</span></span><br><span class="line"><span class="keyword">import</span> java.util.Date;  <span class="comment">//导入Date类</span></span><br></pre></td></tr></table></figure>

<p>2.如果导入的2个包都同时含有同一个类，则会出现编译错误，可以通过添加一个特定的import来指定使用哪个类来解决：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.sql.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Date; <span class="comment">//util和sql中都包含有类Date</span></span><br></pre></td></tr></table></figure>
<p>当需要使用sql中的类Date时，可以直接使用完整的包名来引用 </p>
<p>3.import也可以用来导入静太方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.System.*;</span><br><span class="line">out.println(<span class="string">&quot;Hi&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="包的使用"><a href="#包的使用" class="headerlink" title="包的使用"></a>包的使用</h3><p>如果不手动指定文件中的类所属的包的话，会默认在default包中<br>4.想将类放入包中只需要在文件的开头使用package加上包名即可，此时要注意类文件必须在以包名指定的以.分隔的路径下，如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.maxwi.notes;  <span class="comment">//表示该类将在路径com/maxwi/notes/Employee.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Employee</span></span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译方法是在包的根目录或者同一个目录下的其他子目录，中使用另一个java文件调用该类，然后编译这个调用类的文件即可：<br>类Employee路径com/maxwi/notes/Employee.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.maxwi.notes;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Employee</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Employee</span><span class="params">(String n, <span class="type">int</span> a)</span> &#123;</span><br><span class="line">        name = n;</span><br><span class="line">        age = a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类TestEmployee所在路径：com/testEmployee/TestEmployee.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.testEmployee;</span><br><span class="line"><span class="keyword">import</span> com.maxwi.notes.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestEmployee</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Employee</span> <span class="variable">blueyi</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="string">&quot;blueyi&quot;</span>, <span class="number">27</span>);</span><br><span class="line">        System.out.println(blueyi.getName() + <span class="string">&quot; : &quot;</span> + blueyi.getAge());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要从根目录编译带有main方法的类</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">javac com/testEmployee/TestEmployee.java</span><br></pre></td></tr></table></figure>
<p>运行只需要在根目录下执行带包的类名即可，解释器会自动查找目录下的class文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">java com.testEmployee.TestEmployee</span><br></pre></td></tr></table></figure>
<p>目录结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">E:.</span><br><span class="line">└───com</span><br><span class="line">    ├───maxwi</span><br><span class="line">    │   └───notes</span><br><span class="line">    │           Employee.class</span><br><span class="line">    │           Employee.java</span><br><span class="line">    │</span><br><span class="line">    └───testEmployee</span><br><span class="line">            TestEmployee.class</span><br><span class="line">            TestEmployee.java</span><br></pre></td></tr></table></figure>

<p>5.被public修饰的部分可以被任意的类使用，被private修饰的部分只能被定义它的类使用，而没有指定public或private的部分（类、方法或变量）可以被同一个包中的所有方法访问。</p>
<p>6.类路径必须与包名匹配，另外类文件也可以存储在JAR（Java归档）文件中，JAR文件就是包含目录结构的java文件，为了使类能够被多个程序共享，首先必须将类以包名指定的目录结构存放，或者直接是一个JAR文件中，然后将其加入到类路径（class path）中，类路径就是包含类文件的路径的集合，类路径默认不包含不当前路径，即点，所以通常也要将当前目录加入类路径。UNIX环境中类路径以:分隔，windows下以分号;分隔。在编译时通过选项<code>-classpath</code>或<code>-cp</code>来指定类路径：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">java -classpath /home/usr/classdir:.:/home/usr/archive/archive.jar  MyProg # linux系统</span><br></pre></td></tr></table></figure>
<p>或者通过设置CLASSPATH环境变量的方法来实现。</p>
<h3 id="javadoc注释"><a href="#javadoc注释" class="headerlink" title="javadoc注释"></a>javadoc注释</h3><p>可以在源文件中使用/<em>*….</em>/进行文档注释，然后使用javadoc工具生成html类型的类文档，文档注释应该放在所描述特性的前面，例如类前面，类方法前面等，注释文档中可以有以@开始的标记，如@author、@param、@return等，或者是自由格式文本，也可以包含html标签用于强调等，如<code>&lt;em&gt;...&lt;/em&gt;</code></p>
<p>类注释必须放在import语句之后，类定义之前</p>
<p>生成javadoc：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">javadoc -d docDirectory nameOfPackage  #对包生成</span><br><span class="line">javadoc -d docDirectory *.java #对java文件生成，如果省略-d docDirectory选项，会默认生成在当前目录</span><br></pre></td></tr></table></figure>

<h3 id="类设计技巧"><a href="#类设计技巧" class="headerlink" title="类设计技巧"></a>类设计技巧</h3><ul>
<li>一定要保证数据私有</li>
<li>一定要对数据初始化</li>
<li>不要在类中使用过多的基本类型</li>
<li>不是所有的域都需要独立的域访问器或域更改器</li>
<li>将职责过多的类进行分解</li>
<li>类名和方法名要能够体现它们的职责</li>
</ul>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><h3 id="类与子类"><a href="#类与子类" class="headerlink" title="类与子类"></a>类与子类</h3><p>1.反射（reflection）是指在程序运行期间发现更多的类及其属性的能力。<br>2.Java中的继承是使用关键字extends代替C++中的冒号（:）。在java中，所有的继承都是公有继承，而没有C++中的私有继承和保护继承。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Manager</span> <span class="keyword">extends</span> <span class="title class_">Employee</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">double</span> bonus;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBonus</span><span class="params">(<span class="type">double</span> b)</span></span><br><span class="line">  &#123;</span><br><span class="line">    bonus = b;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3.派生类不能够直接访问超类（父类）的私有域，需要借助关键字super，同样派生类的构造函数也不能直接调用超类的构造函数，需要借助super关键字。例如定义Manager的getSalary方法时需要调用其父类的方法返回值+其bonus参数后返回，则需要如下方法调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getSalary</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">double</span> <span class="variable">baseSalary</span> <span class="operator">=</span> <span class="built_in">super</span>.getSalary(); <span class="comment">//相当于C++中的Employee::getSalary();</span></span><br><span class="line">  <span class="keyword">return</span> baseSalary + bonus;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>构造器的应用如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Manager</span><span class="params">(String n, <span class="type">double</span> s, <span class="type">int</span> year, <span class="type">int</span> month, <span class="type">int</span> day)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">super</span>(n, s, year, month, day);</span><br><span class="line">  bonus = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相当于C++中的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Manager::<span class="built_in">Manager</span>(std::string n, <span class="type">double</span> s, <span class="type">int</span> year, <span class="type">int</span> month, <span class="type">int</span> day) : <span class="built_in">Employee</span>(n, s, year, month, day)</span><br><span class="line">&#123;</span><br><span class="line">  bonus = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在java中，不需要将方法声明为虚方法，动态绑定是默认发生的，即父类定义的变量可以调用子类对象中的方法。java中的对象变量都是多态的，一个父类变量即可以引用其父类对象，也可以引用其任意一个子类的任何对象。但父类的引用不能赋给子类变量（与C++的多态类似）。如果不希望让一个方法具有虚拟特征，可以将它标记为final。</p>
<p>4.final修饰的类将不允许被继承，当类中的方法被声明为final时，则该方法在子类中就不能被覆盖。final类中的所有方法都自动地被成为final方法。</p>
<p>5.可以通过instanceof运算符在进行类型转换之前测试是否可以转换：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (x <span class="keyword">instanceof</span> C)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">C</span> <span class="variable">ax</span> <span class="operator">=</span> (C) x;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>6.包含一个或多个抽象方法的类必须被声明为抽象的，类即使不含抽象方法，也可以将类声明为抽象类。抽象类不能被实例化，即使用abstract修饰的类不能创建其类对象，但可以创建一个抽象类的对象变量，并用它引用非抽象子类的对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Person</span> <span class="comment">//抽象类</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title function_">getDescription</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;blueyi&quot;</span>, <span class="number">22</span>); <span class="comment">//抽象类对象p引用其子类的对象</span></span><br></pre></td></tr></table></figure>

<p>7.Java中的访问保护：</p>
<ul>
<li>private–仅对本类可见</li>
<li>public–对所有类可见</li>
<li>protected–对本包和所有子类可见</li>
<li>默认，不加修饰符–对本包可见  </li>
</ul>
<h3 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h3>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>notes</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java学习笔记之基础语法</title>
    <url>/2016/10/03/java-study-notes-basic/</url>
    <content><![CDATA[<p>主要是记录Java中与C++不同的地方，快速浏览，参考书是《Java核心技术 卷I》<br>Java 8 SE API：<a href="https://docs.oracle.com/javase/8/docs/api/">https://docs.oracle.com/javase/8/docs/api/</a></p>
<span id="more"></span>
<h2 id="HelloWorld"><a href="#HelloWorld" class="headerlink" title="HelloWorld"></a>HelloWorld</h2><p>1.Java中类名的命名方法通常采用驼峰法（CamelCase），java源代码的文件名必须与公共类的名字相同，并以.java作为扩展名。<br>2.Java的运行需要有java虚拟机JVM，使用<code>javac Hello.java</code>将java源代码编译成Hello.class文件，使用<code>java Hello</code>来让JVM加载Hello.class中的内容并执行。JVM的执行入口是java中的main方法，main方法同样需要在一个类中，并且main需要是public的静态方法。下面是一个HelloWorld程序：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorld</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Hello world!&quot;</span>);  <span class="comment">//println默认输出结尾有换行，print输出结尾没有换行</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3.Java中的所有函数都属于某个类的方法（称为类方法而不是成员函数），java的main方法为void，即没有返回值，如果java程序正常退出，则退出代码为0，如果想返回其他退出值，需要调用<code>System.exit()</code>，该函数的参数即为指定的java程序返回值。</p>
<p>4.Java中注释与C++一样，但<code>/*...*/</code>不支持嵌套，并增加了一种<code>/**...*/</code>的注释方式，这种注释可以自动生成文档</p>
<h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><p>5.Java中的基本数据类型有4类，8种：<br><strong>整型：</strong></p>
<table>
<thead>
<tr>
<th>类型</th>
<th>占用存储空间</th>
<th>表示范围</th>
</tr>
</thead>
<tbody><tr>
<td>byte</td>
<td>1字节</td>
<td>-128 ~ 127</td>
</tr>
<tr>
<td>short</td>
<td>2字节</td>
<td>-2^15 ~ 2^15-1</td>
</tr>
<tr>
<td>int</td>
<td>4字节</td>
<td>-2^32 ~ 2^31-1</td>
</tr>
<tr>
<td>long</td>
<td>8字节</td>
<td>-2^63 ~ 2^63-1</td>
</tr>
</tbody></table>
<p>同样支持十进制、八进制和十六进制，默认整数类型都是int型，如果声明为long类型，就需要在数字后接上l或者L<br>Java 7开始支持二进制，以<code>0b</code>为前缀，例如：<code>0b1001</code>即是十进制的9，还可以为了易读在数字字面量加上下划线，如<code>1_024_123</code>，java编译器会自动去掉下划线。<br><strong>浮点型：</strong></p>
<table>
<thead>
<tr>
<th>类型</th>
<th>占用存储空间</th>
<th>表示范围</th>
</tr>
</thead>
<tbody><tr>
<td>float</td>
<td>4字节</td>
<td>-3.403E38 ~ 3.4083E38</td>
</tr>
<tr>
<td>double</td>
<td>8字节</td>
<td>-1.798E308 ~ 1.798E308</td>
</tr>
</tbody></table>
<p>科学计数法与C++一样，Java中默认小数类型是double，所以如果要声明float类型，后面需要添加字母f或者F。<br>float有效位数为6~7位，double有效位数为15位<br>有3个用于表示浮点类型溢出或者出错的常量：</p>
<ul>
<li><code>-Infinity</code>：负无穷大，例如<code>-1.0/0.0</code></li>
<li><code>Infinity</code>：正无穷大，例如：<code>1.0/0.0</code></li>
<li><code>NaN</code>：不是一个数字，例如：<code>0.0/0.0</code></li>
<li>整数被0除时将产生异常*</li>
<li>可以使用关键字strctfp来修饰方法，使该方法中的浮点计算采用严格的浮点计算来处理，严格浮点计算更精确，但有可能导致溢出*</li>
</ul>
<p><strong>字符类型：</strong><br><code>char</code>：以单引号（<code>&#39;</code>）括住，java字符采用Unicode编码，每个字符占2个字节，所以可以表示中文，也可以采用16进制编码形式表示，如：<br><code>char ch = &#39;\u03C0&#39;;</code>中ch即对应圆周率的字符派，与C++一样，字符中也可以有转义字符，如<code>char ch = &#39;\a&#39;;</code><br><code>\u</code>还可以出现在字符常量或字符串的引号之外，例如main方法可以这样写：<code>public static void main(String\u005B\u005D args)</code><br><em>UTF-16编码采用不同长度的编码表示所有Unicode代码点，代码点（code point）是指一个编码表中的某个字符对应的代码值。Unicode编码通常以U+为前缀，后面跟4位16进制。由于UTF-16只能表示最多65536个字符，Java为了支持多语言，从JDK 5.0靓妈，采用的Unicode代码点可以分成17个级别（code plane），其中第一个级别称为基本的多语言级别（basic multilingual plane），代码点从U+0000到U+FFFF；其余的16个附加级别代码点从U+10000到U+10FFFF，其中包括了一些辅助字符（supplementary character）。在基本的多语言级别中，每个字符用16位表示，通常被称为代码单元（code unit）。而对于那些不在基本语言级别中的辅助字符使用一对连续的代码单元进行编码，这对代码单元区域被称为替代区域（surrogate area），其中U+D800<del>U+DBFF用于表示第一个代码单元，U+DC00</del>U+DFFF用于第二个代码单元。这样的巧妙设计可以很方便的通过一个代码单元知道该编码是一个字符编码，还是一个辅助字符编码的第一或第二部分。例如表示整数集合的数学符号的代码点是U+1D56B，并且是用两个代码单元U+D835和U+DD6B编码的。</em></p>
<p><strong>Java中强烈建议不要使用char类型，除非是需要对UTF-16代码单元进行操作，最好将需要处理的字符串用抽象数据类型表示</strong></p>
<p><strong>bool类型：</strong><br><code>boolean</code>：只有两个值<code>true</code>和<code>false</code>，与C++不同的是boolean类型不能转换为整型</p>
<p>6.Java中不区分变量的声明与定义，只声明为初始化的变量直接使用是错误的，所有变量必须在初始化之后才能使用。<br>7.使用final定义常量，类似C++中的final，const也是java中的保留关键字，但并未使用。常量可以被定义在main方法之外，并且定义为static的类常量，以便可以被其他类方法使用，如果常量被声明为public，那么该常量将可以被其他类方法使用，通常常量的命名为全大写。<br>8.位运算符中<code>&gt;&gt;&gt;</code>将使用0填充高位，<code>&gt;&gt;</code>运算符用符号位填充高位，没有<code>&lt;&lt;&lt;</code>运算符<br>9.java中没有幂运算符，需要使用类Math中的pow方法，该方法默认返回值为double类型。x的a次方调用方法为<code>Math.pow(x, a)</code>，如果想直接可以调用pow而不需要使用Math前缀，可以在源文件顶部通过<code>import static java.lang.Math.*;</code>来导入，注意这句同样需要以分号结尾。<br>10.强制类型转换与C++类似，但boolean类型除外，boolean类型不能与任何数值类型转换，但可以通过<code>b? 1 : 0</code>的方式来获得整型值。可以使用Math.round()方法获取最接近的整数值，该方法返回值为long，例如：<code>double x = 9.997; int nx = (int) Math.round(x);</code>中nx的值为10<br>11.java中不存在逗号运算符，但for循环中可以使用逗号分隔表达式列表。</p>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>12.java中没有内置的字符串类型，而是在标准Java类库中提供一个String类来处理字符串，Java中每个用双引号括起来的字符串都是String类的一个实例。<br>13.Java中当将一个非字符串使用+号与字符串拼接时，将被自动转换为字符串<br>14.Java中的字符串类String中的字符串是不可变字符串，即无法修改某个字符，类似于C++中的字符串常量或字符串字面值。<br>15.Java中的字符串不能通过==号来判等，需要使用类方法equals，<code>&quot;Hello&quot;.equals(greeting)</code>，如果忽略大小写则可使用equalsIgnoreCase方法。==号在java中只能判断两个字符串是否放在同一个位置上，java中只有字符串常量在同一个位置上共享，而被+或substring等操作产生的字符串并不共享。<br>16.空串””是长度为0的字符串，判空使用<code>if (str.length() == 0)</code>或<code>if (str.equals(&quot;&quot;))</code>，声明的String可以是null，所以如果要检查一个字符串即不为空，也不是null，需要使用<code>if (str != null &amp;&amp; str.length() != 0)</code>，直接在null上调用方法会出错<br>17.Java中的字符串是由char序列组成，而char类型是由采用UTF-16编码表示Unicode代码点的代码单元，也就是一个字符是占用2个字节的，而length方法刚好返回的是采用UTF-16编码表示的给定字符串所需要的代码单元的数量。如果想得到字符串的实际长度，也就是字符串所占用的代码点</p>
<p>10.通过String的+号来连接字符串或单个字符通过+号添加到字符串末尾时效率比较低，可以通过StringBuilder类来构建字符串，效率更高，该类在Java 5.0之后加入，前身是StringBuffer，他们API相同，但StringBuilder支持多线程。用法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">StringBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();  <span class="comment">//创建一个字符串构造器</span></span><br><span class="line">builder.append(ch);  <span class="comment">//将字符ch追加到builder</span></span><br><span class="line">builder.append(str);  <span class="comment">//将字符串str追加到builder</span></span><br><span class="line"><span class="type">String</span> <span class="variable">newstr</span> <span class="operator">=</span> builder.toString();  <span class="comment">//调用toString将字符串构建器中的字符序列转成字符串</span></span><br></pre></td></tr></table></figure>
<p>StringBuilder相当于支持在原地修改的字符串</p>
<h2 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h2><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><p>1.Java中通过将类Scanner对象与标准输入流<code>System.in</code>关联起来来实现输入操作，Scanner类定义在java.util包中，当某个类不是定义在java.lang包中时，必须通过import指令将相应的包加载进来。<br>2.Scanner对象通过方法nextLine方法获取输入流中的一行，通过next读取一个以空白分隔的字符串，通过nextInt方法获取一个整数，nextDouble方法获取一个浮点数；hasNext检测输出中是否还有其他单词，相应的有hasNextInt、hasNextDouble。<br>用法举例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorld</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;What&#x27;s your name:&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> in.next();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;How old are you:&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> in.nextInt();</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;How many dollar you spend:&quot;</span>);</span><br><span class="line">        <span class="type">double</span> <span class="variable">money</span> <span class="operator">=</span> in.nextDouble();</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;Hello, &quot;</span> + name + <span class="string">&quot; , your age is &quot;</span> + age + <span class="string">&quot; and have spent &quot;</span> + money + <span class="string">&quot; dollars.&quot;</span>);</span><br><span class="line"></span><br><span class="line">        in.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="格式化输出"><a href="#格式化输出" class="headerlink" title="格式化输出"></a>格式化输出</h3><p>1.Java中的System.out.printf()函数可以像C语言中的printf一样进行格式化输出。<br>2.System.out.printf支持分组的分隔符输出，例如System.out.printf(“%,.2f”, 10000.0 / 3.0);的输出结果为3,333.33<br>当然printf还支持其他很多格式化输出标志，可以参见官方API：<a href="https://docs.oracle.com/javase/8/docs/api/java/util/Formatter.html#syntax">https://docs.oracle.com/javase/8/docs/api/java/util/Formatter.html#syntax</a><br>3.printf中可以使用s转换符格式化任意的对象，对于任意实现了Formattable接口的对象都将调用formatTo方法，否则将调用toString方法。<br>4.可以使用静态的String.format方法创建一个格式化的字符串，而不是打印输出，如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> String.format(<span class="string">&quot;Hello, %s. Next year, you&#x27;ll be %d&quot;</span>, name, age);</span><br></pre></td></tr></table></figure>
<p>5.java中有非常多针对时间的格式化输出控制字符，并且可以通过%号后面紧跟参数索引及$来指定复用某个参数。如下面输出当前日期，格式为月 日, 年：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.printf(<span class="string">&quot;%1$s %2$tB %2$te, %2$tY&quot;</span>, <span class="string">&quot;Now date:&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br></pre></td></tr></table></figure>
<p>注意$前面的序号是指后面的参数序列，从左到右从1开始记，t表示格式化输出时间，t后面跟的B、e、Y分别表示月的完整拼写、两位数字的月、4位数字的年。</p>
<h3 id="文件输入与输出"><a href="#文件输入与输出" class="headerlink" title="文件输入与输出"></a>文件输入与输出</h3><p>1.读取文件需要用File对象构造一个Scanner对象，由于默认情况下字符串构造的Scanner对象中包含的是字符串本身，所以需要使用File对象来构造，下面的Paths.get方法返回的就是一个File对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Scanner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(Paths.get(<span class="string">&quot;myfile.txt&quot;</span>));</span><br></pre></td></tr></table></figure>
<p>Scanner的用法与读写字符串是一样的。</p>
<p>2.对于文件的输出使用的是PrintWriter对象，该对象可以直接通过一个表示文件名的字符串来构造：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(<span class="string">&quot;myfile.txt&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>可以像System.out一样来对PrintWriter对象使用print、println等命令<br>3.可以使用System.getProperty方法来获取当前程序的启动路径<br>4.对于打开文件失败时有可能是由于文件不存在引起的异常需要在main方法中用throws子句标记，如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> FileNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">Scanner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(Paths.get(<span class="string">&quot;myfile.txt&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>5.java中可以使用重定向将任意文件绑定到System.in和System.out：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java MyProg &lt; myfile.txt &gt; output.txt</span><br></pre></td></tr></table></figure>

<h2 id="控制流程"><a href="#控制流程" class="headerlink" title="控制流程"></a>控制流程</h2><p>1.Java的控制流程结构与C/C++的控制流程结构一样，只有很少的例外情况，没有goto，但break语句可以带标签，利用它可以实现从内层循环跳出的目的，C语言中可以使用goto实现。<br>注意for循环是在每次迭代之后更新计数器或类似的变量来控制迭代次数<br>2.Java支持类似C++11中的foreach循环来遍历数组或一个实现了Iterable接口的类对象（ArrayList）中的所有元素。语法：<code>for (type variable : collection) statement</code>，与C++11中用法基本完全一样。</p>
<h2 id="大数值类"><a href="#大数值类" class="headerlink" title="大数值类"></a>大数值类</h2><p>Java的java.math包中有两个可用于计算任意长度和精度的数值类：BigInteger和BigDecimal。普通数值需要使用valueOf方法转换为大数值，由于Java不支持运算符重载，所以常见的四则运算都需要通过调用方法来实现，例如<code>BigInteger d = c.multiply(b.add(BigInteger.valueOf(2))); //d = c * (b + 2)</code></p>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>1.Java中有2种数组声明方法：<code>int[] a;</code>或者<code>int a[];</code>，这样只是声明数组变量a，并没有将a初始化为一个真正的数组，需要使用new运算符创建数组，或者在声明时直接创建：<code>int[] a = new int[10];</code>，数组a中含有10个元素。Java中数组一旦创建，其大小也无法改变，如果想创建可变大小的数组，需要使用另一种数组结构——数组列表（array list）。通过array.length属性获取数组长度，注意length是属性，后面不加方法调用符（()）。<br>2.使用Arrays.toString(a)方法可以打印出数组a中所有的数值。<br>3.使用new方法创建一个数组时，如果是数字数组，所有元素都会被初始化为0，boolean数组的元素会被初始化为false，对象数组的元素则初始化为一个特殊值null，这表示这些元素还未存放任何对象。如：<code>String[] names = new String[10];</code>，names中的10个元素都是null，要获得空串，必须手动赋值，如：<code>for (int i = 0; i &lt; 10; i++) names[i] = &quot;&quot;;</code><br>4.可以在创建数组时使用花括号元素对数组进行初始化，此时不需要关键字new，也不需要指定数组大小：<code>int[] arr = &#123;1, 2, 3, 4, 5&#125;;</code>；还可以创建一个匿名数组：<code>new int[] &#123;21, 33, 44, 215, 36&#125;;</code>，使用这种方法可以在不创建新变量的情况下重新初始化一个数组，如：<code>arr = new int[] &#123;11, 12, 13, 14, 15&#125;;</code>，其等价于<code>int[] anonymous = &#123;11, 12, 13, 14, 15&#125;; arr = anonymous;</code><br>Java中可以创建长度为0的数组，数组长度为0与null不同。<br>5.Java通过Arrays类的copyTo的方法拷贝数组，而直接通过赋值运算符只相当于C++中的引用，例如<code>int[] luckyNumbers = arr;</code>此时luckyNumbers与arr指向同一个数组，luckyNumbers只相当于arr的别名，而<code>int[] luckyNumbers = Arrays.copyof(arr, arr.length);</code>则将arr中的元素逐一拷贝到luckyNumbers数组中，该方法还可以用来增加数组的大小：<code>luckyNumbers = Arrays.copyof(arr, 2 * arr.length);</code><br>Java中的数组类似于C++中分配在堆上的数组。<br>6.Java的命令行参数存储在args中，与C++不同的是其第一个元素不是程序名，而是确确实实的第一个命令行参数。</p>
<p>7.java.util.Arrays中包含很多用于数组的实用函数，比如前面的toString（返回括号包含，逗号分隔的数组元素的字符串），copyOf（拷贝字符串），sort（排序），binarySearch（二分查找），fill（快速填充数组元素），equals（比较两个数组元素是否相同）等。<br>下面是一个举例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LuckyNumber</span> &#123;</span><br><span class="line">    <span class="comment">//从一个长度为length中序列中随机抽取luckyNumber个不重复的数， 并按升序输出</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.print(<span class="string">&quot;Your total number:&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> in.nextInt();</span><br><span class="line">        System.out.print(<span class="string">&quot;Your lucky number:&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">luckyNumber</span> <span class="operator">=</span> in.nextInt();</span><br><span class="line">        <span class="type">int</span>[] total = <span class="keyword">new</span> <span class="title class_">int</span>[length];</span><br><span class="line">        <span class="comment">//生成一个1~n的序列</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; total.length; ++i)</span><br><span class="line">            total[i] = i + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span>[] lucky = <span class="keyword">new</span> <span class="title class_">int</span>[luckyNumber];</span><br><span class="line">        <span class="comment">//随机选择luckyNumber个数，通过使用Math.random函数来生成一个随机下标，然后从序列中选取该下标对应的数，</span></span><br><span class="line">        <span class="comment">//并将最后一个数移到该位置之后，从剩下的n-1个数中选取下一个数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; lucky.length; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> (<span class="type">int</span>)(Math.random() * length);  <span class="comment">//Math.random产生一个0~1的随机数，含0，不含1</span></span><br><span class="line">            lucky[i] = total[r];  <span class="comment">//将该下标中的数字取出</span></span><br><span class="line">            total[r] = total[length - <span class="number">1</span>];  <span class="comment">//移出被取出的数字，确保不重复</span></span><br><span class="line">            --length;</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(lucky);  <span class="comment">//排序数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> l : lucky)</span><br><span class="line">            System.out.printf(<span class="string">&quot;%d &quot;</span>, l);</span><br><span class="line">        System.out.println();</span><br><span class="line">        in.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>8.二维数组声明方式为<code>int[][] arr = new int[n][m]</code>，获取其中一维的长度可用<code>arr[0].length</code>，java中的多维数组也是数组的数组，当然也支持直接在声明时初始化，如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[][] arr = </span><br><span class="line">&#123;</span><br><span class="line">  &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;,</span><br><span class="line">  &#123;<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>二维数组的一个举例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr[<span class="number">0</span>].length; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr.length; j++)</span><br><span class="line">                arr[i][j] = i + j;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] r : arr) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> a : r)</span><br><span class="line">                System.out.printf(<span class="string">&quot;%d\t&quot;</span>, a);</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>9.由于Java中的多维数组是数组的数组，所以可以创建不规则的二维数组（即第一行的元素个数不同），并且可以直接交换两行：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] temp = arr[i];</span><br><span class="line">arr[i] = arr[i + <span class="number">1</span>];</span><br><span class="line">arr[i + <span class="number">1</span>] = temp;</span><br></pre></td></tr></table></figure>

<p>Java中创建一个形如<code>double[][] arr = new double[10][6];</code>与C++中的<code>double arr[10][6];//创建一个10行6列的二维数组</code>不与同，也不同于<code>double (*arr)[6] = new double[10][6];//创建一个指向含有6个元素的数组的指针，该指针指向含有10个元素的数组的首地址</code>。而是等同于分配一个包含10个指针的数组，然后指针数组的每一个元素被填充了一个包含6个数字的数组：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span>** arr = <span class="keyword">new</span> <span class="type">double</span>*[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">  arr[i] = <span class="keyword">new</span> <span class="type">double</span>[<span class="number">6</span>];</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>notes</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>ubuntu下2种配置oracle jdk的方法</title>
    <url>/2016/10/01/java-env-set/</url>
    <content><![CDATA[<p>虽然现在都流行TL;DR，但还是一如继往地授之以渔，虽然看似很长，其实非常简单，更多的内容是在讲原因。不仅适用于ubuntu系的系统，手动安装方式同样可类似地用于其他系统。无法就两步：下载并解决JDK，配置环境变量。</p>
<span id="more"></span>

<h2 id="通过ubuntu的PPA来安装"><a href="#通过ubuntu的PPA来安装" class="headerlink" title="通过ubuntu的PPA来安装"></a>通过ubuntu的PPA来安装</h2><p>详情可参见：<a href="http://www.ubuntuupdates.org/ppa/webupd8_java">http://www.ubuntuupdates.org/ppa/webupd8_java</a></p>
<h3 id="安装java"><a href="#安装java" class="headerlink" title="安装java"></a>安装java</h3><p>安装ppa源，并安装java8：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo add-apt-repository ppa:webupd8team/java </span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install oracle-java8-installer</span><br></pre></td></tr></table></figure>
<p>需要安装其他相应的版本，替换成相应的版本即可</p>
<h3 id="设置为默认java环境"><a href="#设置为默认java环境" class="headerlink" title="设置为默认java环境"></a>设置为默认java环境</h3><p>这个PPA也提供了一个自动设置oracle java为默认java的包，通过以下命令安装后会自动将oracle java设置为默认：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install oracle-java8-set-default</span><br></pre></td></tr></table></figure>
<p>不过我测试中发现，安装oracle-java8-installer时，会自动安装oracle-java8-set-default并将这个ppa安装的java设置为默认的java</p>
<p>或者手动选择使用哪个java，特别是当你系统中有多个java版时：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo update-alternatives --config java</span><br></pre></td></tr></table></figure>
<p>此时会列出系统中的所有java，根据需要输入数字选择即可</p>
<p>如果系统中有多个javac可供选择，也可以通过以下命令设置默认的javac：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo update-alternatives --config javac</span><br></pre></td></tr></table></figure>

<p>测试是否安装成功：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">java -version</span><br><span class="line">javac -version</span><br></pre></td></tr></table></figure>

<h3 id="环境变量设置"><a href="#环境变量设置" class="headerlink" title="环境变量设置"></a>环境变量设置</h3><p>由于很多软件都需要根据java的环境变量来确定需要使用的java，所以需要为其设置环境变量。有2种方式设置，即可以在用户目录下的个人配置文件中设置，也可以在全局环境中设置，推荐在个人配置文件中设置，因为这样方便不同的用户使用不同的java版本。<br><strong>通过修改~/.bashrc设置当前用户的java环境变量</strong><br>可以根据刚才使用的命令<code>sudo update-alternatives --config java</code> 来显示你的java路径<br>在.bashrc的最后添加以下内容，我这里安装的是java8，根据自己的情况修改：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">JAVA_HOME=/usr/lib/jvm/java-8-oracle</span><br><span class="line">JRE_HOME=$JAVA_HOME/jre</span><br><span class="line">CLASSPATH=.:$JAVA_HOME/lib:$JRE_HOME/lib</span><br><span class="line">PATH=$PATH:$JAVA_HOME/bin:$JRE_HOME/bin</span><br><span class="line">export JAVA_HOME</span><br><span class="line">export JRE_HOME</span><br><span class="line">export CLASSPATH</span><br><span class="line">export PATH</span><br></pre></td></tr></table></figure>

<p>使用以下命令使环境变量配置立即生效：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">source .bashrc</span><br></pre></td></tr></table></figure>

<p>通过以下命令验证环境变量的配置：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo $JAVA_HOME</span><br><span class="line">echo $JRE_HOME</span><br><span class="line">echo $CLASSPATH</span><br><span class="line">echo $PATH</span><br></pre></td></tr></table></figure>
<p>输出中应该会包含你刚设置的路径了</p>
<p><strong>通过修改/etc/profile或/etc/environment来修改全局java环境变量</strong><br>如果要修改整个系统，包括系统内的所有用户的java环境变量，可以通过修改/etc/profile而不是修改~/.bashrc来实现，因为所有用户登录系统后都会自动加载/etc/profile中的配置，修改方式与上面完全一样。</p>
<p>或者通过修改/etc/environment来实现，只需要将以下内容追加到文件最后，然后通过<code>source /etc/environment</code>加载即可：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">JAVA_HOME=/usr/lib/jvm/java-8-oracle</span><br><span class="line">JRE_HOME=$JAVA_HOME/jre</span><br><span class="line">CLASSPATH=.:$JAVA_HOME/lib:$JRE_HOME/lib</span><br><span class="line">PATH=$PATH:$JAVA_HOME/bin:$JRE_HOME/bin</span><br></pre></td></tr></table></figure>
<h3 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h3><p>正常通过apt-get卸载</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get remove --purge oracle-java8-*</span><br></pre></td></tr></table></figure>
<p>然后删除自己添加的环境变量即可</p>
<h2 id="通过手动去oracle官网下载后安装"><a href="#通过手动去oracle官网下载后安装" class="headerlink" title="通过手动去oracle官网下载后安装"></a>通过手动去oracle官网下载后安装</h2><p>其实上面的ppa也是从oracle下载编译好的包，然后解压后配置环境来实现的，只是那个解压等工作自动完成了。</p>
<h3 id="下载java"><a href="#下载java" class="headerlink" title="下载java"></a>下载java</h3><p>去oracle官网的java下载页面<a href="http://www.oracle.com/technetwork/java/javase/downloads/index.html">http://www.oracle.com/technetwork/java/javase/downloads/index.html</a> 找到需要的链接，然后使用wget下载即可，注意由于wget不能自动重定向，所以需要加上前面那些验证，同样为了保证https的证书问题，加上了<code>--no-check-certificate</code> ：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget --no-check-certificate --no-cookies --header &quot;Cookie: oraclelicense=accept-securebackup-cookie&quot; http://download.oracle.com/otn-pub/java/jdk/8u112-b15/jdk-8u112-linux-x64.tar.gz</span><br></pre></td></tr></table></figure>
<p>由于刚才通过ppa自动安装的是8u111的版本，所以这里安装8u112版本。</p>
<h3 id="安装java-1"><a href="#安装java-1" class="headerlink" title="安装java"></a>安装java</h3><p>首先为java创建解压目录：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo mkdir /usr/java</span><br></pre></td></tr></table></figure>
<p>解压刚下载的jdk压缩包到/usr/java目录：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo tar --strip-components=1 -zxvf jdk-8u112-linux-x64.tar.gz -C /usr/java/</span><br></pre></td></tr></table></figure>
<p>如果系统中只有这一个java，可以直接根据上面的方法设置环境变量即可，设置完成环境变量即算是已经安装成功，但并没有被设置为系统默认的java</p>
<h3 id="设置为系统默认JDK"><a href="#设置为系统默认JDK" class="headerlink" title="设置为系统默认JDK"></a>设置为系统默认JDK</h3><p>执行以下命令为系统添加可选的java版本：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo update-alternatives --install /usr/bin/java java /usr/java/bin/java 300  </span><br><span class="line">sudo update-alternatives --install /usr/bin/javac javac /usr/java/bin/javac 300  </span><br><span class="line">sudo update-alternatives --install /usr/bin/jar jar /usr/java/bin/jar 300   </span><br><span class="line">sudo update-alternatives --install /usr/bin/javah javah /usr/java/bin/javah 300   </span><br><span class="line">sudo update-alternatives --install /usr/bin/javap javap /usr/java/bin/javap 300 </span><br></pre></td></tr></table></figure>
<p>注意最后那个300是表示优先级，可以修改为其他数值</p>
<p>执行以下命令选择需要的JDK：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo update-alternatives --config java</span><br></pre></td></tr></table></figure>
<p>剩下的环境变量及测试的方式与上面一样。</p>
<h3 id="卸载-1"><a href="#卸载-1" class="headerlink" title="卸载"></a>卸载</h3><p>直接删除自己设置的解压目录即可</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo rm -rf /usr/java</span><br></pre></td></tr></table></figure>
<p>记得删除自己设置的环境变量</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>notes</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>超大整数实现及其四则运算</title>
    <url>/2016/09/22/big-number/</url>
    <content><![CDATA[<p>超大整数的表示及四则运算，大家的多数方法是采用字符串表示超大整数，然后再根据竖式计算的原理进行计算。例如12345678 + 87654321，就是两个字符串，然后将这两个字符串中的各个位取出来右对齐后进行一位位相加，如果有进位就考虑进位的问题，例如这里至少需要相加8次，如果最高位有进位，就是9次。<br>这里采用的方法相当于采用10^n进制来存储超大整数，例如12345678，如果按10000进制来存的话（因为这样的两个最大数相乘刚好不会超过10^9，可用用int32存），就是存成[1234,5678]，两个整数，这样的话，只需要相加2次就可以了，而且进位的计算也最多只需要2次。相比字符串，当整数超大时，时间复杂度会降低很多。下面的实现中采用的是vector来存储的，由于加入了时间统计及DEBUG，所以看上去代码略多。<br>由于最近太忙，只实现了加、减和乘，除等以后有时间了再，下面是完整的代码，也不整理了，注释比较少，优化空间也很大，等以后有时间了再整，留个备注</p>
<span id="more"></span>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdint&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NDEBUG</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//方便调试的DEBUG输出函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">std::ostream&amp; <span class="title">DEBUG</span><span class="params">(<span class="type">const</span> T&amp; t, <span class="type">const</span> std::string &amp;msg = <span class="string">&quot;DEBUG&quot;</span>, std::ostream&amp; os = std::cout)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    os &lt;&lt; <span class="string">&quot;=&quot;</span> &lt;&lt; msg &lt;&lt; <span class="string">&quot;=&quot;</span> &lt;&lt; t &lt;&lt; <span class="string">&quot;==&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::ostream&amp; <span class="title">DEBUG</span><span class="params">(<span class="type">const</span> std::vector&lt;<span class="type">uint32_t</span>&gt; &amp;vec, <span class="type">const</span> std::string &amp;msg = <span class="string">&quot;DEBUG&quot;</span>, std::ostream&amp; os = std::cout)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    os &lt;&lt; <span class="string">&quot;=&quot;</span> &lt;&lt; msg &lt;&lt; <span class="string">&quot;=&quot;</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> v : vec)</span><br><span class="line">        os &lt;&lt; std::<span class="built_in">setw</span>(<span class="number">4</span>) &lt;&lt; std::<span class="built_in">setfill</span>(<span class="string">&#x27;0&#x27;</span>) &lt;&lt; v &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    os &lt;&lt; <span class="string">&quot;==&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//按10000进制划分数字，因为相乘后的10^8不会越界</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> DEC = <span class="number">4</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">//10进制码表，以快速计算10^n</span></span><br><span class="line"><span class="comment">//由于使用int最多只能存到10^9，够用了</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">quick_pow10</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> pow10[<span class="number">10</span>] = &#123;</span><br><span class="line">        <span class="number">1</span>, <span class="number">10</span>, <span class="number">100</span>, <span class="number">1000</span>, <span class="number">10000</span>, <span class="number">100000</span>, <span class="number">1000000</span>, <span class="number">10000000</span>,</span><br><span class="line">        <span class="number">100000000</span>, <span class="number">1000000000</span> </span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> pow10[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//比较含整型vector的大小</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">vcompare</span><span class="params">(<span class="type">const</span> std::vector&lt;<span class="type">uint32_t</span>&gt;&amp;, <span class="type">const</span> std::vector&lt;<span class="type">uint32_t</span>&gt;&amp;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BigInt</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span>&gt;(<span class="type">const</span> BigInt&amp;, <span class="type">const</span> BigInt&amp;);</span><br><span class="line">    <span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> BigInt&amp;, <span class="type">const</span> BigInt&amp;);</span><br><span class="line">    <span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> BigInt&amp;, <span class="type">const</span> BigInt&amp;);</span><br><span class="line">    <span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> BigInt&amp;, <span class="type">const</span> BigInt&amp;);</span><br><span class="line">    <span class="comment">// 存有正整数的vec相加</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> std::vector&lt;<span class="type">uint32_t</span>&gt; <span class="title">vadd</span><span class="params">(<span class="type">const</span> std::vector&lt;<span class="type">uint32_t</span>&gt; &amp;, <span class="type">const</span> std::vector&lt;<span class="type">uint32_t</span>&gt; &amp;)</span></span>;</span><br><span class="line">    <span class="comment">// 存有正整数的vec相减，大减小，lsh - rhs</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> std::vector&lt;<span class="type">uint32_t</span>&gt; <span class="title">vsub</span><span class="params">(<span class="type">const</span> std::vector&lt;<span class="type">uint32_t</span>&gt; &amp;, <span class="type">const</span> std::vector&lt;<span class="type">uint32_t</span>&gt; &amp;)</span></span>;</span><br><span class="line">    <span class="comment">// 存有正整数的vec相乘</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> std::vector&lt;<span class="type">uint32_t</span>&gt; <span class="title">vmul</span><span class="params">(<span class="type">const</span> std::vector&lt;<span class="type">uint32_t</span>&gt; &amp;, <span class="type">const</span> std::vector&lt;<span class="type">uint32_t</span>&gt; &amp;)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">BigInt</span>() : <span class="built_in">negative</span>(<span class="literal">false</span>), <span class="built_in">zero</span>(<span class="literal">true</span>) &#123; vnum.<span class="built_in">push_back</span>(<span class="number">0</span>); &#125;</span><br><span class="line">    <span class="built_in">BigInt</span>(<span class="type">const</span> std::string &amp;);</span><br><span class="line">    <span class="built_in">BigInt</span>(<span class="type">const</span> BigInt&amp;);</span><br><span class="line">    BigInt&amp; <span class="keyword">operator</span>=(<span class="type">const</span> BigInt&amp;);</span><br><span class="line">    <span class="comment">//负加负、负加正、正加负转化为正减负</span></span><br><span class="line">    BigInt <span class="keyword">operator</span>+(<span class="type">const</span> BigInt&amp;) <span class="type">const</span>;</span><br><span class="line">    BigInt <span class="keyword">operator</span>-(<span class="type">const</span> BigInt&amp;) <span class="type">const</span>;</span><br><span class="line">    BigInt <span class="keyword">operator</span>*(<span class="type">const</span> BigInt&amp;) <span class="type">const</span>;</span><br><span class="line">    BigInt <span class="keyword">operator</span>/(<span class="type">const</span> BigInt&amp;) <span class="type">const</span>;</span><br><span class="line">    ~<span class="built_in">BigInt</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    void setnegative(bool ne) &#123; negative = ne; &#125;</span></span><br><span class="line"><span class="comment">//    void setzero(bool ze) &#123; zero = ze; &#125;</span></span><br><span class="line"><span class="comment">//    bool getnegative() const &#123; return negative; &#125;</span></span><br><span class="line"><span class="comment">//    bool getzero() const &#123; return zero; &#125;</span></span><br><span class="line"><span class="comment">//    void setvnum(const std::vector&lt;uint32_t&gt; num) &#123; vnum = num; setzero(false); &#125;</span></span><br><span class="line">    <span class="function">std::ostream&amp; <span class="title">print</span><span class="params">(std::ostream&amp; os = std::cout)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将string按n位一组划分为整型，存入vector</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">strtovec</span><span class="params">(std::vector&lt;<span class="type">uint32_t</span>&gt; &amp;, <span class="type">const</span> std::string &amp;, <span class="type">const</span> <span class="type">int</span> n)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;<span class="type">uint32_t</span>&gt; vnum;  <span class="comment">//存放读取的数字</span></span><br><span class="line">    <span class="type">bool</span> negative;  <span class="comment">//是否为负数</span></span><br><span class="line">    <span class="type">bool</span> zero;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">ctoi</span><span class="params">(<span class="type">char</span> ch)</span> </span>&#123; <span class="keyword">return</span> (ch - <span class="string">&#x27;0&#x27;</span>); &#125;  <span class="comment">//字符转整型</span></span><br><span class="line">    <span class="function"><span class="type">char</span> <span class="title">itoc</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123; <span class="keyword">return</span> (i + <span class="string">&#x27;0&#x27;</span>); &#125;  <span class="comment">//整数转字符</span></span><br><span class="line">    <span class="function"><span class="type">uint32_t</span> <span class="title">strtoi</span><span class="params">(<span class="type">const</span> std::string &amp;str)</span></span>;  <span class="comment">//字符串转整型</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">vcompare</span><span class="params">(<span class="type">const</span> std::vector&lt;<span class="type">uint32_t</span>&gt;&amp;lhs, <span class="type">const</span> std::vector&lt;<span class="type">uint32_t</span>&gt;&amp;rhs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lhs.<span class="built_in">size</span>() &gt; rhs.<span class="built_in">size</span>())</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (lhs.<span class="built_in">size</span>() &lt; rhs.<span class="built_in">size</span>()) </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (std::vector&lt;<span class="type">uint32_t</span>&gt;::size_type i = <span class="number">0</span>; i &lt; lhs.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> ( lhs[i] &gt; rhs[i] )</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ( lhs[i] &lt; rhs[i] )</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>&gt;(<span class="type">const</span> BigInt&amp;lhs, <span class="type">const</span> BigInt&amp;rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> std::vector&lt;<span class="type">uint32_t</span>&gt; &amp;lhsv = lhs.vnum;</span><br><span class="line">    <span class="type">const</span> std::vector&lt;<span class="type">uint32_t</span>&gt; &amp;rhsv = rhs.vnum;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">#ifndef NDEBUG</span></span><br><span class="line"><span class="comment">    DEBUG(lhs, &quot;lhs&quot;);</span></span><br><span class="line"><span class="comment">    DEBUG(rhs, &quot;rhs&quot;);</span></span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="keyword">if</span> (lhs.negative &amp;&amp; ((!rhs.negative) || rhs.zero))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!lhs.negative &amp;&amp; rhs.negative)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((lhs.negative &amp;&amp; rhs.negative) || (!lhs.negative &amp;&amp; !rhs.negative)) &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">#ifndef NDEBUG</span></span><br><span class="line"><span class="comment">        DEBUG(vcompare(lhsv, rhsv), &quot;vcom&quot;);</span></span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">        <span class="type">int</span> vcom = <span class="built_in">vcompare</span>(lhsv, rhsv);</span><br><span class="line">        <span class="keyword">if</span> (vcom == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!lhs.negative)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (vcom == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (lhs.negative)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> BigInt&amp;lhs, <span class="type">const</span> BigInt&amp;rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> std::vector&lt;<span class="type">uint32_t</span>&gt; &amp;lhsv = lhs.vnum;</span><br><span class="line">    <span class="type">const</span> std::vector&lt;<span class="type">uint32_t</span>&gt; &amp;rhsv = rhs.vnum;</span><br><span class="line">    <span class="keyword">if</span> (lhs.negative &amp;&amp; (!rhs.negative || rhs.zero))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!lhs.negative &amp;&amp; rhs.negative)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((lhs.negative &amp;&amp; rhs.negative) || (!lhs.negative &amp;&amp; !rhs.negative)) &#123;</span><br><span class="line">       <span class="type">int</span> vcom = <span class="built_in">vcompare</span>(lhsv, rhsv);</span><br><span class="line">        <span class="keyword">if</span> (vcom == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!lhs.negative)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (vcom == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (lhs.negative)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> BigInt&amp;lhs, <span class="type">const</span> BigInt&amp;rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (lhs.zero &amp;&amp; rhs.zero)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (lhs.negative == rhs.negative &amp;&amp; <span class="built_in">vcompare</span>(lhs.vnum, rhs.vnum) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> BigInt&amp;lhs, <span class="type">const</span> BigInt&amp;rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">return</span> (lhs == rhs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">uint32_t</span> <span class="title">BigInt::strtoi</span><span class="params">(<span class="type">const</span> std::string &amp;str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">uint32_t</span> uin = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> c : str) &#123;</span><br><span class="line">        uin = uin * <span class="number">10</span> + <span class="built_in">ctoi</span>(c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> uin;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BigInt::strtovec</span><span class="params">(std::vector&lt;<span class="type">uint32_t</span>&gt; &amp;vec, <span class="type">const</span> std::string &amp;str, <span class="type">const</span> <span class="type">int</span> n = DEC)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::string::size_type s_length = str.<span class="built_in">length</span>();</span><br><span class="line">    <span class="type">int</span> first_item_length = s_length % n;</span><br><span class="line">    <span class="keyword">if</span> (first_item_length != <span class="number">0</span>) &#123;</span><br><span class="line">        std::string fir_str = str.<span class="built_in">substr</span>(<span class="number">0</span>, first_item_length);</span><br><span class="line">        vec.<span class="built_in">push_back</span>(<span class="built_in">strtoi</span>(fir_str));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (std::string::size_type sec = first_item_length; sec &lt; s_length; sec += n) &#123;</span><br><span class="line">        std::string sstr = str.<span class="built_in">substr</span>(sec, n);</span><br><span class="line">        vec.<span class="built_in">push_back</span>(<span class="built_in">strtoi</span>(sstr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BigInt::<span class="built_in">BigInt</span>(<span class="type">const</span> std::string &amp;str)</span><br><span class="line">&#123;</span><br><span class="line">    negative = <span class="literal">false</span>;</span><br><span class="line">    zero = <span class="literal">false</span>;</span><br><span class="line">    std::string tstr = str;</span><br><span class="line">    <span class="keyword">if</span> (str[<span class="number">0</span>] == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">        negative = <span class="literal">true</span>;</span><br><span class="line">        tstr = str.<span class="built_in">substr</span>(<span class="number">1</span>, str.<span class="built_in">length</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (str[<span class="number">0</span>] == <span class="string">&#x27;+&#x27;</span>) &#123;</span><br><span class="line">        tstr = str.<span class="built_in">substr</span>(<span class="number">1</span>, str.<span class="built_in">length</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (tstr.<span class="built_in">find_first_not_of</span>(<span class="string">&quot;0123456789&quot;</span>) != std::string::npos || tstr.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Non-number detected!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::string::size_type nzeropos = tstr.<span class="built_in">find_first_not_of</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (nzeropos == std::string::npos) &#123;</span><br><span class="line">        negative = <span class="literal">false</span>;</span><br><span class="line">        zero = <span class="literal">true</span>;</span><br><span class="line">        vnum.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        tstr = tstr.<span class="built_in">substr</span>(nzeropos, tstr.<span class="built_in">length</span>());</span><br><span class="line">        <span class="built_in">strtovec</span>(vnum, tstr, DEC);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BigInt::<span class="built_in">BigInt</span>(<span class="type">const</span> BigInt&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    negative = rhs.negative; </span><br><span class="line">    zero = rhs.zero;</span><br><span class="line">    vnum = rhs.vnum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BigInt&amp; BigInt::<span class="keyword">operator</span>=(<span class="type">const</span> BigInt&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;rhs) &#123;</span><br><span class="line">        negative = rhs.negative; </span><br><span class="line">        zero = rhs.zero;</span><br><span class="line">        vnum = rhs.vnum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::ostream&amp; <span class="title">BigInt::print</span><span class="params">(std::ostream&amp; os)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (zero) &#123;</span><br><span class="line">        os &lt;&lt; <span class="number">0</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> os;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (negative)</span><br><span class="line">        os &lt;&lt; <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> first_nozero = <span class="literal">false</span>;  <span class="comment">//从第一个非0开始输出</span></span><br><span class="line">    <span class="keyword">for</span> (std::vector&lt;<span class="type">uint32_t</span>&gt;::size_type i = <span class="number">0</span>; i &lt; vnum.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (vnum[i] != <span class="number">0</span> )</span><br><span class="line">            first_nozero = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i != <span class="number">0</span> &amp;&amp; first_nozero)</span><br><span class="line">            os &lt;&lt; std::<span class="built_in">setw</span>(<span class="number">4</span>) &lt;&lt; std::<span class="built_in">setfill</span>(<span class="string">&#x27;0&#x27;</span>) &lt;&lt; vnum[i];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (first_nozero || i == (vnum.<span class="built_in">size</span>() - <span class="number">1</span>))</span><br><span class="line">            os &lt;&lt; vnum[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; os, <span class="type">const</span> BigInt&amp; num)</span><br><span class="line">&#123;</span><br><span class="line">    num.<span class="built_in">print</span>(os);</span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">std::istream&amp; <span class="keyword">operator</span>&gt;&gt;(std::istream&amp; os, BigInt&amp; num)</span><br><span class="line">&#123;</span><br><span class="line">    std::string str;</span><br><span class="line">    os &gt;&gt; str;</span><br><span class="line">    num = <span class="built_in">BigInt</span>(str);</span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::vector&lt;<span class="type">uint32_t</span>&gt; <span class="title">vadd</span><span class="params">(<span class="type">const</span> std::vector&lt;<span class="type">uint32_t</span>&gt; &amp;lhs, <span class="type">const</span> std::vector&lt;<span class="type">uint32_t</span>&gt; &amp;rhs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">uint32_t</span>&gt; <span class="title">lvnum</span><span class="params">(lhs)</span></span>;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">uint32_t</span>&gt; <span class="title">rvnum</span><span class="params">(rhs)</span></span>;</span><br><span class="line">    std::<span class="built_in">reverse</span>(lvnum.<span class="built_in">begin</span>(), lvnum.<span class="built_in">end</span>());</span><br><span class="line">    std::<span class="built_in">reverse</span>(rvnum.<span class="built_in">begin</span>(), rvnum.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    std::vector&lt;<span class="type">uint32_t</span>&gt; &amp;long_vec = rvnum;</span><br><span class="line">    std::vector&lt;<span class="type">uint32_t</span>&gt; &amp;short_vec = lvnum;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (rvnum.<span class="built_in">size</span>() &lt; lvnum.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        std::<span class="built_in">swap</span>(long_vec, short_vec);</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">#ifndef NDEBUG</span></span><br><span class="line"><span class="comment">    DEBUG(long_vec, &quot;lvec&quot;);</span></span><br><span class="line"><span class="comment">    DEBUG(short_vec, &quot;svec&quot;);</span></span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> carry = <span class="number">0</span>;</span><br><span class="line">    std::vector&lt;<span class="type">uint32_t</span>&gt; resvnum;</span><br><span class="line">    std::vector&lt;<span class="type">uint32_t</span>&gt;::size_type sindex = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> pow = <span class="built_in">quick_pow10</span>(DEC);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (; sindex &lt; short_vec.<span class="built_in">size</span>(); ++sindex) &#123;</span><br><span class="line">        <span class="type">uint32_t</span> res = long_vec[sindex] + short_vec[sindex] + carry;</span><br><span class="line">        resvnum.<span class="built_in">push_back</span>(res % pow);</span><br><span class="line">        carry = res / pow;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (; sindex &lt; long_vec.<span class="built_in">size</span>(); ++sindex) &#123;</span><br><span class="line">        <span class="type">uint32_t</span> res = long_vec[sindex] + carry;</span><br><span class="line">        resvnum.<span class="built_in">push_back</span>(res % pow);</span><br><span class="line">        carry = res / pow;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (carry != <span class="number">0</span>)</span><br><span class="line">        resvnum.<span class="built_in">push_back</span>(carry);</span><br><span class="line"></span><br><span class="line">    std::<span class="built_in">reverse</span>(resvnum.<span class="built_in">begin</span>(), resvnum.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">return</span> resvnum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::vector&lt;<span class="type">uint32_t</span>&gt; <span class="title">vadd_reverse</span><span class="params">(<span class="type">const</span> std::vector&lt;<span class="type">uint32_t</span>&gt; &amp;lhs, <span class="type">const</span> std::vector&lt;<span class="type">uint32_t</span>&gt; &amp;rhs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">uint32_t</span>&gt; <span class="title">lvnum</span><span class="params">(lhs)</span></span>;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">uint32_t</span>&gt; <span class="title">rvnum</span><span class="params">(rhs)</span></span>;</span><br><span class="line"></span><br><span class="line">    std::vector&lt;<span class="type">uint32_t</span>&gt; &amp;long_vec = rvnum;</span><br><span class="line">    std::vector&lt;<span class="type">uint32_t</span>&gt; &amp;short_vec = lvnum;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (rvnum.<span class="built_in">size</span>() &lt; lvnum.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        std::<span class="built_in">swap</span>(long_vec, short_vec);</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">#ifndef NDEBUG</span></span><br><span class="line"><span class="comment">    DEBUG(long_vec, &quot;lvec&quot;);</span></span><br><span class="line"><span class="comment">    DEBUG(short_vec, &quot;svec&quot;);</span></span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> carry = <span class="number">0</span>;</span><br><span class="line">    std::vector&lt;<span class="type">uint32_t</span>&gt; resvnum;</span><br><span class="line">    std::vector&lt;<span class="type">uint32_t</span>&gt;::size_type sindex = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> pow = <span class="built_in">quick_pow10</span>(DEC);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (; sindex &lt; short_vec.<span class="built_in">size</span>(); ++sindex) &#123;</span><br><span class="line">        <span class="type">uint32_t</span> res = long_vec[sindex] + short_vec[sindex] + carry;</span><br><span class="line">        resvnum.<span class="built_in">push_back</span>(res % pow);</span><br><span class="line">        carry = res / pow;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (; sindex &lt; long_vec.<span class="built_in">size</span>(); ++sindex) &#123;</span><br><span class="line">        <span class="type">uint32_t</span> res = long_vec[sindex] + carry;</span><br><span class="line">        resvnum.<span class="built_in">push_back</span>(res % pow);</span><br><span class="line">        carry = res / pow;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (carry != <span class="number">0</span>)</span><br><span class="line">        resvnum.<span class="built_in">push_back</span>(carry);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> resvnum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">std::vector&lt;<span class="type">uint32_t</span>&gt; <span class="title">vsub</span><span class="params">(<span class="type">const</span> std::vector&lt;<span class="type">uint32_t</span>&gt; &amp;lhs, <span class="type">const</span> std::vector&lt;<span class="type">uint32_t</span>&gt; &amp;rhs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">uint32_t</span>&gt; <span class="title">lvnum</span><span class="params">(lhs)</span></span>;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">uint32_t</span>&gt; <span class="title">rvnum</span><span class="params">(rhs)</span></span>;</span><br><span class="line">    std::<span class="built_in">reverse</span>(lvnum.<span class="built_in">begin</span>(), lvnum.<span class="built_in">end</span>());</span><br><span class="line">    std::<span class="built_in">reverse</span>(rvnum.<span class="built_in">begin</span>(), rvnum.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> carry = <span class="number">0</span>;</span><br><span class="line">    std::vector&lt;<span class="type">uint32_t</span>&gt; resvnum;</span><br><span class="line">    std::vector&lt;<span class="type">uint32_t</span>&gt;::size_type sindex = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> pow = <span class="built_in">quick_pow10</span>(DEC);</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">for</span> (; sindex &lt; rvnum.<span class="built_in">size</span>(); ++sindex) &#123;</span><br><span class="line">        <span class="type">uint32_t</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (lvnum[sindex] &lt; rvnum[sindex]) &#123;</span><br><span class="line">            res = lvnum[sindex] - carry + pow - rvnum[sindex];</span><br><span class="line">            carry = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (lvnum[sindex] == rvnum[sindex]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (carry == <span class="number">1</span>) &#123;</span><br><span class="line">                res = lvnum[sindex] - carry + pow - rvnum[sindex];</span><br><span class="line">                carry = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                res = lvnum[sindex] - rvnum[sindex];</span><br><span class="line">                carry = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            res = lvnum[sindex] - carry - rvnum[sindex];</span><br><span class="line">            carry = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        resvnum.<span class="built_in">push_back</span>(res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (; sindex &lt; lvnum.<span class="built_in">size</span>(); ++sindex) &#123;</span><br><span class="line">        <span class="type">uint32_t</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (lvnum[sindex] == <span class="number">0</span> &amp;&amp; carry == <span class="number">1</span>) &#123;</span><br><span class="line">            res = lvnum[sindex] + pow - carry;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            res = lvnum[sindex] - carry;</span><br><span class="line">            carry = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        resvnum.<span class="built_in">push_back</span>(res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::<span class="built_in">reverse</span>(resvnum.<span class="built_in">begin</span>(), resvnum.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">return</span> resvnum;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">std::vector&lt;<span class="type">uint32_t</span>&gt; <span class="title">vmul</span><span class="params">(<span class="type">const</span> std::vector&lt;<span class="type">uint32_t</span>&gt; &amp;lhs, <span class="type">const</span> std::vector&lt;<span class="type">uint32_t</span>&gt; &amp;rhs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">uint32_t</span>&gt; <span class="title">lvnum</span><span class="params">(lhs)</span></span>;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">uint32_t</span>&gt; <span class="title">rvnum</span><span class="params">(rhs)</span></span>;</span><br><span class="line">    std::<span class="built_in">reverse</span>(lvnum.<span class="built_in">begin</span>(), lvnum.<span class="built_in">end</span>());</span><br><span class="line">    std::<span class="built_in">reverse</span>(rvnum.<span class="built_in">begin</span>(), rvnum.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    std::vector&lt;<span class="type">uint32_t</span>&gt; &amp;long_vec = rvnum;</span><br><span class="line">    std::vector&lt;<span class="type">uint32_t</span>&gt; &amp;short_vec = lvnum;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (rvnum.<span class="built_in">size</span>() &lt; lvnum.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        std::<span class="built_in">swap</span>(long_vec, short_vec);</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    std::vector&lt;<span class="type">uint32_t</span>&gt; resvnum&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    std::vector&lt;<span class="type">uint32_t</span>&gt;::size_type sindex = <span class="number">0</span>, lindex = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> pow = <span class="built_in">quick_pow10</span>(DEC);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (; sindex &lt; short_vec.<span class="built_in">size</span>(); ++sindex) &#123;</span><br><span class="line">        std::vector&lt;<span class="type">uint32_t</span>&gt; resv;</span><br><span class="line">        <span class="type">uint32_t</span> carry = <span class="number">0</span>;</span><br><span class="line">        std::vector&lt;<span class="type">uint32_t</span>&gt;::size_type i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i++ &lt; sindex) &#123;</span><br><span class="line">            resv.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (lindex = <span class="number">0</span>; lindex &lt; long_vec.<span class="built_in">size</span>(); ++lindex) &#123;</span><br><span class="line">            <span class="type">uint32_t</span> res = long_vec[lindex] * short_vec[sindex] + carry;</span><br><span class="line">            resv.<span class="built_in">push_back</span>(res % pow);</span><br><span class="line">            carry = res / pow;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (carry != <span class="number">0</span>)</span><br><span class="line">            resv.<span class="built_in">push_back</span>(carry);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> NDEBUG</span></span><br><span class="line">        <span class="built_in">DEBUG</span>(resv, <span class="string">&quot;resv&quot;</span>);</span><br><span class="line">        <span class="built_in">DEBUG</span>(carry, <span class="string">&quot;carry&quot;</span>);</span><br><span class="line">        <span class="built_in">DEBUG</span>(resvnum, <span class="string">&quot;resvnum&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">        resvnum = <span class="built_in">vadd_reverse</span>(resvnum, resv);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::<span class="built_in">reverse</span>(resvnum.<span class="built_in">begin</span>(), resvnum.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">return</span> resvnum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">BigInt BigInt::<span class="keyword">operator</span>+(<span class="type">const</span> BigInt&amp;rhs) <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (rhs.zero)</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;zero)</span><br><span class="line">        <span class="keyword">return</span> rhs;</span><br><span class="line"></span><br><span class="line">    BigInt res;</span><br><span class="line"></span><br><span class="line">    res.vnum = <span class="built_in">vadd</span>(<span class="keyword">this</span>-&gt;vnum, rhs.vnum);  <span class="comment">//正加正</span></span><br><span class="line">    res.zero = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (negative &amp;&amp; rhs.negative) &#123; <span class="comment">// 负加负</span></span><br><span class="line">        res.negative = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (negative &amp;&amp; !rhs.negative) &#123; <span class="comment">//负加正</span></span><br><span class="line">        BigInt <span class="built_in">lhs</span>(*<span class="keyword">this</span>);</span><br><span class="line">        lhs.negative = <span class="literal">false</span>;</span><br><span class="line">        res = rhs - lhs;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!negative &amp;&amp; rhs.negative) &#123; <span class="comment">//正加负</span></span><br><span class="line">        BigInt <span class="built_in">rrhs</span>(rhs);</span><br><span class="line">        rrhs.negative = <span class="literal">false</span>;</span><br><span class="line">        res = *<span class="keyword">this</span> - rrhs;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BigInt BigInt::<span class="keyword">operator</span>-(<span class="type">const</span> BigInt&amp;rhs) <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">    BigInt res;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (rhs.zero)</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;zero) &#123;</span><br><span class="line">        res = *<span class="keyword">this</span>;</span><br><span class="line">        res.negative = !negative;</span><br><span class="line">        <span class="keyword">if</span> (rhs.zero)</span><br><span class="line">            res.zero = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::vector&lt;<span class="type">uint32_t</span>&gt; long_vec, short_vec;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">vcompare</span>(<span class="keyword">this</span>-&gt;vnum, rhs.vnum) == <span class="number">-1</span>) &#123;</span><br><span class="line">        long_vec = rhs.vnum;</span><br><span class="line">        short_vec = <span class="keyword">this</span>-&gt;vnum;</span><br><span class="line">        res.negative = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        long_vec = <span class="keyword">this</span>-&gt;vnum;</span><br><span class="line">        short_vec = rhs.vnum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    res.vnum = <span class="built_in">vsub</span>(long_vec, short_vec);</span><br><span class="line">    res.zero = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (negative &amp;&amp; rhs.negative) &#123; <span class="comment">// 负减负</span></span><br><span class="line">        res.negative = !res.negative;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (negative &amp;&amp; !rhs.negative) &#123; <span class="comment">//负减正</span></span><br><span class="line">        res.negative = <span class="literal">true</span>;</span><br><span class="line">        res.vnum = <span class="built_in">vadd</span>(vnum, rhs.vnum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!negative &amp;&amp; rhs.negative) &#123; <span class="comment">//正减负</span></span><br><span class="line">        res.negative = <span class="literal">false</span>;</span><br><span class="line">        res.vnum = <span class="built_in">vadd</span>(vnum, rhs.vnum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BigInt BigInt::<span class="keyword">operator</span>*(<span class="type">const</span> BigInt&amp;rhs) <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">    BigInt res;</span><br><span class="line">    <span class="keyword">if</span> (rhs.zero || <span class="keyword">this</span>-&gt;zero) &#123;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    res.vnum = <span class="built_in">vmul</span>(<span class="keyword">this</span>-&gt;vnum, rhs.vnum);  <span class="comment">//正乘正，负乘负</span></span><br><span class="line">    res.zero = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((negative &amp;&amp; !rhs.negative) || (!negative &amp;&amp; rhs.negative)) &#123; <span class="comment">//负乘正，正乘负</span></span><br><span class="line">        res.negative = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BigInt BigInt::<span class="keyword">operator</span>/(<span class="type">const</span> BigInt&amp;rhs) <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">    BigInt res;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BigInt <span class="title">cacBigInt</span><span class="params">(<span class="type">const</span> std::string &amp;str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::istringstream <span class="title">is</span><span class="params">(str)</span></span>;</span><br><span class="line">    <span class="type">char</span> op;</span><br><span class="line">    BigInt lnum, rnum, res;</span><br><span class="line">    is &gt;&gt; lnum &gt;&gt; op &gt;&gt; rnum;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">#ifndef NDEBUG</span></span><br><span class="line"><span class="comment">DEBUG(lnum);</span></span><br><span class="line"><span class="comment">DEBUG(op);</span></span><br><span class="line"><span class="comment">DEBUG(rnum);</span></span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="keyword">switch</span>(op) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">            res = lnum + rnum; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">            res = lnum - rnum; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">            res = lnum * rnum; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">            res = lnum / rnum; <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::ifstream <span class="title">inf</span><span class="params">(<span class="string">&quot;cal.txt&quot;</span>)</span></span>;</span><br><span class="line">    std::string line;</span><br><span class="line">    <span class="keyword">while</span> (std::<span class="built_in">getline</span>(inf, line) &amp;&amp; !line.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;==&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">auto</span> t_start = std::chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line"></span><br><span class="line">        std::cout &lt;&lt; <span class="built_in">cacBigInt</span>(line) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> t_end = std::chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line">        std::cout &lt;&lt; std::fixed &lt;&lt; std::<span class="built_in">setprecision</span>(<span class="number">5</span>) &lt;&lt; <span class="string">&quot;---Caculate time: &quot;</span></span><br><span class="line">                  &lt;&lt; std::chrono::<span class="built_in">duration</span>&lt;<span class="type">double</span>, std::micro&gt;(t_end - t_start).<span class="built_in">count</span>()</span><br><span class="line">                  &lt;&lt; <span class="string">&quot; μs---&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;==&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    inf.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">getchar</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithms</category>
      </categories>
      <tags>
        <tag>CPP</tag>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux下fork函数及pthread函数的总结</title>
    <url>/2016/08/17/linux-fork/</url>
    <content><![CDATA[<h1 id="fork"><a href="#fork" class="headerlink" title="fork"></a>fork</h1><p>Linux多进程编程中的可以使用fork函数来创建子进程。fork函数定义在头文件unistd.h中（uni表示unix，std当然是标准库，所以很好记），该函数的声明为<code>pid_t fork(void)</code>其中函数的返回值类型为pid_t，可以理解为一个整型，返回值具体为：</p>
<ul>
<li>在父进程中，fork返回新创建的子进程的进程ID；</li>
<li>在子进程中，fork返回0；</li>
<li>如果创建子进程失败，则返回一个负值</li>
</ul>
<p>具体创建的子进程与父进程的关系，很显示fork函数不能接受任何参数，它只简单地将父进程的几乎所有资源全部复制给子进程，然后就相当于父进程的一个副本运行，且无法与父进行共享数据。<br>具体 来说使用fork函数得到的子进程从父进程继承了整个进程的地址空间，包括：进程上下文、进程堆栈、内存信息、打开的文件描述符、信号控制设置、进程优先级、进程组号、当前工作目录、根目录、资源限制、控制终端等。<br><strong>子进程与父进程的区别在于：</strong></p>
<ul>
<li>父进程设置的锁，子进程不继承（因为如果是排它锁，被继承的话，矛盾了） </li>
<li>各自的进程ID和父进程ID不同 </li>
<li>子进程的未决告警被清除； </li>
<li>子进程的未决信号集设置为空集。</li>
</ul>
<span id="more"></span>
<p>当然linux下的头文件sched.h中有一个fork升级版本的进程创建函数clone。clone是fork的升级版本，不仅可以创建进程或者线程，还可以指定创建新的命名空间（namespace）、有选择的继承父进程的内存、甚至可以将创建出来的进程变成父进程的兄弟进程等。clone() 函数则可以将部分父进程的资源通过参数设定有选择地复制给子进程，没有复制的资源可以通过指针共享给子进程<br>下面主要分析fork函数创建进程数及运行情况<br>获取进程ID的相关函数有：</p>
<ul>
<li>getppid()返回当前进程的父进程ID</li>
<li>getpid()返回当前进程ID</li>
</ul>
<p>这两个函数都在头文件unistd.h中，不接受参数，返回值类型为pid_t<br>网上关于fork函数创建多少个子进程的分析有很多，这里说一个简单分析方法，其实fork就是为父进程创建子进程，也就是说一个进程，执行fork之后就会变成2个进程，仅此而已。当执行多次fork函数时与二叉树很像，从根结点往叶子节点，每次一个变2个，可以很好地用二叉树来分析创建的子进程树，以及涉及到循环时，循环执行的次数。首先说一下结论：假定根结点为二叉树的第0层（为了方便后面分析），每执行一次fork，就增加一层，如果使用循环执行n个fork，则共有n层，相应满二叉树的叶子结点数2^n即为总共创建的子进程数（根为第0层），满二叉树除了根结点之外的总结点数2^(n+1)-2就是循环执行的总次数。也就是说 <strong>执行n次fork函数，创建的子进程数为2^n个，用循环创建的fork时，循环执行的总次数为2^(n+1)-2次</strong><br>下面使用几个实例分析根据fork的原理和二叉树方法（其实也是根据原理）来分析：</p>
<h2 id="fork-用法"><a href="#fork-用法" class="headerlink" title="fork()用法"></a><strong>fork()用法</strong></h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">pid_t</span> fpid; <span class="comment">//创建一个临时变量用于存放fork的返回值</span></span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    fpid = fork();  <span class="comment">//创建子进程，父进程与子进程将分别执行此后的代码</span></span><br><span class="line">    <span class="keyword">if</span> (fpid &lt; <span class="number">0</span>)   <span class="comment">//创建子进程失败时将返回负值</span></span><br><span class="line">    ¦   std::cout &lt;&lt; <span class="string">&quot;Error in fork!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (fpid == <span class="number">0</span>) &#123;  <span class="comment">//子进程中fork的返回值为0，所以将由子进程执行该分支</span></span><br><span class="line">    ¦   std::cout &lt;&lt; <span class="string">&quot;Child: parent_pid:&quot;</span> &lt;&lt; <span class="built_in">getppid</span>() &lt;&lt; <span class="string">&quot; pid:&quot;</span> &lt;&lt; <span class="built_in">getpid</span>() &lt;&lt; <span class="string">&quot; child_pid:&quot;</span> &lt;&lt; fpid &lt;&lt; std::endl;</span><br><span class="line">    ¦   count++;  <span class="comment">//子进程复制来的count值为0，++之后将为1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;  <span class="comment">//父进程中fork的返回值为子进程的pid，所以将由父进程执行该分支</span></span><br><span class="line">    ¦   std::cout &lt;&lt; <span class="string">&quot;Parent: parent_pid:&quot;</span> &lt;&lt; <span class="built_in">getppid</span>() &lt;&lt; <span class="string">&quot; pid:&quot;</span> &lt;&lt; <span class="built_in">getpid</span>() &lt;&lt; <span class="string">&quot; child_pid:&quot;</span> &lt;&lt; fpid &lt;&lt; std::endl;</span><br><span class="line">    ¦   count++;  <span class="comment">//父进程中count为0，父子进程中的变量等数据是完全独立的</span></span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;count: &quot;</span> &lt;&lt; count &lt;&lt; std::endl;  <span class="comment">//最后输出count的当前值，显示该句父子进程都要执行</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Parent: parent_pid:<span class="number">3084</span> pid:<span class="number">3087</span> child_pid:<span class="number">3088</span></span><br><span class="line">count: <span class="number">1</span></span><br><span class="line">Child:  parent_pid:<span class="number">3087</span> pid:<span class="number">3088</span> child_pid:<span class="number">0</span></span><br><span class="line">count: <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>可以看到父进程的中创建的子进程的pid:3088刚好是子进程当前的pid，两个进程输出的count都是1，也就是只进行了一次累加<br>套用上面关于二叉树方法分析的情况，执行一次fork，即2^1=2两个进程</p>
<h2 id="通过循环执行多个fork-1"><a href="#通过循环执行多个fork-1" class="headerlink" title="通过循环执行多个fork-1"></a><strong>通过循环执行多个fork-1</strong></h2><p>不看输出的话考虑输出结果是什么，会输出多少次</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">4</span>; ++i) &#123;  <span class="comment">//通过for循环执行3次fork</span></span><br><span class="line">    ¦   fork();</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; ++count &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>执行第一个fork时，由原来的1个进程变成2个进程，第二次fork时，由2个变成4个，第三次fork时，由4个变成8个。所以最终共有8个进程。<br>二叉树法分析：<br>一共8个1，for循环中执行了3次fork，共创建了2^3=8个子进程，所以共有8个1输出。如下二叉树图中叶子结点所示：<br><img data-src="fork-1.jpg" alt=""><br>红色结点（即叶子结点）为创建的所有子进程<br>如图中标识，C1、P2、P3都是P1的子进程，只是它们创建于p1的不同时期，同样P4是P2的子进程，从C1创建的子进程有C2，C3。其中来自不同颜色的箭头表示不同的关系，箭头表示父进程-&gt;子进程，相同颜色的线表示来自同一个进程。<br>可以通过以下代码来验证：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">4</span>; ++i) &#123; </span><br><span class="line">    ¦   fork();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//分别输出各进程的父进程PID:当前进程PID:子进程PID</span></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">getppid</span>() &lt;&lt; <span class="string">&quot; : &quot;</span> &lt;&lt; <span class="built_in">getpid</span>() &lt;&lt; <span class="string">&quot; : &quot;</span> &lt;&lt; fpid &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>某一次的执行结果为（每次执行的结果都不一样，因为进程号肯定不同，当然有可能会出现进程号为1的情况，由于当获取父进程时，如果父进程此时已经执行完成并退出，那么系统中就不存在此进程，此时就返回其进程号为1）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3628 : 3630 : 3633</span><br><span class="line">3630 : 3633 : 0</span><br><span class="line">3629 : 3634 : 0</span><br><span class="line">3628 : 3629 : 3634</span><br><span class="line">3625 : 3628 : 3632</span><br><span class="line">3628 : 3632 : 0</span><br><span class="line">3629 : 3631 : 3635</span><br><span class="line">3631 : 3635 : 0</span><br></pre></td></tr></table></figure>
<p>可以根据类似链表的关系画出如下图：<br>!()[fork-1-1.jpg]<br>再根据上图的分析，很容易推断出各进程的ID在二叉树图上的对应关系</p>
<h2 id="通过循环执行多个fork-2"><a href="#通过循环执行多个fork-2" class="headerlink" title="通过循环执行多个fork-2"></a><strong>通过循环执行多个fork-2</strong></h2><p>注意下面的代码与上面fork-1中的唯一区别是将输出放在了for循环里面<br>不看输出的话考虑输出结果是什么，会输出多少次</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">4</span>; ++i) &#123;  <span class="comment">//通过for循环执行3次fork</span></span><br><span class="line">    ¦   fork();</span><br><span class="line">        std::cout &lt;&lt; ++count &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>创建的子进程数分析与fork-1中一样，都是8个子进程。关于for循环中的输出执行次数，当i=1时，执行一次fork，创建2个子进程，记为p1, c1（px表示父进程，cx表示子进程），进程p1,c1将分别从i=1执行到i=3，在for循环内部共执行2<em>3=6次，即这两个子进程会分别输出1，2，3各一次。由于这两个进程在执行for循环时还会继续创建进程，所以它们的2个1会首先输出在前面。当i=2时，执行第二次fork，之前的2个进程p1, c1将分别再创建一个进程，记为p2、c2（假设p2来自p1,c2来自c1），p2、c2将从i=2开始执行到i=3，这两个进程for循环内部共执行2</em>2=4次。当前执行到i=2时共有4个进程，分别为p1、c1、p2、c2，它们会分别输出一次2，共输出4个2。当i=3时，当前的4个进程将再分别创建一个进程，共创建4个进程，新创建的4个进程将各自执行一次for循环内部，for循环即结束了，共执行4次for循环内部。此时共有8个进程，每个进程都会输出一次3，共8个3。再综合各个进程中for循环执行的次数，可知6+4+4=14次，所以共有14个输出。</p>
<p>二叉树分析如下图所示：<br><img data-src="fork-2.jpg" alt=""><br>从上图可以看出i的取值为1，2，3阶段，各阶段执行的进程数分别为2，4，8，虽然一共只有8个进程，但for循环各阶段的进程都会进行一次输出，所以共输出14次，即为二叉树除根节点的结点总数2^4-2=14。</p>
<h2 id="fork-fork-进程数"><a href="#fork-fork-进程数" class="headerlink" title="fork()||fork()进程数"></a><strong>fork()||fork()进程数</strong></h2><p>分析如下代码创建的进程数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    fork() || fork();</span><br><span class="line">    std::cout &lt;&lt; count &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>由于fork函数在不同进程中的返回值不同，在子进程中返回为0，所以第一个fork执行完之后会有两个进程，父进程中fork返回值为真，||后面的代码不会执行，直接返回。子进程中fork()返回值为0，需要继续执行后面一个fork，再次为子进程创建一个子进程，所以共有3个子进程。<br>画二叉树分析：<br><img data-src="fork-4.jpg" alt=""><br>图中叶子节点数即为进程数。</p>
<h2 id="fork-amp-amp-fork-fork"><a href="#fork-amp-amp-fork-fork" class="headerlink" title="fork()&amp;&amp;fork()||fork()"></a><strong>fork()&amp;&amp;fork()||fork()</strong></h2><p>分析以下代码创建的进程数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    (fork() &amp;&amp; fork()) || fork();</span><br><span class="line">    std::cout &lt;&lt; count &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>首先第一个fork执行完之后为父进程（记为p1）创建一个子进程，记为c1，由于子进程fork返回值为0，所以子进程中第一个括号&amp;&amp;后面的表达式不需要再执行。父进程p1需要继续执行第二个fork，再次创建一个子进程p2，父进程p1的fork返回为真，||后面的不需要再执行。第二个子进程p2需要继续执行第三个fork，再次为第二子进程创建一个子进程p3，同样由于c1进程fork返回值为0，所以也还需要执行第三个fork，为其创建一个子进程c2，所以一共会创建5个进程。<br>画二叉树分析，如下图：<br><img data-src="fork-5.jpg" alt=""></p>
<p>对于以下代码创建的进程数为多少？</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    fork();  <span class="comment">//执行完后将有2个进程</span></span><br><span class="line">    (fork() &amp;&amp; fork()) || fork();  <span class="comment">//根据上面分析，这部分会创建5个进程，执行完成会有2*5=10个进程</span></span><br><span class="line">    fork();  <span class="comment">//执行完这句进程数会再次翻倍</span></span><br><span class="line">    std::cout &lt;&lt; count &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果为2<em>5</em>2=20，自行分析，这类问题只需要分步分析即可，如果涉及到一些输出的情况，最好画图看看</p>
<h2 id="循环fork，不刷新输出缓冲区的情况"><a href="#循环fork，不刷新输出缓冲区的情况" class="headerlink" title="循环fork，不刷新输出缓冲区的情况"></a><strong>循环fork，不刷新输出缓冲区的情况</strong></h2><p>考虑以下程序会输出多少个*：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123; </span><br><span class="line">        fork(); </span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;*&quot;</span>; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">************************</span><br></pre></td></tr></table></figure>
<p>按照通常的的想法，比如我们之前的公式，应该输出2^4-2=14个<em>，实际上输出结果去是3</em>8=24个<em>。<br>因为std::cout后面没有输出\n或者std::endl，也就是说在输出时没有刷新输出缓冲区，会导致父进程中的输出缓冲区内容依然是上次的内容，子进程在复制时同样会复制输出缓冲区中的内容，导致子进程输出缓冲区的内容实际上与父进程是一样的。由于第一个父进程的for循环会执行3次，输出缓冲区中会有3个</em>，虽然有的子进程的循环只能执行2次或1次，但输出缓冲区中的内容并没有少，所以同样最终也都会输出3个<em>。一共有8个进程，所以共有3</em>8=24个*输出。</p>
<h2 id="fork与虚拟地址空间"><a href="#fork与虚拟地址空间" class="headerlink" title="fork与虚拟地址空间"></a><strong>fork与虚拟地址空间</strong></h2><p>思考下面这段程序的输出中父进程与子进程中的num及num地址是否相同：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> pid;</span><br><span class="line">    <span class="type">int</span> num=<span class="number">1</span>;</span><br><span class="line">    pid=fork();</span><br><span class="line">    <span class="keyword">if</span>(pid&gt;<span class="number">0</span>)&#123;</span><br><span class="line">    ¦   num++;</span><br><span class="line">    ¦   std::cout &lt;&lt; <span class="string">&quot;in parent:num:&quot;</span> &lt;&lt; num &lt;&lt; <span class="string">&quot; addr:&quot;</span> &lt;&lt; &amp;num &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pid==<span class="number">0</span>)&#123;</span><br><span class="line">    ¦   std::cout &lt;&lt; <span class="string">&quot;in child:num:&quot;</span> &lt;&lt; num &lt;&lt; <span class="string">&quot; addr:&quot;</span> &lt;&lt; &amp;num &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">in parent:num:<span class="number">2</span> addr:<span class="number">0x7fffed819768</span></span><br><span class="line">in child:num:<span class="number">1</span>  addr:<span class="number">0x7fffed819768</span></span><br></pre></td></tr></table></figure>
<p>竟然num的地址为父进程与子进程中是一样的，但num的值却是不同的，之所以会出现这种情况是因为linu的虚拟地址空间策略下，所有进程都以为自己独享整个地址空间，所以每个进程都可以有0x01地址空间，但其实际映射到的真实地址空间并不相同。就像本文刚开始时说的一样，fork在复制时会继承父进程的整个地址空间，所以num的输出地址是一样的。</p>
<h1 id="pthread"><a href="#pthread" class="headerlink" title="pthread"></a>pthread</h1><p>最后说一下Linux下的pthread函数，该函数属于POSIX线程（POSIX threads）标准，该标准定义了一套用于线程的API，pthread函数包含在头文件pthread.h中。</p>
<h2 id="线程-VS-进程"><a href="#线程-VS-进程" class="headerlink" title="线程 VS 进程"></a>线程 VS 进程</h2><p>线程也称为轻量级的进程（lightweight process, LWP），在支持线程的系统中，线程是CPU调度和分派的基本单元；传统操作系统中CPU高度和分派的基本单位是进程，传统上的进程（相当于只含有一个线程的进程）也被称为重量级进程（heavyweight process, HWP）。当一个进程包含多个线程时，相当于将进程的任务划分成多个子任务，由线程同时执行多个任何。<br>进程中引入线程后，线程即作为CPU调度和分派的基本单位，而进程则作为资源拥有的基本单位，同一进程中的线程切换不会引起进程切换，可以避免昂贵的系统调用。<br>因为进程之间可以并发执行，而同一进程中的线程之间也可以并发执行，所以线程提高了操作系统的并发性，能更有效的使用系统资源和提高系统的吞吐量。<br>线程拥有自己独立的栈、调度优先级和策略、信号屏蔽字（创建时继承）、errno变量以及线程私有数据，这些资源相对于进程占用的资源来说很少。进程的其他地址空间（包含进程的代码段、数据段以及其他系统资源，如已打开的文件、IO设备等）均被所有线程所共享，因此线程可以访问进程的全局变量和堆中分配的数据，并通过同步机制保证对数据访问的一致性。这样多线程相对于进程可以降低系统开销。</p>
<h2 id="pthread线程操作相关的函数或类型"><a href="#pthread线程操作相关的函数或类型" class="headerlink" title="pthread线程操作相关的函数或类型"></a>pthread线程操作相关的函数或类型</h2><ul>
<li>pthread_t 是pthread的线程ID</li>
<li>pthread_create()用于创建新的线程</li>
<li>pthread_equal()用于比较两个线程id是否相等</li>
<li>pthread_self() 用于获取当前线程的id</li>
<li>pthread_exit() 线程调用该函数主动退出线程</li>
<li>pthread_join() 用于线程同步，以阻塞的方式等待指定线程结束</li>
</ul>
<p>参考：</p>
<ul>
<li><a href="http://blog.csdn.net/jason314/article/details/5640969">http://blog.csdn.net/jason314/article/details/5640969</a></li>
<li>man fork</li>
<li>man pthreads</li>
<li>其他网络搜索</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>fork</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux下的软链接和硬链接</title>
    <url>/2016/08/03/linux-soft-hard-link/</url>
    <content><![CDATA[<p>Linux下链接分两种，即硬链接（Hard link）和软链接（Symbolic link）。当然windows下面也有软链接、硬链接之分。<br>为了区分硬链接和软链接，首先需要清楚Linux系统中一切皆文件，文件由两个部分组成：用户数据，即数据块和元数据，即保存文件附加属性的数据（文件大小、创建时间、inode等）。Linux系统下的同一个文件系统中，每个文件都有一个唯一的inode（索引结点）号，inode才是文件的唯一标识，在访问文件时实际上都是通过inode号来访问文件的实际数据块。<br>硬链接和软件链接在访问时都共用一个目标数据块，主要区别就是每个硬链接相当于一个是一个指针，该指针指向同一个inode号，只要一个文件有任意一个硬链接存在，那么该文件就可以直接通过文件的硬链接访问，也就是说当删除一个硬链接时，并不影响其他硬链接来访问文件，硬链接本身并没有单独的inode号，同一个文件的硬链接都共用一个inode号只是文件名不同，甚至可以理解为我们在linux中使用ls看到的文件本身也就是某个数据块的一个硬链接。所以当使用mv命令移动这些硬链接时，并不影响对文件的访问，因为inode都一样。<br>而软链接即符号链接，软链接本身就是个独立的完整文件，相当于windows下的快捷方式，有自己的inode号，只是在访问该软链接时，会被转发为访问其链接到的实际文件，当删除软链接时，并不影响实际文件，甚至删除所有的软链接对实际文件也没有影响。当删除或移动实际文件时，都将无法通过软链接访问到该文件。   </p>
<span id="more"></span>

<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>创建链接使用命令ln，用法为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ln [options] 原文件   链接    #为文件创建链接</span><br><span class="line">ln [options] 原文件夹   链接   #为文件夹创建链接</span><br></pre></td></tr></table></figure>
<p><strong>options有很多可选项，其中常用的有-s用来指定创建软链接，-f用来创建时删除同名文件，-b创建时备份同名文件（备份文件会在原文件名后加个~）</strong></p>
<h2 id="硬链接的特点"><a href="#硬链接的特点" class="headerlink" title="硬链接的特点"></a>硬链接的特点</h2><ul>
<li>文件有相同的 inode 及 data block；</li>
<li>只能对已存在的文件进行创建；</li>
<li>不能交叉文件系统进行硬链接的创建；</li>
<li>不能对目录进行创建，只可对文件创建；</li>
<li>删除一个硬链接文件并不影响其他有相同 inode 号的文件。</li>
</ul>
<h2 id="软链接的特点"><a href="#软链接的特点" class="headerlink" title="软链接的特点"></a>软链接的特点</h2><ul>
<li>软链接有自己的文件属性及权限等；</li>
<li>可对不存在的文件或目录创建软链接，当链接到的文件存在时，即可直接通过软链接访问</li>
<li>软链接可交叉文件系统；</li>
<li>软链接可对文件或目录创建；</li>
<li>创建软链接时，链接计数 i_nlink 不会增加；</li>
<li>删除软链接并不影响被指向的文件，但若被指向的原文件被删除，则相关软连接被称为死链接（即dangling link，若被指向路径文件被重新创建，死链接可恢复为正常的软链接）。</li>
</ul>
<h2 id="链接相关命令"><a href="#链接相关命令" class="headerlink" title="链接相关命令"></a>链接相关命令</h2><ul>
<li>ls 的-i选项可查看文件的inode号，-l选项可以显示一个链接是否为软链接，-L选项显示软链接指向的文件属性而不是软链接本身的文件属性</li>
<li>stat 显示文件的属性，当然包括inode号及软链接情况</li>
<li>find /home -lname data.txt 查找路径/home下文件data.txt的软链接</li>
<li>find /home -samefile data.txt 查找路径/home下与data.txt具有相同inode的所有硬链接</li>
<li>find /home -inum 655420  查看路径/home下所有inode号为655420的硬链接</li>
<li>find /home -type l -ls   以ls命令的-dils的输出格式，列出路径/home下的所有软链接文件</li>
</ul>
<p>使用场景：如果需要当原文件移动后链接依然可用，显然需要硬链接。需要对文件夹创建链接时或者需要跨文件系统（例如一个ext4盘和ntfs盘），需要使用软链接。注意创建软链接时，尽量不要使用相对路径，因为使用相对路径时，当移动软链接后，很有可能就不无法通过该软链接访问原文件了。软链接的使用更广更方便，还可以为不存在的文件创建软链接，当链接到的文件存在时，该链接就又可以生效。</p>
<p>应用：一些配置文件统一放到某个文件夹（该文件夹设置为自动备份，如果使用git备份），然后为他们创建软链接或硬链接。<br>当然也可以像windows下使用mklink /D为文件夹创建符号链接一样将较大的一些文件夹链接到其他地方，以节省某些盘的空间。</p>
<p>参考：<br><a href="https://www.ibm.com/developerworks/cn/linux/l-cn-hardandsymb-links/">理解 Linux 的硬链接与软链接</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>C/C++基础知识拾遗</title>
    <url>/2016/07/30/cpp-gleaning/</url>
    <content><![CDATA[<p>C/C++中一些之前的学习中没有涉及到和容易模糊的知识点。<br>其他专题标签链接：<a href="http://notes.maxwi.com/tags/C-%E6%8B%BE%E9%81%97/">C++拾遗</a></p>
<h1 id="构造函数中需要初始化列表初始化的成员"><a href="#构造函数中需要初始化列表初始化的成员" class="headerlink" title="构造函数中需要初始化列表初始化的成员"></a>构造函数中需要初始化列表初始化的成员</h1><p>在构造函数中需要初始化列表初始化的有如下三种情况  </p>
<ol>
<li>带有const修饰的类成员 ，如const int a  </li>
<li>引用成员数据，如 int &p; （可以参见这里<a href="http://notes.maxwi.com/2016/07/15/cpp-gleaning-reference-member/">C/C++拾遗之类成员含引用变量</a>）</li>
<li>带有引用的类变量  （例如类A中含有有引用成员，类B中定义的类型为A的变量）</li>
</ol>
<p>static 修饰的变量在类外初始化，const修饰的在参数列表初始化 </p>
<span id="more"></span>

<h1 id="面向对象程序设计的SOLID原则"><a href="#面向对象程序设计的SOLID原则" class="headerlink" title="面向对象程序设计的SOLID原则"></a>面向对象程序设计的SOLID原则</h1><p>S.O.L.I.D是面向对象设计和编程(OOD&amp;OOP)中几个重要编码原则(Programming Priciple)的首字母缩写。</p>
<table>
<thead>
<tr>
<th>缩写</th>
<th>全称</th>
<th>中文</th>
</tr>
</thead>
<tbody><tr>
<td>SRP</td>
<td>The Single Responsibility Principle</td>
<td>单一责任原则</td>
</tr>
<tr>
<td>OCP</td>
<td>The Open Closed Principle</td>
<td>开放封闭原则</td>
</tr>
<tr>
<td>LSP</td>
<td>The Liskov Substitution Principle</td>
<td>里氏替换原则</td>
</tr>
<tr>
<td>DIP</td>
<td>The Dependency Inversion Principle</td>
<td>依赖倒置原则</td>
</tr>
<tr>
<td>ISP</td>
<td>The Interface Segregation Principle</td>
<td>接口分离原则</td>
</tr>
</tbody></table>
<h1 id="C-C-位运算符"><a href="#C-C-位运算符" class="headerlink" title="C/C++位运算符"></a>C/C++位运算符</h1><p>运算符优先级为从上到下递减，&lt;&lt;，&gt;&gt;优先级相同。</p>
<table>
<thead>
<tr>
<th>操作符</th>
<th>功能</th>
<th>用法</th>
</tr>
</thead>
<tbody><tr>
<td>~</td>
<td>位求反</td>
<td>~expr</td>
</tr>
<tr>
<td>&lt;&lt;</td>
<td>左移</td>
<td>expr1 &lt;&lt; expr2</td>
</tr>
<tr>
<td>&gt;&gt;</td>
<td>右移</td>
<td>expr1 &gt;&gt; expr2</td>
</tr>
<tr>
<td>&amp;</td>
<td>位与</td>
<td>expr1 &amp; expr2</td>
</tr>
<tr>
<td>^</td>
<td>位异或</td>
<td>expr1 ^ expr2</td>
</tr>
<tr>
<td>一个竖杠</td>
<td>位或</td>
<td>expr1</td>
</tr>
</tbody></table>
<p>其中左移/右移是指expr1中各位向左/右移动expr2位<br>位异或：相异为真，或者有一个为真，另一个为假即为真（或是有一个为真，即为真）。<br><strong>关于位运算的几个用法</strong></p>
<ol>
<li><code>x = x &amp; (x - 1);</code>会消掉x的二进制中最后一位为1的位，如7&amp;6=0111&amp;0110=0110，即将7最后一位1变成了0</li>
<li><code>(!(x &amp; (x-1)) &amp;&amp; x)</code>，返回1则n为2的正整数幂，根据1中的特点以及2的正整数幂的二进制中只有一个1，如1000表示16，&amp;&amp;x是为了排除0</li>
<li><code>(x &amp; 1)</code>，如果返回值为0，则x为偶数，如果返回值为1，则x为奇数。</li>
<li><code>x &lt;&lt; 1</code>相当于乘以2，<code>x &gt;&gt; 1</code>相当于除以2。相应的左多k位就是乘以2^k</li>
<li><code>x &amp; ((1 &lt;&lt; x) - 1)</code> 表示x mod 2^k</li>
<li><code>x = x | (x + 1);</code>会消掉x的二进制中最后一位为0的位，如10|11=1010|1011=1011，即将10的二进制的最后一位0变成了1</li>
</ol>
<h1 id="不能声明为虚函数的函数"><a href="#不能声明为虚函数的函数" class="headerlink" title="不能声明为虚函数的函数"></a>不能声明为虚函数的函数</h1><p>虚函数是为了实现动态绑定，不能声明为虚函数的有：</p>
<ol>
<li>静态成员函数 （静态成员函数不与任何对象绑定，也没有this指针，所有对象及类共用同一份代码，所以不能是虚函数）</li>
<li>类外的普通函数； （虚函数本身就是为了实现通过父类的指针来动态绑定到子类的虚函数的，没类自然没的说）</li>
<li>构造函数；（C++语言规定，网上这个讨论很多，也可以理解为构造函数不能被继承）</li>
<li>友元函数  （友元函数不能被继承）</li>
</ol>
<p>而对于内联函数（inline修饰）是可以声明为虚函数的，只是说，由于虚函数需要在运行时动态绑定（即根据动态类型需要进行虚函数调用），导致内联函数会被编译器在编译函数忽略，而当成普通函数来处理。因为内联函数是指在编译阶段，编译器使用函数的定义体来迭代函数调用语句，从而减少函数的调用来降低函数运行时间，如果内联函数在编译阶段被展开，那么运行时实际上是不存在内联函数的，虚函数定义成内联函数的话，编译器为了支持动态绑定，也就只能忽略内联函数了，毕竟inline关键字也只是给编译器建议，编译器是可以根据需要进行忽略的</p>
<h1 id="内联函数优缺点"><a href="#内联函数优缺点" class="headerlink" title="内联函数优缺点"></a>内联函数优缺点</h1><p>内联函数是指函数在声明时前面加上关键字inline，用来降低程序的运行时间。编译器在编译阶段将使用内联函数的定义体来替代内联函数调用语句，注意这种替代行为发生在编译阶段而非程序运行阶段（所以虚函数声明成的内联会被编译器忽略）。<br>另外内联函数仅仅是对编译器的内联建议，编译器是否采取你的建议取决于函数是否符合内联的有利条件。如果函数体非常大或者虚函数，那么编译器将忽略函数的内联声明，而将内联函数作为普通函数处理。</p>
<p>优点：</p>
<ul>
<li>它通过避免函数调用所带来的开销来提高程序的运行速度。因为 函数调用发生时，它节省了变量弹栈、压栈的开销和函数执行完返回原现场的开销。</li>
<li>通过将函数声明为内联，你可以把函数定义放在头文件内，而无需担心编译时遇到函数重复定义的错误</li>
</ul>
<p>缺点：</p>
<ul>
<li>因为代码的扩展，内联函数增大了可执行程序的体积。</li>
<li>内联函数中代码过多，会造成很大的内存消耗</li>
<li>不允许有循环或者开关语句，如果有的话，执行函数代码时间比调用开销大</li>
</ul>
<h1 id="sizeof-‘a’-的大小"><a href="#sizeof-‘a’-的大小" class="headerlink" title="sizeof(‘a’)的大小"></a>sizeof(‘a’)的大小</h1><p>直接看下面这段代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> c=<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>,<span class="built_in">sizeof</span>(c),<span class="built_in">sizeof</span>(<span class="string">&#x27;a&#x27;</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用gcc以C语言源文件编译运行结果为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 4</span><br></pre></td></tr></table></figure>
<p>而使用g++以C++语言源文件编译运行结果为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 1</span><br></pre></td></tr></table></figure>
<p>因为：<br>C99标准规定，’a’叫做整型字符常量(integer character constant)，被看成是int型，所以在32位机器上占4字节。<br>ISO C++标准规定，’a’叫做字符字面量(character literal)，被看成是char型，占1字节 </p>
<h1 id="需要做为成员函数重载的运算符"><a href="#需要做为成员函数重载的运算符" class="headerlink" title="需要做为成员函数重载的运算符"></a>需要做为成员函数重载的运算符</h1><ul>
<li>只能作为成员函数重载的运算符有：=、()、[]、-&gt;、new、delete。</li>
<li>单目运算符最好重载为成员函数。</li>
<li>对于复合的赋值运算符如+=、-=、*=、/=、&amp;=、!=、~=、%=、&gt;&gt;=、<code>&lt;&lt;=</code>建议重载为成员函数。</li>
<li>对于其它运算符，建议重载为友元函数。 </li>
</ul>
<h1 id="C-中不能被重载的运算符"><a href="#C-中不能被重载的运算符" class="headerlink" title="C++中不能被重载的运算符"></a>C++中不能被重载的运算符</h1><ul>
<li>类属关系运算符<code>.</code></li>
<li>成员指针运算符<code>.*</code></li>
<li>作用域运算符<code>::</code></li>
<li>sizeof运算符</li>
<li>三目运算符<code>?:</code></li>
<li>tpeid</li>
<li>const_cast</li>
<li>dynamstic_cast</li>
<li>reinterpret_cast</li>
<li>static_cast </li>
</ul>
<h1 id="补码"><a href="#补码" class="headerlink" title="补码"></a>补码</h1><p>下述描述中原数值是指绝对值，如-5的原数值为5<br>首先记住整数二进制的最高位即表示符号位，符号位为0表示正数，符号为1表示负数。<br>计算机中整数的二进制是以补码的形式存储在内存中的。一个正数的补码和它的原码相同，当然对于正数来说从其补码求原数值直接转化二进制即可。而负数的补码是该数的绝对值的二进制形式按位取反再加1（或者说是该数值的除符号位之外的各位按位取反再加1，符号位为1）。对于负数来说，从其补码求原数值也是除符号位之外按位取反再加1。<br>例如10的原码和补码（假定是2个字节）都是（符号位为0）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0000000000001010</span><br></pre></td></tr></table></figure>
<p>求-10的补码，直接将上述二进制除符号位按位取反再加1（符号位为1）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1111111111110110</span><br></pre></td></tr></table></figure>
<p>从-10的补码求其原数值10的二进制，还是除符号位，各位按位取反再加1（符号位为0）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0000000000001010</span><br></pre></td></tr></table></figure>
<p>转成10进制就是10，加符号位成-10<br>例如：求执行<code>int x = 1; int y = ~x;</code>后y的值<br>首先1在内存中的补码是其原码（还假定是2个字节，4字节也一样）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0000000000000001</span><br></pre></td></tr></table></figure>
<p>按位取反后赋给y：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1111111111111110</span><br></pre></td></tr></table></figure>
<p>由y的二进制求其原码，由于符号位为1，即负数，所以除符号位按位取反再加1即是y的原数值的二进制</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0000000000000010</span><br></pre></td></tr></table></figure>
<p>转成10进制即2，加符号位，y为-2</p>
<h1 id="C语言math-h中的abs"><a href="#C语言math-h中的abs" class="headerlink" title="C语言math.h中的abs"></a>C语言math.h中的abs</h1><p>C中函数abs申明为 int abs(int num);<br>num为0或正数时，函数返回num值；<br>当num为负数且不是最小的负数时，函数返回num的对应绝对值数，即将内存中该二进制位的符号位取反，并把后面数值位取反加一；<br>当num为最小的负数时（即0x80000000），由于正数里int类型32位表示不了这个数的绝对值，所以依然返回该负数。</p>
<h1 id="C语言文件读写"><a href="#C语言文件读写" class="headerlink" title="C语言文件读写"></a>C语言文件读写</h1><p>C语言中的文件操作函数定义在stdio.h头文件中，主要的文件操作函数有：</p>
<ul>
<li>FILE * fopen(const char *filename, const char *mode);以模式mode打开名为filename的文件</li>
<li>int fclose(FILE *stream);  //关闭一个给定的文件流stream</li>
<li>fread()和fwrite() 实现对文件流中整块数据的读/写</li>
<li>fgetc()和fputc()  对文件流读/写一个字符</li>
<li>fgets()和fputs()  从指定的文件流读/写字符串</li>
<li>fscanf()和fprintf()  对指定的文件流格式化读/读</li>
<li>ftell() 返回文件流的当前读写位置</li>
<li>fseek() 将文件流指针当前的读写位置移到指定的位置</li>
<li>rewind() 将文件指针重新指向指定流的开头</li>
</ul>
<h1 id="C-格式化输出"><a href="#C-格式化输出" class="headerlink" title="C++格式化输出"></a>C++格式化输出</h1><p>C++的cout，确切来说是ostream都是可以格式化输出的，格式化输入输出（Input/output manipulators）所用到的函数主要定义在头文件ios，istream，ostream和iomanip中，参数链接：<br><a href="http://en.cppreference.com/w/cpp/io/manip">Input/output manipulators</a><br>例如：<br>1.按输出4位以下的整数num，并且不足4位的位补0，如12，输出为0012</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::cout &lt;&lt; std::<span class="built_in">setw</span>(<span class="number">4</span>) &lt;&lt; std::<span class="built_in">setfill</span>(<span class="string">&#x27;0&#x27;</span>) &lt;&lt; <span class="number">12</span> &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>
<p>2.输出double，保留小数位后4位：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::cout &lt;&lt; std::<span class="built_in">setiosflags</span>(std::ios::fixed) &lt;&lt; std::<span class="built_in">setprecision</span>(<span class="number">6</span>) &lt;&lt; pi &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>

<h1 id="C-时间相关头文件"><a href="#C-时间相关头文件" class="headerlink" title="C++时间相关头文件"></a>C++时间相关头文件</h1><p>C++下面可以统计时间的相关头文件有两个，一个是C风格的ctime，和C++11中新增的chrono，chrono是一个模板类，当然chrono的优点更多，功能也更强大，可以看SOF上的这个比较和解释<a href="http://stackoverflow.com/questions/36095323/what-is-the-difference-between-chrono-and-ctime">what is the difference between chrono and ctime</a><br>需要注意的是chrono下的函数及类型都定义在头文件std::chrono下。下面来自cppreference上的一个例子给出了它们两个很简单的用法<br>下面我会一句句加注释来解释</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>  <span class="comment">//标准输出头文件，没什么好说的</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span>   <span class="comment">//用于格式化输入输出的头文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span>   <span class="comment">//C++11中新增加的时间操作头文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span>    <span class="comment">//C-style的时间操作头文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span>   <span class="comment">//C++11中用于多线程的头文件</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// the function f() does some time-consuming work</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">double</span> d = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> n=<span class="number">0</span>; n&lt;<span class="number">10000</span>; ++n)</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> m=<span class="number">0</span>; m&lt;<span class="number">10000</span>; ++m)</span><br><span class="line">           d += d*n*m;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::<span class="type">clock_t</span> c_start = std::<span class="built_in">clock</span>();   <span class="comment">// C-style时间函数，返回从当前进程开启到调用该函数时CPU时钟记录的近似时间，必须要除以CLOCKS_PER_SEC来获取以秒为单位的时间</span></span><br><span class="line">    <span class="keyword">auto</span> t_start = std::chrono::high_resolution_clock::<span class="built_in">now</span>();  <span class="comment">//返回当前的最高精确时钟时间，返回值类型为std::chrono::time_point&lt;std::chrono::high_resolution_clock&gt;</span></span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(f)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(f)</span></span>; <span class="comment">// f() is called on two threads</span></span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">    std::<span class="type">clock_t</span> c_end = std::<span class="built_in">clock</span>();</span><br><span class="line">    <span class="keyword">auto</span> t_end = std::chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line"> </span><br><span class="line"> <span class="comment">//通过clock()两次返回值的差获得其两次调用期间所经历的时间</span></span><br><span class="line"> <span class="comment">//通过模板类std::chrono::duration的count函数来获得指定精度的时间时隔</span></span><br><span class="line">    std::cout &lt;&lt; std::fixed &lt;&lt; std::<span class="built_in">setprecision</span>(<span class="number">2</span>) &lt;&lt; <span class="string">&quot;CPU time used: &quot;</span></span><br><span class="line">              &lt;&lt; <span class="number">1000.0</span> * (c_end-c_start) / CLOCKS_PER_SEC &lt;&lt; <span class="string">&quot; ms\n&quot;</span></span><br><span class="line">              &lt;&lt; <span class="string">&quot;Wall clock time passed: &quot;</span></span><br><span class="line">              &lt;&lt; std::chrono::<span class="built_in">duration</span>&lt;<span class="type">double</span>, std::milli&gt;(t_end-t_start).<span class="built_in">count</span>()</span><br><span class="line">              &lt;&lt; <span class="string">&quot; ms\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出是</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">CPU time used: <span class="number">1590.00</span> ms</span><br><span class="line">Wall clock time passed: <span class="number">808.23</span> ms</span><br></pre></td></tr></table></figure>

<h1 id="C-内存布局"><a href="#C-内存布局" class="headerlink" title="C++内存布局"></a>C++内存布局</h1><p>参见这里<a href="http://notes.maxwi.com/2016/06/11/cpp-memory-layout/">实例分析C++内存布局</a></p>
<h1 id="C-标准在哪看"><a href="#C-标准在哪看" class="headerlink" title="C++标准在哪看"></a>C++标准在哪看</h1><p>SOF上的高票回答给出的非常详细<a href="http://stackoverflow.com/questions/81656/where-do-i-find-the-current-c-or-c-standard-documents">Where do I find the current C or C++ standard documents?</a></p>
<h1 id="C-C-GCC编译器标准库源码"><a href="#C-C-GCC编译器标准库源码" class="headerlink" title="C/C++ GCC编译器标准库源码"></a>C/C++ GCC编译器标准库源码</h1><p>可以使用locate来定位所需要的头文件，使用locate之前需要先root运行updatedb来更新locate所需要的数据库文件。如查看string的头文件可能的位置<code>locate string</code>，当然头文件通常都在<code>/usr/include/</code>及其子文件夹下，配合grep筛选查找。</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>CPP</tag>
        <tag>C++拾遗</tag>
      </tags>
  </entry>
  <entry>
    <title>C/C++拾遗之含有可变形参的函数</title>
    <url>/2016/07/29/cpp-gleaning-function-with-varying-parameters/</url>
    <content><![CDATA[<p>C++11中提供了两种可以实现可变参数的函数实现方式：initializer_list的标准模板类型和可变参数模板。C语言中可以通过省略符类型实现可变数量的参数函数（推荐只有在需要与C函数交互时才使用些方式）。</p>
<h2 id="initializer-list形参"><a href="#initializer-list形参" class="headerlink" title="initializer_list形参"></a>initializer_list形参</h2><p>C++11中的头文件initializer_list中提供了一种标准库类型initializer_list类型，通过该模板可以实现全部实参类型都相同的可变参数函数。使用时只需要将initializer_list类型的参数作为函数形参即可，因为initializer_list可以接受多个元素作为初始化列表，相当于一个变长数组，然后在函数中通过initializer_list头文件中提供的相应函数获取其中的元素即可。initializer_list提供的操作有：</p>
<span id="more"></span>

<ul>
<li>initializer_list<T> lst;  //默认初始化；T类型元素的空列表</li>
<li>initializer_list<T> lst{a, b, c…}; lst的元素是相应初始值的副本，且列表中的元素是const</li>
<li>lst2(lst); lst2 = lst; 拷贝或赋值一个initializer_list对象不会拷贝列表中的元素；拷贝后，原始列表和副本共享元素</li>
<li>lst.size() 列表中的元素数量  </li>
<li>lst.begin() 返回指向lst中首元素的指针</li>
<li>lst.end() 返回指向lst中尾元素下一位置的指针</li>
</ul>
<p>用法举例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;initializer_list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function">T <span class="title">sum</span><span class="params">(std::initializer_list&lt;T&gt; args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T total = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp;item : args)   <span class="comment">//使用范围for</span></span><br><span class="line">        total += item;</span><br><span class="line">    <span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">sum</span>&lt;<span class="type">int</span>&gt;(&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">sum</span>&lt;<span class="type">double</span>&gt;(&#123;<span class="number">1</span>, <span class="number">1.2</span>, <span class="number">3</span>, <span class="number">14.4</span>&#125;) &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">15</span><br><span class="line">19.6</span><br></pre></td></tr></table></figure>
<p>与我们期望的一样，double类型的运算中，整型也被正确地隐式转换为了浮点数参与计算</p>
<h2 id="可变参数模板"><a href="#可变参数模板" class="headerlink" title="可变参数模板"></a>可变参数模板</h2><p>一个可变参数模板就是一个可以接受可变数目参数的模板函数或模板类，当然这里我们只会用到模板函数。可变数目的参数被称为参数包，包括模板参数包（由0个多或多个类型组成）和函数参数包（由0个或多个函数参数组成）。可变参数的函数模板声明通常形如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Args是一个模板参数包，rest是一个函数参数包</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> ... Args&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">const</span> T &amp;t, <span class="type">const</span> Args&amp; ... rest)</span></span>;  <span class="comment">//扩展Args</span></span><br></pre></td></tr></table></figure>
<p>也就是<code>typename 省略号（...） 模板参数包名字</code>来定义一个模板参数包，<code>扩展模式 模板包名字 省略号（...） 函数参数包名字</code>来将模板包扩展成相应模式下的函数参数包，同样当将函数参数包名字后跟省略号时，即可扩展函数参数包。当编译器在对模板特例化时，会自动按照提供给参数包的模式进行扩展包，扩展之后的参数相当于一个以逗号分隔的参数列表，如上例中const Arg&amp;会应用到模板参数包Args中的每一个元素，也就是最终rest中包含的所有元素都将是const的引用，类型由编译器根据传递的参数进行自动推断。<br>注意可变参数模板的使用不需要再指定类型，具体类型由编译器根据传递给函数的实参进行推断。<br>当需要在函数内部访问各参数列表中的参数时，直接对函数参数包进行扩展即可，通常是采用递归的方式访问各参数，为了终止递归就需要定义一个重载的函数用于终止递归<br>与可变参数模板对应的还有一个sizeof…运算符，用于返回参数包中的参数个数，当然可以用它来配合递归函数访问各参数。<br>下面还是以一个计算和的例子分析：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">const</span> T &amp;t, <span class="type">const</span> Args&amp; ... args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;sizeof...(Args): &quot;</span> &lt;&lt; <span class="keyword">sizeof</span>...(Args) &lt;&lt; std::endl;  <span class="comment">//输出模板参数Args的个数</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;sizeof...(args): &quot;</span> &lt;&lt; <span class="keyword">sizeof</span>...(args) &lt;&lt; std::endl; <span class="comment">//输出函数参数args的个数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">std::ostream&amp; <span class="title">print</span><span class="params">(std::ostream &amp;os, <span class="type">const</span> T &amp;t)</span>    <span class="comment">//用于结束递归，当参数个数为2个时调用</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> os &lt;&lt; t &lt;&lt; std::endl;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> ... Args&gt;</span><br><span class="line"><span class="function">std::ostream&amp; <span class="title">print</span><span class="params">(std::ostream &amp;os, <span class="type">const</span> T &amp;t, Args ... rest)</span>  <span class="comment">//当参数个数大于2个时调用</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    os &lt;&lt; t &lt;&lt; <span class="string">&quot;, &quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">print</span>(os, rest...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">sum_template</span><span class="params">(<span class="type">const</span> T &amp;t)</span>   <span class="comment">//声明一个重载的固定参数数目的函数，用于结束递归</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function">T <span class="title">sum_template</span><span class="params">(<span class="type">const</span> T &amp;t, <span class="type">const</span> Args&amp;... args)</span>   <span class="comment">//该函数通过调用仅含一个参数的重载函数来结束递归</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span>  <span class="built_in">sum_template</span>(args...) + t;  <span class="comment">//展开函数参数包args中的实参</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">foo</span>(<span class="string">&#x27;a&#x27;</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="string">&quot;ssl&quot;</span>);</span><br><span class="line">    <span class="built_in">print</span>(std::cout, <span class="string">&#x27;a&#x27;</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="string">&quot;ssl&quot;</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">sum_template</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">sum_template</span>(<span class="number">1.1</span>, <span class="number">2.5</span>, <span class="number">3</span>, <span class="number">4.4</span>, <span class="number">5</span>) &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sizeof...(Args): 3</span><br><span class="line">sizeof...(args): 3</span><br><span class="line">a, 2, 3, ssl</span><br><span class="line">15</span><br><span class="line">15.6</span><br></pre></td></tr></table></figure>
<p>结果后面的求和输出结果可见，对于将double与int混合计算时结果是错误的，因为计算过程中发生了double到int的转换，导致精度损失，所以对于这种情况要注意类型转换问题。</p>
<h2 id="省略符类型（…）"><a href="#省略符类型（…）" class="headerlink" title="省略符类型（…）"></a>省略符类型（…）</h2><p>C语言中通过头文件stdarg.h提供的几个宏定义可以实现可变参数的函数，但要求该函数至少要有一个确定的类型的参数。对应C++中的头文件是cstdarg，C++中也允许只有省略参数类型的函数。<br>详细参考链接<a href="http://www.cse.unt.edu/~donr/courses/4410/NOTES/stdarg/">http://www.cse.unt.edu/~donr/courses/4410/NOTES/stdarg/</a><br>主要需要使用到cstdarg头文件中的1个类型和3个函数：</p>
<ul>
<li>va_list varname 用于定义指向参数列表的变量varname</li>
<li>va_start(varname, last_defined_arg) 用于将varname指向所有参数中最后一个确定的参数</li>
<li>va_arg(varname, typename) 获取下一个类型为typename的参数</li>
<li>va_end(varname)  在函数返回前调用，用于清空参数列表栈，以使函数可以正常返回</li>
<li>va_copy(varname) 拷贝参数列表（C++11）<br>举例：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdarg&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//切勿混合使用cstdarg与模板</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">sum_arg</span><span class="params">(<span class="type">int</span> argnum, ...)</span>   <span class="comment">//至少要有一个确定的参数，通常第一个参数用于传递参数的个数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">double</span> total = <span class="number">0.0</span>;</span><br><span class="line">    va_list args;   <span class="comment">//定义一个参数列表变量</span></span><br><span class="line">    <span class="built_in">va_start</span>(args, argnum);    <span class="comment">//初始化参数列表变量，指向最后一个确定的参数（因为可以有多个确定的参数）</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; argnum; ++i)</span><br><span class="line">        total += <span class="built_in">va_arg</span>(args, <span class="type">double</span>);    <span class="comment">//获取下一个参数</span></span><br><span class="line">    <span class="built_in">va_end</span>(args);   <span class="comment">//清空系统栈，返回使用函数调用者可以正常返回</span></span><br><span class="line">    <span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;double-1: &quot;</span> &lt;&lt; <span class="built_in">sum_arg</span>(<span class="number">5</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3.4</span>, <span class="number">5</span>, <span class="number">6.2</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;double-2: &quot;</span> &lt;&lt; <span class="built_in">sum_arg</span>(<span class="number">5</span>, <span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.4</span>, <span class="number">5.0</span>, <span class="number">6.2</span>) &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
输出为：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">double-1: 1.36621e+161</span><br><span class="line">double-2: 17.6</span><br></pre></td></tr></table></figure>
发现double-1的输出结果是错误的，因为double-1中传递的有一些整型值，此时函数中只会读取参数列表中所有的浮点型，一共只有2个浮点型，导致后面的3个参数读取的内存中存储随机值，所以出错。而double-2中都是浮点数，所以没有问题。可见这种方式不像initializer_list的方式那样可以进行隐式类型转换。</li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++拾遗</tag>
      </tags>
  </entry>
  <entry>
    <title>C/C++拾遗之extern &quot;C&quot;</title>
    <url>/2016/07/28/cpp-gleaning-extern-c/</url>
    <content><![CDATA[<p>extern “C”的主要作用是让C++中的函数名字使用C语言的编译处理方式（也就是在编译阶段，确切来说 是汇编阶段不对函数名进行mangle处理），这样就可以让C语言代码能够通过“与C语言兼容的方式声明的头文件”来链接C++编译器生成的二进制格式文件中函数。由于C++支持函数重载，而C语言不支持，C++编译器为了支持函数重载，就需要为同名但参数列表不同的函数名指定一个全局唯一的名字（该名字被称为mangled name），也就是编译阶段的mangle name过程，这些名字通常会包含相应的参数列表类型等，不同的编译器实现不同。<br>由于有extern的修饰，表示被修饰的变量或函数的对外部文件可见，或其定义来自其他文件中，与static的作用刚好相反。<br>SOF上的回答：<a href="http://stackoverflow.com/questions/1041866/in-c-source-what-is-the-effect-of-extern-c">http://stackoverflow.com/questions/1041866/in-c-source-what-is-the-effect-of-extern-c</a></p>
<span id="more"></span>

<p>下面以代码来分析，环境为ubuntu 14.04.4，gcc 4.8.4：<br>文件较多，一一分析。<br><strong>文件名：extern_c.h</strong>，该头文件显然是可以被C及C++源码包含的，因为里面没有用到C++的高级特性</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//与C语言兼容的函数声明，函数定义放在C++的源代码中</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> EXTERN_C_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXTERN_C_H</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">char</span> <span class="title">get</span><span class="params">(<span class="type">char</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">mult</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* !EXTERN_C_H */</span></span></span><br></pre></td></tr></table></figure>

<p><strong>文件名：divi.h</strong>，该文件中包含有不兼容于C语言的头文件，所以这个文件是不能被C源码包含的</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> DIVI_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DIVI_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">divi</span><span class="params">(<span class="type">float</span>, <span class="type">float</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* !DIVI_H */</span></span></span><br></pre></td></tr></table></figure>

<p>文件名：extern_add.cpp，该文件中的add函数被声明为extern “C”属性</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>查看其汇编代码（命令g++ -S extern_add.cpp，汇编文件名为extern_add.s）如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">	.file	&quot;extern_add.cpp&quot;</span><br><span class="line">	.text</span><br><span class="line">	.globl	add</span><br><span class="line">	.type	add, @function</span><br><span class="line">add:</span><br><span class="line">.LFB0:</span><br><span class="line">	.cfi_startproc</span><br><span class="line">	pushq	%rbp</span><br><span class="line">	.cfi_def_cfa_offset 16</span><br><span class="line">	.cfi_offset 6, -16</span><br><span class="line">	movq	%rsp, %rbp</span><br><span class="line">	.cfi_def_cfa_register 6</span><br><span class="line">	movl	%edi, -4(%rbp)</span><br><span class="line">	movl	%esi, -8(%rbp)</span><br><span class="line">	movl	-8(%rbp), %eax</span><br><span class="line">	movl	-4(%rbp), %edx</span><br><span class="line">	addl	%edx, %eax</span><br><span class="line">	popq	%rbp</span><br><span class="line">	.cfi_def_cfa 7, 8</span><br><span class="line">	ret</span><br><span class="line">	.cfi_endproc</span><br><span class="line">.LFE0:</span><br><span class="line">	.size	add, .-add</span><br><span class="line">	.ident	&quot;GCC: (Ubuntu 4.8.4-2ubuntu1~14.04.3) 4.8.4&quot;</span><br><span class="line">	.section	.note.GNU-stack,&quot;&quot;,@progbits</span><br></pre></td></tr></table></figure>
<p>显示汇编之后的函数add的名字依然是add</p>
<p><strong>文件名：extern_c.cpp</strong>，该文件是extern_c.h头文件中声明的函数的定义</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;  </span><br><span class="line"><span class="comment">//将头文件声明为extern &quot;C&quot;之后，该头文件中声明的所有函数都将在编译时以C语言的方式处理</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;extern_c.h&quot;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;    </span><br><span class="line"><span class="comment">//此时是否加extern &quot;C&quot;都一样，因为整个头文件都被声明为了extern &quot;C&quot;</span></span><br><span class="line">    <span class="function"><span class="type">char</span> <span class="title">get</span><span class="params">(<span class="type">char</span> ch)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ch;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">mult</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>   <span class="comment">//不需要extern &quot;C&quot;，因为头文件已经被声明为extern &quot;C&quot;</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a * b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">divi</span><span class="params">(<span class="type">float</span> a, <span class="type">float</span> b)</span>  <span class="comment">//未被声明为extern &quot;C&quot; 属性，将无法被C源代码引用</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a / b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对extern_c编译之后读取其符号表内容如下（命令readelf -s extern_c.o）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Symbol table &#x27;.symtab&#x27; contains 11 entries:</span><br><span class="line">   Num:    Value          Size Type    Bind   Vis      Ndx Name</span><br><span class="line">     0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND </span><br><span class="line">     1: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS extern_c.cpp</span><br><span class="line">     2: 0000000000000000     0 SECTION LOCAL  DEFAULT    1 </span><br><span class="line">     3: 0000000000000000     0 SECTION LOCAL  DEFAULT    2 </span><br><span class="line">     4: 0000000000000000     0 SECTION LOCAL  DEFAULT    3 </span><br><span class="line">     5: 0000000000000000     0 SECTION LOCAL  DEFAULT    5 </span><br><span class="line">     6: 0000000000000000     0 SECTION LOCAL  DEFAULT    6 </span><br><span class="line">     7: 0000000000000000     0 SECTION LOCAL  DEFAULT    4 </span><br><span class="line">     8: 0000000000000000    15 FUNC    GLOBAL DEFAULT    1 get</span><br><span class="line">     9: 000000000000000f    19 FUNC    GLOBAL DEFAULT    1 mult</span><br><span class="line">    10: 0000000000000022    42 FUNC    GLOBAL DEFAULT    1 _Z4diviff</span><br></pre></td></tr></table></figure>
<p>从符号表中可以看到被声明为extern “C”的函数get和mult的函数名在汇编之后没有变，这样当C语言代码的链接这个编译之后的文件时才能找到相应的函数get和mult，但找不到div，因为可以看到div在编译之后名字被mangle成为_Z4diviff。（当然通过查看汇编代码也可以清楚地分析到来其作用，因为mangle是在汇编阶段进行的）</p>
<p><strong>文件名：c_test_extern.c</strong>，该文件为C语言源代码，用它来链接C++编译生成的可链接的目标文件</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;extern_c.h&quot;</span>  <span class="comment">//该头文件实际是C++的头文件，里面只有兼容C语言的声明，但由于定义都带有extern &quot;C&quot;， 所以可以引用</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">3</span>, b = <span class="number">5</span>;</span><br><span class="line">    <span class="type">int</span> a_b_add = add(a, b);</span><br><span class="line">    <span class="type">int</span> a_b_mult = mult(a, b);</span><br><span class="line">    <span class="type">char</span> ch = get(<span class="number">65</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a + b = %d\na * b = %d\nchar(65) = %c\n&quot;</span>, a_b_add, a_b_mult, ch);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译方法：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">g++ -c extern_c.cpp extern_add.cpp  #编译C++源文件</span><br><span class="line">gcc -c c_test_extern.c  #编译C语言源文件</span><br><span class="line">gcc -o c_test_extern extern_c.o extern_add.o c_test_extern.o  #将链接C与C++源文件编译出的可重定位的目标文件，并生成可执行的目标文件c_test_extern</span><br></pre></td></tr></table></figure>
<p>没有任何问题，因为gcc在链接时，由于C++的目标文件在编译时函数名没有被mangle，所以可以正常找到函数名<br>执行c_test_extern输出为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a + b = 8</span><br><span class="line">a * b = 15</span><br><span class="line">char(65) = A</span><br></pre></td></tr></table></figure>
<p>假如在定义add函数的C++文件extern_c.cpp中不声明为extern “C”，则链接会出错，错误内容为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">c_test_extern.o: In function `main&#x27;:</span><br><span class="line">c_test_extern.c:(.text+0x21): undefined reference to `add&#x27;</span><br><span class="line">collect2: error: ld returned 1 exit status</span><br></pre></td></tr></table></figure>
<p>提示很明显：未定义的引用add，因为add的名字被g++ mangle成其他名字了。</p>
<p><strong>文件名：cpp_test_extern.cpp</strong> 用于测试C++引用extern “C”中的函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line"><span class="comment">//由于extern_c.h头文件中的声明的函数在定义时都增加了extern &quot;C&quot;属性，当C++源文件需要</span></span><br><span class="line"><span class="comment">//引用这些函数时都必须声明为extern &quot;C&quot;，否则在链接时由于默认情况下C++汇编器会mangle函数名</span></span><br><span class="line"><span class="comment">//从而导致链接器会以mangle之后的名字去找需要引用的函数，但定义这些函数的源代码</span></span><br><span class="line"><span class="comment">//却是以C语言的方式汇编，即函数名都是原名，从而导致找不到需要引用的函数。</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;extern_c.h&quot;</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;divi.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">3</span>, b = <span class="number">5</span>;</span><br><span class="line">    <span class="type">int</span> a_b_add = <span class="built_in">add</span>(a, b);</span><br><span class="line">    <span class="type">int</span> a_b_mult = <span class="built_in">mult</span>(a, b);</span><br><span class="line">    <span class="type">float</span> a_b_div = <span class="built_in">divi</span>(a, b);</span><br><span class="line">    <span class="type">char</span> ch = <span class="built_in">get</span>(<span class="number">65</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;a + b = &quot;</span> &lt;&lt; a_b_add &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;a * b = &quot;</span> &lt;&lt; a_b_mult &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;a / b = &quot;</span> &lt;&lt; a_b_div &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;char(65) = &quot;</span> &lt;&lt; ch &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译方法：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">g++ -o cpp_test_extern cpp_test_extern.cpp extern_c.cpp extern_add.cpp</span><br></pre></td></tr></table></figure>
<p>运行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a + b = 8</span><br><span class="line">a * b = 15</span><br><span class="line">a / b = 0.6</span><br><span class="line">char(65) = A</span><br></pre></td></tr></table></figure>
<p>假如在包含头文件时，不使用extern “C”声明头文件extern_c.h，编译会输出错误：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cpp_test_extern.o: In function `main&#x27;:</span><br><span class="line">cpp_test_extern.cpp:(.text+0x22): undefined reference to `add(int, int)&#x27;</span><br><span class="line">cpp_test_extern.cpp:(.text+0x34): undefined reference to `mult(int, int)&#x27;</span><br><span class="line">cpp_test_extern.cpp:(.text+0x5b): undefined reference to `get(char)&#x27;</span><br><span class="line">collect2: error: ld returned 1 exit status</span><br></pre></td></tr></table></figure>
<p>错误意思为： 未定义的引用，即无法找到相应的函数</p>
<p>最后注意extern “C”影响的只是编译器对于编译时函数名的处理方式，并不影响语言特性，也就是说不管带不带extern “C”，代码都是以C++的方式处理，而不是说带了extern “C”的代码就以C语言方式处理。例如对于常量字符，我们知道C语言认为是int型，如’a’，C语言认为其占用4个字节，而C++认为是char型，即1个字节。如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cpp_print</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> c=<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>,<span class="built_in">sizeof</span>(c),<span class="built_in">sizeof</span>(<span class="string">&#x27;a&#x27;</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="type">void</span> <span class="title">c_print</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> c=<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;extern_c:%d %d\n&quot;</span>,<span class="built_in">sizeof</span>(c),<span class="built_in">sizeof</span>(<span class="string">&#x27;a&#x27;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cpp_print</span>();</span><br><span class="line">    <span class="built_in">c_print</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">1</span></span><br><span class="line">extern_c:<span class="number">1</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>显示都是C++的方式处理的</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++拾遗</tag>
      </tags>
  </entry>
  <entry>
    <title>C/C++拾遗之条件编译</title>
    <url>/2016/07/27/cpp-gleaning-conditional-compile/</url>
    <content><![CDATA[<p>条件编译是由一批预处理器指令，通过指定一些限定的条件，有选择性地对源代码进行预处理，从而实现条件编译。后续的编译、链接等过程都是在预处理之后的代码上进行的，所以预处理之后的代码通常要精简很多（这里精简的思想是包含那个引入的头文件的），无意义的编译指令，根据条件编译代码不需要编译的代码，还有注释都会有预处理之后忽略掉。常用的预的处理器指令主要有（方括号中为后面需要跟的内容）：</p>
<span id="more"></span>

<p><strong>#空指令： 无意义，预处理时会被忽略</strong><br><strong>#include [file_name]： 包含一个源代码文件，通常是头文件</strong><br><strong>#define [args] [可选的常量]： 定义宏</strong><br><strong>#undef [args]：取消已定义的宏</strong><br><strong>#if [args]： 如果给定条件为真，则编译下面代码，args必须是已定义的常量宏，或者未定义</strong><br><strong>#ifdef [args]：如果宏已经定义，则编译下面代码</strong><br><strong>#ifndef [args]：如果宏没有定义，则编译下面代码</strong><br><strong>#elif [args]：如果前面的#if给定条件不为真，当前条件为真，则编译下面代码</strong><br><strong>#endif：结束一个#if……#else条件编译块</strong><br><strong>#error [sentence]：停止编译并显示错误信息</strong><br><strong>#line [number] [file_name]：修改变量<strong>LINE</strong>和<strong>FILE</strong>的值</strong></p>
<p>注意有两个特殊的运算符：#运算符和##运算符<br>下面以代码举例：<br>头文件：<br>macro.h</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MACRO_H  <span class="comment">//防止头文件被重复包含</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MACRO_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">#   <span class="comment">//空指令，没有任何意义</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* !MACRO_H */</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>源文件：<br>macro.cpp</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;macro.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PI 3.1415926   <span class="comment">//#define指令</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CUBE(x) (x)*(x)*(x)  <span class="comment">//带参数的#define指令</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AGE(x) <span class="string">&quot;My age is &quot;</span> #x   <span class="comment">//#运算符用于将后面的参数转成字符串</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CON(x, y, z) x##y##z  <span class="comment">//##运算符将其两侧的参数合并为一个符号，注意x, y, z必须为数字</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RUN 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NODEBUG</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IS_COMPILE</span></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> IS_COMPILE   <span class="comment">//取消宏定义</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; PI &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">CUBE</span>(PI + PI) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">AGE</span>(<span class="number">25</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">CON</span>(<span class="number">18</span>, <span class="number">19</span>, <span class="number">20</span>) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> DEBUG  <span class="comment">//#if后面必须是个常量，如果DEBUG为真，则编译其后的代码，直到#elif，或#else，或#endif</span></span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Debug&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> RUN  <span class="comment">//同#if，与控制语句else if作用一样</span></span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Run&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;NONE&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> NODEUBG  <span class="comment">//等价于#if defined NODEUBG</span></span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;NoDebug&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> IS_COMPILE</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;is compile&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> NODEUBG  <span class="comment">//等价于#if !defined NODEUBG</span></span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;no NoDebug&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">line</span> 15 <span class="string">&quot;my_macro.cpp&quot;</span>  <span class="comment">//更改当前行为第15行，文件名为my_macro.cpp，也就是修改__LINE__和__FILE__变量的值</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !defined(__cplusplus)   <span class="comment">//如果没有定义__cplusplus则报错误#error+其后的字符串内容</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">error</span> C++ compiler required.</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码通过g++ 4.8.4预处理（命令是g++ -E -std=c++11 macro.cpp）之后的代码如下（忽略掉包含的头文件iostream部分）：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"># <span class="number">1</span> <span class="string">&quot;macro.cpp&quot;</span></span><br><span class="line"># <span class="number">1</span> <span class="string">&quot;&lt;built-in&gt;&quot;</span></span><br><span class="line"># <span class="number">1</span> <span class="string">&quot;&lt;command-line&gt;&quot;</span></span><br><span class="line"># <span class="number">1</span> <span class="string">&quot;/usr/include/stdc-predef.h&quot;</span> <span class="number">1</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"># <span class="number">1</span> <span class="string">&quot;&lt;command-line&gt;&quot;</span> <span class="number">2</span></span><br><span class="line"># <span class="number">1</span> <span class="string">&quot;macro.cpp&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># <span class="number">1</span> <span class="string">&quot;macro.h&quot;</span> <span class="number">1</span></span><br><span class="line"># <span class="number">10</span> <span class="string">&quot;macro.h&quot;</span></span><br><span class="line"># <span class="number">1</span> <span class="string">&quot;/usr/include/c++/4.8/iostream&quot;</span> <span class="number">1</span> <span class="number">3</span></span><br><span class="line"># <span class="number">36</span> <span class="string">&quot;/usr/include/c++/4.8/iostream&quot;</span> <span class="number">3</span></span><br><span class="line">       </span><br><span class="line"># <span class="number">37</span> <span class="string">&quot;/usr/include/c++/4.8/iostream&quot;</span> <span class="number">3</span></span><br><span class="line"></span><br><span class="line"># <span class="number">1</span> <span class="string">&quot;/usr/include/x86_64-linux-gnu/c++/4.8/bits/c++config.h&quot;</span> <span class="number">1</span> <span class="number">3</span></span><br><span class="line"># <span class="number">184</span> <span class="string">&quot;/usr/include/x86_64-linux-gnu/c++/4.8/bits/c++config.h&quot;</span> <span class="number">3</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># <span class="number">11</span> <span class="string">&quot;macro.h&quot;</span> <span class="number">2</span></span><br><span class="line"># <span class="number">9</span> <span class="string">&quot;macro.cpp&quot;</span> <span class="number">2</span></span><br><span class="line"># <span class="number">18</span> <span class="string">&quot;macro.cpp&quot;</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="number">3.1415926</span> &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; (<span class="number">3.1415926</span> + <span class="number">3.1415926</span>)*(<span class="number">3.1415926</span> + <span class="number">3.1415926</span>)*(<span class="number">3.1415926</span> + <span class="number">3.1415926</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;My age is &quot;</span> <span class="string">&quot;25&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="number">181920</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Run&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"># <span class="number">38</span> <span class="string">&quot;macro.cpp&quot;</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;no NoDebug&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"># <span class="number">15</span> <span class="string">&quot;my_macro.cpp&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到代码中少了很多预处理器不需要处理的代码，而且里面已经没有任何预处理指令了，所有剩下的代码都是必须编译并执行的代码。而且return 0的前面一句显示出行号和文件名被#line改成了15、my_macro.cpp</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++拾遗</tag>
      </tags>
  </entry>
  <entry>
    <title>C/C++拾遗之深拷贝和浅拷贝</title>
    <url>/2016/07/25/cpp-gleaning-deep-copy-shallow-copy/</url>
    <content><![CDATA[<p>深拷贝（Deep copy）和浅拷贝（Shallow copy）是指对于类或结构体这类复合类型的变量，当它们的成员变量中含有指针时，在赋值或初始化的过程中，如果只是修改指针的指向，则属于浅拷贝（也称位拷贝）。因为此时指针所指向的实际内容依然只有一份，当其中一个变量销毁时，则该内存将被释放，那么此时另一个变量中将存在悬挂指针。而如果在发生拷贝时首先将需要被拷贝的内容复制到一个新的内存地址，然后再将相应的指针指向该新地址，则称为深拷贝。SOF上的一个相关回答<a href="http://stackoverflow.com/questions/184710/what-is-the-difference-between-a-deep-copy-and-a-shallow-copy">http://stackoverflow.com/questions/184710/what-is-the-difference-between-a-deep-copy-and-a-shallow-copy</a>&lt;&gt;</p>
<p>首先提示：在C++中，对于类型class1来说，class1 a(b);等价于class1 a = b;都将调用拷贝构造函数进行初始化，而不是将后面的语句中使用赋值运算符对a进行赋值。如果要使用赋值运算符将b赋值给a，需要<code>class1 a; a = b;</code></p>
<p>下面举例说明：</p>
<span id="more"></span>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//注释语句注释的是紧接着下面的语句</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//指定为delete，阻止编译器合成默认的构造函数，当调用该构造函数时，将出现编译错误</span></span><br><span class="line">    <span class="comment">//如果不指定为delete，或指定为default，则系统将合成默认的构造函数</span></span><br><span class="line">    <span class="built_in">A</span>() = <span class="keyword">delete</span>;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">//将定义该构造函数为深拷贝构造函数，即需要将str的内容复制到一个新的内存地址中，</span></span><br><span class="line">    <span class="comment">//而不仅仅是将成员变量指针name指向str所在的地址</span></span><br><span class="line">    <span class="built_in">A</span>(<span class="type">const</span> <span class="type">char</span> *str);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果不定义该拷贝构造函数，则编译器会合成一个默认的拷贝构造函数</span></span><br><span class="line">    <span class="comment">//如果不定义赋值运算符，则合成的赋值运算符将会调用该拷贝构造函数</span></span><br><span class="line">    <span class="built_in">A</span>(<span class="type">const</span> A &amp;other);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//深拷贝的拷贝构造函数，为了与上面的构造函数区分，多加一个无用的形参</span></span><br><span class="line">    <span class="built_in">A</span>(<span class="type">const</span> A &amp;other, <span class="type">bool</span> unuse);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义为一个深拷贝的赋值运算符，也就是将other的成员变量name所指定的内存中的内容</span></span><br><span class="line">    <span class="comment">//复制到一个新地址，并将赋值运算符左侧变量的name指向该新地址</span></span><br><span class="line">    A&amp; <span class="keyword">operator</span>=(<span class="type">const</span> A&amp; other);</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">A</span>();</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span> *name;</span><br><span class="line">    <span class="type">bool</span> unused;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//浅拷贝，因为当other析构时，other的成员变量name所指向的空间将被销毁</span></span><br><span class="line"><span class="comment">//被赋值的实例变量name将成为悬挂指针</span></span><br><span class="line">A::<span class="built_in">A</span>(<span class="type">const</span> A &amp;other)  </span><br><span class="line">&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;浅拷贝的拷贝构造函数&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    name = other.name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//深拷贝的构造函数，使用新的内存来存放对象other的成员变量name所指向内存的内容</span></span><br><span class="line">A::<span class="built_in">A</span>(<span class="type">const</span> A &amp;other, <span class="type">bool</span> unuse)</span><br><span class="line">&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;深拷贝的拷贝构造函数&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    name = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(other.name) + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(name, other.name);</span><br><span class="line">    unused = unuse;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">A::<span class="built_in">A</span>(<span class="type">const</span> <span class="type">char</span> *str)</span><br><span class="line">&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;深拷贝的构造函数&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">if</span> (str != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        name = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(str) + <span class="number">1</span>];</span><br><span class="line">        std::<span class="built_in">strcpy</span>(name, str);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        name = <span class="keyword">new</span> <span class="type">char</span>[<span class="number">1</span>];</span><br><span class="line">        name[<span class="number">0</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//深拷贝的赋值运算符</span></span><br><span class="line">A&amp; A::<span class="keyword">operator</span>=(<span class="type">const</span> A&amp; other)</span><br><span class="line">&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;深拷贝的赋值运算符&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;other) &#123;</span><br><span class="line">        <span class="function">A <span class="title">to</span><span class="params">(other, <span class="literal">true</span>)</span></span>;  <span class="comment">//调用深拷贝构造函数，以免浅拷贝导致内存泄漏</span></span><br><span class="line">        <span class="type">char</span> *tn = name;</span><br><span class="line">        name = to.name;</span><br><span class="line">        to.name = tn;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">A::~<span class="built_in">A</span>()</span><br><span class="line">&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;析构函数&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">delete</span>[] name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> ts[] = <span class="string">&quot;I love China&quot;</span>;</span><br><span class="line">    <span class="function">A <span class="title">a</span><span class="params">(ts)</span></span>;   <span class="comment">//深拷贝，析构时没有问题</span></span><br><span class="line"><span class="comment">//    A b(a);  //浅拷贝的构造函数，a和b的name将指向同一块内存，所以时析构时将出错</span></span><br><span class="line"><span class="comment">//    A c = a;  //等价于A b(a)都是调用拷贝构造函数</span></span><br><span class="line">    <span class="function">A <span class="title">d</span><span class="params">(ts)</span></span>;  <span class="comment">//先定义d，再使用a赋值给d，将调用赋值运算符</span></span><br><span class="line">    d = a;  <span class="comment">//如果没有自定义赋值运行符，将调用合成的赋值运算符，析构d时将出错</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">深拷贝的构造函数</span><br><span class="line">深拷贝的构造函数</span><br><span class="line">深拷贝的赋值运算符</span><br><span class="line">深拷贝的拷贝构造函数</span><br><span class="line">析构函数</span><br><span class="line">析构函数</span><br><span class="line">析构函数</span><br></pre></td></tr></table></figure>
<p>如果使用浅拷贝，也就是取消注释<code>A c = a;</code>输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">深拷贝的构造函数</span><br><span class="line">浅拷贝的拷贝构造函数</span><br><span class="line">深拷贝的构造函数</span><br><span class="line">深拷贝的赋值运算符</span><br><span class="line">深拷贝的拷贝构造函数</span><br><span class="line">析构函数</span><br><span class="line">析构函数</span><br><span class="line">析构函数</span><br><span class="line">析构函数</span><br><span class="line">*** Error in `./copy_deep_shallow&#x27;: double free or corruption (fasttop): 0x0000000002595010 ***</span><br><span class="line"></span><br><span class="line">Command terminated</span><br></pre></td></tr></table></figure>

<p>由此可见<br><strong>深拷贝会拷贝动态分配的成员对象，而不仅仅是简单的指针赋值</strong><br><strong>深拷贝只拷贝非静态成员数据，因为类的静态成员被类及所有类对象共有一份</strong></p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++拾遗</tag>
      </tags>
  </entry>
  <entry>
    <title>C/C++拾遗之实例分析static的作用</title>
    <url>/2016/07/24/cpp-gleaning-static/</url>
    <content><![CDATA[<h2 id="C语言中static的作用"><a href="#C语言中static的作用" class="headerlink" title="C语言中static的作用"></a>C语言中static的作用</h2><p><strong>1.隐藏变量或函数。被static修饰的变量或者函数，对其他文件是不可见的</strong><br>如果变量或函数没有被static修饰，那么一个文件可以通过extern关键字来引用在另一个变量中声明的变量或函数。如：</p>
<span id="more"></span>
<p>文件a中的代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//static_a.cpp</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>文件b中的代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">int</span> <span class="title">func</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> a;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">func</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; a &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当使用<code>g++ -o static static_a.cpp static_b.cpp</code>进行编译时，会得到如下错误：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/tmp/cc3q1SaL.o: In function `main&#x27;:</span><br><span class="line">static_b.cpp:(.text+0x24): undefined reference to `a&#x27;</span><br><span class="line">collect2: error: ld returned 1 exit status</span><br></pre></td></tr></table></figure>
<p>也就是说对于static_b.cpp文件来说，static_a.cpp中的a是不可见的，因为static关键字隐藏了它。</p>
<p><strong>2.保持变量生命周期直到整个程序执行结束才结束</strong><br>一般情况下，局部变量会被存储在栈区，栈区的内存会在离开该语句块时由系统自动回收。但static修饰的变量却会被存储在内存布局的.data区段，该段内存中的变量值会在整个程序运行期间保持。如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> a = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">return</span> a--;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">func</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">func</span>() &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上例输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">2</span><br></pre></td></tr></table></figure>
<p>即func()函数的中的static变量a的值一直在保存着。第一次调用时是3，然后再次调用时并没有再次将a初始化为3，而是上次的2。</p>
<p><strong>3.static修饰的变量未初始化时，会被编译器自动初始化为0</strong><br>因为static修饰的变量像全局变量一样，当未初始化时，会被存放在.bss内存区段，而不是.data区域，.bss内存区域的变量会在程序执行前被自动初始化为0（详见<a href="http://notes.maxwi.com/2016/06/11/cpp-memory-layout/">实例分析C++内存布局</a>），.bss段的内存中的内容具体是在编译时进行的0填充还是运行时不用管，总之是在程序运行前。如以下代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//file name: bss_ini.cpp</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> a;</span><br><span class="line"><span class="type">int</span> b;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> c;</span><br><span class="line">    <span class="type">int</span> d;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中全局变量b，全局静态变量a和局部变量c都是未初始化的，它们会被存放在.bss段，查看编译之后的可重定位的目标文件的section大小：<br><code>size bss_ini.o</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">text    data     bss     dec     hex filename</span><br><span class="line">67        0      12      79      4f bss_ini.o</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可见bss段刚好占12个字节=三个int所占的字节大小。<br>再来查看.bss段中的变量值：<br>反汇编命令：<code>objdump -CS -s -j .bss bss_ini</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bss_ini:     file format elf64-x86-64</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Disassembly of section .bss:</span><br><span class="line"></span><br><span class="line">0000000000601038 &lt;__bss_start&gt;:</span><br><span class="line">  601038:	00 00                	add    %al,(%rax)</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">000000000060103c &lt;b&gt;:</span><br><span class="line">  60103c:	00 00 00 00                                         ....</span><br><span class="line"></span><br><span class="line">0000000000601040 &lt;a&gt;:</span><br><span class="line">  601040:	00 00 00 00 </span><br><span class="line">0000000000601044 &lt;main::c&gt;:</span><br><span class="line">  601044:	00 00 00 00 </span><br></pre></td></tr></table></figure>
<p>可以看到b, a, c的值全是0，注意输出中是以16进制表示，所以是8个0，共32位二进制。</p>
<h2 id="C-中static的作用"><a href="#C-中static的作用" class="headerlink" title="C++中static的作用"></a>C++中static的作用</h2><p>由于类的静态数据成员要在程序一开始运行时就已经存在，但函数却是在程序运行过程中被调用，所以类的静态数据成员不能在任何函数内分配空间和初始化，当然可以在类中声明，而定义放在类外。因为类的声明只是声明一个类的“尺寸和规格”，而并不进行实际的内存分配，所以只能在类的内部声明，并在类的外部定义并初始化（当然可以在类内直接声明成const类型并初始化）。<br>已经定义的静态数据成员引用方式为：<code>&lt;类名&gt;::&lt;静态成员员&gt;</code><br><strong>1.static修饰类中的成员函数或变量时，类的所有对象及类本身共用该成员变量或成员函数</strong><br>类的所有实例共用静态数据成员（包括成员变量和成员函数）。类的静态变量和静态函数可以直接被类引用，而不需要类对象来引用。注意类中使用static声明的变量，只是进行了声明，并没有定义，需要在类的外部（也必须是其他任何函数函数的外部进行定义）定义，或者在类的内部定义成const类型的常量。如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> a;   <span class="comment">//声明静态数据成员a</span></span><br><span class="line">    <span class="type">const</span> <span class="type">static</span> <span class="type">int</span> c = <span class="number">3</span>;  <span class="comment">//在类中声明并定义const static类型的变量（其实是常量）</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">static</span> <span class="type">int</span> b = <span class="number">100</span>;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b++ &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> A::a = <span class="number">5</span>;   <span class="comment">//必须在类外部及main函数外部进行定义并初始化</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;A::c = &quot;</span> &lt;&lt; A::c &lt;&lt; std::endl;</span><br><span class="line">    A::<span class="built_in">func</span>(A::a);</span><br><span class="line">    A obj_a, obj_b;</span><br><span class="line">    A::a = <span class="number">7</span>;</span><br><span class="line">    obj_a.<span class="built_in">func</span>(obj_a.a);</span><br><span class="line">    obj_a.a = <span class="number">9</span>;</span><br><span class="line">    obj_b.<span class="built_in">func</span>(obj_b.a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A::c = 3</span><br><span class="line">a = 5</span><br><span class="line">b = 100</span><br><span class="line">a = 7</span><br><span class="line">b = 101</span><br><span class="line">a = 9</span><br><span class="line">b = 102</span><br></pre></td></tr></table></figure>
<p>根据a和b的输出结果可见类的所有对象及类本身共有静态成员变量和静态成员函数，且类可以直接引用静态成员函数和静态成员变量。</p>
<h2 id="类的静态成员注意事项"><a href="#类的静态成员注意事项" class="headerlink" title="类的静态成员注意事项"></a>类的静态成员注意事项</h2><p>1.类的静态成员函数属于整个类而非类的对象，所以它没有this指针，这就导致它仅能访问类的静态数据和静态成员函数。<br>2.不能将静态成员函数定义为虚函数<br>3.静态常量声明只可以是整型，即static const类型的成员变量只能是整型，或者使用constexpr来定义常量表达式，具体看这里<br><a href="http://stackoverflow.com/questions/370283/why-cant-i-have-a-non-integral-static-const-member-in-a-class">http://stackoverflow.com/questions/370283/why-cant-i-have-a-non-integral-static-const-member-in-a-class</a><br>如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Ba</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">const</span> <span class="type">static</span> <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">static</span> <span class="type">double</span> b = <span class="number">2.0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++拾遗</tag>
      </tags>
  </entry>
  <entry>
    <title>C/C++拾遗之位字段(Bit Field)</title>
    <url>/2016/07/23/cpp-gleaning-bit-field/</url>
    <content><![CDATA[<p>位字段（bit field）也称位域，是一个由signed int 或 unsigned int中一组相邻的位 (C99 还允许 <code>_Bool</code>类型的位字段). 位字段由一个结构体声明建立, 该结构声明为每个字段提供标签, 并决定字段的宽度。使用位字段可以将有些仅需要很少的变量范围的值压缩到一个较小的结构体中。<br>声明时需要在变量名后面跟冒号（<code>:</code>），冒号后面跟上需要设置的它的位宽度。<br>或者在在类型名后面跟冒号再跟位宽度，用于对齐占位</p>
<span id="more"></span>

<p>如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">bit_conf</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> a:<span class="number">1</span>;    <span class="comment">//声明一个位宽为1位的成员变量a，也就是a只能是1或0</span></span><br><span class="line">    <span class="type">int</span> b:<span class="number">4</span>;        <span class="comment">//声明一个位宽为4的成员变量b，其可表示范围为有符号的-2^2~2^2</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> c:<span class="number">7</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> d:<span class="number">20</span>;    <span class="comment">//一个int占4个字节，32位，那么一个字节之内bit_conf中共可以有32个位</span></span><br><span class="line">                          <span class="comment">//，所以此时sizeof(bit_conf)为4，如果将d声明为21，则sizeof(bit_conf)将为8，由于内存对齐的原因，就需要占用8个字节</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    bit_conf conf;</span><br><span class="line">    conf.b = <span class="number">-8</span>;    <span class="comment">//其取值只能是-8～8</span></span><br><span class="line">    std::cout &lt;&lt; conf.b &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;sizeof(bit_conf):&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(bit_conf) &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">-8</span></span><br><span class="line"><span class="built_in">sizeof</span>(bit_conf):<span class="number">4</span></span><br></pre></td></tr></table></figure>
<p>注意位域具有不可移植性，也就是说各平台之间具体特异性，不同的平台实现可能不一样。</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++拾遗</tag>
      </tags>
  </entry>
  <entry>
    <title>C/C++拾遗之内存对齐(Memory Alignment)</title>
    <url>/2016/07/21/cpp-gleaning-memory-allignment/</url>
    <content><![CDATA[<p>有两篇很不错的文章，总结的已经非常好，所以就不再重复详细说明。</p>
<ul>
<li><a href="http://www.cnblogs.com/TenosDoIt/p/3590491.html">C++ 内存对齐</a></li>
<li><a href="https://github.com/ludx/The-Lost-Art-of-C-Structure-Packing">失传的C结构体打包技艺</a></li>
</ul>
<p>其他多数类似文章中没有提及的几个重要的内容（当然上面的文章有详细讲解）:</p>
<span id="more"></span>

<p><strong>内存对齐原因:</strong></p>
<ul>
<li>平台原因(移植原因)：不是所有的硬件平台都能访问任意地址上的任意数据的；某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。</li>
<li>性能原因：数据结构(尤其是栈)应该尽可能地在自然边界上对齐。原因在于，为了访问未对齐的内存，处理器需要作两次内存访问；而对齐的内存访问仅需要一次访问。</li>
</ul>
<p><em>为什么未对齐的数据需要两次访问内存呢？由于计算机在从内存中读取数据时，按块进行读取，例如假如一次读取4个字节的数据。当一个占用4个字节的int型变量紧跟在一个刚好自然对齐的short之后，那么如果不进行对齐，int型的数据就必须有2个字节在前面的4字节内存块的后半部分，然后再有2字节在后面4字节内存块的前半部分。如果此时要读取出int，那么就必须先读一次前面的2字节的内存，再读取后面内存块中2字节的内存再进行整合。</em></p>
<p><strong>默认对齐</strong><br>如果有指定对齐字节数目，则编译器会按 <strong>类或结构中最大类型长度来对齐</strong>。可以通过语句<code>#pragma pack(i)</code>来指定对齐字节数目，i的取值为1, 2, 4, 8, 16  </p>
<p><strong>对齐规则：</strong></p>
<ul>
<li>如果设置了内存对齐为 i 字节，类中最大成员对齐字节数为j，那么整体对齐字节n = min(i, j)  （某个成员的对齐字节数定义：如果该成员是c++自带类型如int、char、double等，那么其对齐字节数=该类型在内存中所占的字节数；如果该成员是自定义类型如某个class或者struct，那个它的对齐字节数 = 该类型内最大的成员对齐字节数）</li>
<li>每个成员对齐规则：类中第一个数据成员放在offset为0的位置；对于其他的数据成员（假设该数据成员对齐字节数为k），他们放置的起始位置offset应该是 min(k, n) 的整数倍</li>
<li>整体对齐规则：最后整个类的大小应该是n的整数倍</li>
<li>当设置的对齐字节数大于类中最大成员对齐字节数时，这个设置实际上不产生任何效果；当设置对齐字节数为1时，类的大小就是简单的把所有成员大小相加</li>
</ul>
<p><strong>注意：当数据成员较多时，使用各成员的起始位置来分析更可靠</strong><br>分析举例：<br>不指定对齐大小</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//以起始位置分析</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">node1</span> &#123;   </span><br><span class="line"><span class="comment">//未指定内存对齐，默认以类中占用最大的元素大小对齐，x64系统，所以p指针会占用8个字节</span></span><br><span class="line">    <span class="type">char</span> c;     <span class="comment">//c的起始位置为0,占用1,占用位置为0</span></span><br><span class="line">    <span class="type">char</span> *p;    <span class="comment">//p起始位置需要是8的倍数，所以占用位置为8~15</span></span><br><span class="line">    <span class="type">int</span> a;      <span class="comment">//a的起始位置需要是4的倍数，即16~19</span></span><br><span class="line">    <span class="type">short</span> b;    <span class="comment">//b的起始位置需要是2的倍数，即20~21</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 根据上面的分析，node1的占用应该是从0~21即22个字节，由于整个类需要以8字节对齐，即占用需要是8的倍数，所以总共占用应该是24。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 以占用分析</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">node2</span> &#123;</span><br><span class="line"><span class="comment">// 未指定内存对齐，默认以类中占用最大的元素大小对齐</span></span><br><span class="line"><span class="comment">// 如果里面含有结构体或类类型，则该类型的对齐大小以其中的占用最大元素大小来定，即8</span></span><br><span class="line">    <span class="type">int</span> a;      <span class="comment">//a大小为4字节，按4字节对齐，占用8字节内存块的前4字节</span></span><br><span class="line">    <span class="type">char</span> b;     <span class="comment">//b大小为1，按1字节对齐，由于后面的float类型的c需要4个字节</span></span><br><span class="line">    <span class="type">float</span> c;    <span class="comment">//所以，而这个8字节的内存块放不下，需要将c存到下一个内存块</span></span><br><span class="line">    node1 n;    <span class="comment">//导致b与c之间会有3个字节的空闲。n占用24个字节，显然c后面剩余的那个</span></span><br><span class="line">                <span class="comment">//内存块的4节点放不下，n也需要存到下一个内存块</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 根据上面的分析node2占用应该为4+1+3+8+24=40</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;node1: &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(node1) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;node2: &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(node2) &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出为：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">node1: <span class="number">24</span></span><br><span class="line">node2: <span class="number">40</span></span><br></pre></td></tr></table></figure>
<p>通过#pragma pack()来指定对齐大小举例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack(2)</span></span><br><span class="line"><span class="comment">// 指定对齐大小为2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">node3</span> &#123;</span><br><span class="line">    <span class="type">char</span> a;    <span class="comment">// a按1字节对齐，占用为0</span></span><br><span class="line">    <span class="type">int</span> b;     <span class="comment">//b按2字节对齐，占用为2~5</span></span><br><span class="line">    <span class="type">short</span> c;   <span class="comment">//c按2字节对齐，占用为6~7</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//整个类node3的大小应该是2的整数倍，即8</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;node3: &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(node3) &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">node3: 8</span><br></pre></td></tr></table></figure>

<p>对于结构体中有数组的情况，该数组的对齐大小依然由数组的类型决定，它只表示多个相应类型的数据聚合在一起，如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class node4 &#123;  //整体按double的8个字节对齐</span><br><span class="line">    int a[5];  //a按4字节对齐，占用0-19</span><br><span class="line">    double d;   //d按8字节对齐，占用24-31</span><br><span class="line">    char c;  //c按1字节对齐，占用32</span><br><span class="line">    short s[3]; //s按2字节对齐，占用34-39</span><br><span class="line">&#125;</span><br><span class="line">//整个node4按8字节对齐，需要是8的位数，即40字节</span><br></pre></td></tr></table></figure>
<p>通过sizeof(node4)验证输出为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">40</span><br></pre></td></tr></table></figure>


<p><strong>注意：#pragma另一个作用是保证头文件只被编译一次，用法是在头文件开头加上<code>#pragma once</code></strong></p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++拾遗</tag>
      </tags>
  </entry>
  <entry>
    <title>C/C++拾遗之关于固定大小的整型</title>
    <url>/2016/07/19/cpp-gleaning-fixed-width-integer/</url>
    <content><![CDATA[<p>由于历史上考虑到不同机器架构在处理不同位宽的整型时性能不同，所以当时的标准要求保证只要不小于某一宽度即可，具体多宽可由编译器自行决定，导致了在使用int或long时在不同机器上可能存在表现不同的情况。这样也大大降低了程序的稳定性和可移植性。C99标准中定义一组固定位宽的整型，在头文件stdint.h中，建议在编程中无特殊原因都使用这些固定位宽的整型，以保证程序在不同的机器构架下整型变量的大小依然相同。对应于C++11中相应的固定位宽的头文件是cstdin。所涉及到的类型主要有：</p>
<span id="more"></span>


<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Range</th>
</tr>
</thead>
<tbody><tr>
<td>int8_t</td>
<td>1 byte signed</td>
<td>-128 to 127</td>
</tr>
<tr>
<td>uint8_t</td>
<td>1 byte unsigned</td>
<td>0 to 255</td>
</tr>
<tr>
<td>int16_t</td>
<td>2 byte signed</td>
<td>-32,768 to 32,767</td>
</tr>
<tr>
<td>uint16_t</td>
<td>2 byte unsigned</td>
<td>0 to 65,535</td>
</tr>
<tr>
<td>int32_t</td>
<td>4 byte signed</td>
<td>-2,147,483,648 to 2,147,483,647</td>
</tr>
<tr>
<td>uint32_t</td>
<td>4 byte unsigned</td>
<td>0 to 4,294,967,295</td>
</tr>
<tr>
<td>int64_t</td>
<td>8 byte signed</td>
<td>-9,223,372,036,854,775,808 to 9,223,372,036,854,775,807</td>
</tr>
<tr>
<td>uint64_t</td>
<td>8 byte unsigned</td>
<td>0 to 18,446,744,073,709,551,615</td>
</tr>
</tbody></table>
<p>很好记，就是int或uint后面跟上所需要的位宽，然后后面再加个_t即可<br>查看了下linux下的头文件，发现有如下一些typedef:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* Signed.  */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* There is some amount of overlap with &lt;sys/types.h&gt; as known by inet code */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __int8_t_defined</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __int8_t_defined</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">signed</span> <span class="type">char</span>     <span class="type">int8_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">short</span> <span class="type">int</span>       <span class="type">int16_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span>         <span class="type">int32_t</span>;</span><br><span class="line"><span class="meta"># <span class="keyword">if</span> __WORDSIZE == 64</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">int</span>        <span class="type">int64_t</span>;</span><br><span class="line"><span class="meta"># <span class="keyword">else</span></span></span><br><span class="line">__extension__</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span>       <span class="type">int64_t</span>;</span><br><span class="line"><span class="meta"># <span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Unsigned.  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span>       <span class="type">uint8_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span>  <span class="type">uint16_t</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __uint32_t_defined</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span>        <span class="type">uint32_t</span>;</span><br><span class="line"><span class="meta"># <span class="keyword">define</span> __uint32_t_defined</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __WORDSIZE == 64</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span>   <span class="type">uint64_t</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">__extension__</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span>  <span class="type">uint64_t</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>用法就是直接包含头文件，然后定义使用即可：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdint&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="type">int16_t</span> <span class="title">i</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">    std::cout &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>C++中关于整型的使用建议是：</p>
<ul>
<li>仅在整型变量的大小无关并且该变量不会变大时才使用int</li>
<li>通常情况下都应该考试使用固定宽度的整型，特别是当某个整型变量需要保证宽度的时候</li>
<li>只有当你有一个令人信服的理由时才使用无符号类型</li>
</ul>
<p>当unsigned类的整型与signed整型混合使用时非常容易出问题（我自己写程序时遇到这个情况，debug好久才发现）如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">doSoming</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">//Run some code</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">doSoming</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面传递给函数中的-1有可能会变成非常大的数字。<br>所以编程中如果没有特别需要，最好避免使用unsigned类型。</p>
<p><strong>一个小插曲</strong><br>考虑练习下这些类型区别时，出现了一个让自己百思不得其解的问题，看如下代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdint&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int8_t</span> i8 = <span class="number">8</span>;</span><br><span class="line">    <span class="type">int16_t</span> i16 = <span class="number">-16</span>;</span><br><span class="line">    <span class="type">int32_t</span> i32 = <span class="number">32</span>;</span><br><span class="line">    <span class="type">int64_t</span> i64= <span class="number">64</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;==&quot;</span> &lt;&lt; i8 &lt;&lt; <span class="string">&quot;==&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;==&quot;</span> &lt;&lt; i8 &lt;&lt; i16 &lt;&lt; i32 &lt;&lt; i64;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我的第一反应是输出中i8的输出应该是8，结果却发现输出中第一行只有3个等号。很费解，gdb调试查看变量情况，gdb给的提示是<code>i8 = 8 &#39;\b&#39;</code>，我依然没有反应过来哪里有问题（唉，这是有多久没有用char了）。然后开始查看头文件中对int8_t的定义，发现了上述头文件，原来这货就是个有符号的char，然后印象中char不就是可以用来存int吗，而且它俩在很多情况下是可以无损转换的，为什么输出不是8呢。这才开始查char的资料，突然想起来ASCII码的事，char在内存中确实是以整型存储，但存储的是ASCII码的整型，而8的ASCII码是’\b’（表示退格）。注意对于char来说，它只能存储一个（对于转义字符只算一个字符）使用单引号括起来的字符，将一个整数赋给它实际上发生了类型转换，char会保留该整数的低8位，存储为相应ASCII码的二进制。如：<code>std::cout &lt;&lt; int(&#39;\b&#39;);</code>将会输出整数十进制的8；<code>std::cout &lt;&lt; char(8);</code>将会输出一个退格（虽然看不见），因为十进制ASCII码8对应的是退格；<code>std::cout &lt;&lt; int(&#39;8&#39;);</code>将会输出56,因为字符’8’对应的ASCII码的十进制是56；<code>std::cout &lt;&lt; char(&#39;8&#39;);</code>将输出一个字符8,当然本身就是个字符，是否强制转换并无影响。<br>总之，代码要天天敲，基础知识要经常回顾，不然忘的太快了。</p>
<p>参考：<a href="http://www.learncpp.com/cpp-tutorial/24a-fixed-width-integers/">Fixed-width integers and the unsigned controversy</a></p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++拾遗</tag>
      </tags>
  </entry>
  <entry>
    <title>C/C++拾遗之new/delete与malloc/free的异同</title>
    <url>/2016/07/18/cpp-gleaning-new-malloc/</url>
    <content><![CDATA[<p>SOF上一个比较全面的回答：<a href="http://stackoverflow.com/questions/240212/what-is-the-difference-between-new-delete-and-malloc-free">http://stackoverflow.com/questions/240212/what-is-the-difference-between-new-delete-and-malloc-free</a><br>根据理解举例总结如下：<br>共同点就是都可以用于分配和销毁动态内存。<br>不同点：<br>默认是指new/delete :   </p>
<ol>
<li>在空内存池（Free Store）上分配内存空间，而malloc是在堆上分配，关于free-store和heap的区别可以看这里, 下面会对内存区域详解。<a href="http://stackoverflow.com/questions/1350819/c-free-store-vs-heap">http://stackoverflow.com/questions/1350819/c-free-store-vs-heap</a>   </li>
</ol>
<span id="more"></span>

<ol start="2">
<li>new返回一个类型安全的指针，即该指针有明确的类型，而malloc返回的是个void *，所以需要将其强制转换为所需要的指针。即new相当于在动态内存上创建一个新对象，并调用该对象的默认构造函数初始化该对象，而malloc就单纯是分配一块原始内存   </li>
<li>new在失败时会抛出异常std::bad_alloc，而malloc在分配失败时返回NULL  </li>
<li>new可以根据类型自动计算所需要分配的空间大小，而malloc必须手动指定需要分配的空间字节数</li>
<li>new可以直接处理数组，例如<code>int *p = new int[4];</code>，而malloc需要手动确定大小。<code>int *p = (int *) malloc(4 * sizeof(int));</code>，但要记得使用delete[]来释放使用new分配的数组。   </li>
<li>需要对已分配的内存扩容时，malloc分配的可以调用realloc高效的直接分配一块更大的内存。但由于new分配的其实相当于是对象，由于拷贝构造函数的问题，所以无法直接简单地扩展其内存。   </li>
<li>new/delete的实现其实就是调用malloc和free   </li>
<li>可以通过设置std::set_new_handler来控制new/operator new在分配内存失败是调用处理函数new_handler来补救，而malloc不能   </li>
<li>new/delete是操作符，所以可以被重载，而malloc/free是函数，无法被覆盖   </li>
<li>new/delete在分配内存后会调用相应的构造函数初始化已经分配的内存/析构函数释放内存，而malloc分配的就是原始内存   </li>
</ol>
<p><strong>总结来说就是：new/delete是操作符而malloc/free是两个函数，new/delete会调用构造函数和析构函数，可以被类重载，且new是类型安全的，一般情况下尽量避免使用malloc/free而使用new/delete。</strong><br><strong>另外注意delete或free只是释放相应的内存，并不会修改原指针变量，所以如有需要依然可以让原指针变量指向其他地址，如下例</strong></p>
<p><strong>operator new和operator new[]是两个操作符，同样operator delete和oprator delete[]也是两个操作符。</strong>   </p>
<p><strong>sizeof运算符作用于指针时不能像作用于数组那样获得整个数组的大小，sizeof作用于指针时只能获取指针本身的大小，例如32位系统是4个字节，64位系统是8个字节</strong></p>
<p>使用<code>operator new(size)</code>和<code>operator delete(p)</code>也可以用于一次开辟一段指定大小的原始内存，类似malloc的功能，如：   </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">//malloc和free在该头文件中   </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="comment">//operator new和operator delete在该头文件中</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;new&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span>* <span class="title">assign</span><span class="params">(<span class="type">int</span> *p, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        p[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> *p, <span class="type">int</span> n)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        std::cout &lt;&lt; p[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//使用new和malloc使用三种方式实现动态数组   </span></span><br><span class="line">    <span class="comment">//使用operator new操作符先分配一段原始内存，再强制转换为所需要的内存</span></span><br><span class="line">    <span class="type">void</span> *p = <span class="keyword">operator</span> <span class="built_in">new</span>(<span class="number">5</span> * <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="type">int</span> *p1 = <span class="built_in">static_cast</span>&lt;<span class="type">int</span> *&gt;(p);</span><br><span class="line">    <span class="built_in">assign</span>(p1, <span class="number">5</span>);</span><br><span class="line">    <span class="built_in">print</span>(p1, <span class="number">5</span>);</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">delete</span> <span class="params">(p)</span></span>; <span class="comment">//或 delete p1;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用new操作符直接声明数组</span></span><br><span class="line">    <span class="comment">//注意此处依然使用p1</span></span><br><span class="line">    p1 = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">5</span>];</span><br><span class="line">    <span class="built_in">assign</span>(p1, <span class="number">5</span>);</span><br><span class="line">    <span class="built_in">print</span>(p1, <span class="number">5</span>);</span><br><span class="line">    <span class="keyword">delete</span>[] p1;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用malloc函数   </span></span><br><span class="line">    p1 = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="number">5</span> * <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="built_in">assign</span>(p1, <span class="number">5</span>);</span><br><span class="line">    <span class="built_in">print</span>(p1, <span class="number">5</span>);</span><br><span class="line">    <span class="built_in">free</span>(p1);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++拾遗</tag>
      </tags>
  </entry>
  <entry>
    <title>C/C++拾遗之函数对象</title>
    <url>/2016/07/17/cpp-gleaning-function-object/</url>
    <content><![CDATA[<p>函数对象即是定义了函数调用运算符<code>()</code>的类的对象，该类表现上像个函数，参见<a href="http://notes.maxwi.com/2015/12/13/CPP-OOP/#函数调用运算符">http://notes.maxwi.com/2015/12/13/CPP-OOP/#函数调用运算符</a><br>通过函数对象的方式即简洁又可以方便地实现调用含有不同参数类型的函数对象<br>以下代码分别使用函数对象和函数指针进行举例：   </p>
<span id="more"></span>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * fun_obj.cpp</span></span><br><span class="line"><span class="comment"> * Copyright (C) 2016  &lt;@BLUEYI-PC&gt;</span></span><br><span class="line"><span class="comment"> * 分别使用函数指针和函数对象实现随机通过调用不同的函数随机返回两个数中较大或较小的功能</span></span><br><span class="line"><span class="comment"> * Max返回两个数中较大的，Min返回较小的</span></span><br><span class="line"><span class="comment"> * Distributed under terms of the MIT license.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;random&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="comment">//重载了函数调用运算符()的类</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">class</span> <span class="title class_">Max</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">T <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> T &amp;a, <span class="type">const</span> T &amp;b)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">class</span> <span class="title class_">Min</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">T <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> T &amp;a, <span class="type">const</span> T &amp;b)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a &gt; b ? b : a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过函数对象的方法调用函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> VST&gt; <span class="function">T <span class="title">max_or_min</span><span class="params">(<span class="type">const</span> T &amp;a, <span class="type">const</span> T &amp;b, <span class="type">const</span> VST &amp;func)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">func</span>(a, b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过函数指针的方法调用函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function">T <span class="title">max_or_min</span><span class="params">(<span class="type">const</span> T &amp;a, <span class="type">const</span> T &amp;b, T (*func)(<span class="type">const</span> T&amp;, <span class="type">const</span> T&amp;))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">func</span>(a, b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Max&lt;<span class="type">int</span>&gt; maxObj;</span><br><span class="line">    Min&lt;<span class="type">int</span>&gt; minObj;</span><br><span class="line">    <span class="function">std::default_random_engine <span class="title">e</span><span class="params">(time(<span class="literal">NULL</span>))</span></span>;</span><br><span class="line">    <span class="function">std::uniform_int_distribution&lt;<span class="type">int</span>&gt; <span class="title">u</span><span class="params">(<span class="number">0</span>, <span class="number">19</span>)</span></span>;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">5</span>, b = <span class="number">9</span>;</span><br><span class="line">    <span class="comment">//通过调用函数对象的函数随机输出a,b中较大或较小的</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;***Function object***&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">u</span>(e) % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">            std::cout &lt;&lt; <span class="built_in">max_or_min</span>(a, b, maxObj) &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            std::cout &lt;&lt; <span class="built_in">max_or_min</span>(a, b, minObj) &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//通过调用函数指针的函数随机输出a,b中较大或较小的</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;***Function pointer***&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">u</span>(e) % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">            std::cout &lt;&lt; <span class="built_in">max_or_min</span>(a, b, maxObj) &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            std::cout &lt;&lt; <span class="built_in">max_or_min</span>(a, b, minObj) &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++拾遗</tag>
      </tags>
  </entry>
  <entry>
    <title>C/C++拾遗之类成员含引用变量</title>
    <url>/2016/07/15/cpp-gleaning-reference-member/</url>
    <content><![CDATA[<p>1.首先明确当类中含有引用类型的成员变量时，编译器会将所有合成的默认构造函数都定义为<code>delete</code>，也就是说编译器将不会合成任何构造函数，所有构造函数必须由用户显式地定义，且该引用变量必须在所有定义的构造函数初始化列表中直接初始化，而不能在构造函数中初始化，形参也必须是引用类型。  </p>
<span id="more"></span>

<p>2.分析以下代码，注释部分（编译环境g++5.1.0）：   </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> i=<span class="number">3</span>) : <span class="built_in">m_i</span>(i)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;m_i=&quot;</span> &lt;&lt; m_i &lt;&lt; endl; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_i;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//如果有以下两行时都将报错未初始化的引用变量，因为当含有引用类型的成员时，必须在初始化列表中对该成员进行直接初始化</span></span><br><span class="line"><span class="comment">//    B()&#123;&#125;     </span></span><br><span class="line"><span class="comment">//    B(A&amp; a) &#123; m_a = a; &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">B</span>(A&amp; a) : <span class="built_in">m_a</span>(a) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123; m_a.<span class="built_in">print</span>(); &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    A&amp; m_a;     <span class="comment">//引用类型的变量</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">A <span class="title">a</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">    <span class="function">B <span class="title">b</span><span class="params">(a)</span></span>;</span><br><span class="line">    b.<span class="built_in">display</span>();</span><br><span class="line">    <span class="function">B <span class="title">b2</span><span class="params">(a)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果有以下这行将报错使用了delete function，因为由于B中含有引用变量，编译器并不会合成默认的赋值运算符</span></span><br><span class="line"><span class="comment">//  b = b2;  </span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.用处：例如当有两个类要对第三个类的数据进行共享处理时，可以考虑将第三个类作为这两个类的引用类型的成员变量。   </p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++拾遗</tag>
      </tags>
  </entry>
  <entry>
    <title>C/C++拾遗之tuple类型</title>
    <url>/2016/07/14/cpp-gleaning-tuple/</url>
    <content><![CDATA[<p>1.C++11中提供的tuple类型，即元组，该类型类似于pair类型，可以存放不同类型的变量，不同之处是它没有数量限制。该类型定义在头文件tuple中。  </p>
<p>2.tuple类型支持常见的操作，如<code>==</code>、<code>!=</code>、<code>get&lt;i&gt;(t);//获取t中第i个值</code>等。   </p>
<p>3.tuple中不但可以存储右值，而且可以存储左值。可以利用tuple让函数一次返回多个值。  </p>
<span id="more"></span>

<p>4.一个tuple使用的例子：  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tuple&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//定义并初始化一个tuple</span></span><br><span class="line">    std::tuple&lt;<span class="type">int</span>, std::string, std::vector&lt;<span class="type">double</span>&gt;, std::list&lt;<span class="type">int</span>&gt;&gt;</span><br><span class="line">        <span class="built_in">tuVal</span>(<span class="number">5</span>, <span class="string">&quot;blueyi&quot;</span>, &#123;<span class="number">0.1</span>, <span class="number">0.2</span>, <span class="number">0.3</span>, <span class="number">0.4</span>&#125;, &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;);</span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">decltype</span><span class="params">(tuVal)</span> tuType</span>; <span class="comment">//定义一个tuVal的类型的别名</span></span><br><span class="line">    <span class="type">int</span> cnt = std::tuple_size&lt;tuType&gt;::value; <span class="comment">//获取tuVal中成员个数</span></span><br><span class="line">    std::cout &lt;&lt; cnt &lt;&lt; std::endl;</span><br><span class="line">    std::tuple_element&lt;<span class="number">0</span>, tuType&gt;::type ti = std::<span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(tuVal); <span class="comment">//获取tuVal中的第1个成员，其中ti类型为int</span></span><br><span class="line">    <span class="comment">//tuple_element&lt;i, tupleType&gt;::type中的i必须是一个const值</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;0: &quot;</span> &lt;&lt; ti &lt;&lt; std::endl;</span><br><span class="line">    std::tuple_element&lt;<span class="number">1</span>, tuType&gt;::type ts = std::<span class="built_in">get</span>&lt;<span class="number">1</span>&gt;(tuVal); <span class="comment">//获取tuVal中的第2个成员，其中ti类型为int</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;1: &quot;</span> &lt;&lt; ts &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::tuple_element&lt;<span class="number">2</span>, tuType&gt;::type tv = std::<span class="built_in">get</span>&lt;<span class="number">2</span>&gt;(tuVal); <span class="comment">//获取tuVal中的第3个成员，其中tv类型为vector</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;2: &quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> t : tv) &#123;</span><br><span class="line">        std::cout &lt;&lt; t &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"> </span><br><span class="line">    std::tuple_element&lt;<span class="number">3</span>, tuType&gt;::type tl = std::<span class="built_in">get</span>&lt;<span class="number">3</span>&gt;(tuVal); <span class="comment">//获取tuVal中的第4个成员，其中tv类型为list</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;3: &quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> t : tl) &#123;</span><br><span class="line">        std::cout &lt;&lt; t &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++拾遗</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL学习总结</title>
    <url>/2016/06/21/sql-introduce/</url>
    <content><![CDATA[<p>对SQL的了解一直就那几个语句，关键是那几个语句还经常记不清楚，虽然上过一次数据库的课，但并没有认真听，也没有系统的学习一遍SQL的基础知识，所以对于SQL，基本还处于完全陌生态。趁今晚的闲暇来系统的学习一下SQL相关知识（其实是因为今晚不想学习，权当休闲，哈哈）。<br>本文内容主要参考:</p>
<ul>
<li>《SQL必知必会》    </li>
<li>《MySQL必知必会》（后来发现有这本书，所以就补上了）</li>
</ul>
<p>工欲善其事，必先利其器。为了方便后面练习，首先安装MySQL，这里只以Ubuntu下的安装为例</p>
<span id="more"></span>
<p>后期补充内容：<br>1.为了使字段名可以使用MySQL关键字，同时也为了更好地区分字段名、表名等，最好在MySQL语句中使用反单引号（backtick）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">`</span><br></pre></td></tr></table></figure>
<p>将表名、字段名等括住，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT `user_name`, `user_id`, `score` FROM `user_db`.`user`;</span><br></pre></td></tr></table></figure>
<p>具体更多原因查看SOF上的回答：<a href="http://stackoverflow.com/questions/11069044/what-does-back-tick-do-in-mysql-statements">http://stackoverflow.com/questions/11069044/what-does-back-tick-do-in-mysql-statements</a></p>
<h1 id="安装MySQL"><a href="#安装MySQL" class="headerlink" title="安装MySQL"></a>安装MySQL</h1><p>由于只是用于练习之用，所以暂不考虑各种编译优化等，所以直接使用apt安装。<br>安装方法可以参见官方<a href="http://dev.mysql.com/doc/mysql-apt-repo-quick-guide/en/">A Quick Guide to Using the MySQL APT Repository</a></p>
<p>安装命令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install mysql-server #安装MySQL服务端及核心程序</span><br><span class="line">sudo apt-get install mysql-client #安装MySQL客户端</span><br><span class="line">sudo apt-get install mysql-workbench #安装MySQL工作台，这个工作台提供对MySQL的管理，非常好用，而且有图形界面</span><br></pre></td></tr></table></figure>
<p>安装过程中会提示输入root密码或直接确认设置默认密码为空<br>安装结束后使用以下命令验证安装是否成功：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo netstat -tap | grep mysql</span><br></pre></td></tr></table></figure>
<p>如果安装成功，输出大致为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">blueyi@vm:~$ sudo netstat -tap | grep mysql</span><br><span class="line">tcp        0      0 localhost:mysql         *:*                     LISTEN      9495/mysqld</span><br></pre></td></tr></table></figure>
<p>MySQL管理命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo service mysql status   #查看MySQL的当前状态</span><br><span class="line">sudo service mysql stop   #停止MySQL服务</span><br><span class="line">sudo service mysql start   #启动MySQL服务</span><br></pre></td></tr></table></figure>
<p>当然还有如下：<code>start|stop|restart|reload|force-reload|status</code>管理MySQL服务的命令</p>
<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>1.数据库（database）是指保存有组织的数据的容器，一个数据库中可以包含多个表（table），每个表中都可以存储同类型的多条数据。表可以被想像成类似excel中由行和列构成的表一样。<br>2.通常所说的MySQL、PostgreSQL、SQLite及Microsoft SQL Server等并不是数据库，它们只是被称为数据库管理系统（即DBMS）的数据库软件，数据库是通过DBMS创建和操作数据的容器。而SQL是一咱语言而不是一个应用程序。<br>3.数据库中的表（table）是指某种特定类型数据的结构化清单。同一个数据库中的每个表名都必须唯一。表具有一些特性，这些特性定义了数据在表中如何存储等信息，这组信息即称为模式（schema），模式即可以用来描述数据库中特定的表，也可以用来描述整个数据库（和其中表的关系），所以模式即关于数据库和表的布局及特性的信息。<br>4.表中的列（column）即表中的一个字段，数据库中的每个列都有相应的数据类型（datatype），数据类型及其名称是SQL不兼容的一个主要原因。<br>5.表中的行（row）是表中的一个记录（record），表中的数据是按行存储的。<br>6.主键即是指一列（或一组列），其值能够唯一标识表中的每一行。能够唯一标识表中每行的这个列称为主键。虽然不总是需要主键，但应该总是定义主键。表中的任何列都可以作为主键，一个表可以有多个主键，主键需要满足以下条件:</p>
<ul>
<li>任意两行都不具有相同的主键值；</li>
<li>每一行都必须具有一个主键值（主键列不允许NULL值）；</li>
<li>主键列中的值不允许修改或更新；</li>
<li>主键值不能重用（如何某行从表中删除，它的主键不能赋给以后的新行）    </li>
</ul>
<p>7.SQL（发音为字母S-Q-L或sequel）是结构化查询语言（Structured Query Language）的缩写。SQL是一种专门用来与数据库沟通的语言。许多DBMS厂商通过增加语句或指令来对SQL进行扩展。标准SQL由ANSI标准委员会管理，称为ANSI SQL，各个DBMS都有自己的名字，例如MySQL，但它们都会支持标准SQL。   </p>
<h1 id="MySQL基本操作概览"><a href="#MySQL基本操作概览" class="headerlink" title="MySQL基本操作概览"></a>MySQL基本操作概览</h1><p>为了后续先讲解SELECT等基础语句，这里先迅速脑补一下MySQL的基本操作   </p>
<h2 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h2><p>1.打开MySQL，并使用root用户登录：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">~$ </span><span class="language-bash">sudo service mysql start</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">不带-h参数，默认表示登录本地localhost的mysql</span></span><br><span class="line"><span class="meta prompt_">~$ </span><span class="language-bash">mysql -u root   <span class="comment">#如果MySQL的root密码为空，直接登录，否则会报ERROR 1045</span></span></span><br><span class="line"><span class="meta prompt_">~$ </span><span class="language-bash">mysql -u root -p    <span class="comment">#回车会提示你输入你的root账户登录密码</span></span></span><br><span class="line"><span class="meta prompt_">~$ </span><span class="language-bash">mysql -u root -p123    <span class="comment">#直接附带上登录密码123，注意密码与-p之间没有空格</span></span></span><br><span class="line"><span class="meta prompt_">~$ </span><span class="language-bash">mysql -u root -p123    <span class="comment">#直接附带上登录密码123，注意密码与-p之间没有空格</span></span></span><br><span class="line"><span class="meta prompt_">~$ </span><span class="language-bash">mysql -h 192.168.1.1 -P 3306 -u root -p123    <span class="comment">#-h后面是要登录的mysql主机IP，-P后面是端口</span></span></span><br></pre></td></tr></table></figure>
<p>登录成功后会提示如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Welcome to the MySQL monitor.  Commands end with ; or \g.</span><br><span class="line">Your MySQL connection id is 43</span><br><span class="line">Server version: 5.5.46-0ubuntu0.14.04.2 (Ubuntu)</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">....</span></span><br></pre></td></tr></table></figure>
<p>并且bash的前导符会变成<code>mysql&gt;</code>   </p>
<h2 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h2><p>2.查看数据库</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; show databases;</span><br><span class="line">+--------------------+</span><br><span class="line">| Database           |</span><br><span class="line">+--------------------+</span><br><span class="line">| information_schema |</span><br><span class="line">| mysql              |</span><br><span class="line">| performance_schema |</span><br><span class="line">+--------------------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>
<p>这三个数据库是MySQL安装后自动生成的，每个数据库中都包含有多个不同的表用来存储数据<br>注意不要漏掉SQL语句后面的分号“;”，如果SQL语句太长可以直接回车换行，直到分号换行才表示一个语句完成，有点类型C/C++<br>SQL语句大小写不敏感，也就是说上面的查看数据库的语句等价于<code>SHOW DATABASES;</code></p>
<h2 id="选择某个数据库"><a href="#选择某个数据库" class="headerlink" title="选择某个数据库"></a>选择某个数据库</h2><p>3.连接/使用某个数据库</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; USE information_schema;</span><br><span class="line">Reading table information for completion of table and column names</span><br><span class="line">You can turn off this feature to get a quicker startup with -A</span><br><span class="line"></span><br><span class="line">Database changed</span><br></pre></td></tr></table></figure>
<p>这个USE语句后面可以没有分号，也会直接执行，另外在选择数据库时数据库名称也可以不区分大小写，但你会发现使用大写的数据库名字通常无法使用Tab键自动补全。   </p>
<h2 id="查看表"><a href="#查看表" class="headerlink" title="查看表"></a>查看表</h2><p>4.查看表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SHOW tables;</span><br><span class="line">+----------------------------------------------+</span><br><span class="line">| Tables_in_performance_schema                 |</span><br><span class="line">+----------------------------------------------+</span><br><span class="line">| cond_instances                               |</span><br><span class="line">| events_waits_current                         |</span><br><span class="line">| events_waits_history                         |</span><br><span class="line">| events_waits_history_long                    |</span><br><span class="line">| events_waits_summary_by_instance             |</span><br><span class="line">| events_waits_summary_by_thread_by_event_name |</span><br><span class="line">| events_waits_summary_global_by_event_name    |</span><br><span class="line">| file_instances                               |</span><br><span class="line">| file_summary_by_event_name                   |</span><br><span class="line">| file_summary_by_instance                     |</span><br><span class="line">| mutex_instances                              |</span><br><span class="line">| performance_timers                           |</span><br><span class="line">| rwlock_instances                             |</span><br><span class="line">| setup_consumers                              |</span><br><span class="line">| setup_instruments                            |</span><br><span class="line">| setup_timers                                 |</span><br><span class="line">| threads                                      |</span><br><span class="line">+----------------------------------------------+</span><br><span class="line">17 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>
<p>5.查看表列，或称为字段</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SHOW COLUMNS FROM performance_timers;</span><br><span class="line">+------------------+---------------------------------------------------------------+------+-----+---------+-------+</span><br><span class="line">| Field            | Type                                                          | Null | Key | Default | Extra |</span><br><span class="line">+------------------+---------------------------------------------------------------+------+-----+---------+-------+</span><br><span class="line">| TIMER_NAME       | enum(&#x27;CYCLE&#x27;,&#x27;NANOSECOND&#x27;,&#x27;MICROSECOND&#x27;,&#x27;MILLISECOND&#x27;,&#x27;TICK&#x27;) | NO   |     | NULL    |       |</span><br><span class="line">| TIMER_FREQUENCY  | bigint(20)                                                    | YES  |     | NULL    |       |</span><br><span class="line">| TIMER_RESOLUTION | bigint(20)                                                    | YES  |     | NULL    |       |</span><br><span class="line">| TIMER_OVERHEAD   | bigint(20)                                                    | YES  |     | NULL    |       |</span><br><span class="line">+------------------+---------------------------------------------------------------+------+-----+---------+-------+</span><br><span class="line">4 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>
<p>或：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; DESCRIBE performance_timers;</span><br><span class="line">+------------------+---------------------------------------------------------------+------+-----+---------+-------+</span><br><span class="line">| Field            | Type                                                          | Null | Key | Default | Extra |</span><br><span class="line">+------------------+---------------------------------------------------------------+------+-----+---------+-------+</span><br><span class="line">| TIMER_NAME       | enum(&#x27;CYCLE&#x27;,&#x27;NANOSECOND&#x27;,&#x27;MICROSECOND&#x27;,&#x27;MILLISECOND&#x27;,&#x27;TICK&#x27;) | NO   |     | NULL    |       |</span><br><span class="line">| TIMER_FREQUENCY  | bigint(20)                                                    | YES  |     | NULL    |       |</span><br><span class="line">| TIMER_RESOLUTION | bigint(20)                                                    | YES  |     | NULL    |       |</span><br><span class="line">| TIMER_OVERHEAD   | bigint(20)                                                    | YES  |     | NULL    |       |</span><br><span class="line">+------------------+---------------------------------------------------------------+------+-----+---------+-------+</span><br><span class="line">4 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<h2 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h2><p>6.创建一个名为mysql_test的数据库</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; CREATE DATABASE mysql_test;</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br></pre></td></tr></table></figure>
<p>查看创建后的数据库变化</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; show databases;</span><br><span class="line">+--------------------+</span><br><span class="line">| Database           |</span><br><span class="line">+--------------------+</span><br><span class="line">| information_schema |</span><br><span class="line">| mysql              |</span><br><span class="line">| mysql_test         |</span><br><span class="line">| performance_schema |</span><br><span class="line">+--------------------+</span><br><span class="line">4 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<h2 id="批量运行数据库命令"><a href="#批量运行数据库命令" class="headerlink" title="批量运行数据库命令"></a>批量运行数据库命令</h2><p>7.批量运行数据库命令<br>这里使用《MySQ必知必会》中提供的样例文件命令为例，关于文件的说明：   </p>
<blockquote>
<p>create.txt 包含创建 5 个数据库表(包括定义所有主键和外键约束)的 SQL 语句。<br>populate.txt 包含用来填充这些表的 SQL INSERT语句。</p>
</blockquote>
<p>通过使用source命令，可以导入需要批量执行的文件并执行。注意作者所提供的create.txt并不是使用utf-8编码，且其中含有大量<code>^M</code>结尾的windows平台换行符，在linux下操作会出错，可以使用文本编辑器重新另存成utf-8格式。或者vim打开后，使用<code>:%s /\r$//g</code>清除掉后面的<code>^M</code>后保存，再进行以下操作。也可以直接下载我已经处理好了的这两个文件<a href="create.txt">create.txt</a>、<a href="populate.txt">populate.txt</a>·<br>我们将create.txt和populate.txt中的命令作用于以面创建的数据库mysql_test：<br>SQL语句中后#号后面是注释，SQL命令后面的内容都是相应SQL命令执行的输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; USE mysql_test   #选择mysql_test数据库   </span><br><span class="line">Database changed</span><br><span class="line"></span><br><span class="line">mysql&gt; source /home/blueyi/Downloads/TeachYourselfSQL_MySQL/create.txt  #导入create.txt中的命令来创建表</span><br><span class="line">Query OK, 0 rows affected (0.20 sec)</span><br><span class="line"></span><br><span class="line">Query OK, 0 rows affected (0.19 sec)</span><br><span class="line"></span><br><span class="line">Query OK, 0 rows affected (0.23 sec)</span><br><span class="line"></span><br><span class="line">Query OK, 0 rows affected (0.16 sec)</span><br><span class="line">#....省略很多输出#</span><br><span class="line"></span><br><span class="line">mysql&gt; show tables;   #查看现在mysql_test中的表都有哪些</span><br><span class="line">+----------------------+</span><br><span class="line">| Tables_in_mysql_test |</span><br><span class="line">+----------------------+</span><br><span class="line">| Customers            |</span><br><span class="line">| OrderItems           |</span><br><span class="line">| Orders               |</span><br><span class="line">| Products             |</span><br><span class="line">| Vendors              |</span><br><span class="line">+----------------------+</span><br><span class="line">5 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT * FROM Customers;   #查看表Customers中的数据，显示为空</span><br><span class="line">Empty set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; source /home/blueyi/Downloads/TeachYourselfSQL_MySQL/populate.txt   #导入populate.txt中的命令来填充表内容</span><br><span class="line">Query OK, 1 row affected (0.05 sec)</span><br><span class="line"></span><br><span class="line">Query OK, 1 row affected (0.07 sec)</span><br><span class="line"></span><br><span class="line">Query OK, 1 row affected (0.06 sec)</span><br><span class="line">#....省略很多输出#</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT * FROM Customers;   #再次查看表Customers中的内容，显然已经成功创建</span><br><span class="line">+------------+---------------+----------------------+-----------+------------+----------+--------------+--------------------+-----------------------+</span><br><span class="line">| cust_id    | cust_name     | cust_address         | cust_city | cust_state | cust_zip | cust_country | cust_contact       | cust_email            |</span><br><span class="line">+------------+---------------+----------------------+-----------+------------+----------+--------------+--------------------+-----------------------+</span><br><span class="line">| 1000000001 | Village Toys  | 200 Maple Lane       | Detroit   | MI         | 44444    | USA          | John Smith         | sales@villagetoys.com |</span><br><span class="line">| 1000000002 | Kids Place    | 333 South Lake Drive | Columbus  | OH         | 43333    | USA          | Michelle Green     | NULL                  |</span><br><span class="line">| 1000000003 | Fun4All       | 1 Sunny Place        | Muncie    | IN         | 42222    | USA          | Jim Jones          | jjones@fun4all.com    |</span><br><span class="line">| 1000000004 | Fun4All       | 829 Riverside Drive  | Phoenix   | AZ         | 88888    | USA          | Denise L. Stephens | dstephens@fun4all.com |</span><br><span class="line">| 1000000005 | The Toy Store | 4545 53rd Street     | Chicago   | IL         | 54545    | USA          | Kim Howard         | NULL                  |</span><br><span class="line">+------------+---------------+----------------------+-----------+------------+----------+--------------+--------------------+-----------------------+</span><br><span class="line">5 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<h2 id="HELP"><a href="#HELP" class="headerlink" title="HELP"></a>HELP</h2><p>8.善用HELP命令，直接<code>HELP;</code>会显示总的帮助。<code>HELP command;</code>可以显示想要查看的帮助，例如<code>HELP SHOW;</code>会显示与SHOW相关的命令帮助。</p>
<h2 id="查看错误与警告"><a href="#查看错误与警告" class="headerlink" title="查看错误与警告"></a>查看错误与警告</h2><p>查看上一句命令的错误信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW ERRORS;</span><br></pre></td></tr></table></figure>
<p>查看上一句命令的警告信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW WARNINGS;</span><br></pre></td></tr></table></figure>

<p>9.退出MySQL</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; quit   #或者exit</span><br><span class="line">Bye</span><br></pre></td></tr></table></figure>

<h1 id="检索数据"><a href="#检索数据" class="headerlink" title="检索数据"></a>检索数据</h1><p>通常建议在写SQL语句时，SQL关键字应该使用大写，并且总是以分号“;”结尾，较长的语句可以分成多行，SQL语句中的所有空格都会被忽略。   </p>
<h2 id="SELECT语句的基本用法"><a href="#SELECT语句的基本用法" class="headerlink" title="SELECT语句的基本用法"></a>SELECT语句的基本用法</h2><p>1.SELECT语句必须至少给出两条信息——想选择什么，以及从什么地方选择。SELECT语句的作用对象是表（table）而不能是数据库。<br>2.SELECT语句检索单列</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT prod_name</span><br><span class="line">FROM Products;</span><br></pre></td></tr></table></figure>
<p>表示从表Products中选出列prod_name列中的所有内容。<br>3.SELECT检索多列：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT prod_id, prod_name, prod_price</span><br><span class="line">FROM Products;</span><br></pre></td></tr></table></figure>
<p>表示从表Products中选择三列并输出这三列，将需要选择的不同列使用逗号,分隔。<br>4.检索所有列：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT *</span><br><span class="line">FROM Products;</span><br></pre></td></tr></table></figure>
<p>5.添加关键字DISTINCT检索不相同的值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT DISTINCT vend_id</span><br><span class="line">FROM Products;</span><br></pre></td></tr></table></figure>
<p>会从表Products中选出列vend_id下的所有不相同的值，即会自动过滤掉多个相同的值而只保留一个。<br>DISTINCT会作用于其后面的所有列，也就是说会输出各列中所有不同的值，由于SQL语句的输出总是按原表中各行对应的顺序输出，所以输出结果中有些列会有重复值，但不会所有列都有重复的值。如</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT DISTINCT vend_id, prod_price FROM Products;</span><br></pre></td></tr></table></figure>
<p>该语句的输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT DISTINCT vend_id, prod_price FROM Products;</span><br><span class="line">+---------+------------+</span><br><span class="line">| vend_id | prod_price |</span><br><span class="line">+---------+------------+</span><br><span class="line">| DLL01   |       3.49 |</span><br><span class="line">| BRS01   |       5.99 |</span><br><span class="line">| BRS01   |       8.99 |</span><br><span class="line">| BRS01   |      11.99 |</span><br><span class="line">| DLL01   |       4.99 |</span><br><span class="line">| FNG01   |       9.49 |</span><br><span class="line">+---------+------------+</span><br><span class="line">6 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>
<p>vend_id列有重复值，但prod_price列没有。<br>6.SELECT语句默认会返回指定表中匹配的所有行，可以通过限制来返回指定数量的行，但不同的DBMS的实现不同。对于MySQL通过关键字LIMIT和OFFSET来实现。：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT prod_name</span><br><span class="line">FROM Products</span><br><span class="line">LIMIT 5 OFFSET 3;</span><br></pre></td></tr></table></figure>
<p>表示从表Products的prod_name列的第3行开始，输出检索到的前5条数据，LIMIT后面的数据表示需要检索的行数，OFFSET后面的数字表示从第几行开始，SQL中默认行号从0开始。<br>也可以通过逗号“,”来简写而省略OFFSET关键字，但LIMIT关键字不能省略，且此时逗号前面的数字表示从哪儿开始，逗号后面的数字表示检索的行数，上述语句等价于</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT prod_name</span><br><span class="line">FROM Products</span><br><span class="line">LIMIT 3, 5;</span><br></pre></td></tr></table></figure>

<p>7.SQL支持三种注释方式：行内注释使用<code>#</code>或<code>--</code>，注意那是2个短划线后跟一个空格，即<code>#</code>后面可以直接跟注释，短划线后面必须有个空格然后再跟注释内容。或者使用多行注释<code>/*common*/</code>，类似与C语言。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT prod_name   #这是注释</span><br><span class="line">FROM Products      -- 这也是注释</span><br><span class="line">LIMIT 3, 5;       /*这同样是注释*/</span><br></pre></td></tr></table></figure>
<h2 id="排序数据"><a href="#排序数据" class="headerlink" title="排序数据"></a>排序数据</h2><p>1.SQL语句由子句构成，有些子句是必须的，有些子句是可选的，一个子句通常由一个关键字加上所提供的数据组成。上面的SELECT…FROM…语句中就有SELECT语句的FROM子句。<br>2.使用ORDER BY来对SELECT语句输出的结果进行排序，ORDER BY子句可以跟一个或多个列的名字，以这些名字来对输出进行排序，当有多个列时，只有前一个列相同时才按后一个列进行排序。默认情况是按字典序升序排列。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT prod_name, prod_id, prod_price</span><br><span class="line">FROM Products</span><br><span class="line">ORDER BY prod_price, prod_name;</span><br></pre></td></tr></table></figure>
<p>ORDER BY子句可以通过数字来指定相对位置而不是列名，SELECT子句后面的列名从序号1开始，所以上述语句等价于</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT prod_name, prod_id, prod_price</span><br><span class="line">FROM Products</span><br><span class="line">ORDER BY 3, 1;</span><br></pre></td></tr></table></figure>
<p>3.ORDER BY子句后面的列可以是表中的任意列，不需要必须是选择的列<br>4.可以通过ORDER BY子句的列后面跟DESC或DESCENDING来指定该列按降序排列，当然也可以指定ASC或ASCENDING，如果想在多个列上进行降序，必需对每一列指定DESC关键字。上述语句按prod_price和prod_name的降序排列语句为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT prod_name, prod_id, prod_price</span><br><span class="line">FROM Products</span><br><span class="line">ORDER BY prod_price DESC, prod_name DESC;</span><br></pre></td></tr></table></figure>

<h2 id="过滤数据"><a href="#过滤数据" class="headerlink" title="过滤数据"></a>过滤数据</h2><p>1.SELECT语句可以通过WHERE子句进行输出结果的过滤，WHERE子句后面需要跟上相应的过滤条件，大多数DBMS支持以下条件的判断：</p>
<table>
<thead>
<tr>
<th>操作符</th>
<th>说 明</th>
</tr>
</thead>
<tbody><tr>
<td>=</td>
<td>等于</td>
</tr>
<tr>
<td>&lt; &gt;</td>
<td>不等于</td>
</tr>
<tr>
<td>!=</td>
<td>不等于</td>
</tr>
<tr>
<td>&lt;</td>
<td>小于</td>
</tr>
<tr>
<td>&lt;=</td>
<td>小于等于</td>
</tr>
<tr>
<td>!</td>
<td>不小于</td>
</tr>
<tr>
<td>&gt;</td>
<td>大于</td>
</tr>
<tr>
<td>&gt;=</td>
<td>大于等于</td>
</tr>
<tr>
<td>!&gt;</td>
<td>不大于</td>
</tr>
<tr>
<td>BETWEEN..AND..</td>
<td>在指定的两个值之间</td>
</tr>
<tr>
<td>IS NULL</td>
<td>为NULL值</td>
</tr>
</tbody></table>
<p>如下例所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM Products</span><br><span class="line">WHERE prod_price = 3.49;  #选择所有prod_price值为3.49的数据</span><br><span class="line"></span><br><span class="line">SELECT * FROM Products</span><br><span class="line">WHERE prod_price BETWEEN 4 AND 10;  #选择所有prod_price值在4到10之间的数据</span><br><span class="line"></span><br><span class="line">SELECT vend_id, prod_name </span><br><span class="line">FROM Products</span><br><span class="line">WHERE vend_id != &#x27;DLL01&#x27;;  #选择vend_id的值不等于DLL01的vend_id列和prod_name列</span><br><span class="line"></span><br><span class="line">SELECT * FROM Products</span><br><span class="line">WHERE prod_price BETWEEN 4 AND 10 </span><br><span class="line">ORDER BY prod_price DESC;  #选择所有prod_price值在4到10之间的数据，并按prod_price降序排列</span><br></pre></td></tr></table></figure>
<p>2.注意上例中对于非数值列进行比较时需要使用单引号将值括起来。ORDER BY子句必须放在WHERE子句的后面，否则会报错。</p>
<p>3.空值检查必须使用IS NULL，并且NULL（即无值，no value）与字段为0、空字符串或只包含空格都不同，而且不能通过检查是否=NULL来验证，必须使用IS NULL。如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT vend_id, prod_name </span><br><span class="line">FROM Products</span><br><span class="line">WHERE vend_id IS NULL;  #选择vend_id的值不等于DLL01的vend_id列和prod_name列</span><br></pre></td></tr></table></figure>
<p>4.通过过滤不包含指定值的所有行时，无法获得值为NULL的行，所以过滤数据时，一定要验证被过滤列中含有NULL的行确实出现在返回的数据中。<br>5.WHERE子句中有多个条件时，可以使用AND或OR进行连接，他们的意义也就是正常的逻辑意思，但当AND与OR混合连接时，默认情况下AND的优先级较高，可以通过加圆括号来改变默认优先级：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT prod_id, vend_id, prod_price </span><br><span class="line">FROM Products </span><br><span class="line">WHERE (vend_id = &#x27;BRS01&#x27; OR vend_id = &#x27;DLL01&#x27;) AND prod_price &gt;= 4</span><br><span class="line">ORDER BY prod_price DESC, prod_name DESC;</span><br></pre></td></tr></table></figure>
<p>意思是从表Products中选择列prod_id、vend_id、prod_price，且要求vend_id的值为BRS01或DLL01，且prod_price的值大于或等于4，然后将结果进行排序后输出<br>6.IN操作符可以用来指定条件范围，范围中的每个条件都可以进行匹配。IN取一组由逗号分隔、括在圆括号中的合法值，功能类似于OR，但圆括号中可以有其他SELECT子句。上面5中的语句与下面这句等价：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT prod_id, vend_id, prod_price</span><br><span class="line">FROM Products</span><br><span class="line">WHERE vend_id IN (&#x27;BRS01&#x27;, &#x27;DLL01&#x27;) AND prod_price &gt;= 4</span><br><span class="line">ORDER BY prod_price DESC, prod_name DESC;</span><br></pre></td></tr></table></figure>
<p>IN操作符有很多优点，且它比OR速度要快</p>
<p>7.NOT操作符用来否定其后所跟的条件，如果需要否定后面的每个条件，则需要括号来限定范围，NOT从不单独使用。如要选出prod_price的值不为3.49和9.49的所有数据，代码可为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * </span><br><span class="line">FROM Products  </span><br><span class="line">WHERE NOT (prod_price = 3.49 OR prod_price = 9.49);</span><br></pre></td></tr></table></figure>
<p>8.关键字LIKE可使WHERE子句支持通配符（wildcard）匹配，由字面值、通配符或两者组合构成的搜索条件称为搜索模式（search pattern）。LIKE被称为谓词（predicate）而不是操作符。<br>SQL通常支持的通配符有：</p>
<ul>
<li>百分号（%）–用于匹配0个或多个字符，Microsoft Access使用*而不是%</li>
<li>下划线（<em>）–用于匹配1个字符，Microsoft Access使用?而不是</em>   </li>
</ul>
<p>不同的DBMS支持的通配符不一样。<br>通配符使用示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM Products WHERE prod_name LIKE &#x27;%bean%&#x27;;</span><br></pre></td></tr></table></figure>
<p>搜索出prod_name中含有bean的所有行。<br>注意：</p>
<ul>
<li>百分号不能匹配NULL</li>
<li>注意表内容后面所跟的空格，包括Access在内的许多DBMS都用空格来填补字段的内容，即如果某列有50个字符，而实际只有10个字符，则会自动使用40个空格填充</li>
<li>不要过度使用通配符。如果其他操作符能达到相同的目的，应该使用其他操作符。</li>
<li>在确实需要使用通配符时，也尽量不要把它们用在搜索模式的开始处。把通配符置于开始处，搜索起来是最慢的。</li>
<li>仔细注意通配符的位置。如果放错地方，可能不会返回想要的数据。</li>
</ul>
<h1 id="用正则表达式搜索"><a href="#用正则表达式搜索" class="headerlink" title="用正则表达式搜索"></a>用正则表达式搜索</h1><p>1.关于正则表达式的基础知识，可以参见这里<a href="2015/10/04/Regular-Expression-Study-Note/">正则表达式学习笔记</a><br>2.MySQL通过关键字REGEXP来提供对正则表达式的支持。默认情况下不支持大小写，如果要增加对大小写的支持，需要在REGEXP后面跟上关键字BINARY。eg:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT prod_name</span><br><span class="line">FROM Products</span><br><span class="line">WHERE prod_name REGEXP &#x27;[123] ton&#x27;</span><br><span class="line">ORDER BY prod_name;</span><br></pre></td></tr></table></figure>

<p>3.对于字符类的匹配，不支持直接使用\d、\s等，需要使用以下字符类：</p>
<ul>
<li>[:alnum:]    任意字母和数字(同[a-zA-Z0-9])</li>
<li>[:alpha:]    任意字符(同[a-zA-Z])</li>
<li>[:blank:]    空格和制表(同[\t])</li>
<li>[:cntrl:]    ASCII控制字符(ASCII 0到31和127)</li>
<li>[:digit:]    任意数字(同[0-9])</li>
<li>[:graph:]    与[:print:]相同,但不包括空格</li>
<li>[:lower:]    任意小写字母(同[a-z])</li>
<li>[:print:]    任意可打印字符</li>
<li>[:punct:]    既不在[:alnum:]又不在[:cntrl:]中的任意字符</li>
<li>[:space:]    包括空格在内的任意空白字符(同[\f\n\r\t\v])</li>
<li>[:upper:]    任意大写字母(同[A-Z])</li>
<li>[:xdigit:]    任意十六进制数字(同[a-fA-F0-9])</li>
</ul>
<p>例如要匹配以数字开头，然后后面跟的是单词inch，后面再跟任意多个字符时，不能使用<code>\d+\s*inch.*</code>，而需要使用<code>[[:digit:]]+[[:blank:]]*inch.*</code>，也就是使用字符类替换元字符。</p>
<p>4.可以使用SELECT语句测试正则表达式。如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT &#x27;Hello world!&#x27; REGEXP BINARY &#x27;He.*&#x27;;</span><br></pre></td></tr></table></figure>
<p>测试语句只能返回0和1,例如上句将返回1。</p>
<h1 id="计算字段"><a href="#计算字段" class="headerlink" title="计算字段"></a>计算字段</h1><p>1.存储在数据库表中的数据一般不是应用程序所需要的格式，通常需要通过运行时使用SELECT语句创建字段（field），然后再在应用程序中引用这个字段。<br>2.字段基本上与列（column）意思相同，但字段通常与计算字段一起使用，可以通过不同的操作符及函数对不同的列进行操作，例如使用CONCAT()函数（MySQL中是CONCAT函数，Access中是+号）将两列字符串拼接为一列后输出，使用+、-、*、/运算符将不同列的数据运算为相应的一列结果。如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT prod_id, quantity, item_price, quantity * item_price</span><br><span class="line">FROM OrderItems </span><br><span class="line">WHERE order_num = 20008</span><br><span class="line">ORDER BY prod_id;  #将quantity * item_price相乘后输出</span><br></pre></td></tr></table></figure>
<p>3.使用AS可以为新创建的字段创建一个别名，这个别名将可以被外部应用像引用输出的列一样引用。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT prod_id, quantity, item_price, </span><br><span class="line">CONCAT(prod_id, &#x27;(&#x27;, quantity * item_price, &#x27;)&#x27;) </span><br><span class="line">AS prod_name_price </span><br><span class="line">FROM OrderItems  </span><br><span class="line">WHERE order_num = 20008 </span><br><span class="line">ORDER  BY prod_id;</span><br></pre></td></tr></table></figure>
<p>输出内容</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+---------+----------+------------+-----------------+</span><br><span class="line">| prod_id | quantity | item_price | prod_name_price |</span><br><span class="line">+---------+----------+------------+-----------------+</span><br><span class="line">| BNBG01  |       10 |       3.49 | BNBG01(34.90)   |</span><br><span class="line">| BNBG02  |       10 |       3.49 | BNBG02(34.90)   |</span><br><span class="line">| BNBG03  |       10 |       3.49 | BNBG03(34.90)   |</span><br><span class="line">| BR03    |        5 |      11.99 | BR03(59.95)     |</span><br><span class="line">| RGAN01  |        5 |       4.99 | RGAN01(24.95)   |</span><br><span class="line">+---------+----------+------------+-----------------+</span><br><span class="line">5 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>
<p>注意prod_name_price就是新别名<br>别名有时也称为导出列（derived column）</p>
<p>4.SELECT语句可以测试计算，也可以直接执行一些函数，而不需要后面跟FROM子句。eg:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT 3 * 2; #计算3 * 2</span><br><span class="line">SELECT TRIM(&#x27; abc &#x27;); #删除其中的空格</span><br><span class="line">SELECT NOW(); #显示当前时间</span><br><span class="line">SELECT VERSION();  #查看版本</span><br></pre></td></tr></table></figure>
<p>5.不同的DBMS都提供了大量不同的函数和操作符，对于MySQL所支持的函数和操作符，可以参见官方文档<a href="http://dev.mysql.com/doc/refman/5.6/en/functions.html">Chapter 12 Functions and Operators</a></p>
<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="基本函数"><a href="#基本函数" class="headerlink" title="基本函数"></a>基本函数</h2><p>1.在上面计算字段中已经多次使用了函数，例如CONCAT()用于拼接字符串的函数，TRIM()用于清理多余空格的函数等。各公司的DBMS提供的函数都不相同，SQL函数是不可移植的。但大多数DBMS都提供如下函数：</p>
<ul>
<li>用于处理文本字符串（如删除或填充值，转换值为大写或小写）的文本函数。</li>
<li>用于在数值数据上进行算术操作（如返回绝对值，进行代数运算）的数值函数。</li>
<li>用于处理日期和时间值并从这些值中提取特定成分（如返回两个日期之差，检查日期有效性）的日期和时间函数。</li>
<li>返回DBMS正使用的特殊信息（如返回用户登录信息）的系统函数。</li>
</ul>
<p>MySQL提供的函数可在其官方文档<a href="http://dev.mysql.com/doc/refman/5.6/en/functions.html">functions</a>中找到，有大量非常实用的函数。</p>
<p>2.举一个使用函数的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT vend_name ,UPPER(vend_name) </span><br><span class="line">FROM Vendors;  #输出vend_name及vend_name大写之后的内容</span><br></pre></td></tr></table></figure>
<p>3.有一个比较特别的函数SOUNDEX()，该函数可以检测出发音一样的内容，如“Michelle Green”与“Michael Green”发音一样，则可以通过SOUNDEX()函数过滤出这两个发音相同的数据：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT cust_name, cust_contact </span><br><span class="line">FROM Customers </span><br><span class="line">WHERE SOUNDEX(cust_contact) = SOUNDEX(&#x27;Michael Green&#x27;);  #选出cust_contact列中发音与Michael Green一样的内容</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+------------+----------------+</span><br><span class="line">| cust_name  | cust_contact   |</span><br><span class="line">+------------+----------------+</span><br><span class="line">| Kids Place | Michelle Green |</span><br><span class="line">+------------+----------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>
<p>验证：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT SOUNDEX(&#x27;Michael Green&#x27;), SOUNDEX(&#x27;Michelle Green&#x27;);</span><br><span class="line">+--------------------------+---------------------------+</span><br><span class="line">| SOUNDEX(&#x27;Michael Green&#x27;) | SOUNDEX(&#x27;Michelle Green&#x27;) |</span><br><span class="line">+--------------------------+---------------------------+</span><br><span class="line">| M24265                   | M24265                    |</span><br><span class="line">+--------------------------+---------------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>
<p>4.日期和时间处理函数是非常重要的一组函数，也经常使用，所以MySQL中对日期和时间采用了相应的数据类型和特殊的格式存储。日期格式通常必须为yyyy-mm-dd，如2016年6月27就是2016-06-27。通常默认的时间数据类型为datetime时，这种类型即包含日期，又包含时间，所以获取这种数据类型的列时需要使用Date()函数。例如查询2012年2月3号的订单：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT order_num, cust_id FROM Orders WHERE Date(order_date) = &#x27;2012-02-03&#x27;;</span><br><span class="line">+-----------+------------+</span><br><span class="line">| order_num | cust_id    |</span><br><span class="line">+-----------+------------+</span><br><span class="line">|     20008 | 1000000005 |</span><br><span class="line">+-----------+------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>
<p>注意SQL中除了数值之外的数据，都需要使用单引号括住</p>
<p>5.查看3个月内没有签到的用户：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT email FROM user WHERE UNIX_TIMESTAMP(now()) - last_check_in_time &gt; 7862400;</span><br></pre></td></tr></table></figure>
<p>注：last_check_in_time中存储的时间是unix时间戳</p>
<h2 id="聚集函数"><a href="#聚集函数" class="headerlink" title="聚集函数"></a>聚集函数</h2><p>1.聚集函数（aggregate function）也就是那些用于汇总数据的函数，MySQL提供的聚集函数有：</p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>AVG()</td>
<td>Return the average value of the argument</td>
</tr>
<tr>
<td>BIT_AND()</td>
<td>Return bitwise AND</td>
</tr>
<tr>
<td>BIT_OR()</td>
<td>Return bitwise OR</td>
</tr>
<tr>
<td>BIT_XOR()</td>
<td>Return bitwise XOR</td>
</tr>
<tr>
<td>COUNT()</td>
<td>Return a count of the number of rows returned</td>
</tr>
<tr>
<td>COUNT(DISTINCT)</td>
<td>Return the count of a number of different values</td>
</tr>
<tr>
<td>GROUP_CONCAT()</td>
<td>Return a concatenated string</td>
</tr>
<tr>
<td>MAX()</td>
<td>Return the maximum value</td>
</tr>
<tr>
<td>MIN()</td>
<td>Return the minimum value</td>
</tr>
<tr>
<td>STD()</td>
<td>Return the population standard deviation</td>
</tr>
<tr>
<td>STDDEV()</td>
<td>Return the population standard deviation</td>
</tr>
<tr>
<td>STDDEV_POP()</td>
<td>Return the population standard deviation</td>
</tr>
<tr>
<td>STDDEV_SAMP()</td>
<td>Return the sample standard deviation</td>
</tr>
<tr>
<td>SUM()</td>
<td>Return the sum</td>
</tr>
<tr>
<td>VAR_POP()</td>
<td>Return the population standard variance</td>
</tr>
<tr>
<td>VAR_SAMP()</td>
<td>Return the sample variance</td>
</tr>
<tr>
<td>VARIANCE()</td>
<td>Return the population standard variance</td>
</tr>
</tbody></table>
<p>官方文档在这里<a href="http://dev.mysql.com/doc/refman/5.6/en/group-by-functions.html">GROUP BY (Aggregate) Function Descriptions</a></p>
<p>2.AVG的用法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT AVG(prod_price) AS prod_price_avg FROM Products;</span><br><span class="line">+----------------+</span><br><span class="line">| prod_price_avg |</span><br><span class="line">+----------------+</span><br><span class="line">|       6.823333 |</span><br><span class="line">+----------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>
<p>注意AVG的参数只能是一个表达式，当然后面也可以增加WHERE子句来缩小计算范围</p>
<p>3.COUNT()函数有两种使用方式：</p>
<ul>
<li>使用COUNT(*)对表中行的数目进行计数，不管表列中包含的是空值（NULL）还是非空值。</li>
<li>使用COUNT(column)对特定列中具有值的行进行计数，忽略NULL值。</li>
</ul>
<p>4.MAX()函数不仅可以作用于数值或日期，也可以使用于字符串，作用于字符串时返回该列排序后的最后一行。MIN()函数同理。</p>
<p>5.这些函数也可以计算合计之后的列的值，如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT SUM(quantity * item_price)  FROM OrderItems;</span><br><span class="line">+----------------------------+</span><br><span class="line">| SUM(quantity * item_price) |</span><br><span class="line">+----------------------------+</span><br><span class="line">|                    5730.70 |</span><br><span class="line">+----------------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>
<p>6.这些函数都默认会忽略掉列值为NULL的行   </p>
<p>7.可以使用DISTINCT参数聚集不同的值，这些聚集函数通常都可以如下使用：</p>
<ul>
<li>对所有行执行计算，指定ALL参数或不指定参数（因为ALL是默认行为）。也就是说ALL参数不需要指定，因为它是默认行为。如果不指定DISTINCT，则假定为ALL</li>
<li>只包含不同的值，指定DISTINCT参数。<br>如：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT prod_price FROM Products WHERE vend_id = &#x27;DLL01&#x27;;  #所有DLL01的价格</span><br><span class="line">+------------+</span><br><span class="line">| prod_price |</span><br><span class="line">+------------+</span><br><span class="line">|       3.49 |</span><br><span class="line">|       3.49 |</span><br><span class="line">|       3.49 |</span><br><span class="line">|       4.99 |</span><br><span class="line">+------------+</span><br><span class="line">4 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT AVG( prod_price ) AS avg_price FROM Products WHERE vend_id = &#x27;DLL01&#x27;;  </span><br><span class="line">+-----------+</span><br><span class="line">| avg_price |</span><br><span class="line">+-----------+</span><br><span class="line">|  3.865000 |#所有DLL01价格的平均值</span><br><span class="line">+-----------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT AVG(DISTINCT prod_price) AS avg_price FROM Products WHERE vend_id = &#x27;DLL01&#x27;; </span><br><span class="line">+-----------+</span><br><span class="line">| avg_price |</span><br><span class="line">+-----------+</span><br><span class="line">|  4.240000 | #使用DISTINCT之后只是价格不同的行进行平均</span><br><span class="line">+-----------+</span><br><span class="line">1 row in set (0.01 sec)</span><br></pre></td></tr></table></figure></li>
</ul>
<p>8.可以一次使用多个聚集函数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT COUNT(*) AS num_items,</span><br><span class="line">MIN(prod_price) AS price_min,</span><br><span class="line">MAX(prod_price) AS price_max,</span><br><span class="line">AVG(prod_price) AS price_avg</span><br><span class="line">FROM Products;</span><br></pre></td></tr></table></figure>

<h1 id="分组数据"><a href="#分组数据" class="headerlink" title="分组数据"></a>分组数据</h1><p>1.分组使用SELECT语句的GROUP BY子句创建，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT vend_id, COUNT(*) AS num_prod, prod_price</span><br><span class="line">FROM Products </span><br><span class="line">WHERE prod_price &gt;= 4 </span><br><span class="line">GROUP BY vend_id </span><br><span class="line">ORDER BY num_prod, vend_id;</span><br></pre></td></tr></table></figure>
<p>输出结果为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+---------+----------+------------+</span><br><span class="line">| vend_id | num_prod | prod_price |</span><br><span class="line">+---------+----------+------------+</span><br><span class="line">| DLL01   |        1 |       4.99 |</span><br><span class="line">| FNG01   |        2 |       9.49 |</span><br><span class="line">| BRS01   |        3 |       5.99 |</span><br><span class="line">+---------+----------+------------+</span><br><span class="line">3 rows in set (0.01 sec)</span><br></pre></td></tr></table></figure>
<p>意思是从表Products中选择vend_id列，prod_price列，并用聚合函数COUNT进行计数，要求prod_price必须大于等于4，使用GROUP BY按vend_id排序并分组数据，最后将计算结果使用COUNT(*)和vend_id排序。<br>对照以下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT *  FROM Products;</span><br><span class="line">+---------+---------+---------------------+------------+-----------------------------------------------------------------------+</span><br><span class="line">| prod_id | vend_id | prod_name           | prod_price | prod_desc                                                             |</span><br><span class="line">+---------+---------+---------------------+------------+-----------------------------------------------------------------------+</span><br><span class="line">| BNBG01  | DLL01   | Fish bean bag toy   |       3.49 | Fish bean bag toy, complete with bean bag worms with which to feed it |</span><br><span class="line">| BNBG02  | DLL01   | Bird bean bag toy   |       3.49 | Bird bean bag toy, eggs are not included                              |</span><br><span class="line">| BNBG03  | DLL01   | Rabbit bean bag toy |       3.49 | Rabbit bean bag toy, comes with bean bag carrots                      |</span><br><span class="line">| BR01    | BRS01   | 8 inch teddy bear   |       5.99 | 8 inch teddy bear, comes with cap and jacket                          |</span><br><span class="line">| BR02    | BRS01   | 12 inch teddy bear  |       8.99 | 12 inch teddy bear, comes with cap and jacket                         |</span><br><span class="line">| BR03    | BRS01   | 18 inch teddy bear  |      11.99 | 18 inch teddy bear, comes with cap and jacket                         |</span><br><span class="line">| RGAN01  | DLL01   | Raggedy Ann         |       4.99 | 18 inch Raggedy Ann doll                                              |</span><br><span class="line">| RYL01   | FNG01   | King doll           |       9.49 | 12 inch king doll with royal garments and crown                       |</span><br><span class="line">| RYL02   | FNG01   | Queen doll          |       9.49 | 12 inch queen doll with royal garments and crown                      |</span><br><span class="line">+---------+---------+---------------------+------------+-----------------------------------------------------------------------+</span><br><span class="line">9 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>
<p>2.由上例可见GROUP BY子句指示DBMS分组数据，然后对每个分组而不是整个结果集进行聚集。<br>3.GROUP BY在使用时需要注意以下内容：</p>
<ul>
<li>GROUP BY子句可以包含任意数目的列，因而可以对分组进行嵌套，更细致地进行数据分组。</li>
<li>如果在GROUP BY子句中嵌套了分组，数据将在最后指定的分组上进行汇总。换句话说，在建立分组时，指定的所有列都一起计算（所以不能从个别的列取回数据）。</li>
<li>GROUP BY子句中列出的每一列都必须是检索列或有效的表达式（但不能是聚集函数）。如果在SELECT中使用表达式，则必须在GROUP BY子句中指定相同的表达式。不能使用别名。</li>
<li>大多数SQL实现不允许GROUP BY列带有长度可变的数据类型（如文本或备注型字段）。</li>
<li>除聚集计算语句外，SELECT语句中的每一列都必须在GROUP BY子句中给出。</li>
<li>如果分组列中包含具有NULL值的行，则NULL将作为一个分组返回。如果列中有多行NULL值，它们将分为一组。</li>
<li>GROUP BY子句必须出现在WHERE子句之后，ORDER BY子句之前。</li>
</ul>
<p>4.类似与WHERE子句可以过滤掉特定的行，HAVING子句可以过滤分组。如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT vend_id, COUNT(*) AS num_prod, prod_price  </span><br><span class="line">FROM Products </span><br><span class="line">WHERE prod_price &gt;= 4 </span><br><span class="line">GROUP BY vend_id </span><br><span class="line">HAVING num_prod &gt;= 2 </span><br><span class="line">ORDER BY num_prod, vend_id;</span><br></pre></td></tr></table></figure>
<p>输出结果为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+---------+----------+------------+</span><br><span class="line">| vend_id | num_prod | prod_price |</span><br><span class="line">+---------+----------+------------+</span><br><span class="line">| FNG01   |        2 |       9.49 |</span><br><span class="line">| BRS01   |        3 |       5.99 |</span><br><span class="line">+---------+----------+------------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>
<p>可见只输出了COUNT(*)大于等于2的数组<br>5.HAVING子句的语法与WHERE相同，同样支持通配符、逻辑运算等。但它们的意义却完全不同，WHERE在数据分组前按行进行过滤，HAVING是在数据分组后按组进行过滤，WHERE排除的行将不被包括在分组中。<br>6.GROUP BY分组的数据虽然也会排序，但不应该依赖于它的排序，应该使用ORDER BY进行排序<br>7.SELECT子句的顺序：</p>
<table>
<thead>
<tr>
<th>子　　句</th>
<th>说　　明</th>
<th>是否必须使用</th>
</tr>
</thead>
<tbody><tr>
<td>SELECT</td>
<td>要返回的列或表达式</td>
<td>是</td>
</tr>
<tr>
<td>FROM</td>
<td>从中检索数据的表</td>
<td>仅在从表选择数据时使用</td>
</tr>
<tr>
<td>WHERE</td>
<td>行级过滤</td>
<td>否</td>
</tr>
<tr>
<td>GROUP BY</td>
<td>分组说明</td>
<td>仅在按组计算聚集时使用</td>
</tr>
<tr>
<td>HAVING</td>
<td>组级过滤</td>
<td>否</td>
</tr>
<tr>
<td>ORDER BY</td>
<td>输出排序顺序</td>
<td>否</td>
</tr>
<tr>
<td>LIMIT</td>
<td>要检索的行数</td>
<td>否</td>
</tr>
</tbody></table>
<p>8.MySQL在进行分组查询时，可以在GROUP BY子句附带WITH ROLLUP关键字来对每个分组进行汇总。如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT vend_id, COUNT(*) AS num_prod, prod_price, SUM(prod_price) AS price_total </span><br><span class="line">FROM Products </span><br><span class="line">WHERE prod_price &gt;=4 </span><br><span class="line">GROUP BY vend_id;</span><br></pre></td></tr></table></figure>
<p>输出为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+---------+----------+------------+-------------+</span><br><span class="line">| vend_id | num_prod | prod_price | price_total |</span><br><span class="line">+---------+----------+------------+-------------+</span><br><span class="line">| BRS01   |        3 |       5.99 |       26.97 |</span><br><span class="line">| DLL01   |        1 |       4.99 |        4.99 |</span><br><span class="line">| FNG01   |        2 |       9.49 |       18.98 |</span><br><span class="line">+---------+----------+------------+-------------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>
<p>为GROUP BY子句加上WITH ROLLUP之后：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT vend_id, COUNT(*) AS num_prod, prod_price, SUM(prod_price) AS price_total </span><br><span class="line">FROM Products </span><br><span class="line">WHERE prod_price &gt;=4 </span><br><span class="line">GROUP BY vend_id </span><br><span class="line">WITH ROLLUP;</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+---------+----------+------------+-------------+</span><br><span class="line">| vend_id | num_prod | prod_price | price_total |</span><br><span class="line">+---------+----------+------------+-------------+</span><br><span class="line">| BRS01   |        3 |       5.99 |       26.97 |</span><br><span class="line">| DLL01   |        1 |       4.99 |        4.99 |</span><br><span class="line">| FNG01   |        2 |       9.49 |       18.98 |</span><br><span class="line">| NULL    |        6 |       9.49 |       50.94 |</span><br><span class="line">+---------+----------+------------+-------------+</span><br><span class="line">4 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>
<p>可以看到最后一行多了NULL，后面对应的数值除了prod_price列之外（对该列的统计本身也就没有意义），num_prod和price_total的最后一行都是之前3行的总和。这就是WITH ROLLUP的作用。<br>但需要注意的是ROLLUP关键字与ORDER BY关键字互斥，也就是使用了ROLLUP之后就不能再使用ORDER BY进行排序。</p>
<h1 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h1><p>1.SELECT语句是SQL的查询（query），任何SQL语句都是查询，但查询通常是指SELECT语句。子查询（subquery）是指嵌套在其他查询中的查询，即把一条SELECT语句返回的结果用于另一条SELECT语句的WHERE子句。或者将子查询作为计算字段。<br>如这个例子中，列出订购物品RGAN01的所有顾客</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT cust_name, cust_email  </span><br><span class="line">FROM Customers </span><br><span class="line">WHERE cust_id IN (SELECT cust_id</span><br><span class="line">                  FROM Orders </span><br><span class="line">                  WHERE order_num IN(SELECT order_num </span><br><span class="line">                                     FROM OrderItems </span><br><span class="line">                                     WHERE prod_id = &#x27;RGAN01&#x27;));</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+---------------+-----------------------+</span><br><span class="line">| cust_name     | cust_email            |</span><br><span class="line">+---------------+-----------------------+</span><br><span class="line">| Fun4All       | dstephens@fun4all.com |</span><br><span class="line">| The Toy Store | NULL                  |</span><br><span class="line">+---------------+-----------------------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>
<p>子查询没有嵌套次数限制，每个子查询都会从内到外依次解析，但过深的子查询会影响性能。<br>2.作为计算字段使用子查询，即使用子查询创建计算字段。如要显示Customers表中每个顾客的订单总数，但订单信息都存储在Orders表中，共有的字段是cust_id。代码为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT cust_name, cust_email, (SELECT COUNT(*) </span><br><span class="line">                               FROM Orders </span><br><span class="line">                               WHERE Orders.cust_id = Customers.cust_id) AS Orders</span><br><span class="line">FROM Customers</span><br><span class="line">ORDER BY cust_name ;</span><br></pre></td></tr></table></figure>
<p>这里的Orders.cust_id称为完全限定列名，为了避免歧义<br>结果为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+---------------+-----------------------+--------+</span><br><span class="line">| cust_name     | cust_email            | Orders |</span><br><span class="line">+---------------+-----------------------+--------+</span><br><span class="line">| Fun4All       | jjones@fun4all.com    |      1 |</span><br><span class="line">| Fun4All       | dstephens@fun4all.com |      1 |</span><br><span class="line">| Kids Place    | NULL                  |      0 |</span><br><span class="line">| The Toy Store | NULL                  |      1 |</span><br><span class="line">| Village Toys  | sales@villagetoys.com |      2 |</span><br><span class="line">+---------------+-----------------------+--------+</span><br><span class="line">5 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>
<p><strong>注意在作为计算字段的子查询中，这里的子查询对检索出的每个顾客各执行一次，由于对Customers检索出了5个顾客，所以共执行了5次。这里的子查询是在原查询的SELECT语句中，所以不像前面嵌套查询那样是在WHERE子句中必须先执行，而是在SELECT语句的检索到相应的行之后传递给子查询，然后由子查询进行计算字段的查询</strong></p>
<h1 id="联结表"><a href="#联结表" class="headerlink" title="联结表"></a>联结表</h1><h2 id="内联结"><a href="#内联结" class="headerlink" title="内联结"></a>内联结</h2><p>1.联结（join）表就是使用SELECT将多个表通过特定的列中的相等值联结在一起进行查询。这也是关系数据库设计的基础，即将信息分解成多个表，一类数据一个表，各表通过某些共同的值互相关联，而不是为存储共有的信息而给每个数据行都单独存一份。<br>一个表的外键（foreign key）定义它与另一表的关系。外键为某个表的一列，它包含另一个表的主键值，定义了两个表之间的关系。<br>2.可以在WHERE子句中使用等号（=）创建联结，也可以使用INNER JOIN…ON子句创建联结。如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT vend_name, prod_name, prod_price  </span><br><span class="line">FROM Vendors, Products </span><br><span class="line">WHERE Vendors.vend_id = Products.vend_id </span><br><span class="line">ORDER BY prod_price;</span><br></pre></td></tr></table></figure>
<p>等价于</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT vend_name, prod_name, prod_price  </span><br><span class="line">FROM Vendors INNER JOIN Products </span><br><span class="line">ON Vendors.vend_id = Products.vend_id</span><br><span class="line">ORDER BY prod_price;</span><br></pre></td></tr></table></figure>
<p>注意这里面没有WHERE子句，这种基于两个表之间的相等测试产生的联结称为等值链接（equition）,也称为内联结（inner join）。<br>笛卡儿积（cartesian product）：由没有联结条件的表关系返回的结果为笛卡儿积。检索出的行为数目将是第一个表中的行数乘以第二个表中的行数。<br>3.需要联结多个表时使用AND将需要链接多个表联结在一起即可，如使用子查询列出RGAN01所有顾客的例子可以改写为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT cust_name, cust_email</span><br><span class="line">FROM Customers, Orders, OrderItems</span><br><span class="line">WHERE Customers.cust_id = Orders.cust_id</span><br><span class="line">AND Orders.order_num = OrderItems.order_num</span><br><span class="line">AND OrderItems.prod_id = &#x27;RGAN01&#x27;;</span><br></pre></td></tr></table></figure>
<p>4.当SQL语句中表名太长时，也可以为表定义别名，如上述选择RGAN01产品的顾客信息的SQL语句可改写为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT cust_name, cust_contact  </span><br><span class="line">FROM Customers AS C, Orders AS O, OrderItems AS OI </span><br><span class="line">WHERE C.cust_id = O.cust_id </span><br><span class="line">AND OI.order_num = O.order_num </span><br><span class="line">AND prod_id = &#x27;RGAN01&#x27;;</span><br></pre></td></tr></table></figure>
<p>表别名不仅可以用于WHERE子句，也可用于SELECT列表、ORDER BY子句以及其他语句部分<br>对于Oracle用户可以去掉AS，因为Oracel不支持AS，直接表名后面跟一个别名就可以</p>
<h2 id="自联结"><a href="#自联结" class="headerlink" title="自联结"></a>自联结</h2><p>自联结就是当需要多次引用同一个表时，可以为该表创建多个不同的别名，然后引用，可以用于代替子查询实现的效果，而且比子查询速度要快。<br>例如要选择出Customers表中的与Jim Jones同一公司的所有顾客，使用子查询为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT cust_id, cust_name, cust_contact</span><br><span class="line">FROM Customers</span><br><span class="line">WHERE cust_name = (SELECT cust_name </span><br><span class="line">                   FROM Customers</span><br><span class="line">                   WHERE cust_contact = &#x27;Jim Jones&#x27;);</span><br></pre></td></tr></table></figure>
<p>这段语句意思是先从表Customers中选出contact为Jim Jones的人所在的公司名字，然后再从Customers表中选出该公司名字下的所有用户。<br>那么可以理解为两次引用了Customers表，相当于内容相同的两个Customers表，选择的依据是从第一个表中选择与第二个名具有相同cust_name的用户，并且要求第二表的cust_contact必须为Jim Jones。使用自联结实现为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT c1.cust_id, c1.cust_name, c1.cust_contact</span><br><span class="line">FROM Customers AS c1, Customers AS c2</span><br><span class="line">WHERE c1.cust_name = c2.cust_name</span><br><span class="line">AND c2.cust_contact = &#x27;Jim Jones&#x27;;</span><br></pre></td></tr></table></figure>

<h2 id="自然联结"><a href="#自然联结" class="headerlink" title="自然联结"></a>自然联结</h2><p>自然联结也就是说能够进行相关联的表，通常都会有一列的一一对应相同的，当对这些数组进行联结后统一输出，就会出现重复的列，可以通过限定条件之后，使用通配符一次输出所需要各表的所有列。如要输出购买RGAN01的所有顾客的所有信息，可以这样写：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT C.*, O.*, OI.* </span><br><span class="line">FROM Customers AS C, Orders AS O, OrderItems AS OI </span><br><span class="line">WHERE C.cust_id = O.cust_id  </span><br><span class="line">AND OI.order_num = O.order_num  </span><br><span class="line">AND prod_id = &#x27;RGAN01&#x27;;</span><br></pre></td></tr></table></figure>
<p>注意这些联结条件中列cust_id至少在两个表中相同，order_num也至少在两个表中相同，所以它们都分别分出现两次，可以通过将第一个使用通配符而后面的都直接使用确定的列避免，如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT C.*, O.order_num, O.order_date, OI.prod_id, OI.quantity, OI.item_price </span><br><span class="line">FROM Customers AS C, Orders AS O, OrderItems AS OI </span><br><span class="line">WHERE C.cust_id = O.cust_id  </span><br><span class="line">AND OI.order_num = O.order_num  </span><br><span class="line">AND prod_id = &#x27;RGAN01&#x27;;</span><br></pre></td></tr></table></figure>

<h2 id="外联结"><a href="#外联结" class="headerlink" title="外联结"></a>外联结</h2><p>1.一般的联结是将一个表中的行与另一个表中的行相关联，会忽略掉那些没有关联行的那些行，而外联结则可以包含所有行。<br>例如要检索所有顾客的订单，可以这样：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT Customers.cust_id, Orders.order_num </span><br><span class="line">FROM Customers </span><br><span class="line">INNER JOIN Orders </span><br><span class="line">ON Customers.cust_id = Orders.cust_id;</span><br></pre></td></tr></table></figure>
<p>这样检索的数据会忽略掉cust_id不相等的行，结果为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+------------+-----------+</span><br><span class="line">| cust_id    | order_num |</span><br><span class="line">+------------+-----------+</span><br><span class="line">| 1000000001 |     20005 |</span><br><span class="line">| 1000000001 |     20009 |</span><br><span class="line">| 1000000003 |     20006 |</span><br><span class="line">| 1000000004 |     20007 |</span><br><span class="line">| 1000000005 |     20008 |</span><br><span class="line">+------------+-----------+</span><br><span class="line">5 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>
<p>如果要包含Customers中cust_id与Orders中没有匹配的行，就需要使用外链接：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT Customers.cust_id, Orders.order_num </span><br><span class="line">FROM Customers </span><br><span class="line">LEFT OUTER JOIN Orders  </span><br><span class="line">ON Customers.cust_id = Orders.cust_id;</span><br></pre></td></tr></table></figure>
<p>结果为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+------------+-----------+</span><br><span class="line">| cust_id    | order_num |</span><br><span class="line">+------------+-----------+</span><br><span class="line">| 1000000001 |     20005 |</span><br><span class="line">| 1000000001 |     20009 |</span><br><span class="line">| 1000000002 |      NULL |</span><br><span class="line">| 1000000003 |     20006 |</span><br><span class="line">| 1000000004 |     20007 |</span><br><span class="line">| 1000000005 |     20008 |</span><br><span class="line">+------------+-----------+</span><br><span class="line">6 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>
<p>对于Customers中的cust_id来说1000000002无法与Orders中匹配，因为Orders中没有1000000002。此时就需要对Customers使用外链接。<br>2.外联结通过使用OUTER JOIN子句来完成，在使用OUTER JOIN语法时，必须使用RIGHT或LEFT关键字指定包括其所有行的表（RIGHT指出的是OUTER JOIN右边的表，而LEFT指出的是OUTER JOIN左边的表）。上面的例子使用LEFT OUTER JOIN从FROM子句左边的表（Customers表）中选择所有行。如果为了从右边的表中选择所有行，则需要使用RIGHT OUTER JOIN。当然很多DBMS也支持FULL OUTER JOIN，即同时包含左边和右边的表。</p>
<h2 id="使用带聚集函数的联结"><a href="#使用带聚集函数的联结" class="headerlink" title="使用带聚集函数的联结"></a>使用带聚集函数的联结</h2><p>聚集函数也可以与联结一起使用：<br>例如要检索所有顾客及每个顾客的下单数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT Customers.cust_id, COUNT(Orders.order_num) AS num_ord </span><br><span class="line">FROM Customers </span><br><span class="line">INNER JOIN Orders ON Customers.cust_id = Orders.cust_id </span><br><span class="line">GROUP BY Customers.cust_id;</span><br></pre></td></tr></table></figure>
<p>也可以使用外联结检索出没有下过单的用户：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT Customers.cust_id, COUNT(Orders.order_num) AS num_ord </span><br><span class="line">FROM Customers </span><br><span class="line">LEFT OUTER JOIN Orders ON Customers.cust_id = Orders.cust_id </span><br><span class="line">GROUP BY Customers.cust_id;</span><br></pre></td></tr></table></figure>

<h2 id="联结使用条件"><a href="#联结使用条件" class="headerlink" title="联结使用条件"></a>联结使用条件</h2><ul>
<li>注意所使用的联结类型。一般我们使用内联结，但使用外联结也有效。</li>
<li>关于确切的联结语法，应该查看具体的文档，看相应的DBMS支持何种语法（大多数DBMS使用这两课中描述的某种语法）。</li>
<li>保证使用正确的联结条件（不管采用哪种语法），否则会返回不正确的数据。</li>
<li>应该总是提供联结条件，否则会得出笛卡儿积。</li>
<li>在一个联结中可以包含多个表，甚至可以对每个联结采用不同的联结类型。虽然这样做是合法的，一般也很有用，但应该在一起测试它们前分别测试每个联结。这会使故障排除更为简单。</li>
</ul>
<h1 id="组合查询"><a href="#组合查询" class="headerlink" title="组合查询"></a>组合查询</h1><p>1.利用UNION操作符可以将多条SELECT语句组合成一个结果集，并将结果集返回，称为并（union）或复合查询（compound query），默认情况下UNION会将消除重复的行。UNION使用方法即直接将多条SELECT语句使用UNION连接起来即可。<br>如下这个使用WHERE子句实现的查询：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT cust_name, cust_contact, cust_email  </span><br><span class="line">FROM Customers </span><br><span class="line">WHERE cust_state IN (&#x27;IL&#x27;, &#x27;IN&#x27;, &#x27;MI&#x27;) OR cust_name = &#x27;Fun4ALL&#x27;</span><br><span class="line">ORDER BY cust_name, cust_contact;</span><br></pre></td></tr></table></figure>
<p>改成UNION查询为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT cust_name, cust_contact, cust_email  </span><br><span class="line">FROM Customers </span><br><span class="line">WHERE cust_state IN (&#x27;IL&#x27;, &#x27;IN&#x27;, &#x27;MI&#x27;) </span><br><span class="line">UNION  </span><br><span class="line">SELECT cust_name, cust_contact, cust_email  </span><br><span class="line">FROM Customers </span><br><span class="line">WHERE cust_name = &#x27;Fun4ALL&#x27; </span><br><span class="line">ORDER BY cust_name, cust_contact;</span><br></pre></td></tr></table></figure>
<p>注意只能有一个ORDER BY子句</p>
<p>2.UNION不仅可以用于对一个条的多次查询，也可以用于对不同表的查询。UNION使用有以下限制：</p>
<ul>
<li>UNION必须由两条或两条以上的SELECT语句组成，语句之间用关键字UNION分隔（因此，如果组合四条SELECT语句，将要使用三个UNION关键字）。</li>
<li>UNION中的每个查询必须包含相同的列、表达式或聚集函数（不过，各个列不需要以相同的次序列出）。</li>
<li>列数据类型必须兼容：类型不必完全相同，但必须是DBMS可以隐含转换的类型（例如，不同的数值类型或不同的日期类型）。</li>
</ul>
<h1 id="全文本搜索"><a href="#全文本搜索" class="headerlink" title="全文本搜索"></a>全文本搜索</h1><p>1.全文本搜索使得MySQL可以进行高级的数据查询和选择，可以快速地检索每一个词，比LIKE功能强大而且速度更快。然而并不是所有的数据库引擎都支持全文本搜索，MyISAM较早地支持了全文本搜索，而InnoDB引擎在MySQL 5.6之后才支持。而且全文本搜索无法支持像中文这种需要单独分词的语言。</p>
<p>2.为了进行全文本搜索，必须索引被搜索的列，而且要随着数据的改变不断地重新索引。在索引之后，SELECT可与Match()和Against()一起使用来进行实际的搜索。并且必须要对需要进行全文本搜索的列启动全文本搜索才能在后续对其建立索引。</p>
<p>3.一般在创建表时使用FULLTEXT子句对需要被索引的列增加全文索引功能，当需要索引多个列时，则使用逗号分隔。下面是一个创建表时增加全文本搜索的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE productnotes</span><br><span class="line">(</span><br><span class="line">    note_id    int           NOT NULL AUTO_INCREMENT,</span><br><span class="line">    prod_id    char(10)      NOT NULL,</span><br><span class="line">    note_date datetime       NOT NULL,</span><br><span class="line">    note_text  text          NULL ,</span><br><span class="line">    PRIMARY KEY(note_id),</span><br><span class="line">    FULLTEXT(note_text)     #对note_text列启用全文本搜索</span><br><span class="line">) ENGINE=MyISAM;</span><br></pre></td></tr></table></figure>
<p>在将某列定义为全文本搜索之后，MySQL将自动维护该索引。在增加、更新或删除行时，索引随之自动更新。可以在创建表时指定FULLTEXT，或在稍后指定（在这种情况下所有已有数据必须立即索引）。不要在导入数据时使用FULLTEXT，应该在导入之后再修改表，定义FULLTEXT，这样有助于更快导入数据，而且总是索引时间也会比每行导入都索引的总时间小。</p>
<p>4.使用两个函数Match()和Against()执行全文本搜索，其中Match()指定被搜索的列，Against()指定要使用的搜索表达式。<br>如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT note_text </span><br><span class="line">FROM productnotes </span><br><span class="line">WHERE MATCH(note_text) Against(&#x27;rabbit&#x27;);</span><br></pre></td></tr></table></figure>
<p>这个语句会对列note_text进行全文搜索，搜索内容是含有词rabbit的行，并返回搜索到的行。默认情况下全文本搜索不区分大小写<br>上面的语句与以下LIKE语句完成的功能相同</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT note_text </span><br><span class="line">FROM productnotes </span><br><span class="line">WHERE note_text LIKE &#x27;%rabbit%&#x27;;</span><br></pre></td></tr></table></figure>

<p>5.全文本搜索会对返回结果按等级排序，各行的等级确定方式是根据匹配的程序来定，等级由MySQL根据行中词的数目、唯一词的数目、整个索引中词的总数以及包含该词的行的数目计算出来。可以通过下SELECT语句来执行MATCH和AGAINST函数来查看各行等级，数值越大，等级越高：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT note_text, Match(note_text) Against(&#x27;rabbit&#x27;) AS rank </span><br><span class="line">FROM productnotes;</span><br></pre></td></tr></table></figure>
<p>6.可以通过在AGAINST()函数中添加WITH QUERY EXPANSION关键字来扩展查询结果。使用查询扩展时，MySQL会通过对数据和索引进行两遍扫描来完成搜索，第一遍扫描进行基本的全文本搜索，第二遍扫描根据匹配行中所有有用的词进行再次全文本搜索，最后返回所有结果。<br>如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT note_text</span><br><span class="line">FROM productnotes </span><br><span class="line">WHERE MATCH(note_text) Against(&#x27;anvils&#x27; WITH QUERY EXPANSION);</span><br></pre></td></tr></table></figure>
<p>如果不使用扩展查询，只能返回一行数据，因为只有一行中包含关键字anvils，而使用扩展搜索之后会返回多行。</p>
<p>7.MySQL也可以通过布尔方式（boolean mode）支持全文本搜索。布尔搜索不需要FULLTEXT索引也可以使用，这是一种非常缓慢的操作。布尔搜索支持以下操作：</p>
<ul>
<li>要匹配的词;</li>
<li>要排斥的词(如果某行包含这个词,则不返回该行,即使它包含其他指定的词也是如此);</li>
<li>排列提示(指定某些词比其他词更重要,更重要的词等级更高) ;</li>
<li>表达式分组;</li>
<li>另外一些内容</li>
</ul>
<p>一些布尔搜索的例子：<br>简单的布尔搜索，搜索note_text中含有heavy词的行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT note_text</span><br><span class="line">FROM productnotes</span><br><span class="line">WHERE Match(note_text) Against(&#x27;heavy&#x27; IN BOOLEAN MODE);</span><br></pre></td></tr></table></figure>
<p>匹配含有heavy但不包含任意以rope开始的词的行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT note_text</span><br><span class="line">FROM productnotes</span><br><span class="line">WHERE Match(note_text) Against(&#x27;heavy -rope*&#x27; IN BOOLEAN MODE);</span><br></pre></td></tr></table></figure>
<p>注意上面这个例子中，需要搜索的搜索串使用<code>-</code>进行排除和<code>*</code>进行匹配结尾。<br>全文本布尔操作符有以下这些：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+   包含,词必须存在</span><br><span class="line">+- 排除,词必须不出现</span><br><span class="line">&gt;  包含,而且增加等级值</span><br><span class="line">&gt;&lt;  包含,且减少等级值</span><br><span class="line">()  把词组成子表达式(允许这些子表达式作为一个组被包含、排除、排列等)</span><br><span class="line">~  取消一个词的排序值</span><br><span class="line">*  词尾的通配符</span><br><span class="line">*&quot;&quot;  定义一个短语(与单个词的列表不一样,它匹配整个短语以便包含或排除这个短语)</span><br></pre></td></tr></table></figure>
<p>一些布尔搜索串举例：<br><code>Against(&#39;+rabbit +bait&#39; IN BOOLEAN MODE)</code> 搜索匹配含词rabbit和bait的行<br><code>Against(&#39;rabbit bait&#39; IN BOOLEAN MODE)</code> 搜索匹配含rabbit和bait中至少一个词的行<br><code>Against(&#39;&quot;rabbit bait&quot;&#39; IN BOOLEAN MODE)</code> 搜索匹配短语rabbit bait而不是两个词<br><code>Against(&#39;+rabbit +(&lt;bait)&#39; IN BOOLEAN MODE)</code> 搜索匹配词rabbit和bait，降低后者的等级</p>
<p>8.全文搜索的一些说明：</p>
<ul>
<li>在索引全文本数据时,短词被忽略且从索引中排除。短词定义为那些具有3个或3个以下字符的词(如果需要,这个数目可以更改) 。</li>
<li>MySQL带有一个内建的非用词(stopword)列表,这些词在索引全文本数据时总是被忽略。如果需要,可以覆盖这个列表(请参阅MySQL文档以了解如何完成此工作) 。</li>
<li>许多词出现的频率很高,搜索它们没有用处(返回太多的结果)。因此,MySQL规定了一条50%规则,如果一个词出现在50%以上 的行中,则将它作为一个非用词忽略。 50%规则不用于 IN BOOLEAN MODE 。</li>
<li>如果表中的行数少于3行,则全文本搜索不返回结果(因为每个词或者不出现,或者至少出现在50%的行中)。</li>
<li>忽略词中的单引号。例如, don’t 索引为 dont 。</li>
<li>不具有词分隔符(包括日语和汉语)的语言不能恰当地返回全文本搜索结果。</li>
<li>并不是所有数据库引擎都支持全文搜索</li>
</ul>
<h1 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h1><p>1.SQL使用INSERT（或INSERT INTO）来向表中插入数据，在不与SELECT配合的情况下一次只能插入一行数据，可以插入完整行（即所有列都有的行），也可以插入部分行（即省略有些列的插入）插入完整行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO Customers </span><br><span class="line">VALUES(&#x27;10000007&#x27;, </span><br><span class="line">&#x27;Toy land&#x27;, </span><br><span class="line">&#x27;123 Any Street&#x27;, </span><br><span class="line">&#x27;New York&#x27;, </span><br><span class="line">&#x27;NY&#x27;, </span><br><span class="line">&#x27;1111&#x27;, </span><br><span class="line">&#x27;USA&#x27;, </span><br><span class="line">NULL, </span><br><span class="line">NULL);</span><br></pre></td></tr></table></figure>
<p>注意，像上面这样不指定列名插入数据时，必须每一列数据都与原表中的列一一对应，不能少，也不能错列，其中INTO关键字在很多DBMS中可以省略。<br>或者像下面这样指定要插入的列，只插入一部分数据，有些数据使用表设置的默认值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO Customers(cust_name,</span><br><span class="line">cust_id,</span><br><span class="line">cust_city,</span><br><span class="line">cust_address,</span><br><span class="line">cust_state,</span><br><span class="line">cust_zip,</span><br><span class="line">cust_country)</span><br><span class="line">VALUES(&#x27;Toy land&#x27;, </span><br><span class="line">&#x27;10000009&#x27;, </span><br><span class="line">&#x27;New York&#x27;, </span><br><span class="line">&#x27;123 Any Street&#x27;, </span><br><span class="line">&#x27;NY&#x27;, </span><br><span class="line">&#x27;1111&#x27;, </span><br><span class="line">&#x27;USA&#x27;);</span><br></pre></td></tr></table></figure>
<p>注意此时有些列并没有给出，因为表中设置了默认值，所以会自动插入默认值。而且列值的顺序也与原表中的列在顺序上不是一一对应，而是通过指定列名进行插入，但指定的列名顺序必须与下面要插入的值一一对应。<br>2.省略的列必须满足以下条件：</p>
<ul>
<li>该列定义为允许NULL值（无值或空值）。</li>
<li>在表定义中给出默认值。这表示如果不给出值，将使用默认值。</li>
</ul>
<p>对于有些列被设置为自动增量，在插入时如果没有指定限定列，而必须在值相应的位置使用NULL，这样MySQL会在插入时自动填入合适的增量值。对于指定限定列的情况下，可以忽略，增量值会被自动填入。</p>
<p>2.这样的INSERT语句一次只能插入一行，要插入多行必须使用多个INSERT语句，多条INSERT语句使用分号分隔后一次提交即可。但可以有效率更高的方式，如下所示一次插入多行，只需要列名和次序相同，各组值之间使用逗号分隔即可：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO Customers(cust_id,</span><br><span class="line">                      cust_contact,</span><br><span class="line">                      cust_email,</span><br><span class="line">                      cust_name)</span><br><span class="line">               VALUES(&#x27;10000009&#x27;, </span><br><span class="line">                      &#x27;Toy land&#x27;,</span><br><span class="line">                      &#x27;sfasa@qq.com&#x27;, </span><br><span class="line">                      &#x27;blueyi&#x27;</span><br><span class="line">                     ),</span><br><span class="line">                     (&#x27;100000011&#x27;, </span><br><span class="line">                      &#x27;Land&#x27;,</span><br><span class="line">                      &#x27;ddaa@qq.com&#x27;, </span><br><span class="line">                      &#x27;maxwi&#x27;</span><br><span class="line">                     );</span><br></pre></td></tr></table></figure>

<p>下面这种与SELECT配合使用的时候可以批量插入数据<br>3.使用INSERT…SELECT从一个表检索数据并插入另一个，当然也可以是同一个表，但主键不能重复，这种方式一次可以插入多行。如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO Customers(cust_id,</span><br><span class="line">                      cust_contact,</span><br><span class="line">                      cust_email,</span><br><span class="line">                      cust_name,</span><br><span class="line">                      cust_address,</span><br><span class="line">                      cust_city,</span><br><span class="line">                      cust_state,</span><br><span class="line">                      cust_zip,</span><br><span class="line">                      cust_country)</span><br><span class="line">SELECT cust_id,</span><br><span class="line">       cust_contact,</span><br><span class="line">       cust_email,</span><br><span class="line">       cust_name,</span><br><span class="line">       cust_address,</span><br><span class="line">       cust_city,</span><br><span class="line">       cust_state,</span><br><span class="line">       cust_zip,</span><br><span class="line">       cust_country</span><br><span class="line">FROM CustNew;</span><br></pre></td></tr></table></figure>
<p>使用这种方式插入时，并不要求前后列名都一致，只要数据可以匹配即可。实际上DBMS并不是根据SELECT列名进行获取数据插入，而是使用列的位置，但INSERT中的列名必须是已经存入于Customers，当然也不需要顺序与原表中的列完全一致。</p>
<p>4.从一个表复制数据到另一表的语句是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE CustCopy AS</span><br><span class="line">SELECT *</span><br><span class="line">FROM Customers;</span><br></pre></td></tr></table></figure>
<p>创建名为CustCopy的表，并从Customers中复制所有数据到该表。<br>有些DBMS的该语句是<code>SELECT * INTO CustCopy FROM Customers;</code></p>
<p>5.SELECT INTO支持以下操作：</p>
<ul>
<li>任何SELECT选项和子句都可以使用，包括WHERE和GROUP BY；</li>
<li>可利用联结从多个表插入数据；</li>
<li>不管从多少个表中检索数据，数据都只能插入到一个表中</li>
</ul>
<p>6.为了提供性能，如果对数据检索是最重要的，可以通过在INSERT和INTO之间添加关键字LOW_PRIORITY指示MySQL降低INSERT语句的优先级。如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT LOW_PRIORITY INTO</span><br></pre></td></tr></table></figure>
<p>这种方式也同时适用于UPDATE和DELETE语句。</p>
<h1 id="更新和删除数据"><a href="#更新和删除数据" class="headerlink" title="更新和删除数据"></a>更新和删除数据</h1><h2 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a>更新数据</h2><p>1.使用UPDATE…SET…语句更新数据，UPDATE语句即可用于更新表中的特定行，也可以更新表中的所有行。<br>指定WHERE子句即可限定只更新特定行，当省略WHERE子句时，即直接更新所有行，所以要慎重省略WHERE。<br>UPDATE语句由三部分组成：</p>
<ul>
<li>要更新的表；</li>
<li>列名和它们的新值；</li>
<li>确定要更新哪些行的过滤条件</li>
</ul>
<p>需要更新某一行的多个列时，只需要将不同的“列=值”对之间用逗号分隔（最后一列之后不用逗号）。<br>如设置某个cust_id的联系方式和邮箱：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UPDATE Customers</span><br><span class="line">SET cust_contact = &#x27;Blueyi&#x27;,</span><br><span class="line">cust_email = &#x27;hello@gmail.com&#x27;</span><br><span class="line">WHERE cust_id = &#x27;10000000006&#x27;;</span><br></pre></td></tr></table></figure>
<p>当省略上述的WHERE之句时，所有cust_contact列和cust_email列都将被更新。</p>
<p>2.UPDATE语句中可以使用子查询，使得能用SELECT语句检索出的数据更新列数据。也可以使用FROM子句，用一个表的数据更新另一表的数据，详见各DBMS说明。</p>
<p>3.要删除某列的值，可以设置它为NULL（假定表定义允许NULL值）</p>
<p>4.如果用UPDATE语句更新多行时，当其中一行或多行出现一个错误，整个UPDATE操作都会被取消，为使发生错误后继续进行更新，可使用IGNORE关键字：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UPDATE IGNORE Customers...</span><br></pre></td></tr></table></figure>


<h2 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h2><p>1.使用DELETE FROM语句删除表（FROM关键字在有些DBMS中可以省略），即可使用DELETE删除特定的行，也可以删除所有行。<br>同样是使用WHERE子句来限定删除特定的行，否则会删除所有行。<br>如删除某个ID的行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELETE FROM Customers</span><br><span class="line">WHERE cust_id = &#x27;1000000006&#x27;;</span><br></pre></td></tr></table></figure>
<p>2.当使用DELETE语句从表中删除所有行时，DELETE不删除表本身，删除的只是行。如果要删除所有行，可以使用<code>TRUNCATE TABLE CustCopy;</code>，而不是使用<code>DELETE FROM CustCopy;</code> ，因为前者速度更快（因为它不记录数据的变动）。</p>
<p>3.DBMS通常会使用外键来严格定义表相互之间的关系，当存在外键时，DBMS为了使用它们实施引用的完整性，通常不允许删除某个关系需要用到的行。</p>
<p>4.下面是许多SQL程序员使用UPDATE或DELETE时所遵循的重要原则。</p>
<ul>
<li>除非确实打算更新和删除每一行，否则绝对不要使用不带WHERE子句的UPDATE或DELETE语句。</li>
<li>保证每个表都有主键，尽可能像WHERE子句那样使用它（可以指定各主键、多个值或值的范围）。</li>
<li>在UPDATE或DELETE语句使用WHERE子句前，应该先用SELECT进行测试，保证它过滤的是正确的记录，以防编写的WHERE子句不正确。</li>
<li>使用强制实施引用完整性的数据库，这样DBMS将不允许删除其数据与其他表相关联的行。</li>
<li>有的DBMS允许数据库管理员施加约束，防止执行不带WHERE子句的UPDATE或DELETE语句。如果所采用的DBMS支持这个特性，应该使用它。</li>
</ul>
<h2 id="复制表的两种方式"><a href="#复制表的两种方式" class="headerlink" title="复制表的两种方式"></a>复制表的两种方式</h2><p>1.当已经存在表时，使用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO CustCopy    #CustCopy表已经存储，里面没有数据，当然也可以有数据，但主键不能重复</span><br><span class="line">SELECT *</span><br><span class="line">FROM Customers;</span><br></pre></td></tr></table></figure>
<p>2.当表不存在时，使用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE CustCopy3 AS   #AS可以被省略</span><br><span class="line">SELECT * </span><br><span class="line">FROM Customers;</span><br></pre></td></tr></table></figure>

<h2 id="清空表的两种方式"><a href="#清空表的两种方式" class="headerlink" title="清空表的两种方式"></a>清空表的两种方式</h2><ul>
<li><code>DELETE FROM CustCopy;</code></li>
<li><code>TRUNCATE TABLE CustCopy;</code></li>
</ul>
<h2 id="清空数据库"><a href="#清空数据库" class="headerlink" title="清空数据库"></a>清空数据库</h2><p>删除数据库中的所有表，而不删除数据库本身，注意，不是删除数据库中表的数据，而是对数据库中的所有表执行<code>DROP TABLE &lt;表名&gt;</code>操作：<br>首先使用以下语句获取到数据库中的所有表的删除语句，然后批量执行该删除语句即可：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT CONCAT(&#x27;drop table &#x27;, table_name, &#x27;;&#x27;) FROM information_schema.`TABLES` WHERE table_schema=&#x27;数据库名&#x27;;</span><br></pre></td></tr></table></figure>

<h1 id="创建和操纵表"><a href="#创建和操纵表" class="headerlink" title="创建和操纵表"></a>创建和操纵表</h1><h2 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h2><p>1.使用CREATE TABLE创建表，创建表时必须给出下列信息：</p>
<ul>
<li>新表的名字，在关键字CREATE TABLE之后给出；</li>
<li>表列的名字和定义，用逗号分隔；</li>
<li>有的DBMS还要求指定表的位置。</li>
</ul>
<p>如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE customers</span><br><span class="line">(</span><br><span class="line">    cust_id      int       NOT NULL AUTO_INCREMENT,</span><br><span class="line">    cust_name    char(50)  NOT NULL ,</span><br><span class="line">    cust_address char(50)  NULL ,</span><br><span class="line">    cust_city    char(50)  NULL ,</span><br><span class="line">    cust_state   char(5)   NULL ,</span><br><span class="line">    cust_zip     char(10)  NULL ,</span><br><span class="line">    cust_country char(50)  NULL ,</span><br><span class="line">    cust_contact char(50)  NULL ,</span><br><span class="line">    cust_email   char(255) NULL ,</span><br><span class="line">    PRIMARY KEY (cust_id)</span><br><span class="line">) ENGINE=InnoDB;</span><br></pre></td></tr></table></figure>
<p>从上面的例子可以看到，表名紧跟CREATE TABLE关键字。实际的表定义（所有列）括在圆括号之中，各列之间用逗号分隔。这个表由9列组成。每列的定义以列名（它在表中必须是唯一的）开始，后跟列的数据类型。整条语句以圆括号后的分号结束。表的主键可以在创建表时使用PRIMARY KEY关键字指定。这里，列cust_id指定作为主键列。<br>可以在表名后面添加关键字IF NOT EXISTS来指定只在一个表不存在时创建它。</p>
<p>2.查看表都有哪些列：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DESCRIBE Products;</span><br></pre></td></tr></table></figure>
<p>如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; DESCRIBE Products;</span><br><span class="line">+------------+--------------+------+-----+---------+-------+</span><br><span class="line">| Field      | Type         | Null | Key | Default | Extra |</span><br><span class="line">+------------+--------------+------+-----+---------+-------+</span><br><span class="line">| prod_id    | char(10)     | NO   |     | NULL    |       |</span><br><span class="line">| vend_id    | char(10)     | NO   |     | NULL    |       |</span><br><span class="line">| prod_name  | char(254)    | NO   |     | NULL    |       |</span><br><span class="line">| prod_price | decimal(8,2) | NO   |     | NULL    |       |</span><br><span class="line">| prod_desc  | text         | YES  |     | NULL    |       |</span><br><span class="line">+------------+--------------+------+-----+---------+-------+</span><br><span class="line">5 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>3.关于NULL值，就是是否允许该列在插入时不给出该列的值，不允许NULL值的列不接受没有列值的行。当不指名是否为NULL时，默认为允许NULL值。主键是唯一标识表中每一行的列，所以允许NULL值的列不能作为主键列。</p>
<p>3.主键值必须唯一，主键可以使用单个列，也可以使用多列，如果使用多个列，则这些列的组合值必须唯一（也就是说单个列可以不唯一）。将多个列作为主键时，各列之间使用逗号分隔：<code>PRIMARY KEY(order_num, order_item)</code></p>
<p>4.AUTO_INCREMENT即是用来设置插入某些列时的自动增量值，每个表只允许一个AUTO_INCREMENT列，而且它必须被索引（如，通过使它成为主键）。被设置为AUTO_INCREMENT列也可以在插入时手动指定个值，只要该值唯一即可，后续的增量将开始使用该手工插入的值为基础值。可以使用函数last_insert_id()耿获取最后一个AUTO_INCREMENT值，如<code>SELECT last_insert_id();</code></p>
<p>4.可以在创建表时使用DEFAULT关键字指定默认值。如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE OrderItems </span><br><span class="line">(</span><br><span class="line">order_num      INTEGER          NOT NULL,</span><br><span class="line">order_item     INTEGER          NOT NULL,</span><br><span class="line">prod_id        CHAR(10)         NOT NULL,</span><br><span class="line">quantity       INTEGER          NOT NULL      DEFAULT 1,</span><br><span class="line">item_price     DECIMAL(8,2)     ,    #默认为允许NULL</span><br><span class="line">item_desc    text(1000)  #默认为允许NULL</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>上面的创建结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; DESCRIBE OrderItems;</span><br><span class="line">+------------+--------------+------+-----+---------+-------+</span><br><span class="line">| Field      | Type         | Null | Key | Default | Extra |</span><br><span class="line">+------------+--------------+------+-----+---------+-------+</span><br><span class="line">| order_num  | int(11)      | NO   |     | NULL    |       |</span><br><span class="line">| order_item | int(11)      | NO   |     | NULL    |       |</span><br><span class="line">| prod_id    | char(10)     | NO   |     | NULL    |       |</span><br><span class="line">| quantity   | int(11)      | NO   |     | 1       |       |</span><br><span class="line">| item_price | decimal(8,2) | YES  |     | NULL    |       |</span><br><span class="line">| item_desc  | text         | YES  |     | NULL    |       |</span><br><span class="line">+------------+--------------+------+-----+---------+-------+</span><br><span class="line">6 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>
<p>MySQL允许使用<code>DEFAULT CURRENT_DATE()</code>将当前时间设定为默认值</p>
<p>5.为已存储在列添加默认值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alter table表名alter column字段名drop default; (若本身存在默认值，则先删除)</span><br><span class="line">alter table表名 alter column 字段名 set default默认值;(若本身不存在则可以直接设定)</span><br></pre></td></tr></table></figure>
<p>如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE user ALTER COLUMN theme SET DEFAULT &#x27;material&#x27;;</span><br></pre></td></tr></table></figure>

<h2 id="更改或删除表"><a href="#更改或删除表" class="headerlink" title="更改或删除表"></a>更改或删除表</h2><p>5.使用ALTER关键字更改表结构，必须给出如下信息：</p>
<ul>
<li>在ALTER TABLE之后给出要更改的表名（该表必须存在，否则将出错）；</li>
<li>列出要做哪些更改。<br>如：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE OrderItems</span><br><span class="line">ADD isbn CHAR(20);  #增加列</span><br><span class="line"></span><br><span class="line">ALTER TABLE OrderItems</span><br><span class="line">DROP COLUMN isbn;   #删除列</span><br></pre></td></tr></table></figure>
ALTER TABLE一种常见的用途是定义外键：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE orderitems</span><br><span class="line">ADD CONSTRAINT fk_orderitems_orders</span><br><span class="line">FOREIGN KEY (order_num) REFERENCES orders (order_num);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>6.删除表使用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DROP TABLE CustCopy;</span><br></pre></td></tr></table></figure>

<p>7.重命名表：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">RENAME TABLE OrderItems TO NewOrder;</span><br></pre></td></tr></table></figure>
<p>也可以一次重命名多个表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">RENAME TABLE OrderItems1 TO NewOrder1,</span><br><span class="line">             OrderItems2 TO NewOrder2,</span><br><span class="line">             OrderItems2 TO NewOrder2;</span><br></pre></td></tr></table></figure>

<p>8.重命名列：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE OrderItems</span><br><span class="line">CHANGE isbn Isbn CHAR(20)</span><br></pre></td></tr></table></figure>

<p>9.改变列的类型及是否为NULL：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE OrderItems</span><br><span class="line">CHANGE isbn Isbn INTEGER not NULL; #更改为不允许为null的integer</span><br><span class="line"></span><br><span class="line">ALTER TABLE OrderItems</span><br><span class="line">CHANGE isbn Isbn FLOAT NULL; 更改isbn列名字为Isbn，且值为可NULL的float</span><br></pre></td></tr></table></figure>


<p>8.复杂的表结构更改一般需要手动删除过程，它涉及以下步骤：</p>
<ul>
<li>用新的列布局创建一个新表；</li>
<li>使用INSERT SELECT语句（关于这条语句的详细介绍，请参阅第15课）从旧表复制数据到新表。有必要的话，可以使用转换函数和计算字段；</li>
<li>检验包含所需数据的新表；</li>
<li>重命名旧表（如果确定，可以删除它）；</li>
<li>用旧表原来的名字重命名新表；</li>
<li>根据需要，重新创建触发器、存储过程、索引和外键。</li>
</ul>
<p>9.创建表时可以在最后面使用ENGINE=来指定需要的引擎类型，如果不指定，MySQL会使用默认引擎。与其他DBMS一样，MySQL有一个具体管理和处理数据的内部引擎。在使用CREATE TABLE语句时，该引擎具体创建表，同样，在使用SELECT等语句操作数据库时，都是该引擎在内部处理请求。MySQL具有多个引擎，不同的引擎具有不同的功能和特性。主要有以下几个：</p>
<ul>
<li>InnoDB是一个可靠的事务处理引擎</li>
<li>MEMORY在功能上等同于MyISAM，但由于数据存储在内存（不是磁盘）中，速度很快（特别适合于临时表）</li>
<li>MyISAM是一个性能极高的引擎，但不支持事务处理</li>
</ul>
<p>引擎类型可以混合使用，但外键不能跨引擎。</p>
<h1 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h1><p>1.视图是虚拟的表，它们包含的不是数据而是根据需要检索数据的查询。视图提供了一种封装SELECT语句的层次，可以用来简化数据处理，重新格式化或保护基础数据。视图创建完之后，使用起来就像使用表一样，但实际上它每次都要重新进行查询，所以大量的视图可能会影响性能。视图可以理解为一种动态的表，相当于临时用，临时创建，可以大大减化复杂而且需要重复使用的查询过程。</p>
<p>2.使用CREATE VIEW创建视图，类似于CREATE TABLE一样，只能用于创建不存在的视图，当然也可以使用DROP VIEW viewname;删除视图。<br>以上文中选择所有购买了RGAN01产品的顾客信息为例，假如经常需要检索出购买某种产品的所有顾客信息，而这些信息又在多个表中，每次检索都需要输入相同的SELECT和WHERE限定条件，那么可以创建一个这些公共部分的视图，相当于创建一个包含我们所需要的所有顾客的信息列组成的虚拟表。以后在需要检索哪个产品时，就从这个虚拟表检索即可。过程如下：<br>创建视图：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE VIEW ProductCustomers AS</span><br><span class="line">SELECT cust_name, cust_contact, prod_id</span><br><span class="line">FROM Customers, Orders, OrderItems</span><br><span class="line">WHERE Customers.cust_id = Orders.cust_id</span><br><span class="line">AND OrderItems.order_num = Orders.order_num;</span><br></pre></td></tr></table></figure>
<p>查看现在都有哪个表：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SHOW TABLES;</span><br><span class="line">+----------------------+</span><br><span class="line">| Tables_in_mysql_test |</span><br><span class="line">+----------------------+</span><br><span class="line">| Customers            |</span><br><span class="line">| OrderItems           |</span><br><span class="line">| Orders               |</span><br><span class="line">| ProductCustomers     |</span><br><span class="line">| Products             |</span><br><span class="line">| Vendors              |</span><br><span class="line">+----------------------+</span><br><span class="line">10 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>
<p>可以看到多了一个刚刚创建的视图虚拟表，<br>查看已创建的视图ProductCustomers的信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM ProductCustomers;</span><br><span class="line">+---------------+--------------------+---------+</span><br><span class="line">| cust_name     | cust_contact       | prod_id |</span><br><span class="line">+---------------+--------------------+---------+</span><br><span class="line">| Village Toys  | John Smith         | BR01    |</span><br><span class="line">| Village Toys  | John Smith         | BR03    |</span><br><span class="line">| Village Toys  | John Smith         | BNBG01  |</span><br><span class="line">| Village Toys  | John Smith         | BNBG02  |</span><br><span class="line">| Village Toys  | John Smith         | BNBG03  |</span><br><span class="line">| Fun4All       | Jim Jones          | BR01    |</span><br><span class="line">| Fun4All       | Jim Jones          | BR02    |</span><br><span class="line">| Fun4All       | Jim Jones          | BR03    |</span><br><span class="line">| Fun4All       | Denise L. Stephens | BR03    |</span><br><span class="line">| Fun4All       | Denise L. Stephens | BNBG01  |</span><br><span class="line">| Fun4All       | Denise L. Stephens | BNBG02  |</span><br><span class="line">| Fun4All       | Denise L. Stephens | BNBG03  |</span><br><span class="line">| Fun4All       | Denise L. Stephens | RGAN01  |</span><br><span class="line">| The Toy Store | Kim Howard         | RGAN01  |</span><br><span class="line">| The Toy Store | Kim Howard         | BR03    |</span><br><span class="line">| The Toy Store | Kim Howard         | BNBG01  |</span><br><span class="line">| The Toy Store | Kim Howard         | BNBG02  |</span><br><span class="line">| The Toy Store | Kim Howard         | BNBG03  |</span><br><span class="line">+---------------+--------------------+---------+</span><br><span class="line">18 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>
<p>现在在视图上检索购买了RGAN01的所有顾客：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT cust_name, cust_contact</span><br><span class="line">FROM ProductCustomers</span><br><span class="line">WHERE prod_id = &#x27;RGAN01&#x27;;</span><br></pre></td></tr></table></figure>
<p>当然，此时需要检索其他产品，也直接在这个视图上即可，就不需要每次都去输入那些联结表的信息了。</p>
<p>3.视图的操作：</p>
<ul>
<li>视图用 CREATE VIEW 语句来创建。</li>
<li>使用 SHOW CREATE VIEW viewname;来查看创建视图的语句。</li>
<li>用 DROP 删除视图,其语法为 DROP VIEW viewname;。</li>
<li>更新视图时,可以先用DROP再用CREATE,也可以直接用CREATE OR REPLACE VIEW。如果要更新的视图不存在,则第 2 条更新语句会创建一个视图;如果要更新的视图存在,则第 2 条更新语句会替换原有视图。</li>
</ul>
<p>3.利用视图可以为任意检索出的新数据创建一个虚拟表，以便后续使用。<br>3.1例如之前检索过需要的格式化数据，使用视图可以这样：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE VIEW VendorLocations AS </span><br><span class="line">SELECT CONCAT(RTRIM(vend_name), &#x27; (&#x27;, RTRIM(vend_country), &#x27;)&#x27;)  AS vend_title </span><br><span class="line">FROM Vendors;</span><br></pre></td></tr></table></figure>
<p>以后再使用时，直接</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT *</span><br><span class="line">FROM VendorLocations;</span><br></pre></td></tr></table></figure>
<p>即可<br>3.2使用视图过滤数据：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE VIEW CustomerEMailList AS</span><br><span class="line">SELECT cust_id, cust_name, cust_email</span><br><span class="line">FROM Customers</span><br><span class="line">WHERE cust_email IS NOT NULL;</span><br></pre></td></tr></table></figure>
<p>3.3创建含有计算字段的视图：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE VIEW OrderItemsExpanded AS</span><br><span class="line">SELECT order_num,</span><br><span class="line">prod_id,</span><br><span class="line">quantity,</span><br><span class="line">item_price,</span><br><span class="line">quantity*item_price AS expanded_price</span><br><span class="line">FROM OrderItems;</span><br></pre></td></tr></table></figure>
<p>视图通常是可更新的，如果你对视图增加或删除行,实际上是对其基表增加或删除行。</p>
<h1 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h1><p>1.存储过程就是为以后的使用而保存的一条或多条MySQL语句的集合，可将其视为针对MySQL的批处理，其实类似于编程语言中的函数。使用存储过程的好处：简单、安全、高性能。</p>
<h2 id="创建存储过程"><a href="#创建存储过程" class="headerlink" title="创建存储过程"></a>创建存储过程</h2><p>存储过程的使用方法为先使用CREATE PROCEDURE创建存储过程，然后使用CALL来调用创建的存储过程名。需要注意的是默认的MySQL语句分隔符为;（也就是当编辑多条MySQL语句时，需要使用分号分隔），但mysql命令行实用程序（也就是我们这里使用的mysql命令行程序）也使用;作为命令结束的分隔符（也就是mysql命令行程序在遇到分号时就开始对之前的语句进行解析）。这样就会导致在编写存储过程时，存储过程内的MySQL语句分隔符，会被mysql程序当成一句已经结束了，而进行解析。为解决这个问题，可以使用DELIMITER关键字临时更改命令行实用程序的语句分隔符。如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELIMITER //  #更改mysql程序的语句分隔符为//</span><br><span class="line">CREATE PROCEDURE productpricing()   #创建名为productpricing的过程</span><br><span class="line">BEGIN  </span><br><span class="line">  SELECT Avg(prod_price) AS price_average </span><br><span class="line">  FROM Products; </span><br><span class="line">END //</span><br><span class="line">DELIMITER ;   #再改回来，以方便后续继续使用;作为mysql的命令行程序的语句分隔符</span><br></pre></td></tr></table></figure>
<p>除了\符号外，任何字符都可以作为语句分隔符。<br>上面的语句创建了一个名为productpricing的存储过程，注意存储过程名后面需要有()，其实就相当于函数，可以有参数放在()之间，当然这里没有参数，然后存储过程体放在BEGIN和END之间。<br>调用存储过程：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; CALL productpricing();</span><br><span class="line">+---------------+</span><br><span class="line">| price_average |</span><br><span class="line">+---------------+</span><br><span class="line">|      6.823333 |</span><br><span class="line">+---------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br></pre></td></tr></table></figure>
<p>与函数不同的是需要使用CALL来调用存储过程，而不能使用SELECT。<br>由于这个存储过程中有SELECT语句，所以会直接显示出结果。</p>
<h2 id="查看存储过程"><a href="#查看存储过程" class="headerlink" title="查看存储过程"></a>查看存储过程</h2><p>1.显示某个存储过程的详细信息，包括存储过程语句：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW CREATE PROCEDURE productpricing;</span><br></pre></td></tr></table></figure>
<p>2.显示系统中的所有存储过程：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW PROCEDURE STATUS;</span><br></pre></td></tr></table></figure>

<p>3.可以使用LIKE指定过滤模式，如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW PROCEDURE STATUS LIKE &#x27;ordertotal&#x27;;</span><br></pre></td></tr></table></figure>

<h2 id="删除存储过程"><a href="#删除存储过程" class="headerlink" title="删除存储过程"></a>删除存储过程</h2><p>使用DROP PROCEDURE语句删除存储过程，存储过程一旦创建之后，在删除之前一直存储于系统之中。存储过程创建之后不能再创建与之同名的存储过程，只能先将其删除，再重新创建。如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DROP PROCEDURE productpricing;  #如果不存在，会报错</span><br><span class="line">DROP PROCEDURE IF EXISTS productpricing;   #只在存在时删除，不存在也不产生错误</span><br></pre></td></tr></table></figure>
<p>删除名为productpricing的存储过程，注意这里存储过程的后面不需要有()</p>
<h2 id="使用参数"><a href="#使用参数" class="headerlink" title="使用参数"></a>使用参数</h2><p>1.一般存储过程不显示结果，而是将结果返回给指定的变量（variable），用来临时存储数据。如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELIMITER //  #更改mysql程序的语句分隔符为//</span><br><span class="line">CREATE PROCEDURE productpricing(</span><br><span class="line">    OUT pl DECIMAL(8,2),</span><br><span class="line">    OUT ph DECIMAL(8,2),</span><br><span class="line">    OUT pa DECIMAL(8,2)</span><br><span class="line">)</span><br><span class="line">BEGIN</span><br><span class="line">    SELECT Min(prod_price)</span><br><span class="line">    INTO pl</span><br><span class="line">    FROM Products;</span><br><span class="line"></span><br><span class="line">    SELECT MAX(prod_price)</span><br><span class="line">    INTO ph</span><br><span class="line">    FROM Products;</span><br><span class="line"></span><br><span class="line">    SELECT Avg(prod_price)</span><br><span class="line">    INTO pa</span><br><span class="line">    FROM Products;</span><br><span class="line">END //</span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure>
<p>此存储过程接受3个参数：pl存储最低价，ph存储最高价，pa存储平均价，这三个参数相当于形参。每个参数都必须具有指定的类型，这里使用的是十进制值。关键字OUT指出相应的参数用来从存储过程传出一个值（返回给调用者）。MySQL支持IN（传递给存储过程）、OUT（从存储过程付出）和INOUT（对存储过程传入和付出）三种类型的参数。通过INTO关键字将检索到的相应数据存储到指定的变量而不是显示。<br>2.调用些存储过程必须传递给他们3个参数，不多也不能少，当然传递进去的参数并不需要提前声明。所有MySQL变量都必须以@开始，当然在存储过程中使用的不需要。如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CALL productpricing(@pricelow,</span><br><span class="line">                    @pricehigh,</span><br><span class="line">                    @priceaverage);</span><br></pre></td></tr></table></figure>
<p>3.显示这些参数值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT @pricehigh, @pricelow, @priceaverage;</span><br><span class="line">+------------+-----------+---------------+</span><br><span class="line">| @pricehigh | @pricelow | @priceaverage |</span><br><span class="line">+------------+-----------+---------------+</span><br><span class="line">|      11.99 |      3.49 |          6.82 |</span><br><span class="line">+------------+-----------+---------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>4.以下这个例子创建一个存储过程，当调用该存储过程时自动显示相应订单号的总价格：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELIMITER //  #更改mysql程序的语句分隔符为//</span><br><span class="line">CREATE PROCEDURE ordertotal(</span><br><span class="line">  IN onumber INT,   #用于传递需要查看订单价格的订单号</span><br><span class="line">  OUT ototal DECIMAL(8,2)   #存储总价格</span><br><span class="line">)</span><br><span class="line">BEGIN</span><br><span class="line">  SELECT Sum(item_price * quantity)</span><br><span class="line">  FROM OrderItems</span><br><span class="line">  WHERE order_num = onumber;</span><br><span class="line">  INTO ototal   #注意这个例子里面INTO语句放在了FROM之句的后面，当然也可以放在FROM之句之前</span><br><span class="line">END //</span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure>
<p>调用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CALL ordertotal(20009, @total);</span><br><span class="line">mysql&gt; SELECT @total;</span><br><span class="line">+---------+</span><br><span class="line">| @total  |</span><br><span class="line">+---------+</span><br><span class="line">| 1867.50 |</span><br><span class="line">+---------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<h2 id="建立存储过程："><a href="#建立存储过程：" class="headerlink" title="建立存储过程："></a>建立存储过程：</h2><p>存储过程可以很复杂，可以包含像函数一样的内总计算，并在编写存储过程是使用注释（前面放置– 或#），使用DECLARE语句定义局部变量，使用IF..THEN..ELSEIF..ELSE等语句进行流程控制，也可以COMMENT关键字添加备注信息，以便使用SHOW PROCEDURE STATUS来查看。<br>下面是一个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELIMITER //</span><br><span class="line">-- Name: ordertotal</span><br><span class="line">-- Parameters:  onumber = order number</span><br><span class="line">--              taxable = 0 if not taxable, 1 if taxable</span><br><span class="line">--              ototal = order total variable</span><br><span class="line">CREATE PROCEDURE ordertotal(</span><br><span class="line">  IN onumber INT,</span><br><span class="line">  IN taxable BOOLEAN,</span><br><span class="line">  OUT ototal DECIMAL(8,2)  </span><br><span class="line">) COMMENT &#x27;Obtain order total, optionally adding tax&#x27;</span><br><span class="line">BEGIN</span><br><span class="line">  -- Declare variable for total</span><br><span class="line">  DECLARE total DECIMAL(8, 2);   #声明时需要指定类型</span><br><span class="line">  -- Declare tax percentage</span><br><span class="line">  DECLARE taxrate INT DEFAULT 6;   #声明时指定默认值</span><br><span class="line">  -- Get the order total</span><br><span class="line">  SELECT Sum(item_price * quantity)</span><br><span class="line">  FROM OrderItems </span><br><span class="line">  WHERE order_num = onumber</span><br><span class="line">  INTO total;</span><br><span class="line">  -- Is this taxable?</span><br><span class="line">  IF taxable THEN </span><br><span class="line">    -- Yes, so add taxrate to the total</span><br><span class="line">    SELECT total + (total / 100 * taxrate) INTO TOTAL;</span><br><span class="line">  END IF;</span><br><span class="line">  -- And finally, save to out variable</span><br><span class="line">  SELECT total INTO ototal;</span><br><span class="line">END //</span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure>
<p>对于BOOLEAN类型来说，非0为真，0为假<br>调用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; CALL ordertotal(20009, 0, @total);</span><br><span class="line">Query OK, 1 row affected (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT @total;</span><br><span class="line">+---------+</span><br><span class="line">| @total  |</span><br><span class="line">+---------+</span><br><span class="line">| 1867.50 |</span><br><span class="line">+---------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<h1 id="使用游标"><a href="#使用游标" class="headerlink" title="使用游标"></a>使用游标</h1><p>1.游标就是使得MySQL可以通过存储过程或函数对SELECT语句获取到的数据进行一行一行处理的方式，也就是说游标也只能通过存储过程或函数来使用，相当于存储过程或函数中的一个局部变量。游标（cursor）是一个存储在MySQL服务器上的数据库查询，它不是一条SELECT语句，而是被该语句检索出来的结果集。在存储了游标之后，应用程序可以根据需要滚动或浏览其中的数据。游标主要用于交互式应用，其中用户需要滚动屏幕上的数据，并对数据进行浏览或做出更改。</p>
<p>2.使用游标需要以下几个步骤：</p>
<ul>
<li>在能够使用游标前,必须声明(定义)它。这个过程实际上没有检索数据,它只是定义要使用的 SELECT 语句。</li>
<li>一旦声明后,必须打开游标以供使用。这个过程用前面定义的SELECT 语句把数据实际检索出来。</li>
<li>对于填有数据的游标,根据需要取出(检索)各行。</li>
<li>在结束游标使用时,必须关闭游标。</li>
</ul>
<p>游标声明后，可以根据需要频繁地打开和关闭它，游标打开后可以根据需要频繁地执行取操作。</p>
<h2 id="创建游标"><a href="#创建游标" class="headerlink" title="创建游标"></a>创建游标</h2><p>1.使用DECLARE语句创建游标，并定义相应的SELECT语句。如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELIMITER //</span><br><span class="line">CREATE PROCEDURE processorders()</span><br><span class="line">BEGIN</span><br><span class="line">  DECLARE ordernumbers CURSOR   #创建一个名ordernumbers的游标</span><br><span class="line">  FOR </span><br><span class="line">  SELECT order_num FROM Orders;</span><br><span class="line">END//</span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure>
<p>这个例子中游标什么也没干，定义之后，在存储过程执行完成时游标自动消失。</p>
<p>2.使用OPEN cursor_name打开游标，CLOSE cursor_name关闭游标以释放游标使用的所有内存内存和资源，如果没有手动关闭游标，MySQL将会在到达END语句时自动关闭它（毕竟游标只是个局部变量）。</p>
<h2 id="使用游标-1"><a href="#使用游标-1" class="headerlink" title="使用游标"></a>使用游标</h2><p>使用FETCH语句获取游标中的数据，并将游标指向下一个位置<br>下面这个例子利用游标来创建一个新表，该表用于存储各订单号对应的总额。各句注释</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELIMITER //</span><br><span class="line">CREATE PROCEDURE processorders()</span><br><span class="line">BEGIN </span><br><span class="line">  -- Declare local variables</span><br><span class="line">  DECLARE done BOOLEAN DEFAULT 0;  #声明BLOOEAN型变量done，默认值为0，用于控制循环</span><br><span class="line">  DECLARE o INT;</span><br><span class="line">  DECLARE t DECIMAL(8,2);</span><br><span class="line"></span><br><span class="line">  -- Declare the cursor</span><br><span class="line">  DECLARE ordernumbers CURSOR   #声明游标，游标中存放的是order_num</span><br><span class="line">  FOR</span><br><span class="line">  SELECT order_num FROM Orders;</span><br><span class="line"></span><br><span class="line">  -- Declare continue handler</span><br><span class="line">  #这句的意思是定义一个CONTINUE HANDLER，它是条件出现时被执行的代码，这里使用SQLSTATE指定当出现错误信息`02000`时将done设置为1</span><br><span class="line">  #02000不服水土一个未找到的条件，即当REPEATE由于没有更多行供循环时，出现这个条件</span><br><span class="line">  DECLARE CONTINUE HANDLER FOR SQLSTATE &#x27;02000&#x27; SET done = 1;   </span><br><span class="line"></span><br><span class="line">  -- Create a table to store the results</span><br><span class="line">  CREATE TABLE IF NOT EXISTS ordertotals(</span><br><span class="line">      order_num INT,</span><br><span class="line">      total DECIMAL(8,2)</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  -- Open the cursor</span><br><span class="line">  OPEN ordernumbers;</span><br><span class="line"></span><br><span class="line">  -- Loop through all rows</span><br><span class="line">  REPEAT   #循环以下内容</span><br><span class="line">    -- Get order number</span><br><span class="line">    FETCH ordernumbers INTO o;  #获取游标中的order_num到变量o中</span><br><span class="line"></span><br><span class="line">    -- Get the total for this order</span><br><span class="line">    CALL ordertotal(o, 1, t);   #调用之前创建个存储过程，来计算总价格，并存入变量t中</span><br><span class="line"></span><br><span class="line">    -- Insert order and total into ordertotals</span><br><span class="line">    INSERT INTO ordertotals(order_num, total)</span><br><span class="line">                      VALUES(o, t);</span><br><span class="line">  -- END of loop</span><br><span class="line">  UNTIL done END REPEAT;   #当done为真时，结束循环</span><br><span class="line"></span><br><span class="line">  -- Close the cursor</span><br><span class="line">  CLOSE ordernumbers;</span><br><span class="line"></span><br><span class="line">END//</span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure>
<p>注意，这里使用了循环、错误处理等高级语句，关于更多MySQL的错误码，可以参见这里<a href="http://dev.mysql.com/doc/mysql/en/error-handling.html">http://dev.mysql.com/doc/mysql/en/error-handling.html</a><br>也可以通过使用LEAVE语句手动退出循环<br>FETCH可以获取当前游标所指向的内容，并更新游标指向下一个位置</p>
<p>通过调用刚创建的存储过程，来使用游标：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CALL processorders();</span><br></pre></td></tr></table></figure>
<p>调用刚才的存储过程后，将创建并填充一个表，下面查看该表：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM ordertotals;</span><br><span class="line">+-----------+---------+</span><br><span class="line">| order_num | total   |</span><br><span class="line">+-----------+---------+</span><br><span class="line">|     20005 | 1746.88 |</span><br><span class="line">|     20009 | 1979.55 |</span><br><span class="line">|     20006 |  349.38 |</span><br><span class="line">|     20007 | 1797.76 |</span><br><span class="line">|     20008 |  200.98 |</span><br><span class="line">|     20008 |  200.98 |</span><br><span class="line">+-----------+---------+</span><br><span class="line">6 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<h1 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h1><p>1.触发器是MySQL响应以下任意语句而自动执行的一条MySQL语句（或位于BEGIN和END语句之间的一组语句）：DELETE，INSERT，UPDATE。<br>2.使用CREATE TRIGGER来创建触发器<br>由于MySQL现在的触发器规则改变，导致书上的例子或讲解可能会出现问题，所以暂时路过这部分，以后有需要了再补上</p>
<h1 id="事务处理"><a href="#事务处理" class="headerlink" title="事务处理"></a>事务处理</h1><p>1.事务处理（transaction processing）可以用来维护数据库的完整性，它保证成批的MySQL操作要么完全执行，要么完全不执行。相当于让对数据库的操作可以回退。<br>2.一般的MySQL语句都隐含两步操作，即处理数据和提交处理，直有提交之后操作才真得彻底写入数据库。例如删除某一行的语句DELETE操作之后，系统会默认进行隐含提交来真正删除那行。也就是说，如果MySQL不进行隐式提交的话，是可以被回退的。管理事务处理也就是将SQL语句分解为多个逻辑块，然后在需要的时候进行回退。MySQL使用START TRANSACTION开始一个事务处理</p>
<h2 id="ROLLBACK进行回退"><a href="#ROLLBACK进行回退" class="headerlink" title="ROLLBACK进行回退"></a>ROLLBACK进行回退</h2><p>1.MySQL使用ROLLBACK命令来回退（撤销）MySQL语句。只有在开始一个事务处理，或者将关闭自动提交之后才能进行回退：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">START TRANSACTION;  #开始一个事务处理</span><br><span class="line">DELETE FROM ordertotals;  #删除所有行</span><br><span class="line">ROLLBACK;  #回退到START TRANSACTION之前的状态</span><br></pre></td></tr></table></figure>
<p>也就是说进入START TRANSACTION之后的语句时，MySQL语句的自动提交将被临时关闭，直到执行ROLLBACK或COMMIT语句。</p>
<p>2.事务处理可以用来管理INSERT、UPDATE和DELETE语句。不能回退CREATE或DROP操作，事务块中可以使用这两条语句，但执行回退并不会影响这两条语句的操作。</p>
<h2 id="COMMIT提交操作"><a href="#COMMIT提交操作" class="headerlink" title="COMMIT提交操作"></a>COMMIT提交操作</h2><p>1.默认情况下MySQL语句都会自动隐含提交，当关闭自动提交或开始事务处理之后，提交不会隐含地进行，只有手动使用COMMIT语句才能进行明确提交。如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">START TRANSACTION;</span><br><span class="line">DELETE FROM OrderItems WHERE order_num = 20009;</span><br><span class="line">DELETE FROM Orders WHERE order_num = 20009;</span><br><span class="line">COMMIT;   </span><br></pre></td></tr></table></figure>
<p>COMMIT之后便无法再使用ROLLBACK回退，当然如果以上两条语句有一条失败，COMMIT也不会提交，也就是说DELETE会被自动撤销。<br>2.通过设置autocommit的值可以更改默认的提交行为。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SET autocommit = 0; #设置为不自动提交</span><br></pre></td></tr></table></figure>
<p>autocommit标志决定是否自动提交更改。将autocommit设置为0之后，MySQL将不再进行自动提交，直到该值再次设置为1为止。当然设置为不自动提交之后可以使用COMMIT进行手动提交，也可以使用ROLLBACK回退到最后一次提交之前的状态，注意设置为自动提交之前都会有默认自动提交。<br>autocommit标志是针对每个连接而不是服务器。也就是说当退出后再次登录MySQL，之前设置的autocommit状态就会被重置为默认状态。</p>
<h2 id="SAVEPOINT设置保留点"><a href="#SAVEPOINT设置保留点" class="headerlink" title="SAVEPOINT设置保留点"></a>SAVEPOINT设置保留点</h2><p>1.简单的ROLLBACK和COMMIT语句可以写入或撤销整个事务，而结合SAVEPOINT设置的保留点之后，就像建快照以样，可以回退到任何一个保留点状态。<br>使用方法就是首先创建占位符（place-holder），然后使用ROLLBACK TO回退到相应的保留点：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SAVEPOINT delete1;</span><br><span class="line">ROLLBACK TO delete1;</span><br></pre></td></tr></table></figure>
<p>使用SAVEPOINT设置保留点之后，不管是否在事务处理中，都会默认进行不自动提交的状态。如果使用ROLLBACK而不是ROLLBACK TO，会默认回退到最后一个保留点处，回退到保留点之后，会自动删除该保留点。</p>
<p>2.保留点越多越好，不限制个数，保留点在事务处理完成之后（执行一条ROLLBACK或COMMIT）后自动释放。也可以用RELEASE SAVEPOINT idertifer明确地释放保留点。</p>
<h2 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h2><p>1.MySQL支持众多的字符集，使用以下语句可以查看字符集的相关内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW CHARACTER SET;  #显示所有可用的字符集以及每个字符集的描述和默认校对</span><br><span class="line">SHOW COLLATION;  #显示所有可用的校对，以及它们适用的字符集</span><br></pre></td></tr></table></figure>
<p>校对为规定字符如何比较的指令。</p>
<p>2.通常系统管理在安装时会定义一个默认的字符集和校对，也可以在创建数据库时，指定默认的字符集和校对。可以使用以下语句查看所使用的字符集和校对：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW VARIABLES LIKE &#x27;character%&#x27;;</span><br><span class="line">SHOW VARIABLES LIKE &#x27;collation%&#x27;;</span><br></pre></td></tr></table></figure>
<p>3.字符集很少是服务器范围的，甚至不同列都可能需要不同的字符集，可以在创建表时指定字符集，也可以为列指定字符集：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE mytable</span><br><span class="line">(</span><br><span class="line">  column1 INT,</span><br><span class="line">  column2 VARCHAR(10)</span><br><span class="line">) DEFAULT CHARACTER SET hebrew</span><br><span class="line">  COLLATE hebrew_general_ci;</span><br></pre></td></tr></table></figure>
<p>此语句创建一个包含两列的表，并指定一个字符集和一个校对顺序。</p>
<p>4.使用CHARACTER SET和COLLATE来指定字符集和校对，它们的使用规则如下：</p>
<ul>
<li>如果指定 CHARACTER SET 和 COLLATE 两者,则使用这些值。</li>
<li>如果只指定 CHARACTER SET ,则使用此字符集及其默认的校对(如SHOW CHARACTER SET 的结果中所示)。</li>
<li>如果既不指定 CHARACTER SET ,也不指定 COLLATE ,则使用数据库默认。</li>
</ul>
<p>创建表时为列指定字符集和校对：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE mytable</span><br><span class="line">(</span><br><span class="line">  column1 INT,</span><br><span class="line">  column2 VARCHAR(10)</span><br><span class="line">  column2 VARCHAR(10) CHARACTER SET latin1 COLLATE latin1_general_ci</span><br><span class="line">) DEFAULT CHARACTER SET hebrew</span><br><span class="line">  COLLATE hebrew_general_ci;</span><br></pre></td></tr></table></figure>

<p>使用ORDER BY或其他SELECT子句时也可以临时指定校对顺序：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM Customers</span><br><span class="line">ORDER BY lastname, firstname COLLATE latin1_general_cs;</span><br></pre></td></tr></table></figure>

<p>5.可以使用Cast()或Convert()函数来在字符集之间转换</p>
<h1 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h1><h2 id="查看用户"><a href="#查看用户" class="headerlink" title="查看用户"></a>查看用户</h2><p>1.MySQL用户账号和信息存储在名为mysql的MySQL数据库中，通常不需要直接访问mysql数据库和表，也不建议直接访问，因为一旦出错，通常都是致命的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">USE mysql;</span><br><span class="line">SELECT user FROM user;  #查看有哪些用户</span><br></pre></td></tr></table></figure>

<h2 id="创建用户"><a href="#创建用户" class="headerlink" title="创建用户"></a>创建用户</h2><p>1.使用CREATE USER创建用户</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE USER blueyi IDENTIFIED BY &#x27;testpasswd&#x27;;</span><br></pre></td></tr></table></figure>
<p>创建用户blueyi并通常IDENTIFIED BY指定密码，当然也可以不指定密码<br>虽然也可以通过向user表插入行的方式增加用户，但这样很不安全</p>
<p>2.使用GRANT分配权限的同时创建账户：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GRANT SELECT ON mysql_test.* TO maxwi;</span><br></pre></td></tr></table></figure>
<p>创建名为maxwi的用户，并分配SELECT权限</p>
<p>3.授权的一些例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GRANT USAGE ON *.* TO &#x27;ss&#x27;@&#x27;%&#x27; IDENTIFIED BY PASSWORD &#x27;passwd&#x27;; # 创建用户ss，但不分配任何权限</span><br><span class="line">GRANT SELECT ON `sol`.`ukey` TO &#x27;ss&#x27;@&#x27;%&#x27;; # 授予用户ss远程登录并可以访问表sol中的字段ukey</span><br><span class="line">GRANT SELECT, INSERT, UPDATE, DELETE ON `sol`.`node` TO &#x27;ss&#x27;@&#x27;%&#x27;;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FLUSH PRIVILEGES; # 使权限更改生效</span><br></pre></td></tr></table></figure>

<p>4.在不改变表访问权限的情况取消ss的远程访问：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UPDATE `user` SET `host` = &#x27;localhost&#x27; WHERE `user` = &#x27;ss&#x27;;</span><br><span class="line">FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure>
<p>5.在不改变表访问权限的情况下添加ss的远程访问权限：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UPDATE `user` SET `host` = &#x27;%&#x27; WHERE `user` = &#x27;ss&#x27;;</span><br><span class="line">FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure>

<p>6.使用RENAME修改用户名</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">RENAME USER blueyi TO testuser;</span><br></pre></td></tr></table></figure>
<p>也可以使用UPDATE直接更新user表</p>
<h2 id="删除用户账号"><a href="#删除用户账号" class="headerlink" title="删除用户账号"></a>删除用户账号</h2><p>1.使用DROP USER删除用户：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DROP USER blueyi;</span><br></pre></td></tr></table></figure>

<h2 id="设置访问权限"><a href="#设置访问权限" class="headerlink" title="设置访问权限"></a>设置访问权限</h2><p>1.可以使用SHOW GRANTS FOR来查看用户的权限：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SHOW GRANTS FOR maxwi;</span><br><span class="line">+------------------------------------------------------------------------------------------------------+</span><br><span class="line">| Grants for maxwi@%                                                                                   |</span><br><span class="line">+------------------------------------------------------------------------------------------------------+</span><br><span class="line">| GRANT USAGE ON *.* TO &#x27;maxwi&#x27;@&#x27;%&#x27; IDENTIFIED BY PASSWORD &#x27;*CA2DC8B6C2CC6ACB3DE44D56C0BF821DBF383E0B&#x27; |</span><br><span class="line">+------------------------------------------------------------------------------------------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>
<p>输出中maxwi有一个权限为USAGE ON <em>.</em>，USAGE表示根本没有权限。<br>用户定义为user@host MySQL的权限用用户名和主机名结合定义，如果不指定主机名，则使用默认的主机名%。</p>
<p>2.使用GRANT语句设置访问权限，GRANT要求至少提供以下信息：</p>
<ul>
<li>要授予的权限;</li>
<li>被授予访问权限的数据库或表;</li>
<li>用户名。</li>
</ul>
<p>如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GRANT SELECT ON mysql_test.* TO maxwi;</span><br></pre></td></tr></table></figure>
<p>此GRANT允许用户在mysql_test.*（即它的所有表）上使用SELECT。<br>查看权限授予结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SHOW GRANTS FOR maxwi;</span><br><span class="line">+------------------------------------------------------------------------------------------------------+</span><br><span class="line">| Grants for maxwi@%                                                                                   |</span><br><span class="line">+------------------------------------------------------------------------------------------------------+</span><br><span class="line">| GRANT USAGE ON *.* TO &#x27;maxwi&#x27;@&#x27;%&#x27; IDENTIFIED BY PASSWORD &#x27;*CA2DC8B6C2CC6ACB3DE44D56C0BF821DBF383E0B&#x27; |</span><br><span class="line">| GRANT SELECT ON `mysql_test`.* TO &#x27;maxwi&#x27;@&#x27;%&#x27;                                                        |</span><br><span class="line">+------------------------------------------------------------------------------------------------------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>3.使用REVOKE可以撤销特定的权限：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">REVOKE SELECT ON mysql_test.* FROM maxwi;</span><br></pre></td></tr></table></figure>

<p>4.GRANT 和 REVOKE 可在几个层次上控制访问权限:</p>
<ul>
<li>整个服务器,使用 GRANT ALL 和 REVOKE ALL;</li>
<li>整个数据库,使用 ON database.*;</li>
<li>特定的表,使用 ON database.table;</li>
<li>特定的列;</li>
<li>特定的存储过程。</li>
</ul>
<p>5.可供管理的权限：<br>ALL 除GRANT OPTION外的所有权限<br>ALTER 使用ALTER TABLE<br>ALTER ROUTINE 使用ALTER PROCEDURE和DROP PROCEDURE<br>CREATE 使用CREATE TABLE<br>CREATE ROUTINE 使用CREATE PROCEDURE<br>CREATE TEMPORARY TABLES  使用CREATE TEMPORARY TABLE<br>CREATE USER 使用CREATE USER、 DROP USER、 RENAME USER和REVOKE ALL PRIVILEGES<br>CREATE VIEW 使用CREATE VIEW<br>DELETE 使用DELETE<br>DROP 使用DROP TABLE<br>EXECUTE 使用CALL和存储过程<br>FILE 使用SELECT INTO OUTFILE和LOAD DATA INFILE<br>GRANT OPTION 使用GRANT和REVOKE<br>INDEX 使用CREATE INDEX和DROP INDEX<br>INSERT 使用INSERT<br>LOCK TABLES 使用LOCK TABLES<br>PROCESS 使用SHOW FULL PROCESSLIST<br>RELOAD 使用FLUSH<br>REPLICATION CLIENT 服务器位置的访问<br>REPLICATION SLAVE 由复制从属使用<br>SELECT  使用SELECT<br>SHOW DATABASES 使用SHOW DATABASES<br>SHOW VIEW 使用SHOW CREATE VIEW<br>SHUTDOWN 使用mysqladmin shutdown(用来关闭MySQL)<br>SUPER    使用CHANGE MASTER、KILL、LOGS、PURGE、MASTER 和SET GLOBAL。还允许mysqladmin调试登录<br>UPDATE 使用UPDATE<br>USAGE 无访问权限</p>
<p>6.当权限被授予之后，如果删除了表，权限会依然存在，当再次创建该被授予相应权限的表时，权限依然起作用。</p>
<p>7.可以通过逗号分隔一次授予多个权限：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GRANT SELECT, INSERT ON mysql_test.* TO maxwi;</span><br></pre></td></tr></table></figure>

<h2 id="更改口令"><a href="#更改口令" class="headerlink" title="更改口令"></a>更改口令</h2><p>1.MySQL使用SET PASSWORD 设置用户密码，新密码必须传递到Password()函数进行加密：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SET PASSWORD FOR maxwi = Password(&#x27;test@$$pss&#x27;);</span><br></pre></td></tr></table></figure>

<p>2.当不指定用户名时，则是为当前登录用户设置口令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SET PASSWORD = Password(&#x27;testpass&#x27;);</span><br></pre></td></tr></table></figure>

<h1 id="备份数据库"><a href="#备份数据库" class="headerlink" title="备份数据库"></a>备份数据库</h1><h2 id="导入，导出"><a href="#导入，导出" class="headerlink" title="导入，导出"></a>导入，导出</h2><p>导入、导出操作使用的是MySQL的语句实现的，所以需要先登录MySQL<br>1.可以将数据库某个表中的数据保存到一个文件之中，语法格式为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT column1, column2 INTO OUTFILE &#x27;file_path and file_name&#x27; FROM table_name;</span><br></pre></td></tr></table></figure>
<p>例如要将Orders信息导出取文件Orders.txt，语句如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * INTO OUTFILE &#x27;Orders.txt&#x27; FROM Orders;</span><br></pre></td></tr></table></figure>
<p>关于导出路径，如果不指定文件夹，则导出到默认文件夹，默认文件夹可以查看mysql的配置文件，通常在配置文件在<code>/etc/mysql/my.cnf</code>，其中的datadir就是数据路径变量，例如我这里导出的文件路径是<code>/var/lib/mysql/mysql_test/Orders.txt</code>，注意系统会默认放在以相应数据库名命名的文件夹中。<br>如果指定了绝对路径之后报错，是由于系统保护问题，可以参见这里<a href="http://stackoverflow.com/questions/2783313/how-can-i-get-around-mysql-errcode-13-with-select-into-outfile">http://stackoverflow.com/questions/2783313/how-can-i-get-around-mysql-errcode-13-with-select-into-outfile</a></p>
<p>导出的文件中数据按表格的方式存放，如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">20005   2012-05-01 00:00:00 1000000001</span><br><span class="line">20006   2012-01-12 00:00:00 1000000003</span><br><span class="line">20007   2012-01-30 00:00:00 1000000004</span><br><span class="line">20008   2012-02-03 00:00:00 1000000005</span><br><span class="line">20009   2012-02-08 00:00:00 1000000001</span><br></pre></td></tr></table></figure>

<p>2.导入数据的方式为<code>LOAD DATA INFILE &#39;fine_path&#39; INTO TABLE table_name;</code><br>如将刚导入的Orders.txt导入到表ordercopy中，导入时列必须完全对应，所以必须使用与原表结构完全一样结构。所以这里采用将原表复制一份，然后删除复制表里面的所有行，再次导入到复制表中（不删除会导致主键重复而无法导入）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#复制原表结构及数据</span><br><span class="line">CREATE TALBE ordercopy AS SELECT * FROM Orders;</span><br><span class="line">#删除ordercopy中的行</span><br><span class="line">DELETE FROM ordercopy;</span><br><span class="line">#导入数据</span><br><span class="line">LOAD DATA INFILE &#x27;Orders.txt&#x27; INTO TABLE ordercopy;</span><br></pre></td></tr></table></figure>

<h2 id="mysqldump"><a href="#mysqldump" class="headerlink" title="mysqldump"></a>mysqldump</h2><p>1.mysqldump是MySQL用于备份数据库的实用程序，所以它的操作就是命令行工具，它主要产生一个SQL脚本文件，其中包含从头重新创建数据库所必须的所有命令。<br>mysqldump使用方法：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysqldump -h host -u user -ppassword 数据库名 &gt; 备份文件名   #备份整个数据库</span><br><span class="line">mysqldump -h host -u user -ppassword  --databases 数据库名1 数据库名2 &gt; 备份文件名   #同时备份多个数据库</span><br><span class="line">mysqldump -h host -u user -ppassword --all-databases &gt; 备份文件名   #备份所有数据库</span><br><span class="line">mysqldump -h host -u user -ppassword 数据库名 表名字 &gt; 备份文件名  #备份整个表</span><br></pre></td></tr></table></figure>
<p>当然如果是本机操作，可以省略-h参数，如果没有密码，也可以省略-p参数<br>例如备份整个mysql_test数据库和，备份表Products的命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysqldump -u root -ppassword mysql_test &gt; mysql_test_backup.sql #备份整个数据库</span><br><span class="line">mysqldump -u root -ppassword mysql_test.Products &gt; mysql_test_products_backup.sql  #备份表</span><br></pre></td></tr></table></figure>

<p>2.恢复数据库可以使用之前用过的source语句，也就是先登录到MySQL，然后使用语句source进行恢复，也可以使用mysql实用程序进行恢复：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysql -h host -u user -ppassword 数据库 &lt; 数据库的备份文件</span><br></pre></td></tr></table></figure>
<p>如将mysql_test备份的文件恢复到数据库test，当然需要首先登录MySQL后创建数据库test，恢复命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql -u root -ppassword test &lt; mysql_test_backup.sql</span><br></pre></td></tr></table></figure>

<h2 id="mysqlhotcopy"><a href="#mysqlhotcopy" class="headerlink" title="mysqlhotcopy"></a>mysqlhotcopy</h2><p>mysqlhotcopy是MySQL提供的另一个可用于备份的实用程序。</p>
<p>在备份前为了保证所有数据被写到磁盘（包括索引数据），可以使用FLUSH TABLES table_name语句。</p>
]]></content>
      <categories>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>唯一化有序数组</title>
    <url>/2016/05/05/unique-sorted-array/</url>
    <content><![CDATA[<p>删除已经排好序的一维数组中的重复元素，要求时间复杂度为o(n)<br>方法：使用两个指针，指针front指向当前已经唯一化的最后一个位置，指针after向后遍历需要唯一化的元素，保证front之前的所有元素都始终是唯一的。<br>当front与after指向的值相同时，after向后移动，当不同时after值赋给front，且front也向后移动。<br>代码如下：  </p>
<span id="more"></span>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用两个指针，一个指向当前已经唯一化的最后一个位置，另一个向后遍历需要唯一化的元素</span></span><br><span class="line"><span class="comment">//保证front之前的所有元素都始终是唯一的</span></span><br><span class="line"><span class="comment">//当front与after指向的值相同时，after向后移动，当不同时after值赋给front，且front也向后移动</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="type">void</span> <span class="title">uniqueArray</span><span class="params">(std::vector&lt;T&gt; &amp;vec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> front = vec.<span class="built_in">begin</span>(), after = vec.<span class="built_in">begin</span>();  <span class="comment">//都从第一个元素开始，避免只有一个元素而越界</span></span><br><span class="line">    <span class="keyword">while</span> (after++ != vec.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (*front != *after)       <span class="comment">//如果不相同，则将后面的元素赋值给当前front所指向的位置</span></span><br><span class="line">            *(++front) = *after;</span><br><span class="line">    &#125;</span><br><span class="line">    vec.<span class="built_in">erase</span>(front, after - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">10</span>, <span class="number">11</span>&#125;;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Original array:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> v : vec) </span><br><span class="line">        std::cout &lt;&lt; v &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="built_in">uniqueArray</span>&lt;<span class="type">int</span>&gt;(vec);</span><br><span class="line">    std::cout &lt;&lt; std::endl &lt;&lt; <span class="string">&quot;Unique array:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> v : vec) </span><br><span class="line">        std::cout &lt;&lt; v &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithms</category>
      </categories>
      <tags>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>C++随机数类random的使用</title>
    <url>/2016/04/10/cpp-random/</url>
    <content><![CDATA[<p>C++中生成随机数即可以使用C语言中的rand和srand的方式，也可以使用C++11中的random类。  </p>
<h1 id="cstdlib中伪随机数"><a href="#cstdlib中伪随机数" class="headerlink" title="cstdlib中伪随机数"></a>cstdlib中伪随机数</h1><p>C语言中通过函数<code>rand</code>和<code>srand</code>来产生伪随机数，这两个函数包含在头文件<code>cstdlib</code>中，其中<code>srand</code>用来产生设置随机数种子，<code>rand</code>每次返回一个当前的种子对应的随机数，这两个函数的声明如下：   </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">srand</span><span class="params">(<span class="type">unsigned</span> seed)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">rand</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>这两个函数的原型形如：  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> next = <span class="number">1</span>;</span><br><span class="line"><span class="comment">/* rand: return pseudo-random integer on 0..32767 */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">rand</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    next = next * <span class="number">1103515245</span> + <span class="number">12345</span>;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">unsigned</span> <span class="type">int</span>)(next/<span class="number">65536</span>) % <span class="number">32768</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* srand: set seed for rand() */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">srand</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> seed)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    next = seed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>显然rand只能生成整数，需要小数时，只需要跟一个浮点数进行除法即可<br>一个生成[1, 15]的随机数例子：   </p>
<span id="more"></span>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//random num range is min to max, template function</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function">T <span class="title">cRandom</span><span class="params">(<span class="type">int</span> min, <span class="type">int</span> max)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (min + <span class="built_in">static_cast</span>&lt;T&gt;(max * <span class="built_in">rand</span>() / <span class="built_in">static_cast</span>&lt;T&gt;(RAND_MAX + <span class="number">1</span>)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">srand</span>((<span class="type">unsigned</span>)<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line">    <span class="comment">//生成10个整数</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;int: &quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="built_in">cRandom</span>&lt;<span class="type">int</span>&gt;(<span class="number">1</span>, <span class="number">15</span>) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">//生成10个小数</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;double: &quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="built_in">cRandom</span>&lt;<span class="type">double</span>&gt;(<span class="number">1</span>, <span class="number">15</span>) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>生成指定范围的随机数表达式：<br>要取得[a,b)的随机整数，使用(rand() % (b-a))+ a;<br>要取得[a,b]的随机整数，使用(rand() % (b-a+1))+ a;<br>要取得(a,b]的随机整数，使用(rand() % (b-a))+ a + 1;<br>通用公式:a + rand() % n；其中的a是起始值，n是整数的范围。<br>要取得a到b之间的随机整数，另一种表示：a + (int)b * rand() / (RAND_MAX + 1)。<br>要取得0～1之间的浮点数，可以使用rand() / double(RAND_MAX)。</p>
<h1 id="C-11中的random类"><a href="#C-11中的random类" class="headerlink" title="C++11中的random类"></a>C++11中的random类</h1><p>random类是C++11中增加的类，该类可以用于生成随机数，具有C语言中rand生成伪随机数的功能，但其功能更强大。原生支持生成浮点数，及分布类。  </p>
<p>随机数发生器主要由分布对象和随机数引擎对象组成。其中随机数引擎用于根据随机数种子来产生随机数，分布对象对产生的随机数根据需求进行分布。<br>random中定义了多种随机数引擎及分布类型，常用的引擎是默认伪随机数引擎类<code>default_random_engine</code>，常用的分布类有产生整型分布的<code>uniform_int_distribution</code>，产生浮点型的分布<code>uniform_real_distribution</code>。  </p>
<h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><p>该程序输出15个double类型的随机数  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;random&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//该函数接受三个参数分别指定随机数范围和种子，返回double</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">random_unint</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> min, <span class="type">unsigned</span> <span class="type">int</span> max, <span class="type">unsigned</span> <span class="type">int</span> seed = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="type">static</span> std::default_random_engine <span class="title">e</span><span class="params">(seed)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> std::uniform_real_distribution&lt;<span class="type">double</span>&gt; <span class="title">u</span><span class="params">(min, max)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">u</span>(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">15</span>; ++i) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="built_in">random_unint</span>(<span class="number">0</span>, <span class="number">15</span>, <span class="built_in">time</span>(<span class="literal">NULL</span>)) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="需要注意"><a href="#需要注意" class="headerlink" title="需要注意"></a>需要注意</h2><p>1.一个给定的随机数发生器一直会生成相同的随机数序列。一个函数如果定义了局部的随机数发生器，应该将其（包括引擎和分布对象）定义为static的，否则每次调用函数都会生成相同的序列。也就是说定义成static后每次调用还是之前那个发生器，第一次调用产生一批随机数，再次调用将产生接下来的随机数，否则每次调用产生的都是最前面的那些随机数。</p>
<p>2.依然需要使用time来做为种子产生每个不同时刻都不同的随机序列，但由于time默认返回的是以秒计的时间，所以有可能多次使用的都是相同的种子。  </p>
<h2 id="伪随机数引擎"><a href="#伪随机数引擎" class="headerlink" title="伪随机数引擎"></a>伪随机数引擎</h2><p>1.随机数引擎支持的操作如下：  </p>
<ul>
<li>Engine e;    //默认构造函数，使用该引擎类型的默认种子</li>
<li>Engine e(s); //使用整型s做为种子</li>
<li>e.seed(s);   //使用整型s重置引擎状态</li>
<li>e.min();     //返回此引擎所能生成的最小和最大值</li>
<li>e.max();</li>
<li>Engine::result_type  //此引擎生成的类型（unsigned）</li>
<li>e.discard(u);        //将引擎推进u步，u为unsigned long long类型  </li>
</ul>
<p>2.随机数引擎使用  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::default_random_engine e;   <span class="comment">//生成随机的无符号数</span></span><br><span class="line">std::cout &lt;&lt; <span class="built_in">e</span>();       <span class="comment">//通过()调用对象生成下一个随机数并输出</span></span><br></pre></td></tr></table></figure>

<h2 id="分布"><a href="#分布" class="headerlink" title="分布"></a>分布</h2><p>1.分布类型有很多种，常用的有返回整型的<code>uniform_int_distribution</code>和返回浮点型的<code>uniform_real_distribution</code>。<br>2.分布支持的操作  </p>
<ul>
<li>Dist d;       //默认构造函数</li>
<li>Dist d(min, max);    //为d指定范围</li>
<li>d(e)         //e是一个随机数引擎对象</li>
<li>d.min()      //返回d(e)所能生成的最小值和最大值</li>
<li>d.max()     </li>
<li>d.reset();    //重置d的状态，使得随后对d的使用不依赖于d已经生成的值</li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>CPP</tag>
      </tags>
  </entry>
  <entry>
    <title>实战中遇到的C++问题汇总</title>
    <url>/2016/04/03/cpp-problem/</url>
    <content><![CDATA[<p>项目中遇到过的C++问题  </p>
<h2 id="auto与const引用问题"><a href="#auto与const引用问题" class="headerlink" title="auto与const引用问题"></a>auto与const引用问题</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">error: invalid initialization of non-<span class="type">const</span> reference of type <span class="string">&#x27;std::_Rb_tree_const_iterator&lt;std::pair&lt;const std::__cxx11::basic_string&lt;char&gt;, std::__cxx11::basic_string&lt;char&gt; &gt; &gt;&amp;&#x27;</span> from an rvalue of type <span class="string">&#x27;std::map&lt;std::__cxx11::basic_string&lt;char&gt;, std::__cxx11::basic_string&lt;char&gt; &gt;::const_iterator &#123;aka std::_Rb_tree_const_iterator&lt;std::pair&lt;const std::__cxx11::basic_string&lt;char&gt;, std::__cxx11::basic_string&lt;char&gt; &gt; &gt;&#125;&#x27;</span></span><br><span class="line">||          <span class="keyword">auto</span> &amp;valpair = con.<span class="built_in">find</span>(valname[cont]);</span><br><span class="line">||                                                ^</span><br></pre></td></tr></table></figure>
<p>错误行处的代码应更正为<code>auto valpair = con.find(valname[cont]);</code>或者<code>const auto &amp;valpair = con.find(valname[cont]);</code><br>错误原因：<br>map的find成员函数返回的迭代器有可能是const，例如此处传递给函数的map是一个const引用，返回将是一个const的迭代器。而auto此时进行类型推断时，由于使用的是引用，所以auto默认推断的类型为非const的引用。根据修改的内容，显然当不是引用时，auto推断就是const的了；或者手动在auto前面添加一个const。（话说auto应该再智能一点）  </p>
<span id="more"></span>

<h2 id="模板类继承问题"><a href="#模板类继承问题" class="headerlink" title="模板类继承问题"></a>模板类继承问题</h2><p>当一个模板类继承自另一个模板类时，子模板类无法直接访问继承自父模板类的成员，虽然成员已经被继承了，但无法直接在子模板类中访问继承自父模板类的成员，需要使用this指针或者访问限定符来访问继承自父类的成员。  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="type">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">class</span> <span class="title class_">Drive</span> : <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Base</span>&lt;T&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">asign</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123; b = i; &#125; <span class="comment">//错误，提示定义域内不存在b</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">asign</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123; <span class="keyword">this</span>-&gt;b = i; &#125; <span class="comment">//可以</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">asign</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123; Base&lt;T&gt;::b = i; &#125; <span class="comment">//可以</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="getline默认会读取-r"><a href="#getline默认会读取-r" class="headerlink" title="getline默认会读取\r"></a>getline默认会读取<code>\r</code></h2><p>使用getline进行文件读取时，一定要考虑空行和行尾有可能出现<code>\r</code>的情况，getline默认情况下会将<code>\r</code>读入。  </p>
<h2 id="new创建动态数组"><a href="#new创建动态数组" class="headerlink" title="new创建动态数组"></a>new创建动态数组</h2><p>使用new创建动态数组时，如果<code>int *a = new int[25];//定义一个指向含有25个未被初始的元素的动态数组的指针</code>中一旦将中括号<code>[]</code>写成了<code>()</code>，即<code>int *a = new int(25);</code>意思将变成定义一个指向值为25的int型值的指针。   </p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>CPP</tag>
      </tags>
  </entry>
  <entry>
    <title>C++之动态内存管理</title>
    <url>/2016/03/25/cpp-dynamic-memory/</url>
    <content><![CDATA[<h2 id="动态内存与智能指针"><a href="#动态内存与智能指针" class="headerlink" title="动态内存与智能指针"></a>动态内存与智能指针</h2><p>1.静态内存用来保存局部static对象，类static数据成员以及定义在任何函数之外的变量。static对象会在第一次使用前分配，程序结束时销毁。栈内存用来保存定义在函数内的非static对象。栈对象仅在其定义的程序块运行时才存在。分配在静态内存和栈内存中的对象由编译器自动创建和销毁。  </p>
<span id="more"></span>

<p>2.每个程序拥有的内存池即自由空间（free store）或堆（heap）可以由程序控制用于存储动态分配（dynamically allocate）的对象。  </p>
<p>3.动态定义的变量使用的是默认初始化方式，如果变量是含有默认构造函数的类型，将会调用默认构造函数进行初始化，例如<code>string *ps = new string()</code>中ps指向的内存将被默认初始化为空字符串，因为string的默认构造函数会将其初始化为空字符串。如果是内置变量它指向的将是未初始化的内存空间，也就是说它的值将是任意的。虽然默认情况下，内置变量的默认初始化是由其定义的位置决定的，但对于动态分配的内存，其值都将不被初始化，如<code>int *pi = new int;</code>，不管是否将其放在任意函数体的外部，其中<code>pi</code>指向的内存都将是未定义的，虽然当将其放在全局时<code>pi</code>本身是个已经初始化的指针。但<code>int *pi2 = new int()</code>将会调用值初始化来将pi2指向的内存初始化0。     </p>
<p>4.动态内存的管理是通过一对运算符new和delete来完成，new在动态内存中为对象分配空间并返回一个指向该对象的指针，delete接受一个动态对象的指针，销毁该对象并释放相应的内存。  </p>
<h2 id="shared-ptr类"><a href="#shared-ptr类" class="headerlink" title="shared_ptr类"></a>shared_ptr类</h2><p>5.C++11中提供了两个智能指针，它们都是模板类：<code>shared_ptr</code>允许多个指针指向同一个对象，unique_ptr则独占所指向的对象。另外还有一个weak_ptr的伴随类，它是一种弱引用，指向shared_ptr所管理的对象。它们都定义在头文件memory中。  </p>
<p>6.默认初始化的智能指针中保存着一个空指针，如果在一个条件判断中使用智能指针，效果就是检测它是否为空。eg:  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">shared_ptr&lt;string&gt; p1;  <span class="comment">//定义一个可以指向string的shared_ptr</span></span><br><span class="line"><span class="keyword">if</span> (p1 &amp;&amp; p1-&gt;<span class="built_in">empty</span>())  <span class="comment">//如果p1不为空，并检查它是否指向一个空string</span></span><br><span class="line">  *p1 = <span class="string">&quot;hi&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>7.最安全的分配和使用动态内存的方法是调用一个名为<code>make_shared</code>的标准库函数，此函数在动态内存中分配一个对象并初始它，返回指向此对象的shared_ptr。该函数是一个函数模板，所以使用是需要提供类型。类似容器的emplace成员，make_shared用相应的参数来构造给定类型的对象，所以传递给make_shared的参数必须与想要构造的对象的类型的某个构造函数相匹配，如果不传递任何参数，对象就会进行值初始化。eg:  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">shared_ptr&lt;<span class="type">int</span>&gt; p3 = <span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">42</span>);  <span class="comment">//指向一个值为42的int的shared_ptr</span></span><br><span class="line">shared_ptr&lt;string&gt; p4 = <span class="built_in">make_shared</span>&lt;string&gt;(<span class="number">10</span>, <span class="string">&#x27;9&#x27;</span>);  <span class="comment">//p4指向一个值为&quot;9999999999&quot;的string</span></span><br><span class="line">shared_ptr&lt;<span class="type">int</span>&gt; p5 = <span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;();  <span class="comment">//p5指向一个使用值初始化的int，值为0</span></span><br></pre></td></tr></table></figure>

<p>8.每个shared_ptr都关联着一个引用计数器（reference count），当拷贝一个shared_ptr时（例如使用一个shared_ptr初始化另一个shared_ptr，或将它作为参数传递给一个函数，以及作为函数的返回值），计算器都会递增。当给shared_ptr赋予一个新值或是shared_ptr被销毁（例如一个局部的shared_ptr离开作用域）时，计算器会递减。所以当赋值号两边都是shared_ptr时，则左边shared_ptr关联的计算器会被递减，右边会递增。eg:  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> r = <span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">42</span>);  <span class="comment">//r指向的int只有一个引用者</span></span><br><span class="line">r = q; <span class="comment">//给r赋值，令它指向另一个地址</span></span><br><span class="line">      <span class="comment">//递增q指向的对象的引用计数</span></span><br><span class="line">      <span class="comment">//递减r原来指向的对象的引用计数</span></span><br><span class="line">      <span class="comment">//如果r原来指向的对象已没有引用者，会自动释放 </span></span><br></pre></td></tr></table></figure>

<p>9.如果将shared_ptr存放于一个容器中，而后不再需要全部元素，而是只使用其中一部分，要记得用erase删除不再需要的那些元素。否则该部分内存将会一直被占用。  </p>
<p>10.使用动态内存通常出于以下三种原因：  </p>
<ul>
<li>1.程序不知道自己需要使用多少对象  </li>
<li>2.程序不知道所需对象的准备类型  </li>
<li>3.程序需要在多个对象间共享数据  </li>
</ul>
<h2 id="new和delete"><a href="#new和delete" class="headerlink" title="new和delete"></a>new和delete</h2><p>1.默认情况下，动态分配的对象是默认初始化的，这意味着使用new创建的内置类型或组合类型的对象的值将是未定义的，而类类型对象将用默认构造函数进行初始化。可以使用直接初始化方式或C++11中的列表初始化方式在创建时初始化一个动态分配的对象：  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">string *ps = <span class="keyword">new</span> string;  <span class="comment">//默认初始化为空string</span></span><br><span class="line">string *ps1 = <span class="keyword">new</span> <span class="built_in">string</span>();  <span class="comment">//值初始化为空string</span></span><br><span class="line"><span class="type">int</span> *pi1 = <span class="keyword">new</span> <span class="type">int</span>;  <span class="comment">//默认初始化，p1指向一个未初始化的int</span></span><br><span class="line"><span class="type">int</span> *pi2 = <span class="keyword">new</span> <span class="built_in">int</span>();  <span class="comment">//值初始化为0，p2指向一个值为0的int</span></span><br><span class="line"><span class="type">int</span> *pi3 = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">42</span>);  <span class="comment">//pi指向的对象的值为42</span></span><br><span class="line">string *ps3 = <span class="keyword">new</span> <span class="built_in">string</span>(<span class="number">10</span>, <span class="string">&#x27;9&#x27;</span>);  <span class="comment">//*ps的值为9999999999</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; *pv = <span class="keyword">new</span> vector&lt;<span class="type">int</span>&gt;&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;  <span class="comment">//pv指向含有5个int值的vector，值分别为0到4</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; *pv1 = <span class="keyword">new</span> <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;();  <span class="comment">//pv1指向一个空vector，当然可以向pv1中添加push_back值</span></span><br></pre></td></tr></table></figure>

<p>2.C++11中支持使用auto来自动推断new创建的类型：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> p1 = <span class="keyword">new</span> <span class="built_in">auto</span>(obj);  <span class="comment">//p指向一个与obj类型相同的对象，该对象用obj进行初始化</span></span><br></pre></td></tr></table></figure>

<p>3.可以动态分配const对象：  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> *pci = <span class="keyword">new</span> <span class="type">const</span> <span class="built_in">int</span>(<span class="number">1024</span>);</span><br></pre></td></tr></table></figure>

<p>4.默认情况下如果自由空间已经被耗尽，使用new分配失败时会抛出bad_alloc，可以增加nothrow参数来禁止抛出异常，而是返回一个空指针。bad_alloc和nothrow都定义在头文件new中。eg:  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> *p1 = <span class="keyword">new</span> <span class="type">int</span>;  <span class="comment">//如果分配失败，new抛出std::bad_alloc</span></span><br><span class="line"><span class="type">int</span> *p1 = <span class="built_in">new</span> (nothrow) <span class="type">int</span>;  <span class="comment">//如果分配失败，new返回一个空指针</span></span><br></pre></td></tr></table></figure>

<p>5.释放一块并非new分配的内存，或者将相同的指针值释放多次，其行为都是未定义的。但可以释放一个const动态对象。  </p>
<p>6.由内置指针（而非智能指针）管理的动态内存在被显式释放前一直都会存在，所以在函数内创建的局部指针变量，在离开函数前一定要释放，因为一旦离开函数，该指针变量将不可访问，也就无法再释放分配的动态内存。  </p>
<p>7.动态内存常见出错原因：  </p>
<ul>
<li>忘记delete内存  </li>
<li>使用已经释放掉的对象  </li>
<li>同一块内存释放两次  </li>
</ul>
<p>坚持只使用智能指针即可避免这些问题  </p>
<p>8.对于delete之后的指针，该指针值会变成无效指针，但该指针变量本身依然存在，且它指向一个无效的内存地址，该指针成为空悬指针（dangling pointer），可以通过将nullptr赋给空悬指针来避免由于引用该指针而引起的非法内存地址访问问题。这种方式只提供了非常有限的保护，最好还是使用智能指针。  </p>
<p>9.shared_ptr可以和new结合使用，由于接受指针参数的智能指针构造函数是explicit的，所以不能将一个内置指针隐匿转换为一个智能指针，必须使用直接初始化形式。eg:  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">shared_ptr&lt;<span class="type">int</span>&gt; p1 = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">1024</span>);  <span class="comment">//错误，必须使用直接初始化，而不是隐式转换</span></span><br><span class="line"><span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p2</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">1024</span>))</span></span>;  <span class="comment">//正确：使用直接初始化形式</span></span><br><span class="line"><span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">clone</span><span class="params">(<span class="type">int</span> p)</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">int</span>(p); &#125;  <span class="comment">//错误，隐式转换为shared_ptr&lt;int&gt;</span></span><br><span class="line"><span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">clone</span><span class="params">(<span class="type">int</span> p)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">shared_ptr</span>&lt;<span class="type">int</span>&gt;(<span class="keyword">new</span> <span class="built_in">int</span>(p)); <span class="comment">//正确：显式地调用int*创建shared_ptr&lt;int&gt;</span></span><br></pre></td></tr></table></figure>

<p>10.当将一个shared_ptr绑定到new创建普通指针时，就将内存管理的责任交给了shared_ptr，我们不应该再使用内置指针来访问shared_ptr所指向的内存。  </p>
<p>10.shared_ptr的get()函数可以返回一个内置指针，此函数仅在我们需要向不能使用智能指针的代码传递一个内置指针时使用，使用get返回的指针的代码不能delete些指针。永远不要用get初始化另一个智能指针或者为另一个智能指针赋值。  </p>
<p>21.shared_ptr的reset()函数和unique函数通常一起使用来控制多个shared_ptr共享的对象。eg:  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!p.<span class="built_in">unique</span>())</span><br><span class="line">    p.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">string</span>(*p));  <span class="comment">//我们不是唯一用户，分配新的拷贝</span></span><br><span class="line">*p += newVal;  <span class="comment">//现在我们知道自己是唯一的用户，可以改变对象的值</span></span><br></pre></td></tr></table></figure>

<p>22.函数的退出有两可能：正常处理结束或者发生了异常，无论哪种情况，由于局部对象都会被销毁，所以使用智能指针管理动态内存时内存都会被释放掉，但使用内置指针在对应的delete之前内存不会被释放。  </p>
<p>23.shared_ptr默认是使用delete来释放需要被释放的动态内存。可以在初始化shared_ptr为其传递一个删除器（deleter）来完成对不是new分配的内存的释放。eg:  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">end_connection</span><span class="params">(connection *p)</span> </span>&#123;<span class="built_in">disconnect</span>(*p);&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(destination &amp;d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  connection c = <span class="built_in">connect</span>(&amp;d);</span><br><span class="line">  <span class="function">shared_ptr&lt;connection&gt; <span class="title">p</span><span class="params">(&amp;c, end_connection)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>24.智能指针陷阱：  </p>
<ul>
<li>不使用相同的内置指针值初始（或reset）多个智能指针  </li>
<li>不delete get()返回的指针  </li>
<li>不使用get()初始化或reset另一个智能指针  </li>
<li>如果使用get()返回的指针，记住当最后一个对应的智能指针销毁后，该指针就变为无效了。  </li>
<li>如果你使用智能指针管理的资源不是new分配的内存，记住传递给它一个删除器。  </li>
</ul>
<h2 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h2><p>25.一个unique_ptr“拥有”它所指向的对象，与shared_ptr不同，某个时刻只能有一个unique_ptr指向一个给定的对象，当unique_ptr被销毁时，它所指向的对象也被销毁。且unique_ptr没有类似make_shared的标准库函数返回一个unique_ptr，只能通过将其绑定到一个new返回的指针上，且必须采用直接初始化形式：  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">unique_ptr&lt;string&gt; p1;  <span class="comment">//可以指向一个string的unique_ptr</span></span><br><span class="line"><span class="function">unique_ptr&lt;string&gt; <span class="title">p2</span><span class="params">(<span class="keyword">new</span> string(<span class="string">&quot;hi&quot;</span>))</span></span>;  <span class="comment">//p2指向一个值为&quot;hi&quot;的string</span></span><br></pre></td></tr></table></figure>

<p>26.由于unique_ptr拥有它指向的对象，所以它不支持普通拷贝或赋值操作，但可以通过调用release和reset来将指针所有权从一个（非const）unique_ptr转移给另一个unique。eg:  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">unique_ptr&lt;string&gt; <span class="title">p2</span><span class="params">(p1.release())</span></span>; <span class="comment">//release将p1置为空，并将所有权由p1转移给p2</span></span><br><span class="line"><span class="function">unique_ptr&lt;string&gt; <span class="title">p3</span><span class="params">(<span class="keyword">new</span> string(<span class="string">&quot;hello&quot;</span>))</span></span>;  </span><br><span class="line">p2.<span class="built_in">reset</span>(p3.<span class="built_in">release</span>()); <span class="comment">//reset释放了p2原来指向的内存，并将p3原拥有的所有权转移给p2</span></span><br></pre></td></tr></table></figure>

<p>27.不能拷贝unique_ptr的规则有一个例外：我们可以拷贝或赋值一个将要被销毁的unique_ptr，最常见的就是从函数返回一个unique_ptr：  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">clone</span><span class="params">(<span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">unique_ptr</span>&lt;<span class="type">int</span>&gt;(<span class="keyword">new</span> <span class="built_in">int</span>(p));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//或者返回一个局部对象的拷贝</span></span><br><span class="line"><span class="function">unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">clone</span><span class="params">(<span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">  <span class="function">unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">ret</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(p))</span></span>;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>28.可以向unique_ptr传递删除器，但它的删除器必须在尖括号中提供删除器类型，形如：<code>unique_ptr&lt;objT, delT&gt; p (new objT, fcn);</code>  </p>
<h2 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h2><p>29.weak_ptr是一种不控制所指向对象生存期的智能指针，它指向一个shared_ptr管理的对象，将一个weak_ptr绑定到一个shared_ptr不会改变shared_ptr的引用计数，一旦最后一个指向对象的shared_ptr被销毁，则对象就会被释放，与weak_ptr是否指向它无关。创建weak_ptr时需要使用shared_ptr来初始化它，weak_ptr支持将一个shared_ptr赋值给一个weak_ptr：  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> p = <span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">42</span>);</span><br><span class="line"><span class="function">weak_ptr&lt;<span class="type">int</span>&gt; <span class="title">wp</span><span class="params">(p)</span></span>;  <span class="comment">//wp弱共享p；p的引用计数未改变</span></span><br><span class="line">weak_ptr&lt;<span class="type">int</span>&gt; wp1 = p;</span><br></pre></td></tr></table></figure>

<p>30.weak_ptr通常用于核查类，相当于可以放置一个类来监视当前shared_ptr的引用状态，因为它不会对shared_ptr所指向对象的生命周期产生影响。weak_ptr除了支持使用shared_ptr初始化，以及赋值外操作外，还支持以下操作：  </p>
<ul>
<li>w.reset()  将w置为空</li>
<li>w.use_count() 与w共享对象的shared_ptr的数量</li>
<li>w.expired()   若w.use_count()为0，返回true，否则返回false</li>
<li>w.lock()  如果expired为true，返回一个空shared_ptr，否则返回一个指向w的对象的shared_ptr  </li>
</ul>
<p>weak_ptr的使用详解<a href="http://stackoverflow.com/questions/12030650/when-is-stdweak-ptr-useful">http://stackoverflow.com/questions/12030650/when-is-stdweak-ptr-useful</a>  </p>
<h2 id="动态数组"><a href="#动态数组" class="headerlink" title="动态数组"></a>动态数组</h2><p>1.大多数应用应该使用标准库容器而不是动态分配的数组，使用容器更为简单、更不容易出错，并且可能有更好的性能。  </p>
<h2 id="new和数组"><a href="#new和数组" class="headerlink" title="new和数组"></a>new和数组</h2><p>1.使用new分配要求数量的对象并返回指向第一个对象的指针：<code>int *pa = new int[get_size()];</code><br>方括号中的大小必须是整型，但不必是常量。<br>分配一个数组会得到一个元素类型的指针，该指针指向所分配的数组的第一个元素，并不是返回一个数组类型的对象。  </p>
<p>2.默认情况下，new分配的对象，不管是单个分配的还是数组中的，都是默认初始化的。可以使用如下3种方式对数组进行初始化：  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> *pi = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>];  <span class="comment">//10个未初始化的int</span></span><br><span class="line"><span class="type">int</span> *pi2 = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>]();  <span class="comment">//10个值初始化为0的int</span></span><br><span class="line">string *ps = <span class="keyword">new</span> string[<span class="number">10</span>];  <span class="comment">//10个空string</span></span><br><span class="line">string *ps2 = <span class="keyword">new</span> string[<span class="number">10</span>]();  <span class="comment">//10个空string</span></span><br><span class="line"><span class="comment">//C++11支持的初始化方式  </span></span><br><span class="line"><span class="type">int</span> *pi3 = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>]&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;  <span class="comment">//10个int，前4个使用列表初始化，剩下的使用值初始化</span></span><br></pre></td></tr></table></figure>
<p>如果初始化列表的元素数目大于数组元素数目，new会失败，且不分配任何内存<br>不能使用auto分配数组  </p>
<p>3.动态分配一个空数组是合法的。即当我们用new分配一个大小为0的数组时，new返回一个合法的非空指针，此指针与其他任何指针都不同，类似于尾后指针，可以像使用尾后指针一样使用它，但不能对它解引用。  </p>
<p>4.释放动态数组使用<code>delete [] p;</code>，中括号不能省略，delete一个数组指针时忘了方括号，或者在delete一个单一对象时使用了方括号，行为都是未定义的。  </p>
<p>5.标准库中的unique_ptr可以与new配合使用来管理动态数组，unique_ptr声明时必须在对象后面跟一对空方括号，unique_ptr指向数组时，不支持成员访问运算符（点和箭头），毕竟unique_ptr指向的是一个数组而不是单个对象。但支持下标操作。  ：  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">unique_ptr&lt;<span class="type">int</span>[]&gt; <span class="title">up</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>])</span></span>;  <span class="comment">//up指向一个包含10个未初始化int的数组  </span></span><br><span class="line">up.<span class="built_in">release</span>();  <span class="comment">//自动使用delete[]销毁其指针。  </span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i != <span class="number">10</span>; ++i)</span><br><span class="line">  up[i] = i;  <span class="comment">//为每个元素赋予一个新值</span></span><br></pre></td></tr></table></figure>

<p>6.当使用shared_ptr与new一起使用时，由于shared_ptr不支持直接管理动态数组，所以必须提供自已定义的删除器，且不支持下标操作，只能使用get获取一个内置指针：  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">shared_ptr&lt;<span class="type">int</span>[]&gt; <span class="title">sp</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>], [](<span class="type">int</span> *p)&#123; <span class="keyword">delete</span>[] p; &#125;)</span></span>; </span><br><span class="line">sp.<span class="built_in">reset</span>();  <span class="comment">//会使用提供的lambda释放数组，即delete[]</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i != <span class="number">10</span>; ++i)</span><br><span class="line">  *(sp.<span class="built_in">get</span>() + i) = i;  <span class="comment">//使用get获取一个内置指针  </span></span><br></pre></td></tr></table></figure>

<h2 id="allocator类"><a href="#allocator类" class="headerlink" title="allocator类"></a>allocator类</h2><p>使用allocator类来管理动态内存更方便，速度可能会更快。<br>1.标准库allocator类定义在头文件memory中，是一个模板类，它帮助我们将内存分配和对象构造分享开来，它提供一种类型感知的内存分配方法，它分配的内存是原始的，未构造的。allocator定义的方式：  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">allocator&lt;string&gt; alloc;                <span class="comment">//可以分配string的allocator对象</span></span><br><span class="line"><span class="keyword">auto</span> <span class="type">const</span> p = alloc.<span class="built_in">allocate</span>(n);       <span class="comment">//分配n个未初始化的string</span></span><br></pre></td></tr></table></figure>

<p>2.allocator支持的操作：  </p>
<ul>
<li>allocator<T> a        //定义一个名为a的allocator对象，它可以为类型为T的对象分配内存</li>
<li>a.allocate(n)         //分配一段原始的、未构造的内存，保存n个类型为T的对象  </li>
<li>a.deallocate(p, n)    //释放T*指针p中地址开始的内存，这块内存保存了n个类型为T的对象；p必须是一个先前由allocate返回的指针，且n必须是p创建时所要求的大小。在调用deallocate之前，用户必须对每个在这块内存中创建的对象调用destroy。  </li>
<li>a.construct(p, args)  //p必须是一个类型为T*的指针，指向一块原始内存。arg将被传递给类型为T的构造函数，用来在p指向的内存中构造一个对象  </li>
<li>a.destroy(p)          //p为T*类型的指针，该函数对p指向的对象执行析构函数  </li>
</ul>
<p>3.使用allocator的典型方式是：  </p>
<ul>
<li>1.声明指定类型的allocator对象alloc  </li>
<li>2.使用alloc调用alloc.allocate(n)函数分配可以创建n个指定对象的原始内存</li>
<li>3.使用alloc调用alloc.construct(q, args)在原始内存中构造对象  </li>
<li>4.使用alloc对每个对象调用alloc.destroy(p)来销毁它们  </li>
<li>5.使用alloc调用alloc.deallocate(p, n)释放内存，p必须指向所分配内存的第一个位置    </li>
</ul>
<p>使用未构造的内存，其行为是未定义的  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">allocator&lt;string&gt; alloc;                <span class="comment">//可以分配string的allocator对象</span></span><br><span class="line"><span class="keyword">auto</span> <span class="type">const</span> p = alloc.<span class="built_in">allocate</span>(n);       <span class="comment">//分配n个未初始化的string</span></span><br><span class="line"><span class="keyword">auto</span> q = p;  <span class="comment">//q始终指向最后构造的元素之后的位置  </span></span><br><span class="line">alloc.<span class="built_in">construct</span>(q++);  <span class="comment">//*q为空字符串</span></span><br><span class="line">alloc.<span class="built_in">construct</span>(q++, <span class="number">10</span>, <span class="string">&#x27;c&#x27;</span>);  <span class="comment">//*q为ccccccccc</span></span><br><span class="line">alloc.<span class="built_in">construct</span>(q++, <span class="string">&quot;hi&quot;</span>);  <span class="comment">//*q为hi</span></span><br><span class="line"><span class="comment">/*使用该内存中的对象*/</span></span><br><span class="line"><span class="keyword">while</span> (q != p)  </span><br><span class="line">  alloc.<span class="built_in">destroy</span>(--q);  <span class="comment">//释放我们真正构造的string</span></span><br><span class="line">alloc.<span class="built_in">deallocate</span>(p, n); <span class="comment">//释放内存，将其归还给系统  </span></span><br></pre></td></tr></table></figure>

<p>4.标准库为allocator类定义了两个伴随算法，他们可以拷贝和填充未初始的内存。分别是uninitialized_copy(begin, end, b2)，uninitialized_copy_n(begin, n, b2) 和 uninitialized_fill(begin, end, t)，uninitialized_fill_n(begin, n, t)。<br>一次uninitialized_copy的调用会返回一个指针，该指针指向最后一个构造的元素之后的位置。  </p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>CPP</tag>
      </tags>
  </entry>
  <entry>
    <title>GDB调试详解</title>
    <url>/2016/03/19/gdb/</url>
    <content><![CDATA[<h1 id="关于"><a href="#关于" class="headerlink" title="关于"></a>关于</h1><p>使用<code>gcc</code>或<code>g++</code>编译程序时加上<code>-g</code>参数即可将调试信息加入生成的目标文件，否则使用gdb调试时函数名、变量名都只能显示内存地址。直接运行<code>gdb</code>即可进入gdb，然后输入<code>file a.out</code>即可开始调试a.out，当然也可以直接<code>gdb a.out</code>进入<code>a.out</code>的调试状态。可以使用在命令行状态下使用<code>gdb -help</code>来查看帮助，当然也可以用man。在gdb调试状态下使用help可心获得更强大的帮助，类似vim中的帮助，gdb调试状态下使用<code>help step</code>即可查看单步调试相关的帮助。gdb状态下使用<code>quit</code>退出gdb。进入GDB时可以使用可选参数<code>-tui</code>进入GDB的文本用户界面，该界面可以分屏显示源代码及断点所在行，比使用list查看代码方便很多，而且支持使用上下键来滚动显示代码，此时的命令行历史切换需要使用ctrl+n和ctrl+p。当然有一些支持GDB调试的图形软件ddd和code::block。</p>
<h1 id="GDB基本用法"><a href="#GDB基本用法" class="headerlink" title="GDB基本用法"></a>GDB基本用法</h1><span id="more"></span>

<ol>
<li><code>$gdb app -tui</code>：进入调试状态<br>选择一种方式进入gdb，例如<code>$gdb app -tui</code>或者<code>$gdb -tui</code>和<code>(gdb)file app</code>，当然也可以执行程序之后再启动gdb，然后使用指定pid的方式 调试，此处<code>$</code>和<code>(gdb)</code>分别表示bash上的命令行前导符和gdb运行时的前导符  </li>
<li><code>(gdb)break main</code>或<code>(gdb)b N</code>：添加断点<br>在main函数所在行添加断点，当然可以使用<code>(gdb)b 20</code>在第20行添加断点。  </li>
<li><code>(gdb)run args-list</code>：运行调试程序<br>运行程序，run后面可以跟想要传递给所有调试的程序的参数列表。当然可以<code>(gdb)r</code>，即没有输入参数直接运行到断点处  </li>
<li><code>(gdb)list n1,n2</code>：显示被调试程序源代码<br>显示n1到n2行之间的程序源码。或者<code>(gdb)l</code>显示当前行和其后10行的代码  </li>
<li><code>(gdb)next N</code>或者<code>(gdb)step N</code>：单步执行<br>next将单步执行，一次运行N行，当然省略N则表示一次一行，如果当前行是一个函数，next会直接一次运行完该函数，然后继续进入下一行。而step则是单步进入执行，一次执行一行，遇到函数也会进入函数内部执行，遇到对象转到相应类的构造函数。当然这两个命令可以省略为n和s，也可以直接回车表示执行一次的命令。  </li>
<li><code>(gdb)finish</code>或<code>(gdb)until</code>：跳出当前函数或循环体<br>finish执行完当前函数后返回到调用它的函数，并给出函数返回值。例如使用step时，想跳出当前函数即可以使用finish。until在循环开始处使用会直接执行完整个循环体。    </li>
<li><code>(gdb)print var</code>或<code>(gdb)print var=5</code>：显示变量var的值，或将变量var的值修改为5<br>print后面可以是变量名也可以是函数名，还可以是历史记录，当然可以省略为p，可以显示var的状态信息，并且存放在历史记录中。历史记录以<code>$</code>开头，形如<code>$7</code>，使用<code>(gdb)p $7</code>，即可以显示<code>$7</code>中的内容。  </li>
<li><code>(gdb)info breakpoints</code>和<code>(gdb)delete N</code>：显示所以断点和删除断点号为N的断点<br>可以省略为<code>(gdb)i b</code>和<code>(gdb)d N</code></li>
<li><code>(gdb)watch var</code>和<code>(gdb)info watch</code>：监视变量var的值和查看当前所有监视信息<br>当变量var的值变化时显示var的值并暂停程序执行，后面一个命令可以省略为<code>i watch</code>，显示的信息也会跟<code>i b</code>一样带有一个序号，可以使用<code>d N</code>来删除监视对象    </li>
<li><code>(gdb)continue</code>和<code>kill</code>：继续运行程序到下一个断点处和停止本次调试</li>
</ol>
<p>以下是GDB详细用法：  </p>
<h1 id="GDB重要提示"><a href="#GDB重要提示" class="headerlink" title="GDB重要提示"></a>GDB重要提示</h1><ul>
<li>首先编译时必须带上参数<code>-g</code>，如<code>g++ a.cpp -o a -g -std=c++11</code>，这样才能在可执行程序中生成调试信息，以供GDB使用 </li>
<li>不能使用编译优化参数，例如<code>-O</code>或者<code>-O2</code>，由于这些优化参数为了提高性能会重新安排程序执行操作，导致调试信息与源码不匹配 </li>
<li>GDB内部可以使用<code>! command</code>或<code>shell command</code>来执行shell命令  </li>
<li>GDB内部可以使用<code>TAB</code>键进行自动补全，例如<code>info bre</code>+TAB会自动输入命令<code>info breakpoints</code></li>
<li>GDB内部可以使用很多缩写，只要缩写的匹配是唯一的，例如<code>info bre</code>+回车，相当于执行了<code>info breakpoints</code>+回车  </li>
<li>GDB内部使用<code>ctrl+c</code>可以在当前位置处暂停执行正在执行的程序，例如当循环很大或者死循环时又不想退出调试时  </li>
</ul>
<h1 id="GDB传递命令行参数"><a href="#GDB传递命令行参数" class="headerlink" title="GDB传递命令行参数"></a>GDB传递命令行参数</h1><p><code>gdb test</code> 进入调试之后</p>
<p>可以使用以下两种方法输入命令行参数：</p>
<ul>
<li><code>run &lt;命令行参数&gt;</code></li>
<li><code>set args</code>&lt;命令行参数&gt;`</li>
</ul>
<h1 id="GDB所有可用的命令行参数"><a href="#GDB所有可用的命令行参数" class="headerlink" title="GDB所有可用的命令行参数"></a>GDB所有可用的命令行参数</h1><p><strong>调试可执行程序</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gdb &lt;name-of-excutable&gt;</span><br></pre></td></tr></table></figure>

<p><strong>调试带有core文件的可执行程序</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gdb -e &lt;name-of-excutable&gt; -c &lt;name-of-core-file&gt;</span><br></pre></td></tr></table></figure>

<p><strong>调试进程</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gdb &lt;name-of-excutable&gt; --pid=&lt;process-id&gt; # 或者 gdb &lt;name-of-excutable&gt; -p [pid]</span><br></pre></td></tr></table></figure>

<p>可以使用<code>ps -auxw</code>来列出当前正在运行的进程，或者直接<code>pgrep &lt;进程名&gt;</code></p>
<p><strong>调试多线程</strong><br><code>info threads</code> 显示当前可调试的所有线程，每个线程会有一个GDB为其分配的ID，后面操作线程的时候会用到这个ID。 前面有*的是当前调试的线程。</p>
<p><code>thread ID</code> 切换当前调试的线程为指定ID的线程。</p>
<p><code>break thread_test.c:123 thread all</code> 在所有线程中相应的行上设置断点</p>
<p><code>thread apply ID1 ID2 command</code> 让一个或者多个线程执行GDB命令command。 </p>
<p><code>thread apply all command</code> 让所有被调试线程执行GDB命令command。</p>
<p><code>set scheduler-locking off|on|step</code> 估计是实际使用过多线程调试的人都可以发现，在使用step或者continue命令调试当前被调试线程的时候，<br>其他线程也是同时执行的，怎么只让被调试程序执行呢？通过这个命令就可以实现这个需求。off 不锁定任何线程，也就是所有线程都执行，这是默认值。 on 只有当前被调试程序会执行。 step 在单步的时候，除了next过一个函数的情况(熟悉情况的人可能知道，这其实是一个设置断点然后continue的行为)以外，只有当前线程会执行。</p>
<p><strong>调试多进程</strong><br>使用gdb调试多进程时，如果想要在进程间进行切换，那么就需要在fork调用前设置： <code>set detach-on-fork off</code> ，然后使用 <code>info inferiors</code> 来查看进程信息，得到的信息可以看到最前面有一个进程编号，使用 <code>inferior num</code> 来进行进程切换。<br>那么为什么要使用 <code>set detache-on-fork off</code> 呢？它的意思是在调用fork后相关进程的运行行为是怎么样的，是<code>detache on/off</code> 也就是说分离出去独立运行，不受gdb控制还是不分离，被阻塞住。<br>这里还涉及到一个设置 <code>set follow-fork-mode [parents/child]</code> ,就是fork之后，gdb的控制落在谁身上，如果是父进程，那么分离的就是子进程，反之亦然。如果<code>detache-on-fork</code>被off了，那么未受控的那个进程就会被阻塞住，进程状态为T，即处于调试状态。 </p>

      <p> GDB可选的命令行参数: (version 6. 老版本使用一个短划线 "-") </p>
      <dl>
        <dd>
          <table border="1">

            <tbody>
              <tr bgcolor="#c0c0c0">
                <th>Option</th>
                <th>Description</th>
              </tr>

              <tr>
                <td valign="top">--help<br /> -h</td>
                <td valign="top">List command line arguments</td>
              </tr>

              <tr>
                <td valign="top">--exec=<i>file-name</i><br /> -e <i>file-name</i></td>
                <td valign="top">Identify executable associated with core file.</td>
              </tr>

              <tr>
                <td valign="top">--core=<i>name-of-core-file</i><br /> -c <i>name-of-core-file</i></td>
                <td valign="top">Specify core file.</td>
              </tr>

              <tr>
                <td valign="top">--command=<i>command-file</i><br />
-x <i>command-file</i></td>
                <td valign="top">File listing GDB commands to perform. Good for automating set-up.</td>
              </tr>

              <tr>
                <td valign="top">--directory=<i>directory</i><br />
-d <i>directory</i></td>
                <td valign="top">Add directory to the path to search for source files.</td>
              </tr>

              <tr>
                <td valign="top">--cd=<i>directory</i></td>
                <td valign="top">Run GDB using specified directory as the current working directory.</td>
              </tr>

              <tr>
                <td valign="top">--nx<br />
-n</td>
                <td valign="top">Do not  execute  commands  from <tt>~/.gdbinit</tt> initialization file. 
                Default is to look at this file and execute the list of commands.</td>
              </tr>

              <tr>
                <td valign="top">--batch -x <i>command-file</i></td>
                <td valign="top">Run in batch (not interactive) mode. Execute commands from file. Requires <tt>-x</tt> option.</td>
              </tr>

              <tr>
                <td valign="top">--symbols=<i>file-name</i><br />
-s <i>file-name</i></td>
                <td valign="top">Read symbol table from file file.</td>
              </tr>

              <tr>
                <td valign="top">--se=<i>file-name</i></td>
                <td valign="top">Use FILE as symbol file and executable file.</td>
              </tr>

              <tr>
                <td valign="top">--write</td>
                <td valign="top">Enable writing into executable and core files.</td>
              </tr>

              <tr>
                <td valign="top">--quiet<br />
-q</td>
                <td valign="top">Do not print the  introductory  and  copyright messages.</td>
              </tr>

              <tr>
                <td valign="top">--tty=<i>device</i></td>
                <td valign="top">Specify <i>device</i> for running program's standard input and output.</td>
              </tr>

              <tr>
                <td valign="top">--tui</td>
                <td valign="top">Use a terminal user interface. Console curses based GUI interface for GDB. Generates a source and debug console area.</td>
              </tr>

              <tr>
                <td valign="top">--pid=<i>process-id</i><br /> -p <i>process-id</i></td>
                <td valign="top">Specify process ID number to attach to.</td>
              </tr>

              <tr>
                <td valign="top">--version</td>
                <td valign="top">Print version information and then exit.</td>
              </tr>

            </tbody>
          </table>

        </dd>
      </dl>


<h1 id="GDB常用调试命令"><a href="#GDB常用调试命令" class="headerlink" title="GDB常用调试命令"></a>GDB常用调试命令</h1><p>GDB运行时在GDB内部使用的命令</p>
<h2 id="帮助和查看信息命令"><a href="#帮助和查看信息命令" class="headerlink" title="帮助和查看信息命令"></a>帮助和查看信息命令</h2>
          <table border="1">

            <tbody>
              <tr bgcolor="#c0c0c0">
                <th>Command</th>
                <th>Description</th>
              </tr>

              <tr>
                <td valign="top">help</td>
                <td valign="top">List gdb command topics.</td>
              </tr>

              <tr>
                <td valign="top">help <i>topic-classes</i></td>
                <td valign="top">List gdb command within class.</td>
              </tr>

              <tr>
                <td valign="top">help <i>command</i></td>
                <td valign="top">Command description. <br/>eg <tt>help show</tt> to list the show commands</td>
              </tr>

              <tr>
                <td valign="top">apropos <i>search-word</i></td>
                <td valign="top">Search for commands and command topics containing <i>search-word</i>.</td>
              </tr>

              <tr>
                <td valign="top">info args<br /> i args</td>
                <td valign="top">List program command line arguments</td>
              </tr>

              <tr>
                <td valign="top">info breakpoints</td>
                <td valign="top">List breakpoints</td>
              </tr>

              <tr>
                <td valign="top">info break</td>
                <td valign="top">List breakpoint numbers.</td>
              </tr>

              <tr>
                <td valign="top">info break <i>breakpoint-number</i></td>
                <td valign="top">List info about specific breakpoint.</td>
              </tr>

              <tr>
                <td valign="top">info watchpoints</td>
                <td valign="top">List breakpoints</td>
              </tr>

              <tr>
                <td valign="top">info registers</td>
                <td valign="top">List registers in use</td>
              </tr>

              <tr>
                <td valign="top">info threads</td>
                <td valign="top">List threads in use</td>
              </tr>

              <tr>
                <td valign="top">info set</td>
                <td valign="top">List set-able option</td>
              </tr>
            </tbody>
          </table>



<h2 id="断点和监视命令"><a href="#断点和监视命令" class="headerlink" title="断点和监视命令"></a>断点和监视命令</h2>
    <table>
      <tbody>
              <tr bgcolor="#c0c0c0">
                <th>Break and Watch </th>
                <th><br />
                </th>
              </tr>

              <tr>
                <td valign="top">break <i>funtion-name</i><br />break <i>line-number</i><br /><tt>break <i>ClassName::functionName</i></tt></td>
                <td valign="top">Suspend program at specified function of line number.</tt></td>
              </tr>

              <tr>
                <td valign="top">break +<i>offset</i><br />
break -<i>offset</i></td>
                <td valign="top">Set a breakpoint specified number of lines forward or back from the position at which execution stopped.</td>
              </tr>

              <tr>
                <td valign="top">break <i>filename:function</i></td>
                <td valign="top">Don't specify path, just the file name and function name.</td>
              </tr>

              <tr>
                <td valign="top">break <i>filename:line-number</i></td>
                <td valign="top">Don't specify path, just the file name and line number.<br /><tt>break <i>Directory/Path/filename</i>.cpp:62</tt></td>
              </tr>

              <tr>
                <td valign="top">break *<i>address</i></td>
                <td valign="top">Suspend processing at an instruction address. Used when you do not have source.</td>
              </tr>

              <tr>
                <td valign="top">break <i>line-number</i> if <i>condition</i></td>
                <td valign="top">Where condition is an expression. i.e. <tt>x &gt; 5</tt><br />
Suspend when boolean expression is true.</td>
              </tr>

              <tr>
                <td valign="top">break <i>line</i> thread <i>thread-number</i></td>
                <td valign="top">Break in thread at specified line number. Use <tt>info threads</tt> to display thread numbers.</td>
              </tr>

              <tr>
                <td valign="top">tbreak</td>
                <td valign="top">Temporary break. Break once only. Break is then removed. See "break" above for options.</td>
              </tr>

              <tr>
                <td valign="top">watch <i>condition</i></td>
                <td valign="top">Suspend processing when condition is met. i.e. <tt>x &gt; 5</tt></td>
              </tr>

              <tr>
                <td valign="top">clear<br /> clear <i>function</i><br /> clear <i>line-number</i></td>
                <td valign="top">Delete breakpoints as identified by command option.<br/>Delete all breakpoints in <i>function</i><br/>Delete breakpoints at a given line</td>
              </tr>

              <tr>
                <td valign="top">delete<br />
d</td>
                <td valign="top">Delete all breakpoints, watchpoints, or catchpoints.</td>
              </tr>

              <tr>
                <td valign="top">delete <i>breakpoint-number</i><br />
delete <i>range</i></td>
                <td valign="top">Delete the breakpoints, watchpoints, or catchpoints of the breakpoint ranges specified as arguments.</td>
              </tr>

              <tr>
                <td valign="top">disable <i>breakpoint-number-or-range</i><br />
enable <i>breakpoint-number-or-range</i></td>
                <td valign="top">Does not delete breakpoints. Just enables/disables them.<br />
Example:<br />
Show breakpoints: <tt>info break</tt><br />
Disable: <tt>disable 2-9</tt></td>
              </tr>

              <tr>
                <td valign="top">enable <i>breakpoint-number</i> once</td>
                <td valign="top">Enables once</td>
              </tr>

              <tr>
                <td valign="top">continue<br />
c</td>
                <td valign="top">Continue executing until next break point/watchpoint.</td>
              </tr>

              <tr>
                <td valign="top">continue <i>number</i></td>
                <td valign="top">Continue but ignore current breakpoint <i>number</i> times. 
                Usefull for breakpoints within a loop.</td>
              </tr>

              <tr>
                <td valign="top">finish</td>
                <td valign="top">Continue to end of function.</td>
		</tr>
		</tbody>
          </table>



<h2 id="单步执行相关命令"><a href="#单步执行相关命令" class="headerlink" title="单步执行相关命令"></a>单步执行相关命令</h2>
          <table>
            <tbody>
              <tr bgcolor="#c0c0c0">
                <th>Line Execution </th>
                <th><br />
                </th>
              </tr>

              <tr>
                <td valign="top">step<br />
s<br />
step <i>number-of-steps-to-perform</i></td>
                <td valign="top">Step to next line of code. Will step into a function.</td>
              </tr>

              <tr>
                <td valign="top">next<br />
n<br />
next <i>number</i></td>
                <td valign="top">Execute next line of code. Will not enter functions. </td>
              </tr>

              <tr>
                <td valign="top">until<br />
until <i>line-number</i></td>
                <td valign="top">Continue processing until you reach a
specified line number. 
                Also: function name, address, filename:function or filename:line-number.</td>
              </tr>

              <tr>
                <td valign="top">info signals<br />
info handle<br />
handle <i>SIGNAL-NAME</i> <i>option</i></td>
                <td valign="top">Perform the following option when signal recieved: nostop, stop, print, noprint, pass/noignore or nopass/ignore</td>
              </tr>

              <tr>
                <td valign="top">where</td>
                <td valign="top">Shows current line number and which function you are in.</td>
              </tr>
            </tbody>
          </table>



<h2 id="查看堆栈信息命令"><a href="#查看堆栈信息命令" class="headerlink" title="查看堆栈信息命令"></a>查看堆栈信息命令</h2>
          <table>
            <tbody>
              <tr bgcolor="#c0c0c0">
                <th>Stack </th>
                <th><br />
                </th>
              </tr>

              <tr>
                <td valign="top">backtrace<br />
bt<br />
bt <i>inner-function-nesting-depth</i><br />
bt -<i>outer-function-nesting-depth</i></td>
                <td valign="top">Show trace of where you are currently. Which functions you are in. Prints stack backtrace.</td>
              </tr>

              <tr>
                <td valign="top">backtrace full</td>
                <td valign="top">Print values of local variables.</td>
              </tr>

              <tr>
                <td valign="top">frame<br/>frame <i>number</i><br />
f <i>number</i></td>
                <td valign="top">Show current stack frame (function where you are stopped)<br/>Select frame number. (can also user up/down to navigate frames)</td>
              </tr>

              <tr>
                <td valign="top">up<br/>down<br/>up <i>number</i><br />
down <i>number</i></td>
                <td valign="top">Move up a single frame (element in the call stack)<br/>Move down a single frame<br/>Move up/down the specified number of frames in the stack.</td>
              </tr>

              <tr>
                <td valign="top">info frame</td>
                <td valign="top">List address, language, address of arguments/local variables and which registers were saved in frame.</td>
              </tr>

              <tr>
                <td valign="top">info args<br />
info locals<br />
info catch</td>
                <td valign="top">Info arguments of selected frame, local variables and exception handlers.</td>
              </tr>
            </tbody>
          </table>



<h2 id="查看源代码相关信息命令"><a href="#查看源代码相关信息命令" class="headerlink" title="查看源代码相关信息命令"></a>查看源代码相关信息命令</h2>
          <table>
            <tbody>
              <tr bgcolor="#c0c0c0">
                <th>Source Code </th>
                <th><br />
                </th>
              </tr>

              <tr>
                <td valign="top">
list<br />
l<br />
list <i>line-number</i><br />
list <i>function</i><br />
list -<br />
list <i>start#,end#</i><br />
list <i>filename:function</i></td>
                <td valign="top">List source code.</td>
              </tr>

              <tr>
                <td valign="top">set listsize <i>count</i><br />
show listsize</td>
                <td valign="top">Number of lines listed when <tt>list command given.</tt></td>
              </tr>

              <tr>
                <td valign="top">directory <i>directory-name</i><br />
dir <i>directory-name</i><br />
show directories</td>
                <td valign="top">Add specified directory to front of source code path.</td>
              </tr>

              <tr>
                <td valign="top">directory</td>
                <td valign="top">Clear sourcepath when nothing specified.</td>
              </tr>
            </tbody>
          </table>



<h2 id="查看机器代码相关命令"><a href="#查看机器代码相关命令" class="headerlink" title="查看机器代码相关命令"></a>查看机器代码相关命令</h2>
          <table>
            <tbody>
 

              <tr bgcolor="#c0c0c0">
                <th>Machine Language </th>
                <th><br />
                </th>
              </tr>

              <tr>
                <td valign="top">info line<br/>info line <i>number</i></td>
                <td valign="top">Displays the start and end position in object code for the current line in source.<br/>Display position in object code for a specified line in source.</td>
              </tr>

              <tr>
                <td valign="top">disassemble <i>0xstart 0xend</i></td>
                <td valign="top">Displays machine code for positions in object code specified (can use start and end hex memory values given by the <tt>info line</tt> command.</td>
              </tr>

              <tr>
                <td valign="top">stepi<br /> si<br /> nexti<br /> ni</td>
                <td valign="top">step/next assembly/processor instruction.</td>
              </tr>

              <tr>
                <td valign="top">x <i>0xaddress</i><br/>x/nfu <i>0xaddress</i></td>
                <td valign="top">Examine the contents of memory.<br/>Examine the contents of memory and specify formatting.<ul><li>n: number of display items to print</li><li>f: specify the format for the output</li><li>u: specify the size of the data unit (eg. byte, word, ...)</li></ul>Example: <tt>x/4dw var</tt>
</td>
              </tr>
            </tbody>
          </table>



<h2 id="测试变量信息的相关命令"><a href="#测试变量信息的相关命令" class="headerlink" title="测试变量信息的相关命令"></a>测试变量信息的相关命令</h2>
          <table>
            <tbody>
 

              <tr bgcolor="#c0c0c0">
                <th>Examine Variables </th>
                <th><br />
                </th>
              </tr>

              <tr>
                <td valign="top">print <i>variable-name</i><br />
p <i>variable-name</i><br />
p <i>file-name::variable-name</i><br />
p '<i>file-name</i>'::<i>variable-name</i></td>
                <td valign="top">Print value stored in variable.</td>
              </tr>

              <tr>
                <td valign="top">p *<i>array-variable</i>@<i>length</i></td>
                <td valign="top">Print first # values of array specified by <i>length</i>. Good for pointers to dynamicaly allocated memory.</td>
              </tr>

              <tr>
                <td valign="top">p/x <i>variable</i></td>
                <td valign="top">Print as integer variable in hex.</td>
              </tr>

              <tr>
                <td valign="top">p/d <i>variable</i></td>
                <td valign="top">Print variable as a signed integer.</td>
              </tr>

              <tr>
                <td valign="top">p/u <i>variable</i></td>
                <td valign="top">Print variable as a un-signed integer.</td>
              </tr>

              <tr>
                <td valign="top">p/o <i>variable</i></td>
                <td valign="top">Print variable as a octal.</td>
              </tr>

              <tr>
                <td valign="top">p/t <i>variable</i><br />
x/b <i>address</i><br />
x/b &amp;<i>variable</i></td>
                <td valign="top">Print as integer value in binary. (1 byte/8bits)</td>
              </tr>

              <tr>
                <td valign="top">p/c <i>variable</i></td>
                <td valign="top">Print integer as character.</td>
              </tr>

              <tr>
                <td valign="top">p/f <i>variable</i></td>
                <td valign="top">Print variable as floating point number.</td>
              </tr>

              <tr>
                <td valign="top">p/a <i>variable</i></td>
                <td valign="top">Print as a hex address.</td>
              </tr>

              <tr>
                <td valign="top">x/w <i>address</i><br />
x/4b &amp;<i>variable</i></td>
                <td valign="top">Print binary representation of 4 bytes (1 32 bit word) of memory pointed to by address.</td>
              </tr>

              <tr>
                <td valign="top">ptype <i>variable</i><br />ptype <i>data-type</i></td>
                <td valign="top">Prints type definition of the variable or declared variable type. Helpful for viewing class or struct definitions while debugging.</td>
              </tr>
            </tbody>
          </table>



<h2 id="测试GDB模式的命令"><a href="#测试GDB模式的命令" class="headerlink" title="测试GDB模式的命令"></a>测试GDB模式的命令</h2>
          <table>
            <tbody>
 

              <tr bgcolor="#c0c0c0">
                <th>GDB Modes </th>
                <th><br />
                </th>
              </tr>

              <tr>
                <td valign="top">set <i>gdb-option</i> <i>value</i></td>
                <td valign="top">Set a GDB option</td>
              </tr>

              <tr>
                <td valign="top">set logging on<br />
set logging off<br />
show logging<br />
set logging file <i>log-file</i></td>
                <td valign="top">Turn on/off logging. Default name of file is <tt>gdb.txt</tt></td>
              </tr>

              <tr>
                <td valign="top">set print array on<br />
set print array off<br />
show print array</td>
                <td valign="top">Default is off. Convient readable format for arrays turned on/off.</td>
              </tr>

              <tr>
                <td valign="top">set print array-indexes on<br />
set print array-indexes off<br />
show print array-indexes</td>
                <td valign="top">Default off. Print index of array elements.</td>
              </tr>

              <tr>
                <td valign="top">set print pretty on<br />
set print pretty off<br />
show print pretty</td>
                <td valign="top">Format printing of C structures.</td>
              </tr>

              <tr>
                <td valign="top">set print union on<br />
set print union off<br />
show print union</td>
                <td valign="top">Default is on. Print C unions.</td>
              </tr>

              <tr>
                <td valign="top">set print demangle on<br />
set print demangle off<br />
show print demangle</td>
                <td valign="top">Default on. Controls printing of C++ names.</td>
              </tr>
            </tbody>
          </table>



<h2 id="启动和停止的相关命令"><a href="#启动和停止的相关命令" class="headerlink" title="启动和停止的相关命令"></a>启动和停止的相关命令</h2>
          <table>
            <tbody>
              <tr bgcolor="#c0c0c0">
                <th>Start and Stop </th>
                <th><br />
                </th>
              </tr>

<tr>
<td valign="top">
run<br />
r<br />
run <i>command-line-arguments</i><br />
run &lt; <i>infile</i> &gt; <i>outfile</i></td>
<td valign="top">Start program execution from the beginning of the program. 
The command <tt>break main</tt> will get you started. Also allows basic I/O redirection.</td>
</tr>

<tr>
<td valign="top">continue<br />c</td>
<td valign="top">Continue execution to next break point.</td>
</tr>

<tr>
<td valign="top">kill</td>
<td valign="top">Stop program execution.</td>
</tr>

              <tr>
                <td valign="top">quit<br />
q</td>
                <td valign="top">Exit GDB debugger.</td>
              </tr>

            </tbody>
          </table>


<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>主要参考资料：</p>
<ol>
<li><a href="http://www.yolinux.com/TUTORIALS/GDB-Commands.html">GNU GDB Debugger Command Cheat Sheet</a></li>
<li><a href="http://wiki.ubuntu.org.cn/index.php?title=%E7%94%A8GDB%E8%B0%83%E8%AF%95%E7%A8%8B%E5%BA%8F&variant=zh-cn">用GDB调试程序</a>  </li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>CPP</tag>
        <tag>gdb</tag>
      </tags>
  </entry>
  <entry>
    <title>举例详解一维数组、二维数组与指针、函数的问题</title>
    <url>/2016/03/15/array-pointer-function/</url>
    <content><![CDATA[<p>　　首先需要清楚数组名是数组首元素的地址，不管是一维还是多维，它是个常量，而指针是个可以存储地址的变量。使用时可以将数组名看成一个常量指针。<br>　　C/C++中没有内置的多维数组，多维数组是数组的数组。例如二维数组就是元素为一维数组的一维数组，此时数组名依然是数组的第一个元素的地址。<br>具体解释看代码注释及代码的运行结果。<br>　　C/C++中的函数无法返回数组，所以在使用函数操作数组时，只能通过指针或者结构体等方式来间接返回数组，当然可以返回数组名，因为数组是个地址，相当于一个常量指针。具体详解可以看SOF: <a href="http://stackoverflow.com/questions/8617889/return-a-2d-array-from-a-function">Return a 2d array from a function</a>  </p>
<span id="more"></span>

<p>以下代码为了方便查看和分析，所以只是代码片段  </p>
<h1 id="一维数组与指针"><a href="#一维数组与指针" class="headerlink" title="一维数组与指针"></a>一维数组与指针</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> ar[<span class="number">20</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;  <span class="comment">//前3个元素分别是1，2，3</span></span><br><span class="line"><span class="type">int</span> *p1 = ar; <span class="comment">//将p1指向ar数组的第一个元素的地址，指向的是数组的元素，p1+1的增量为1个元素所占的字节空间</span></span><br><span class="line"><span class="built_in">int</span> (*p2)[<span class="number">20</span>] = &amp;ar; <span class="comment">//将p2指向ar数组的地址，即指向整个数组，p2+1的增量为&amp;ar所代表的数组所占的字节空间</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;p1+1: &quot;</span> &lt;&lt; p1+<span class="number">1</span> &lt;&lt; <span class="string">&quot;\tar+1: &quot;</span> &lt;&lt; ar+<span class="number">1</span> &lt;&lt; <span class="string">&quot;\t&amp;ar[1]: &quot;</span> &lt;&lt; &amp;ar[<span class="number">1</span>] &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;*(p1+1): &quot;</span> &lt;&lt; *(p1+<span class="number">1</span>) &lt;&lt; <span class="string">&quot;\t*(ar+1): &quot;</span> &lt;&lt; *(ar+<span class="number">1</span>) &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;*p2: &quot;</span> &lt;&lt; *p2 &lt;&lt; <span class="string">&quot;\tp1: &quot;</span> &lt;&lt; p1 &lt;&lt; <span class="string">&quot;\t**p2: &quot;</span> &lt;&lt; **p2 &lt;&lt; <span class="string">&quot;\t*p1: &quot;</span> &lt;&lt; *p1 &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>
<p>p1是一个指向int型变量的指针，p1存储的地址与ar是一样的，都是数组第一个元素的地址，但p1是指针变量，ar是个常量地址，p1++等价于p1=p1+1， 但不能使用ar++。下标的操作在C++中会转化为对地址的操作，如ar[i]会被转化为<em>(ar + i), p2是一个指针，不同于int *p2[20];不加小括号时，p2会优先与后面的[20]结合，导致p2成为指针数组, 即含有20个int型指针的数组。而加了小括号p2先与</em>结合，p2成为指针，该指针指向一个含有20个int 型元素的数组，恰好与ar数组类型相同。注意ar是一个数组，数组名表示的是该数组的第一个元素的地址。 例外情况是对数组名使用sizeof运算符将获得整个数组的大小（单位是字节）。 而对数组名取地址时，得到的将是该连续20个地址空间的首地址，虽然值相同，但意义不同。 &amp;ar[0]/p1/ar表示的是一个4字节的内存块的首地址，而&amp;ar却表示20<em>4个字节的内存块首地址。 相当于此时对p1/ar加1时增加的最小单位是4个字节的连续内存空间，也就是对应第二个元素，而对&amp;ar/p2加1是毫无意义的，增加是20</em>4个字节的连续内存空间，将会越界， 可对其解引用一次得到数组第一个元素的地址，即*p2等价于p1。  </p>
<h1 id="二维数组与指针"><a href="#二维数组与指针" class="headerlink" title="二维数组与指针"></a>二维数组与指针</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::cout &lt;&lt; <span class="string">&quot;**********二维数组与指针*********&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="comment">//首先C/C++中没有内置的二维数组，多维数组是都是指数组的数组，使用时很多情况下可以视为二维数组</span></span><br><span class="line"><span class="type">int</span> arr[<span class="number">5</span>][<span class="number">6</span>] = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;&#125;; <span class="comment">//5行6列的数组，实际是一个含有5个元素的一维数组，每个元素又是一个含有6个int值的数组</span></span><br><span class="line"><span class="built_in">int</span> (*pp1)[<span class="number">6</span>] = arr;  <span class="comment">//pp1是一个指向含有6个int元素的数组的指针</span></span><br><span class="line"><span class="built_in">int</span> (*pp2)[<span class="number">5</span>][<span class="number">6</span>] = &amp;arr;  <span class="comment">//pp2是一个指向含有5行6列的二维数组的地址，即指向的是整个数组的数组</span></span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;&amp;arr[0][0]: &quot;</span> &lt;&lt; &amp;arr[<span class="number">0</span>][<span class="number">0</span>] &lt;&lt; <span class="string">&quot;\tarr: &quot;</span> &lt;&lt; &amp;arr &lt;&lt; <span class="string">&quot;\tpp1: &quot;</span> &lt;&lt; pp1</span><br><span class="line">          &lt;&lt; <span class="string">&quot;\t*pp2: &quot;</span> &lt;&lt; *pp2 &lt;&lt; <span class="string">&quot;\t**arr: &quot;</span> &lt;&lt; **arr &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用指针访问二维数组</span></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> (*pr)[<span class="number">6</span>] = arr; pr != arr + <span class="number">5</span>; ++pr) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> *pc = *pr; pc != *pr + <span class="number">6</span>; ++pc)</span><br><span class="line">        std::cout &lt;&lt; *pc &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>二维数组arr[i][j]会被解析成<em>(</em>(arr + i) + j)，arr依然是第一个元素的地址， 此处的第一个元素即可以表示arr[0][0]（即二维数组的第一个元素），也可以表示以行为元素的一维数组的 第一个元素<em>(arr + 0)（即第一行的6个元素），显然这两个地址是相同的。所以对arr增加1，即移到下一个 元素的地址，下一个元素即第二行。arr的元素是含有6个int的一维数组，所以指向arr的指针类型也必须是含有 6个int的一维数组，所以</em>pp1的括号和后面的[6]必须要有。 pp2的解释与p2类似</p>
<h1 id="函数和数组"><a href="#函数和数组" class="headerlink" title="函数和数组"></a>函数和数组</h1><p>首先明确C/C++中函数无法返回数组，所以对数组的操作和返回只能通过指针，而数组名本身就是个地址，可以看成是个常量指针<br>以下两种方式定义一个返回二维数组的函数，实际上返回的依然是指针  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用typedef定义一个类型别名，该类型为一个指针，该指针指向含有6个int元素的数组</span></span><br><span class="line"><span class="comment">//小括号不能省略，否则将成为含有6个指针的数组。由于二维数组就是数组的数组，所以该函数可以</span></span><br><span class="line"><span class="comment">//接受一个列数为6的二维数组作为参数，并返回一个指针，该指针同样指向含有6个int元素的数组  </span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*Tarr)</span>[6]</span>;</span><br><span class="line"><span class="function">Tarr <span class="title">func</span><span class="params">(<span class="type">int</span> (*arr)[<span class="number">6</span>])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述声明等价于</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> (*<span class="built_in">func</span>(<span class="built_in">int</span> (*arr)[<span class="number">6</span>]))[<span class="number">6</span>]</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> c[<span class="number">5</span>][<span class="number">6</span>];</span><br><span class="line">Tarr b = <span class="built_in">func</span>(c);</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;&amp;b[1][1]: &quot;</span> &lt;&lt; &amp;b[<span class="number">1</span>][<span class="number">1</span>] &lt;&lt; <span class="string">&quot;\t&amp;c[1][1]: &quot;</span> &lt;&lt; &amp;c[<span class="number">1</span>][<span class="number">1</span>] &lt;&lt; std::endl;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="函数和指针"><a href="#函数和指针" class="headerlink" title="函数和指针"></a>函数和指针</h1><p>这里的介绍非常详细<a href="http://www.cnblogs.com/TenosDoIt/p/3164081.html">http://www.cnblogs.com/TenosDoIt/p/3164081.html</a><br>C语言函数指针的定义形式：<code>返回类型 (*函数指针名称)(参数类型1, 参数类型2, 参数类型3, ...);</code><br>C++语言函数指针的定义形式：<code>返回类型 (类名称::*函数指针名称)(参数类型1, 参数类型2, 参数类型3, ...);</code><br>注意，当定义指向类的成员函数的函数指针时，该成员函数如果不是静态成员函数，也必须通过类对象来调用。不能定义指向一个类对象的函数的函数指针。<br>与C++类相关的函数指针的定义都需要使用作用域运算符<code>::</code>，赋值都要带取地址符<code>&amp;</code>，通过类对象访问需要使用<code>.*</code>，通过类对象指针调用成员函数指针需要使<code>-&gt;*</code>  </p>
<h2 id="普通函数指针和类成员函数指针"><a href="#普通函数指针和类成员函数指针" class="headerlink" title="普通函数指针和类成员函数指针"></a>普通函数指针和类成员函数指针</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tf</span><span class="params">(<span class="type">char</span> c, <span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Normal: &quot;</span> &lt;&lt; c &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">(<span class="type">char</span> c, <span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Class func1: &quot;</span> &lt;&lt; c &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">(<span class="type">char</span> c, <span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Class func2: &quot;</span> &lt;&lt; c &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func3</span><span class="params">(<span class="type">char</span> c, <span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Class func2: &quot;</span> &lt;&lt; c &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func4</span><span class="params">(<span class="type">char</span> c, <span class="type">int</span> i)</span> <span class="type">const</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Class func2: &quot;</span> &lt;&lt; c &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">void</span> (*pf)(<span class="type">char</span>, <span class="type">int</span>) = <span class="literal">NULL</span>;   <span class="comment">//普通函数指针定义并使其指向NULL</span></span><br><span class="line">    pf = tf;</span><br><span class="line">    <span class="built_in">pf</span>(<span class="string">&#x27;t&#x27;</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">void</span> (A::*pf1)(<span class="type">char</span>, <span class="type">int</span>) = &amp;A::func1;  <span class="comment">//指向类的非静态成员函数的指针，初始时必须使用取地址符</span></span><br><span class="line">    A obj_a;</span><br><span class="line">    (obj_a.*pf1)(<span class="string">&#x27;f&#x27;</span>, <span class="number">1</span>);  <span class="comment">//这里必须要使用括号把前面对象和函数指针名括住，且必须使用.*，而不是-&gt;</span></span><br><span class="line"><span class="comment">//    pf = obj_a.func1;  //错误，不能让函数指针pf指向对象的指针，即使他们参数和返回值一样</span></span><br><span class="line"></span><br><span class="line">    A obj_b;</span><br><span class="line">    pf1 = &amp;A::func2;</span><br><span class="line">    (obj_b.*pf1)(<span class="string">&#x27;f&#x27;</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    pf = A::func3;  <span class="comment">//静态成员可以像普通函数一样不加取地址符</span></span><br><span class="line">    <span class="built_in">pf</span>(<span class="string">&#x27;f&#x27;</span>, <span class="number">3</span>);   <span class="comment">//因为是静态成员，所以不需要对象，可以直接通过函数指针调用</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">void</span> (A::*pfc)(<span class="type">char</span>, <span class="type">int</span>) <span class="type">const</span> = &amp;A::func4;  <span class="comment">//const 函数的函数指针也必须带有const</span></span><br><span class="line">    A obj_c;</span><br><span class="line">    (obj_c.*pfc)(<span class="string">&#x27;c&#x27;</span>, <span class="number">4</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Normal: t1</span><br><span class="line">Class func1: f1</span><br><span class="line">Class func2: f1</span><br><span class="line">Class func2: f3</span><br><span class="line">Class func2: c4</span><br></pre></td></tr></table></figure>

<h2 id="函数指针作为参数和返回值"><a href="#函数指针作为参数和返回值" class="headerlink" title="函数指针作为参数和返回值"></a>函数指针作为参数和返回值</h2><p>要善用typedef简化函数指针类型的定义。具体看下面的一个例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">display</span><span class="params">(<span class="type">char</span> c, <span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> n = <span class="number">0</span>; n &lt; i; ++n)</span><br><span class="line">        std::cout &lt;&lt; c;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//接受一个指向形如display的函数指针，一个char和一个int作为参数的函数</span></span><br><span class="line"><span class="comment">//没有返回值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfun</span><span class="params">(<span class="type">int</span> (*pp)(<span class="type">char</span>, <span class="type">int</span>), <span class="type">char</span> c, <span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">pp</span>(c, i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//该函数与dfun函数类似，只是其返回值为指向形如display函数的函数指针</span></span><br><span class="line"><span class="built_in">int</span> (*<span class="built_in">pdfun</span>(<span class="built_in">int</span> (*pd)(<span class="type">char</span>, <span class="type">int</span>), <span class="type">char</span> c, <span class="type">int</span> i))(<span class="type">char</span>, <span class="type">int</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">pd</span>(c, i);</span><br><span class="line">    <span class="keyword">return</span> pd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">dfun</span>(display, <span class="string">&#x27;d&#x27;</span>, <span class="number">6</span>);  <span class="comment">//调用带有函数指针作为参数的函数</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">int</span> (*pd)(<span class="type">char</span>, <span class="type">int</span>) = <span class="built_in">pdfun</span>(display, <span class="string">&#x27;p&#x27;</span>, <span class="number">7</span>);  <span class="comment">//调用返回值为函数指针的函数</span></span><br><span class="line">    <span class="built_in">pd</span>(<span class="string">&#x27;p&#x27;</span>, <span class="number">8</span>);  <span class="comment">//调用函数指针的返回值的函数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用typedef简化函数指针类型的定义</span></span><br><span class="line">    <span class="comment">//定义一个指向形如display的函数指针的类型pd_type</span></span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*pd_type)</span><span class="params">(<span class="type">char</span>, <span class="type">int</span>)</span></span>;</span><br><span class="line">    pd_type pdd = display;</span><br><span class="line">    <span class="built_in">pdd</span>(<span class="string">&#x27;s&#x27;</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义一个指向形如pdfun的函数指针的类型pdfun_tye类型</span></span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*(*pdfun_type)(pd_type, <span class="type">char</span>, <span class="type">int</span>))</span><span class="params">(<span class="type">char</span>, <span class="type">int</span>)</span></span>;</span><br><span class="line">    pdfun_type ppdfun = pdfun;</span><br><span class="line">    pd_type ppd = <span class="built_in">ppdfun</span>(pdd, <span class="string">&#x27;u&#x27;</span>, <span class="number">12</span>);  <span class="comment">//调用并获取其返回的函数指针</span></span><br><span class="line">    <span class="built_in">ppd</span>(<span class="string">&#x27;x&#x27;</span>, <span class="number">15</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dddddd</span><br><span class="line">ppppppp</span><br><span class="line">pppppppp</span><br><span class="line">ssssssssss</span><br><span class="line">uuuuuuuuuuuu</span><br><span class="line">xxxxxxxxxxxxxxx</span><br></pre></td></tr></table></figure>

<h2 id="函数指针数组"><a href="#函数指针数组" class="headerlink" title="函数指针数组"></a>函数指针数组</h2><p>举例说明：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">f1</span><span class="params">(<span class="type">float</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; a &lt;&lt; <span class="string">&quot; + &quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; a + b &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">f2</span><span class="params">(<span class="type">float</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; a &lt;&lt; <span class="string">&quot; * &quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; a * b &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> a * b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//定义并初始化函数指针数组</span></span><br><span class="line">    <span class="built_in">float</span> (*pfa[<span class="number">2</span>])(<span class="type">float</span>, <span class="type">int</span>) = &#123;f1, f2&#125;;</span><br><span class="line">    <span class="comment">//调用该函数指针数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;</span><br><span class="line">        pfa[i](<span class="number">3</span>, <span class="number">9</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//使用typedef简化定义</span></span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">float</span> <span class="params">(*f_type)</span><span class="params">(<span class="type">float</span>, <span class="type">int</span>)</span></span>;</span><br><span class="line">    f_type pfa2[] = &#123;f1, f2&#125;;</span><br><span class="line">    <span class="comment">//调用该函数指针数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;</span><br><span class="line">        pfa2[i](<span class="number">6</span>, <span class="number">8</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3 + 9 = 12</span><br><span class="line">3 * 9 = 27</span><br><span class="line">6 + 8 = 14</span><br><span class="line">6 * 8 = 48</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>CPP</tag>
      </tags>
  </entry>
  <entry>
    <title>C/C++中二维动态数组的使用方法举例</title>
    <url>/2016/03/14/dynamic-two-dimension-arr/</url>
    <content><![CDATA[<p>C/C++中的二维数组实际上都是以一维数组为元素的一维数组，C++中可以有三种方式申请动态数组：</p>
<ul>
<li>使用C语言中的malloc分配，free释放</li>
<li>使用C++中的new[]分配，delete[]释放</li>
<li>使用C++中的vector实现</li>
</ul>
<p>下面分别举例说明：</p>
<span id="more"></span>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * dynamic_2dimension_arr.cpp</span></span><br><span class="line"><span class="comment"> * Copyright (C) 2016  &lt;@BLUEYI-A0835&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Distributed under terms of the MIT license.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//声明一个m * n的动态二维数组，使用函数返回该二维数组，并分别使用malloc和new分配空间</span></span><br><span class="line"><span class="comment">//谨记二给数组即是数组的数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//这三个函数用于验证二维数组的使用</span></span><br><span class="line"><span class="comment">//初始化一个二维数组</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">iniarr</span><span class="params">(<span class="type">int</span>** arr, <span class="type">int</span> m, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j)</span><br><span class="line">            arr[i][j] = i + j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出一个二维数组中的值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printarr</span><span class="params">(<span class="type">int</span>** arr, <span class="type">int</span> m, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            std::cout &lt;&lt; arr[i][j] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用上面两个函数，表示使用二维数组arr</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">usearr</span><span class="params">(<span class="type">int</span>** arr, <span class="type">int</span> m, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">iniarr</span>(arr, m, n);</span><br><span class="line">    <span class="built_in">printarr</span>(arr, m, n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用malloc定义二维数组，两步分配空间，分配的各维空间可能不连续</span></span><br><span class="line"><span class="function"><span class="type">int</span>** <span class="title">mularr_ma</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//声明一个含有m个元素的一维数组，每个数组中的元素都是int*类型（即另一个一维数组）</span></span><br><span class="line">    <span class="comment">//并分配空间，相当于二维的m行</span></span><br><span class="line">    <span class="type">int</span> **arr = (<span class="type">int</span>**)<span class="built_in">malloc</span>(m * <span class="built_in">sizeof</span>(<span class="type">int</span>*));  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">        arr[i] = (<span class="type">int</span>*)<span class="built_in">malloc</span>(n * <span class="built_in">sizeof</span>(<span class="type">int</span>));  <span class="comment">//为一维数组中的每个指针元素申请n个int大小的空间，相当于二维中的列</span></span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用malloc一步分配所有第二维的空间，分配的各维空间连续</span></span><br><span class="line"><span class="function"><span class="type">int</span>** <span class="title">mularr_ma2</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//声明一个含有m个元素的一维数组，每个数组中的元素都是int*类型（即另一个一维数组）</span></span><br><span class="line">    <span class="comment">//并分配空间，相当于二维的m行</span></span><br><span class="line">    <span class="type">int</span> **arr = (<span class="type">int</span>**)<span class="built_in">malloc</span>(m * <span class="built_in">sizeof</span>(<span class="type">int</span>*));  </span><br><span class="line">    arr[<span class="number">0</span>] = (<span class="type">int</span>*)<span class="built_in">malloc</span>(m * n * <span class="built_in">sizeof</span>(<span class="type">int</span>)); <span class="comment">//注意arr[0]的内存很大，直接就是m*n个int的空间</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; m; ++i) <span class="comment">//让arr[1]到arr[m-1]分别指向arr[0]后面的空间</span></span><br><span class="line">        arr[i] = arr[i<span class="number">-1</span>] + n;  <span class="comment">//每次跳过0个元素</span></span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用new分两步分配，各列所处内存可能不连续</span></span><br><span class="line"><span class="function"><span class="type">int</span>** <span class="title">mularr_new</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> **arr = <span class="keyword">new</span> <span class="type">int</span>*[m];  <span class="comment">//m行</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">        arr[i] = <span class="keyword">new</span> <span class="type">int</span>[n];  <span class="comment">//每行n列</span></span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用new分配各列连续的内存，类似上面</span></span><br><span class="line"><span class="function"><span class="type">int</span>** <span class="title">mularr_new2</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> **arr = <span class="keyword">new</span> <span class="type">int</span>*[m];  <span class="comment">//m行</span></span><br><span class="line">    arr[<span class="number">0</span>] = <span class="keyword">new</span> <span class="type">int</span>[m * n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; m; ++i)</span><br><span class="line">        arr[i] = arr[i - <span class="number">1</span>] + n;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用vector代替二维数组</span></span><br><span class="line"><span class="comment">//其实就是vector的vector</span></span><br><span class="line">std::vector&lt;std::vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">mulvec</span>(<span class="type">int</span> m, <span class="type">int</span> n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//声明一个含有m个元素的vector，每个vector使用含有n个int的vector填充</span></span><br><span class="line">    std::vector&lt;std::vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">res</span>(m, std::<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n)); </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用vector，为了效率，传递引用</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">usevec</span><span class="params">(std::vector&lt;std::vector&lt;<span class="type">int</span>&gt;&gt; &amp;vec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//可以像二维数组一样使用</span></span><br><span class="line">    <span class="comment">//赋值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; vec.<span class="built_in">size</span>(); ++i) </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; (vec[<span class="number">0</span>]).<span class="built_in">size</span>(); ++j)</span><br><span class="line">            vec[i][j] = i + j;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历输出</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i : vec) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> j : i)</span><br><span class="line">            std::cout &lt;&lt; j &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        std::cout &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> m = <span class="number">5</span>, n = <span class="number">6</span>;</span><br><span class="line">    <span class="type">int</span> **arr = <span class="built_in">mularr_ma</span>(m, n);</span><br><span class="line">    <span class="built_in">usearr</span>(arr, m, n);</span><br><span class="line">    <span class="comment">//malloc需要使用free释放，释放时先释放每一行，再释放外层一维数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">        <span class="built_in">free</span>(arr[i]);</span><br><span class="line">    <span class="built_in">free</span>(arr);</span><br><span class="line"></span><br><span class="line">    arr = <span class="built_in">mularr_ma2</span>(m, n);</span><br><span class="line">    <span class="built_in">usearr</span>(arr, m, n);</span><br><span class="line">    <span class="comment">//注意此处释放只需要先释放arr[0]，再释放arr即可，不能现你上面那样释放，不然就会重复释放</span></span><br><span class="line">    <span class="built_in">free</span>(arr[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">free</span>(arr);</span><br><span class="line"></span><br><span class="line">    arr = <span class="built_in">mularr_new</span>(m, n);</span><br><span class="line">    <span class="built_in">usearr</span>(arr, m, n);</span><br><span class="line">    <span class="comment">//new的数组需要使用delete[]释放</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i)  <span class="comment">//先释放各维中的内存</span></span><br><span class="line">        <span class="keyword">delete</span>[] arr[i];</span><br><span class="line">    <span class="keyword">delete</span>[] arr; <span class="comment">//再释放最外层这一维的内存</span></span><br><span class="line"></span><br><span class="line">    arr = <span class="built_in">mularr_new2</span>(m, n);</span><br><span class="line">    <span class="built_in">usearr</span>(arr, m, n);</span><br><span class="line">    <span class="comment">//先释放arr[0]，再释放arr即可</span></span><br><span class="line">    <span class="keyword">delete</span>[] arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">delete</span>[] arr; <span class="comment">//再释放最外层这一维的内存</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用vector代替二维数组</span></span><br><span class="line">    std::vector&lt;std::vector&lt;<span class="type">int</span>&gt;&gt; varr = <span class="built_in">mulvec</span>(m, n);</span><br><span class="line">    <span class="built_in">usevec</span>(varr);</span><br><span class="line">    <span class="comment">//容器不需要手动管理内存，非常棒</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于已经确定一维的情况<br>1.假如已知第一维为5，第二维为变量n，声明二维数组</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> *a[<span class="number">5</span>];  <span class="comment">//定义一个含有5个变量的一维数组，每一个元素含有一个int*的元素</span></span><br><span class="line"><span class="comment">//然后为每一维分配第二维的空间</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i)</span><br><span class="line">    a[i] = <span class="keyword">new</span> <span class="type">int</span>[n];</span><br><span class="line"><span class="built_in">usearr</span>(a, <span class="number">5</span>, n);</span><br><span class="line"><span class="comment">//只需释放手动分配的即可</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i)</span><br><span class="line">    <span class="keyword">delete</span>[] a[i];</span><br></pre></td></tr></table></figure>

<p>2.假如已知第二维为6，第一维为变量m，声明二维数组</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> (*b)[<span class="number">6</span>];  <span class="comment">//声明一个指针，该指针指向数组，数组中的元素为含有6个int元素的数组</span></span><br><span class="line">b = <span class="keyword">new</span> <span class="type">int</span>[m][<span class="number">6</span>];  <span class="comment">//使用new开辟一个二维数组空间，注意这种情况下第二维必须已知</span></span><br><span class="line"><span class="built_in">usearr</span>(b, <span class="number">5</span>, n);<span class="comment">//当然此处使用usearr()调用肯定不行，会报类型不匹配，因为usearr的第一个参数是int**</span></span><br><span class="line"><span class="comment">//只需释放手动分配的即可</span></span><br><span class="line"><span class="keyword">delete</span>[] b;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>CPP</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux下常用命令与快捷键整理</title>
    <url>/2016/03/14/linux-terminal-commands-and-shortcuts/</url>
    <content><![CDATA[<p>Linux下面的一些常用命令和terminal的常用快捷键整理，并不断补充</p>
<span id="more"></span>

<h2 id="系统信息"><a href="#系统信息" class="headerlink" title="系统信息"></a>系统信息</h2><table>
<thead>
<tr>
<th>命令</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>date</td>
<td>显示系统日期与时间</td>
</tr>
<tr>
<td>cal</td>
<td>显示本月月历</td>
</tr>
<tr>
<td>uptime</td>
<td>显示开机时数</td>
</tr>
<tr>
<td>w</td>
<td>显示在线用户列表</td>
</tr>
<tr>
<td>whoami</td>
<td>显示目前用户名</td>
</tr>
<tr>
<td>uname -a</td>
<td>显示系统核心信息</td>
</tr>
<tr>
<td>cat /proc/cpuinfo</td>
<td>显示CPU信息</td>
</tr>
<tr>
<td>cat /proc/meminfo</td>
<td>显示内存信息</td>
</tr>
<tr>
<td>df -h</td>
<td>Disk Free，显示硬盘空间信息</td>
</tr>
<tr>
<td>du -h</td>
<td>Directory Usage，以易读的方式显示目录的硬盘占用情况</td>
</tr>
<tr>
<td>du -sh</td>
<td>跟上面一样，但不会列出所有文件，只是文件夹的整体占用，可根据通配符*来列出子文件夹</td>
</tr>
<tr>
<td>free -m</td>
<td>显示内存与Swap区的用量</td>
</tr>
<tr>
<td>sudo fdisk -l</td>
<td>列出所有磁盘的详细信息</td>
</tr>
</tbody></table>
<h2 id="键盘快捷键"><a href="#键盘快捷键" class="headerlink" title="键盘快捷键"></a>键盘快捷键</h2><table>
<thead>
<tr>
<th>按键</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Enter</td>
<td>执行命令</td>
</tr>
<tr>
<td>↑</td>
<td>显示前一个命令</td>
</tr>
<tr>
<td>Ctrl+R</td>
<td>搜索执行过的命令</td>
</tr>
<tr>
<td>Ctrl+Z</td>
<td>将执行中的命令丢到后台并暂停执行</td>
</tr>
<tr>
<td>Ctrl+C</td>
<td>中止执行中的命令</td>
</tr>
<tr>
<td>Ctrl+L</td>
<td>清除屏幕，同clear命令</td>
</tr>
<tr>
<td>命令｜more</td>
<td>命令输出满一页暂停，空格翻页，按q跳出</td>
</tr>
<tr>
<td>命令｜less</td>
<td>同more功能，但支持vim下的查看的命令快捷键</td>
</tr>
<tr>
<td>!!</td>
<td>再次执行上一个命令</td>
</tr>
<tr>
<td>命令 !$</td>
<td>取上一个命令的参数当做此命令之参数</td>
</tr>
<tr>
<td>Esc + .</td>
<td>显示上一命令的参数、修改后执行</td>
</tr>
<tr>
<td>Ctrl+A</td>
<td>光标移回开头位置</td>
</tr>
<tr>
<td>Ctrl+E</td>
<td>光标移回最后位置</td>
</tr>
<tr>
<td>Ctrl+U</td>
<td>剪下光标前方所有文字并复制到暂存粘贴板</td>
</tr>
<tr>
<td>Ctrl+K</td>
<td>剪下光标后方所有文字并复制到暂存粘贴板</td>
</tr>
<tr>
<td>Ctrl+Y</td>
<td>从暂存粘贴板贴上Ctrl+U与Ctrl+K剪下的文字</td>
</tr>
<tr>
<td>Ctrl+T</td>
<td>对调光标左侧两个字元</td>
</tr>
<tr>
<td>Ctrl+W</td>
<td>删除光标前方的单词(Word)</td>
</tr>
<tr>
<td>Ctrl+D</td>
<td>退出Terminal，同exit命令</td>
</tr>
<tr>
<td>Ctrl+Shift+C</td>
<td>复制选中区域的文字到粘贴板</td>
</tr>
<tr>
<td>Ctrl+Shift+V</td>
<td>贴上粘贴板文字到Terminal里</td>
</tr>
<tr>
<td>选中、鼠标中键</td>
<td>先用左钮拖拉选取需要的文字后移动光标到新位置按中键 （两键鼠标则是同时按左右钮），选中文字会被复制到新位置。（linux下默认选中的文件会被复制到粘贴板中）</td>
</tr>
</tbody></table>
<h2 id="查看命令手册"><a href="#查看命令手册" class="headerlink" title="查看命令手册"></a>查看命令手册</h2><table>
<thead>
<tr>
<th>按键</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>man 命令</td>
<td>显示命令的手册内容（man=manual）</td>
</tr>
<tr>
<td>man -k 关键字</td>
<td>显示含有关键字的手册</td>
</tr>
<tr>
<td>man -t 手册主题 ｜ps2pdf –&gt; 手册主题.pdf</td>
<td>将指定的手册输出成PDF档</td>
</tr>
</tbody></table>
<h2 id="搜索文件"><a href="#搜索文件" class="headerlink" title="搜索文件"></a>搜索文件</h2><table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>grep 样式 文件s</td>
<td>在文件s里搜索符合样式的内容</td>
</tr>
<tr>
<td>grep -r 样式 目录</td>
<td>在目录里搜索符合样式的内容</td>
</tr>
<tr>
<td>grep 搜索字串 /dir</td>
<td>由dir目录开始搜索含有搜索字串的文件</td>
</tr>
<tr>
<td>命令｜grep 样式</td>
<td>在命令的输出里搜索符合样式的内容，如：ps aux ｜ grep smb</td>
</tr>
<tr>
<td>locate 文件</td>
<td>搜索符合的文件或目录；必须先用updatedb建立文件名索引。locate -b ‘\name’列出名为name的文件，没加反斜线的话，会列出所有含name的文件</td>
</tr>
<tr>
<td>which 可执行文件名</td>
<td>列出可执行文件名所在路径</td>
</tr>
<tr>
<td>find / -name 文件名</td>
<td>由根目录开始搜索文件名</td>
</tr>
<tr>
<td>find . -name 文件名</td>
<td>由当前目录开始搜索文件名，可以指定目录，文件名支持通配符</td>
</tr>
</tbody></table>
<p>grep更多详情可以参考<a href="http://notes.maxwi.com/2016/02/19/linux-command-tools/#1">http://notes.maxwi.com/2016/02/19/linux-command-tools/#1</a></p>
<h2 id="文件权限"><a href="#文件权限" class="headerlink" title="文件权限"></a>文件权限</h2><table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>chmod 权限数值 文件</td>
<td>变更文件或目录的存取权限为指定的权限数值； 数值为3个八进位数字，依序代表用户（u）、 群组（g）与其他用户（Other）权限，每个数字 可为4(或r，表示可读read）、2（或w，表示可写 write）或1（或ｘ，表示可执行execute）。 chmod的ch是change，mod是mode</td>
</tr>
<tr>
<td>chmod 权限字串 文件</td>
<td>我们也可以用字串来指定权限：r、w或x， 字串前用+（加号）、-（减号）表示增加或移除， 或=（等号）直接指派权限</td>
</tr>
<tr>
<td>例：chmod 777 myfile 或chmod a+rwx myfile</td>
<td>设定myfile的存取权限为所有人皆可读、可写、可执行</td>
</tr>
<tr>
<td>例：chmod 755 myfile</td>
<td>第一个数字是设定用户权限具有所有权限（7=4+2+1）， 第二个数字是设定群组权限具有读取与执行权限 （5=4+1），第三个数字设定其他人的权限为读取与 执行权限</td>
</tr>
<tr>
<td>例：chmod a+x myfile</td>
<td>所有人（all）增加执行权限</td>
</tr>
<tr>
<td>chown usr1:user2 file</td>
<td>更改文件或目录的用户及所属组</td>
</tr>
</tbody></table>
<p>chmod和chown都可以跟参数-R来递归地修改文件夹及其子文件夹中的所有文件。</p>
<h2 id="文件与目录相关命令"><a href="#文件与目录相关命令" class="headerlink" title="文件与目录相关命令"></a>文件与目录相关命令</h2><table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>ls</td>
<td>显示目前所在目录的文件清单（ls=list）</td>
</tr>
<tr>
<td>ls -l</td>
<td>显示长格式以呈现更多文件信息</td>
</tr>
<tr>
<td>ls -al</td>
<td>以长格式显示包含隐藏文件在内的所有文件</td>
</tr>
<tr>
<td>ls -ahl</td>
<td>以长格式显示包含隐藏文件在内的所有文件，文件大小以易读的方式显示，例如mb</td>
</tr>
<tr>
<td>ls -F</td>
<td>附加文件类型，目录附加/，可执行文件附加<code>*</code></td>
</tr>
<tr>
<td>cd 目录</td>
<td>切换目录到指定的目录（cd=Change Directory）</td>
</tr>
<tr>
<td>cd –</td>
<td>cd 减号；切换目录到前一个目录</td>
</tr>
<tr>
<td>cd ~</td>
<td>切换目录回家目录</td>
</tr>
<tr>
<td>mkdir [-p] 目录</td>
<td>建立目录，-p参数表示多级目录不存在时自动创建</td>
</tr>
<tr>
<td>pwd</td>
<td>显示目前位置（pwd=print Working Directory）</td>
</tr>
<tr>
<td>rm 文件</td>
<td>删除文件（rm=remove）</td>
</tr>
<tr>
<td>rm -r 目录</td>
<td>删除目录</td>
</tr>
<tr>
<td>rm -f 文件 或 rm -rf 目录</td>
<td>强制删除文件或目录</td>
</tr>
<tr>
<td>cp 文件1 文件2</td>
<td>复制文件1为文件2</td>
</tr>
<tr>
<td>cp -r 目录1 目录2</td>
<td>递归地复制目录1及其中的文件为目录2，目录2不存在时会建立</td>
</tr>
<tr>
<td>mv 文件1 文件2</td>
<td>文件2不存在时是改名，文件2存在且为目录时是移动</td>
</tr>
<tr>
<td>ln -s 实体文件 连结名</td>
<td>建立符号连结</td>
</tr>
<tr>
<td>touch 文件</td>
<td>变更文件时间为目前时间</td>
</tr>
<tr>
<td>cat 文件</td>
<td>显示文件内容（cat=concatenate，连接）</td>
</tr>
<tr>
<td>cat 文件1 文件2 &gt; 文件3</td>
<td>连接文件1与文件3的内容并输出为文件3</td>
</tr>
<tr>
<td>more 文件</td>
<td>显示文件内容并做分页处理，通过空格翻页</td>
</tr>
<tr>
<td>less 文件</td>
<td>显示文件内容并做分页处理，支持vim下的查看命令快捷键</td>
</tr>
<tr>
<td>head 文件</td>
<td>显示文件开头10行内容</td>
</tr>
<tr>
<td>head -nn 文件</td>
<td>显示文件开头nn行内容</td>
</tr>
<tr>
<td>tail 文件</td>
<td>显示文件倒数10行内容</td>
</tr>
<tr>
<td>tail -nn 文件</td>
<td>显示文件倒数nn行内容</td>
</tr>
</tbody></table>
<p>更符号连接可以参考这里：<a href="http://notes.maxwi.com/2016/08/03/linux-soft-hard-link/">http://notes.maxwi.com/2016/08/03/linux-soft-hard-link/</a></p>
<h2 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h2><table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>tar -cf 文件.tar 要压缩的文件…</td>
<td>将指定的文件压缩到文件.tar（tar=tape archice，c=create）</td>
</tr>
<tr>
<td>tar -xf 文件.tar</td>
<td>解压缩文件.tar（x=extract）</td>
</tr>
<tr>
<td>tar -cfz 文件.tar.gz</td>
<td>把.tar文件再用GZip压缩</td>
</tr>
<tr>
<td>tar -xfz 文件.tar.gz</td>
<td>用GZip解压缩.tar文件</td>
</tr>
<tr>
<td>tar -zxvf 文件.tar.gz -C dir</td>
<td>用GZip解压缩.tar.gz文件到指定的目录dir</td>
</tr>
<tr>
<td>tar -cfj 文件.tar.bz2</td>
<td>把.tar文件再用BZip2压缩</td>
</tr>
<tr>
<td>tar -xfj 文件.tar.bz2</td>
<td>用BZip2解压缩.tar文件</td>
</tr>
<tr>
<td>gzip 文件</td>
<td>将文件压缩为文件.gz</td>
</tr>
</tbody></table>
<p>其中tar后面可以直接接命令，而不需要<code>-</code>，v表示显示命令操作过程</p>
<h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>ifconfig [-a]</td>
<td>列出本机启动中的的网卡信息及ip，加上-a表示所有网上</td>
</tr>
<tr>
<td>ip a show</td>
<td>列出本机所有的网卡信息，新系统中通常用ip命令替换为ifconfig</td>
</tr>
<tr>
<td>ping [-c n] 主机</td>
<td>ping指定的主机，-c表示ping的次数，否则一直ping</td>
</tr>
<tr>
<td>whois 网域</td>
<td>显示网域主机信息</td>
</tr>
<tr>
<td>dig 网域</td>
<td>显示网域的DNS信息</td>
</tr>
<tr>
<td>host -a 网域</td>
<td>显示网域的DNS详细信息</td>
</tr>
<tr>
<td>sudo netstat</td>
<td>显示所有网络连接、路由表等网络信息，可配合grep使用</td>
</tr>
<tr>
<td>arp -an</td>
<td>查看本机arp缓存</td>
</tr>
<tr>
<td>nmap -sP 192.168.1.0/24</td>
<td>使用nmap扫描同一子网下的所有ip</td>
</tr>
<tr>
<td>wget 网址</td>
<td>下载网址文件</td>
</tr>
<tr>
<td>ssh 帐号@主机</td>
<td>用SSH登录主机</td>
</tr>
<tr>
<td>scp 帐号1@主机1:文件名1 帐号2@主机2:文件名2</td>
<td>用scp将主机1上的文件1拷贝到主机2上的文件2中，可省略其中一个主机，换为本地文件</td>
</tr>
<tr>
<td>scp -r 帐号1@主机1:文件夹1 帐号2@主机2:文件夹2</td>
<td>用scp递归地将主机1上的文件夹1及其中的内容拷贝到主机2上的文件夹2中，同样可活省其中一个主机，换为本地文件夹</td>
</tr>
</tbody></table>
<h2 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h2><table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>ps</td>
<td>显示工作中的所有进程</td>
</tr>
<tr>
<td>ps aux</td>
<td>显示所有进程</td>
</tr>
<tr>
<td>ps aux ｜ grep 字串</td>
<td>过滤含有字串的进程</td>
</tr>
<tr>
<td>top</td>
<td>依CPU占用率显示进程信息，可通过按数据1键显示各核CPU的占用</td>
</tr>
<tr>
<td>kill 进程pid</td>
<td>删除指定pid的进程</td>
</tr>
<tr>
<td>killall 进程名</td>
<td>删除所有指定名称的进程</td>
</tr>
<tr>
<td>命令 &amp;</td>
<td>命令后面跟&amp;，让命令在后台执行</td>
</tr>
<tr>
<td>jobs</td>
<td>查看当前后台运行的命令，及其编号</td>
</tr>
<tr>
<td>ctrl + z</td>
<td>将当前命令暂停到后台</td>
</tr>
<tr>
<td>bg %jobnumber</td>
<td>让指定进程号的进程在后台运行（bg=background），不跟编号则执行最后一个命令</td>
</tr>
<tr>
<td>fg %jobnumber</td>
<td>将最近一个背景进程变更到前景（fg=foreground），不跟编号则执行最后一个任务</td>
</tr>
</tbody></table>
<h2 id="用户与组管理"><a href="#用户与组管理" class="headerlink" title="用户与组管理"></a>用户与组管理</h2><h2 id="其他科普内容"><a href="#其他科普内容" class="headerlink" title="其他科普内容"></a>其他科普内容</h2><h3 id="管道符号（-）"><a href="#管道符号（-）" class="headerlink" title="管道符号（|）"></a>管道符号（|）</h3><p>linux下shell中的竖线，即是unix中的航管道，其作用是command1 | command2 把第一个命令command 1执行的结果作为command2的输入传给command2<br>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ls -sha | sort -nr</span><br></pre></td></tr></table></figure>
<p>以易读的方式列出所有文件的大小，并按从大到小重排<br>ls的命令-s是列出文件大小，-h是以易读的方式显示文件大小，-a是显示所有文件。sort是排序，-n是根据字符串中的数据由小到大重新排序字符串，-r是反转排序结果。</p>
<p>管道支持多级级连操作</p>
<h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><p>grep支持正则表达式的匹配，常见的比较强大的编辑器也都支持正则表达式，更多正则表达式可以参见：<br><a href="http://notes.maxwi.com/categories/Regular-Expressions/">http://notes.maxwi.com/categories/Regular-Expressions/</a></p>
<p>参考：<br><a href="http://jdev.tw/blog/3599/linux-terminal-commands-and-shortcuts">http://jdev.tw/blog/3599/linux-terminal-commands-and-shortcuts</a><br>补充并修正了原文中存在的很多问题</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>举例详解指针和引用作为函数参数时的不同</title>
    <url>/2016/03/10/cpp-reference-pointer/</url>
    <content><![CDATA[<p>以下为个人理解：<br>      当引用和指针作为参数传递给函数时，函数参数依然是按值传递的方式。指针实实在在就是个指针，它本身是需要占用内存的，只是它可以指向某个变量的地址。所以当将指针作为参数传递时，将传递指针本身的副本，也就是说在函数内部修改指针指向，即对指针赋值只在函数局部生效（注意是对指针变量本身赋值，而不是对其解引用赋值）。但指针所指向的变量就是实实在在的变量，即可以通过指针在函数内部修改指针所批变量的值（即对指针的解引用赋值）。<br>      而引用则是其原变量的别名，可以理解为原变量的真实地址，所以所有对引用的修改，都相当于对原变量直接进行修改。在将其传递给函数时也一样，就是实实在在的地址，所有是否拷贝并不影响，对其赋值就相当于向相应的内存地址中将值写入<br>下面具体举例说明：</p>
<span id="more"></span>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * pointer_example.cpp</span></span><br><span class="line"><span class="comment"> * Copyright (C) 2016  &lt;@BLUEYI-PC&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Distributed under terms of the MIT license.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> m_value = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//p是个指针，即p中存储的值是地址，地址即变量在内存中的位置，</span></span><br><span class="line"><span class="comment">//所以可以通过指针在函数内部修改外部的变量</span></span><br><span class="line"><span class="comment">//修改之后原变量就为1</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func0</span><span class="params">(<span class="type">int</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    *p = m_value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数是按值传递，所以p在函数内部参与计算的实际是p本身的拷贝，而p的指向并不会变，</span></span><br><span class="line"><span class="comment">//只是编译器为p本身新建了一个临时变量，该临时变量中存储的依然是同一个地址，</span></span><br><span class="line"><span class="comment">//即它依然指向原变量，所以在函数内部对指针的重新绑定无效。</span></span><br><span class="line"><span class="comment">//但指针指向的地址就是实实在在的变量本身，所以可以通过指针形参来修改传递进去的参数值，如func0</span></span><br><span class="line"><span class="comment">//无法修改原变量的值 </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">(<span class="type">int</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    p = &amp;m_value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//p是指针的指针，传递到函数内部的是指针的指针的副本，但指针p却指向*p的地址</span></span><br><span class="line"><span class="comment">//所以对*p赋值，就是修改*p的值，即使*p存储的是m_value的地址</span></span><br><span class="line"><span class="comment">//与func1实现的功能类似，将修改*p的值，即将*p重新绑定到m_value，但无法修改*p原指向的变量的值，具体看调用</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">(<span class="type">int</span> **p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    *p = &amp;m_value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//p是一个引用指针，即p代表某个指针本身的引用，引用即实际变量的别名</span></span><br><span class="line"><span class="comment">//对引用操作，相当于对原变量进行操作，即修改传递进来的指针的绑定</span></span><br><span class="line"><span class="comment">//但无法修改p所指向的原来变量的值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func3</span><span class="params">(<span class="type">int</span> *&amp;p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    p = &amp;m_value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//普通的引用</span></span><br><span class="line"><span class="comment">//可以修改实参的值，相当于将m_value中的值赋给p所引用的变量</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func4</span><span class="params">(<span class="type">int</span> &amp;p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    p = m_value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//无法修改实参的值，传递的是实参的副本</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func5</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    p = m_value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> std::string &amp;func, <span class="type">const</span> <span class="type">int</span> num1, <span class="type">const</span> <span class="type">int</span> num2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;*****************&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; func &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;*pn&quot;</span> &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; num1 &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;l_value&quot;</span> &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; num2 &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;*****************&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argv, <span class="type">char</span> **argc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> l_value = <span class="number">5</span>;</span><br><span class="line">    <span class="type">int</span> *pn = &amp;l_value;</span><br><span class="line">    <span class="type">int</span> &amp;ref = l_value;</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;sizeof(pn): &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(pn) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;sizeof(*pn): &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(*pn) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;sizeof(ref): &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(ref) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;l_value: &quot;</span> &lt;&lt; l_value &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">func0</span>(pn);</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;func0&quot;</span>, *pn, l_value);</span><br><span class="line">    l_value = <span class="number">5</span>;</span><br><span class="line">    pn = &amp;l_value;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">func1</span>(pn);</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;func1&quot;</span>, *pn, l_value);</span><br><span class="line">    l_value = <span class="number">5</span>;</span><br><span class="line">    pn = &amp;l_value;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">func2</span>(&amp;pn);</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;func2&quot;</span>, *pn, l_value);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;func2: &quot;</span> &lt;&lt; l_value &lt;&lt; std::endl;</span><br><span class="line">    l_value = <span class="number">5</span>;</span><br><span class="line">    pn = &amp;l_value;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">func3</span>(pn);</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;func3&quot;</span>, *pn, l_value);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;func3: &quot;</span> &lt;&lt; l_value &lt;&lt; std::endl;</span><br><span class="line">    l_value = <span class="number">5</span>;</span><br><span class="line">    pn = &amp;l_value;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">func4</span>(l_value);</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;func4&quot;</span>, *pn, l_value);</span><br><span class="line">    l_value = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">func5</span>(l_value);</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;func5&quot;</span>, *pn, l_value);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参考：<br><a href="http://stackoverflow.com/questions/57483/what-are-the-differences-between-a-pointer-variable-and-a-reference-variable-in">What are the differences between a pointer variable and a reference variable in C++?</a>   </p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>CPP</tag>
        <tag>指针</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux实用工具总结之cron</title>
    <url>/2016/02/26/linux-command-tools-cron/</url>
    <content><![CDATA[<p>一些会比较经常用到的Linux下的工具，当然都是命令行。多数工具需要与正则表达式配合使用，所以可以很多工具使用前都需要先了解正则表达式，正则表达式可以参考这里<a href="http://notes.maxwi.com/2015/10/04/Regular-Expression-Study-Note/">正则表达式学习笔记</a>   </p>
<span id="more"></span>

<p>cron是linux下执行定时任务的系统服务，由crontab文件来指定执行的时间和具体命令，每个用户都有属于自己的crontab文件，具体信息可以查看<code>man crontab</code>文件的编写信息。<br>通过命令<code>sudo systemctl status cron</code>来查看cron服务是否已经启动</p>
<p>编写当前用户的crontab文件可以执行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">crontab -e</span><br></pre></td></tr></table></figure>
<p>将会修改属于用户自己的crontab文件，使用root身份执行将会修改root用户的crontab：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo crontab -e</span><br></pre></td></tr></table></figure>

<p>列出工作表中的所有命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">crontab -l</span><br></pre></td></tr></table></figure>

<p>删除当前用户的cron服务：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">crontab -r</span><br></pre></td></tr></table></figure>

<p>查看用户blueyi的crontab服务信息：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">crontab -u blueyi -l</span><br></pre></td></tr></table></figure>

<p>删除blueyi的crontab服务信息：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">crontab -u blueyi -r</span><br></pre></td></tr></table></figure>

<p>crontab文件主要在以下几个文件夹中：</p>
<ul>
<li>/var/spool/cron/ 目录下存放的是每个用户包括root的crontab任务，每个任务以创建者的名字命名</li>
<li>/etc/crontab 这个文件负责调度各种管理和维护任务。</li>
<li>/etc/cron.d/ 这个目录用来存放任何要执行的crontab文件或脚本。</li>
<li>我们还可以把脚本放在/etc/cron.hourly、/etc/cron.daily、/etc/cron.weekly、/etc/cron.monthly目录中，让它每小时/天/星期、月执行一次</li>
</ul>
<p>crontab文件中每行是一个定时命令，其中每行的前5个区段为时间和日期区段，最后一个是需要定时执行的命令，以空格分隔。5 个时间区段分别表示分（0-59）、时（0-23）、日（1-31）、月（1-12）、周（0-6，其中0表示周日）。它们可以用数字表示，或者配合以下4个通配符：</p>
<ul>
<li><code>*</code> 表示取值范围内的所有数字</li>
<li><code>/n</code> 表示每过n个相应的数字执行</li>
<li><code>m-n</code> 表示从m到n之间执行</li>
<li><code>m,n,l</code> 表示第m、第n和第l个时间执行</li>
</ul>
<p>举例：<br><strong>每分钟执行一次cmd</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">* * * * * cmd</span><br></pre></td></tr></table></figure>

<p><strong>每小时的10、20、30分钟执行一次cmd</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">10,20,30 * * * * cmd</span><br></pre></td></tr></table></figure>

<p><strong>每天3点10分执行一次cmd</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">10 3 * * * cmd</span><br></pre></td></tr></table></figure>

<p><strong>每隔5天，在21点到23点之间的每20分钟执行一次</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">*/20 21-23 */5 * * cmd</span><br></pre></td></tr></table></figure>

<p><strong>每周六早上1点30分执行一次cmd</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">30 1 * * 6 cmd</span><br></pre></td></tr></table></figure>

<p><strong>每个月的10号和周一到周三的上午11点执行cmd</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 11 10 * mon-wed cmd</span><br></pre></td></tr></table></figure>

<p><em>*一月12号早上4点每10分钟执行一次cmd</em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">*/10 4 12 jan * cmd</span><br></pre></td></tr></table></figure>

<p>如果发现自己创建的定时任务并未执行，可以查看是否由于cron服务没有启动:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo systemctl status cron</span><br></pre></td></tr></table></figure>
<p>启动cron服务：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo systemctl start cron</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>cron</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux实用工具总结之awk</title>
    <url>/2016/02/24/linux-command-tools-awk/</url>
    <content><![CDATA[<p>一些会比较经常用到的Linux下的工具，当然都是命令行。多数工具需要与正则表达式配合使用，所以可以很多工具使用前都需要先了解正则表达式，正则表达式可以参考这里<a href="http://notes.maxwi.com/2015/10/04/Regular-Expression-Study-Note/">正则表达式学习笔记</a>   </p>
<span id="more"></span>

<h2 id="关于"><a href="#关于" class="headerlink" title="关于"></a>关于</h2><p>awk其实并不算一个工具，相当于是一个脚本语言，awk就是这个脚本语言的解释器，这是GNU手册中的定义：<code>pattern scanning and processing language</code>。本文就把它当成一个简单的文本流处理工具来用，虽然我们有了sed，但sed在处理一行中的各列（某种分隔符进行分隔的字符串）时远没有awk功能强大。awk也是以某种模式一行行地处理各列，但对于各列中的内容可以非常精确化地处理。awk会将所处理行中的各列分别赋给$1..$n，$0表示当前一整行。<br>awk的用法为：<code>awk [可选项] &#39;脚本&#39; [INPUTFILES]</code>，或者处理awk脚本文件：<code>awk [可选项] -f SCRIPTFILE [INPUTFILES]</code>，当然awk也可以直接用于处理管道传递来的文本流<br>下面分别说一下这几部分：</p>
<h2 id="可选项"><a href="#可选项" class="headerlink" title="可选项"></a>可选项</h2><p>awk的可选项非常多，这里只说几个常用的</p>
<ul>
<li>-F[fs] 指定列项分隔符fs，fs可以是一个字符串或者表达式，如-F:表示以:分隔的各列，默认情况下分隔符是空格或tab</li>
<li>-f SCRIPTFILE  从脚本文件中读取awk命令</li>
<li>-v var=value 自定义一个变量并赋值</li>
</ul>
<h2 id="脚本语句"><a href="#脚本语句" class="headerlink" title="脚本语句"></a>脚本语句</h2><p>awk的脚本语句格式通常为：<code>&#39;[条件判断1][命令1] [条件判断2][命令2]...&#39;</code><br>脚本需要被放在单引号中，条件类型和命令都是可选的，当只有条件判断而没有命令时，则会输出符合条件的整行。当然如果只有命令而没有条件判断时，则对每一行按命令处理。命令及命令参数需要使用一对大括号括起来，最常用的命令就是print和printf，这两个命令其实都是linux内建的命令，prinf用于输出变量，类似与echo，默认在结尾输出换行。printf类似于C语言中的格式化输出函数printf，可以根据格式化输出参数来格式化输出，默认没有换行，所以如果需要换行就需要使用\n，不需要使用小括号，直接将需要。<br>先来举几个个简单的例子：<br>此处都是/etc/passwd文件为例<br><em>输出/etc/passwd中的第三列小于10的行：</em><br><code>awk -F: &#39;$3&lt;10&#39; /etc/passwd</code><br>这里我们通过-F指定分隔符为:，因为/etc/passwd中的各行包含的内容都以:分隔，然后使用$3取第3列与数字10进行比较</p>
<p><em>输出passwd中各行第1列与第3列的内容：</em><br><code>awk -F: &#39;&#123;print $1,$3&#125;&#39; /etc/passwd</code><br>这里print后面跟的变量以逗号（,）分隔，默认输出结果以空格分隔，如果想要以其他方式分隔中间直接插入双引号引入的字符串即可，例如输出结果以-&gt;分隔：<code>print $1&quot;-&gt;&quot;$3</code>，不分隔：<code>print $1$3</code></p>
<p><em>将第一列与第3列使用-&gt;连接并将第3列以16进制输出：</em><br><code>awk -F: &#39;&#123;printf &quot;%s-&gt;%x\n&quot;, $1,$3&#125;&#39; /etc/passwd</code></p>
<h3 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h3><p>awk通过条件判断部分的语句来过滤需要对哪些行应用后面紧跟着的命令。由于awk是编程语言，自然会包含很多运行算及逻辑运算符，这里一一列出，常用的其实也就进行比较的关系运行符及逻辑判断运算符，当然awk中也支持if..else..if及for循环。下面列出运行算符：</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>= += -= <em>= /= %= ^= *</em>=</td>
<td>赋值</td>
</tr>
<tr>
<td>?:</td>
<td>C条件表达式</td>
</tr>
<tr>
<td>两个竖扛</td>
<td>逻辑或</td>
</tr>
<tr>
<td>&amp;&amp;</td>
<td>逻辑与</td>
</tr>
<tr>
<td>~ ~!</td>
<td>匹配正则表达式和不匹配正则表达式</td>
</tr>
<tr>
<td>&lt; &lt;= &gt; &gt;= != ==</td>
<td>关系运算符</td>
</tr>
<tr>
<td>空格</td>
<td>连接</td>
</tr>
<tr>
<td>+ -</td>
<td>加，减</td>
</tr>
<tr>
<td>* / &amp;</td>
<td>乘，除与求余</td>
</tr>
<tr>
<td>+ - !</td>
<td>一元加，减和逻辑非</td>
</tr>
<tr>
<td>^ ***</td>
<td>求幂</td>
</tr>
<tr>
<td>++ –</td>
<td>增加或减少，作为前缀或后缀</td>
</tr>
<tr>
<td>$</td>
<td>字段引用</td>
</tr>
<tr>
<td>in</td>
<td>数组成员</td>
</tr>
</tbody></table>
<p>条件判断需要放在执行语句之前<br>下面举几个例子说明：<br><em>打印出第3列小于10的行中的第1列跟第3列，并用tab分隔：</em><br><code>awk -F: &#39;$3&lt;10&#123;print $1&quot;\t&quot;$3&#125;&#39; /etc/passwd</code></p>
<p><em>打印出第1列不是root，并且第3列小于10的行中的第1列跟第3列：</em><br><code>awk -F: &#39;$3&lt;10 &amp;&amp; $1!=&quot;root&quot; &#123;print $1&quot;\t&quot;$3&#125;&#39; /etc/passwd</code></p>
<p><em>类似上面的打印，但每行后面紧接着打印该行的第1跟第6列：</em><br><code>awk -F: &#39;$3&lt;10 &amp;&amp; $1!=&quot;root&quot; &#123;print $1&quot;\t&quot;$3&#125; &#123;print $1,$6&#125;&#39; /etc/passwd</code></p>
<p>条件判断与内建变量配合使用才能更加灵活</p>
<h3 id="内建变量"><a href="#内建变量" class="headerlink" title="内建变量"></a>内建变量</h3><table>
<thead>
<tr>
<th>变量</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>$n</td>
<td>当前记录的第n个字段，字段间由FS分隔</td>
</tr>
<tr>
<td>$0</td>
<td>完整的输入记录</td>
</tr>
<tr>
<td>ARGC</td>
<td>命令行参数的数目</td>
</tr>
<tr>
<td>ARGIND</td>
<td>命令行中当前文件的位置(从0开始算)</td>
</tr>
<tr>
<td>ARGV</td>
<td>包含命令行参数的数组</td>
</tr>
<tr>
<td>CONVFMT</td>
<td>数字转换格式(默认值为%.6g)ENVIRON环境变量关联数组</td>
</tr>
<tr>
<td>ERRNO</td>
<td>最后一个系统错误的描述</td>
</tr>
<tr>
<td>FIELDWIDTHS</td>
<td>字段宽度列表(用空格键分隔)</td>
</tr>
<tr>
<td>FILENAME</td>
<td>当前文件名</td>
</tr>
<tr>
<td>FNR</td>
<td>同NR，但相对于当前文件</td>
</tr>
<tr>
<td>FS</td>
<td>字段分隔符(默认是任何空格)</td>
</tr>
<tr>
<td>IGNORECASE</td>
<td>如果为真，则进行忽略大小写的匹配</td>
</tr>
<tr>
<td>NF</td>
<td>当前记录中的字段数</td>
</tr>
<tr>
<td>NR</td>
<td>当前记录数</td>
</tr>
<tr>
<td>OFMT</td>
<td>数字的输出格式(默认值是%.6g)</td>
</tr>
<tr>
<td>OFS</td>
<td>输出字段分隔符(默认值是一个空格)</td>
</tr>
<tr>
<td>ORS</td>
<td>输出记录分隔符(默认值是一个换行符)</td>
</tr>
<tr>
<td>RLENGTH</td>
<td>由match函数所匹配的字符串的长度</td>
</tr>
<tr>
<td>RS</td>
<td>记录分隔符(默认是一个换行符)</td>
</tr>
<tr>
<td>RSTART</td>
<td>由match函数所匹配的字符串的第一个位置</td>
</tr>
<tr>
<td>SUBSEP</td>
<td>数组下标分隔符(默认值是/034)</td>
</tr>
</tbody></table>
<p>其实常用的也就NF、NR、FS、FNR、OFS</p>
<p>这里顺便加两个awk中非常常用的两个关键字BEGIN和END：</p>
<ul>
<li>BEGIN{ 这里面放的是执行前的语句 }</li>
<li>END {这里面放的是处理完所有的行后要执行的语句 }</li>
</ul>
<p>下面举例说明：<br><em>输出从第二行开始的第1列及对应的行号，以及每行所具有的总列数：</em><br><code>awk -F: &#39;NR&gt;2 &#123;print $1 &quot;\tline:&quot; NR&quot;\t&quot;NF&#125;&#39; /etc/passwd</code><br>这句等价于：<br><code>awk &#39;BEGIN&#123;FS=&quot;:&quot;&#125; NR&gt;2 &#123;print $1 &quot;\tline:&quot; NR&quot;\t&quot;NF&#125;&#39; /etc/passwd</code><br>注意那里需要有个BEGIN，如果没有这句而是直接使用FS=”:”，输出结果中会有很多句都不正常，因为相当于在运行awk解析时，还没有设置分隔符，awk会直接采用默认的分隔符，显然会出错，加入BEGIN就是告诉awk这里面的语句需要在任何语句执行前先执行。<br>但使用-F可以与[]配合来指定多个分隔符，例如一行中即有以空格又有以:分隔，又有以,分隔，则可以使用-F’[ :,]’</p>
<p><em>输出各行中第3列小于10的行中第1列跟第3列，并将第3列中的数字增加3倍：</em><br><code>k -v times=3 &#39;BEGIN&#123;FS=&quot;:&quot;&#125; $3&lt;10 &#123;printf &quot;%-8s %d\n&quot;,$1,$3*times&#125;&#39; /etc/passwd</code><br>等价于：<br><code>k &#39;BEGIN&#123;FS=&quot;:&quot;; times=3&#125; $3&lt;10 &#123;printf &quot;%-8s %d\n&quot;,$1,$3*times&#125;&#39; /etc/passwd</code></p>
<p><em>输出$1,$2,$3并以-&gt;分隔：</em><br><code>awk &#39;BEGIN&#123;FS=&quot;:&quot;&#125; &#123;print $1,$2,$3&#125;&#39; OFS=&quot;-&gt;&quot; /etc/passwd</code><br>注意OFS在’’号的外面</p>
<h3 id="使用正则"><a href="#使用正则" class="headerlink" title="使用正则"></a>使用正则</h3><p>awk中通过<code>~</code>表示模式开始，后面跟//包围的正则表达式：<br><em>输出第7列中含有usr并且第3列大于10的行的第1，3，7列：</em><br><code>awk -F: &#39;$7 ~/usr/ &amp;&amp; $3&gt;10 &#123;print $1,$3,$7&#125;&#39; OFS=&quot;\t&quot; /etc/passwd</code></p>
<h3 id="awk脚本"><a href="#awk脚本" class="headerlink" title="awk脚本"></a>awk脚本</h3><p>awk脚本通常由以下3部分构成：</p>
<ul>
<li>BEGIN{ 这里面放的是执行前的语句 }</li>
<li>END {这里面放的是处理完所有的行后要执行的语句 }</li>
<li>{这里面放的是处理每一行时要执行的语句}</li>
</ul>
<p>下面这个例子来自于网上：<br>假如有以下表：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ cat score.txt</span><br><span class="line">Marry   2143 78 84 77</span><br><span class="line">Jack    2321 66 78 45</span><br><span class="line">Tom     2122 48 77 71</span><br><span class="line">Mike    2537 87 97 95</span><br><span class="line">Bob     2415 40 57 62</span><br></pre></td></tr></table></figure>
<p>统计所有人有总钱数，及平均情况的awk脚本：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/bin/awk -f</span></span><br><span class="line"><span class="comment">#运行前</span></span><br><span class="line"><span class="keyword">BEGIN</span> &#123;</span><br><span class="line">    math = <span class="number">0</span></span><br><span class="line">    english = <span class="number">0</span></span><br><span class="line">    computer = <span class="number">0</span></span><br><span class="line"> </span><br><span class="line">    printf <span class="string">&quot;NAME    NO.   MATH  ENGLISH  COMPUTER   TOTAL\n&quot;</span></span><br><span class="line">    printf <span class="string">&quot;---------------------------------------------\n&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#运行中</span></span><br><span class="line">&#123;</span><br><span class="line">    math+=<span class="variable">$3</span></span><br><span class="line">    english+=<span class="variable">$4</span></span><br><span class="line">    computer+=<span class="variable">$5</span></span><br><span class="line">    printf <span class="string">&quot;%-6s %-6s %4d %8d %8d %8d\n&quot;</span>, <span class="variable">$1</span>, <span class="variable">$2</span>, <span class="variable">$3</span>,<span class="variable">$4</span>,<span class="variable">$5</span>, <span class="variable">$3</span>+<span class="variable">$4</span>+<span class="variable">$5</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#运行后</span></span><br><span class="line"><span class="keyword">END</span> &#123;</span><br><span class="line">    printf <span class="string">&quot;---------------------------------------------\n&quot;</span></span><br><span class="line">    printf <span class="string">&quot;  TOTAL:%10d %8d %8d \n&quot;</span>, math, english, computer</span><br><span class="line">    printf <span class="string">&quot;AVERAGE:%10.2f %8.2f %8.2f\n&quot;</span>, math<span class="regexp">/NR, english/</span>NR, computer/NR</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NAME    NO.   MATH  ENGLISH  COMPUTER   TOTAL</span><br><span class="line">---------------------------------------------</span><br><span class="line">Marry  2143     78       84       77      239</span><br><span class="line">Jack   2321     66       78       45      189</span><br><span class="line">Tom    2122     48       77       71      196</span><br><span class="line">Mike   2537     87       97       95      279</span><br><span class="line">Bob    2415     40       57       62      159</span><br><span class="line">---------------------------------------------</span><br><span class="line">  TOTAL:       319      393      350</span><br><span class="line">AVERAGE:     63.80    78.60    70.00</span><br></pre></td></tr></table></figure>

<p>一个打印九九税法表的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">seq 9 | sed &#x27;H;g&#x27; | awk -v RS=&#x27;&#x27; &#x27;&#123;for(i=1;i&lt;=NF;i++)printf(&quot;%dx%d=%d%s&quot;, i, NR, i*NR, i==NR?&quot;\n&quot;:&quot;\t&quot;)&#125;&#x27;</span><br></pre></td></tr></table></figure>

<p>说实话，假如所处平台上有python，哪怕有C++可能我都会优先选择这些编程语言来处理那些非常复杂的处理，当然对于一些比较简单的情形，这些工具还是非常好用的。<br>awk的官方手册：<a href="http://www.gnu.org/software/gawk/manual/gawk.html">http://www.gnu.org/software/gawk/manual/gawk.html</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>awk</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux实用工具总结之grep</title>
    <url>/2016/02/22/linux-command-tools-grep/</url>
    <content><![CDATA[<p>一些会比较经常用到的Linux下的工具，当然都是命令行。多数工具需要与正则表达式配合使用，所以可以很多工具使用前都需要先了解正则表达式，正则表达式可以参考这里<a href="http://notes.maxwi.com/2015/10/04/Regular-Expression-Study-Note/">正则表达式学习笔记</a>   </p>
<span id="more"></span>

<h2 id="关于"><a href="#关于" class="headerlink" title="关于"></a>关于</h2><p>grep的作用就是根据模式（可以是正则表达式或字符串）打印匹配到的内容到标准输出，即可以对管道输出的内容进行匹配，也可以对文件或文件下的文件进行匹配。如果不使用-P指定正则表达式语法兼容Perl，则默认使用-G参数，指定为基本正则表达式<br>用法（来自于man手册）：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grep [OPTIONS] PATTERN [FILE...]</span><br><span class="line">grep [OPTIONS] [-e PATTERN | -f FILE] [FILE...]</span><br></pre></td></tr></table></figure>
<p>OPEIONS的可选项有很多，比较常见的有（加粗表示很实用）：</p>
<h2 id="匹配模式选择"><a href="#匹配模式选择" class="headerlink" title="匹配模式选择"></a>匹配模式选择</h2><p> -E, –extended-regexp     扩展正则表达式egrep<br> -F, –fixed-strings       一个换行符分隔的字符串的集合fgrep<br> -G, –basic-regexp        基本正则<br> -P, –perl-regexp         调用的perl正则<br> -e, –regexp=PATTERN      后面根正则模式，默认就是这个选项<br> -f, –file=FILE           从文件中获得匹配模式<br><strong>-i, –ignore-case         不区分大小写</strong><br><strong>-w, –word-regexp         匹配整个单词</strong><br><strong>-x, –line-regexp         匹配整行</strong><br> -z, –null-data           a data line ends in 0 byte, not newline  </p>
<p>杂项:<br> -s, –no-messages         不显示错误信息<br><strong>-v, –invert-match        显示不匹配的行</strong><br> -V, –version             显示版本号<br> –help                    显示帮助信息<br> –mmap                use memory-mapped input if possible  </p>
<h2 id="输出控制"><a href="#输出控制" class="headerlink" title="输出控制"></a>输出控制</h2><p> -m, –max-count=NUM       显示每一个文件中匹配到的最大次数<br> -b, –byte-offset         打印匹配行前面打印该行所在的块号码。<br><strong>-n, –line-number         显示的加上匹配所在的行号</strong><br> –line-buffered           刷新输出每一行<br> -H, –with-filename       当搜索多个文件时，显示匹配文件名前缀<br> -h, –no-filename         当搜索多个文件时，不显示匹配文件名前缀<br> –label=LABEL            print LABEL as filename for standard input<br><strong>-o, –only-matching       只显示匹配成功的内容，而不是整行。当某个匹配在一行中多次出现，每一个都单独显示一次（与-c配合可以输出某个串一共出现了多少次）</strong><br><strong>-q, –quiet, –silent     不显示任何东西，但可以用于检查grep的退出状态（0为匹配成功）</strong><br> –binary-files=TYPE   assume that binary files are TYPE TYPE is ‘binary’, ‘text’, or ‘without-match’<br> -a, –text                匹配二进制的东西<br> -I                        不匹配二进制的东西<br> -d, –directories=ACTION  目录操作，读取，递归，跳过<br> ACTION is ‘read’, ‘recurse’, or ‘skip’<br> -D, –devices=ACTION      设置对设备，FIFO,管道的操作，读取，跳过<br>      ACTION is ‘read’ or ‘skip’<br><strong>-R, -r, –recursive       递归调用</strong><br>其中-R会递归符号链接目录，-r只递归当前真实目录，而忽略链接目录<br> –include=PATTERN     files that match PATTERN will be examined<br> –exclude=PATTERN     files that match PATTERN will be skipped.<br> –exclude-from=FILE   files that match PATTERN in FILE will be skipped.<br> -L, –files-without-match 匹配多个文件时，显示不匹配的文件名<br><strong>-l, –files-with-matches  匹配多个文件时，显示匹配的文件名</strong><br><strong>-c, –count               显示匹配了多少次</strong><br> -Z, –null                print 0 byte after FILE name  </p>
<p>文件控制:<br> -B, –before-context=NUM  打印匹配本身以及前面的几个行由NUM控制<br> -A, –after-context=NUM   打印匹配本身以及随后的几个行由NUM控制<br><strong>-C, –context=NUM         打印匹配本身以及随后，前面的几个行由NUM控制</strong><br><strong>-NUM                      根-C的用法一样的</strong><br> –color[=WHEN],<br> –colour[=WHEN]       use markers to distinguish the matching string<br> WHEN may be <code>always</code>, <code>never</code> or <code>auto</code>.<br> -U, –binary              do not strip CR characters at EOL (MSDOS)<br> -u, –unix-byte-offsets   report offsets as if CRs were not there (MSDOS) </p>
<h2 id="实例分析"><a href="#实例分析" class="headerlink" title="实例分析"></a>实例分析</h2><p>1.查看grep的man手册中-A参数的作用：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">man grep | grep &#x27;^\s*\-A&#x27; -A 3</span><br></pre></td></tr></table></figure>
<p>首先man手册，然后通过管道使用grep查询以-A开头的行，并通过-A参数，指定输出匹配行及其后3行。结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-A NUM, --after-context=NUM</span><br><span class="line">      Print NUM lines of trailing context after matching lines.  Places a line containing</span><br><span class="line">      a group separator (--) between contiguous  groups  of  matches.   With  the  -o  or</span><br><span class="line">      --only-matching option, this has no effect and a warning is given.</span><br></pre></td></tr></table></figure>

<p>2.查看系统头文件中固定大小的整型是不是通过typedef进行定义的：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grep -ni &#x27;typedef\s\+.*\s\+uint[[:digit:]]*_t&#x27; /usr/include/*.h</span><br></pre></td></tr></table></figure>
<p>使用-n参数显示行号，-i参数忽略大小写，注意正则表达式中匹配一个或多个的+号在这里需要进行转义，否则表示正常匹配+号。\d不能用于匹配数字，需要使用posix的正则表示法，而且方括号还必须是双方括号。最后的文件名，可以使用通配符。<br>注意上述语句等价于使用-P参数指定为Perl正则语法的语句：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grep -niP &#x27;typedef\s+.*\s+uint\d*_t&#x27; /usr/include/*.h</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">/usr/include/stdint.h:<span class="number">48</span>:<span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span>      <span class="type">uint8_t</span>;</span><br><span class="line">/usr/include/stdint.h:<span class="number">49</span>:<span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> <span class="type">uint16_t</span>;</span><br><span class="line">/usr/include/stdint.h:<span class="number">51</span>:<span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span>       <span class="type">uint32_t</span>;</span><br><span class="line">/usr/include/stdint.h:<span class="number">55</span>:<span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span>  <span class="type">uint64_t</span>;</span><br><span class="line">/usr/include/stdint.h:<span class="number">58</span>:<span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> <span class="type">uint64_t</span>;</span><br></pre></td></tr></table></figure>

<p>3.递归匹配头文件中含有单个字符串grep的文件，并显示文件名和行号：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">grep -rniw &#x27;grep&#x27; /usr/include/</span><br></pre></td></tr></table></figure>
<p>使用-r参数，递归匹配，-w进行整词匹配</p>
<p>更多内容可以参见man手册<br><strong>GNU的grep手册：</strong> <a href="https://www.gnu.org/software/grep/manual/grep.html">https://www.gnu.org/software/grep/manual/grep.html</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>grep</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux实用工具总结之sed</title>
    <url>/2016/02/19/linux-command-tools-sed/</url>
    <content><![CDATA[<p>一些会比较经常用到的Linux下的工具，当然都是命令行。多数工具需要与正则表达式配合使用，所以可以很多工具使用前都需要先了解正则表达式，正则表达式可以参考这里<a href="http://notes.maxwi.com/2015/10/04/Regular-Expression-Study-Note/">正则表达式学习笔记</a>   </p>
<span id="more"></span>

<h2 id="关于"><a href="#关于" class="headerlink" title="关于"></a>关于</h2><p>sed是流编辑器，全称为stream editor，即sed可以直接处理管道传递来的命令，当然sed也支持直接处理文件。sed的处理单位为行，也就是说它会根据自己的参数对文件或流中的内容一行一行地进行处理，包含替换、删除、新增、获取特定行等。默认情况下sed处理的是文件的副本，如果要直接改写文件，需要使用选项参数-i。</p>
<h2 id="sed的基本用法"><a href="#sed的基本用法" class="headerlink" title="sed的基本用法"></a>sed的基本用法</h2><p><strong>sed [可选项] [命令模式] [文件名]</strong> </p>
<p>下面分别讲一下常用的可选项和常用的命令 </p>
<h2 id="可选项"><a href="#可选项" class="headerlink" title="可选项"></a>可选项</h2><p><strong><code>-n</code>，<code>--quiet</code>, <code>--silent</code>静默输出</strong><br>默认情况下sed会输出所有行，并在处理完一行之后立即输出被处理过之后的结果行，这就导致输出之后会多出我们并不需要的未处理的行。例如<code>sed &#39;/abc/p&#39; ts.txt</code>，这里我们使用sed只是进行匹配，并调用命令p输出，这样会输出ts.txt中的所有行，并将含abc的行多输出一次，如果想只输出被命令p处理的行。则使用-n选项，表示不显示处理过程，只输出被sed处理过的行。<br><strong><code>-e</code>后跟需要执行的命令模式</strong><br>sed后面可以接多个-e指定的命令模式来进行连续处理。如：<br>将ts.txt中所有第5行到第7行中的第一个abc替换成cdf，并将所有行中的第一个love替换成LOVE，命令如下，暂时只需要知道命令s是替换的功能，跟vim中的s功能简直完全一样：<br><code>sed -e &#39;5,7s/abc/cdf/&#39; -e &#39;s/love/LOVE/&#39; ts.txt</code><br>更多内容参见下面的-f<br><strong><code>-f</code> 后跟一个含有命令模式的文件</strong><br>sed从该文件加载命令模式来处理各行。默认情况下当不提供-e，-f选项时，sed命令后面的第一个非可选项（即以-开头）将被当成模式被执行。所以当不是需要同时顺序执行多个命令时，可以不用-e选项。<br><strong><code>-r</code>,<code>--regexp-extended</code> 表示采用扩展正则表达式</strong><br><strong><code>-i</code> 表示直接在原文件中修改</strong> 这个应该是最重要的命令，因为默认情况下sed并不会修改原文件</p>
<h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><p>命令配合正则表达式组成的模式是sed的关键，命令模式的格式一般为<code>“[address1],[address2] [command] [arguments]”</code>。<br>命令格式即可以使用单引号包括，也可以使用双引号，单引号和双引号可以配合使用，例如要匹配双引号时，可以<code>&#39;/&quot;/&#39;</code>，当然也可以使用转义<code>\</code>。用address来表示想要处理的行范围，当然如果省略所有address表示处理所有行，如果只有一个address，则表示只处理匹配到的这一行。address即可以是行号，也可以是通过正则表达式匹配到的行（sed处理的单位永远是行），例如从第3行到第6行应用命令d（表示删除）：<code>sed &#39;3, 6d&#39;</code>，或者删除从第一个含有<code>abc</code>的行开始到第一个含有<code>xyz</code>之间的行：<code>sed &#39;/abc/,/xyz/d&#39;</code>。而且address还支持相对位置，例如从第一个匹配行开始的后面连接5行输出：<code>sed &#39;/abc/, +5p&#39;</code>。sed命令中所有需要正则匹配的地方都是放在斜扛<code>/</code>之间。`</p>
<h3 id="行内匹配并替换命令s"><a href="#行内匹配并替换命令s" class="headerlink" title="行内匹配并替换命令s"></a><strong>行内匹配并替换命令<code>s</code></strong></h3><p><code>s</code>命令非常常用（substitute），跟vim中的s功能几乎完全一样，<br>使用格式为<code>sed &#39;[addr1][,addr2]s/exp1/exp2/flag&#39;</code><br>其中flag可以取<code>g</code>表示行内全局替换（即替换一行中的所有匹配的串）。或者接一个数字，表示替换一行中的第几个匹配到的串。或者接<br>字符<code>p</code>表示向标准输出打印结果（其实p也是一个单独的命令）<br><em><code>s</code>命令支持使用分号<code>;</code>进行多个匹配处理，使用<code>&amp;</code>表示匹配到的变量，$可以代表最后一行，正则表达式中圆括号匹配的内容可以被当成变量</em><br>下面举几个例子说明：<br><em>将所有行中的第一个abc替换为xyz：</em><br><code>sed &#39;s/abc/xyz/&#39; ts.txt</code></p>
<p><em>将第3行到第6行中的第2开始的abc替换成xyz并输出处理之后的结果行：</em><br><code>sed -n &#39;3,6s/abc/xyz/p&#39; ts.txt</code></p>
<p><em>在原文件中将从第一个含有ab1的行开始到第一个含有xy2的行中的所有my替换成MY：</em><br><code>sed -i &#39;/ab1/,/xy2/s/my/MY/g&#39; ts.txt</code></p>
<p><em>将从第8行开始到第一个含有abc的行中的第2个开始的my全部替换为your：</em><br><code>sed &#39;8,/abc/s/my/your/2g&#39; ts.txt</code></p>
<p><em>将1到3行中的abc替换成xyz，并去掉3行之后的所有abc：</em><br><code>sed &#39;s/abc/xyz/g; 3,$s/abc//g&#39; ts.txt</code><br>上述处理等价于两个<code>-e</code>的处理<code>sed -e &#39;s/abc/xyz/g&#39; -e &#39;3,$s/abc//g&#39; ts.txt</code></p>
<p><em>将所有行中的abc使用圆括：</em><br><code>sed &#39;s/abc/(&amp;)/g&#39; ts.txt</code></p>
<p><em>打印出html文件中所有除标签之外的行中内容：</em><br><code>sed -n &#39;s/&lt;[^&gt;]*&gt;//gp&#39; ts.html</code></p>
<p><em>输出文件中所有含abc[n]和love[n]的行中的abc[n]和love[n]输出，并以:分隔：</em><br><code>sed -n &#39;s/.*\(abc\d*\).*\(love\d*\).*/\1:\2/gp&#39; ts.txt</code><br>注意匹配中的圆括号需要使用转义字符转义，表示其是正则表达式中的意义，后面使用\1,\2…来表示匹配到的变量</p>
<p><strong>行替换命令<code>c</code></strong><br>用法与<code>s</code>类似，不过<code>c</code>命令是直接替换整行，而不是在行内进行替换，用法为：<br><code>sed &#39;[addr1][,addr2]c string&#39;</code>表示将addr1到addr2行内容替换为string，注意这里不是将两个地址之间的各行替换为string，而是指一起替换为一行，但当为单一的正则匹配时，匹配多少行就替换多少行。<br>下面举例说明：<br><em>将3到8行替换为一行love：</em><br><code>nl ts.txt | sed &#39;3,8c love&#39;</code><br>前面的nl命令是为了显示行号。</p>
<p><em>将所有行替换为love：</em><br><code>sed &#39;c love&#39; ts.txt</code></p>
<p><em>将所有含有abc的行替换为love：</em><br><code>sed &#39;/abc/c love&#39; ts.txt</code></p>
<h3 id="行删除命令d"><a href="#行删除命令d" class="headerlink" title="行删除命令d"></a><strong>行删除命令<code>d</code></strong></h3><p><code>d</code>与c的用法一样，只是它表示删除。<br>举一个例子吧：<br><em>删除所有空行：</em><br><code>sed &#39;/^$/d&#39; ts.txt</code></p>
<p><strong>行插入命令<code>a</code>和<code>i</code></strong><br>其中<code>a</code>表示在行后追加一行，<code>i</code>表示在行前追加一行。下面举例说明：<br><em>在第一行前插入hello，最后一行后插入world：</em><br><code>sed -e &#39;1i hello&#39; -e &#39;$a world&#39; ts.txt</code></p>
<p><em>在从含有abc的行开始到含有xyz的行之间的各行后插入一行hello：</em><br><code>sed &#39;/abc/,/xyz/a hello&#39; ts.txt</code></p>
<h3 id="将读或追加下一行到缓冲区命令n与N"><a href="#将读或追加下一行到缓冲区命令n与N" class="headerlink" title="将读或追加下一行到缓冲区命令n与N"></a><strong>将读或追加下一行到缓冲区命令n与N</strong></h3><p>这两个命令可以直接理解为可用于交替处理各行，其中n处理偶数行，N处理奇数行。例如：<br><em>将所有偶数中的love换成LOVE,但奇数行不变：</em><br><code>sed &#39;n; s/love/LOVE/g&#39; ts.txt</code></p>
<p><em>将从第一行开始的两行合并为一行：</em><br><code>sed -i &#39;N; s/\n//&#39; ts.txt</code></p>
<h3 id="打印命令p"><a href="#打印命令p" class="headerlink" title="打印命令p"></a><strong>打印命令<code>p</code></strong></h3><p>p命令已经在s命令中使用过多次，用于向标准输出中打印sed处理的行，由于sed默认会显示处理过程，所以通常p与-n一起使用。例如：<br><em>显示从abc到xyz的所有行：</em><br><code>sed -n &#39;/abc/,/xyz/p&#39; ts.txt</code></p>
<p><em>输出从含有abc行开始的连续3行：</em><br><code>sed -n &#39;/abc/, +3p&#39; ts.txt</code></p>
<h2 id="嵌套命令"><a href="#嵌套命令" class="headerlink" title="嵌套命令"></a>嵌套命令</h2><p>sed支持对命令组合及嵌套使用，通过分号（;）实现多个命令组合使用，通过大括号（{}）实现命令嵌套，举例说明：<br><em>对1到3行执行命令/abc/d：</em><br><code>sed &#39;1,3 &#123;/abc/d&#125;&#39; ts.txt</code></p>
<p><em>对1到3行中含有abc且同时含有xyz的行删除：</em><br><code>sed &#39;1,3 &#123;/abc/&#123;/xyz/d&#125;&#125;&#39; ts.txt</code></p>
<p><em>对所有行匹配到abc则删除，匹配到空行则替换为love：</em><br><code>sed &#39;/abc/d; s/^$/love/&#39; ts.txt</code></p>
<p>sed的gnu官方手册：<a href="http://www.gnu.org/software/sed/manual/sed.html">http://www.gnu.org/software/sed/manual/sed.html</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>sed</tag>
      </tags>
  </entry>
  <entry>
    <title>C++学习笔记之模板与泛型编程</title>
    <url>/2016/01/23/cpp-oop-template/</url>
    <content><![CDATA[<p>面向对象编程（OOP）和泛型编程都能处理在编写程序时不知道类型的情况。不同之处是OOP能处理类型在程序运行之前都未知的情况（即通过多态的动态绑定）；而泛型编程中，在编译时就能确定类型，只是可以应用于不同的类型，例如vector可以放int，也可以放string等。<br>既可以定义函数模板也可以定义类模板。</p>
<h2 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h2><p>1.一个函数模板就相当于一个公式，用来生成针对特定类型的函数版本。模板定义以关键字template开始，后跟一个模板参数列表（template parameter list），多个模板参数需要由逗号分割，使用尖括号包围起来，参数列表不能为空，模板参数表示在类或函数中用到的类型或值，当使用模板时，隐式或显示地指定模板实参（template argument），将其绑定到模板参数上。eg: </p>
<span id="more"></span>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//声明一个函数模板，该函数接受一个参数类型为T的指针，返回值类型为T</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function">T <span class="title">foo</span><span class="params">(T* p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> *p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.当编译器实例化一个模板时，它使用实际的模板实参代替对应的模板参数来创建出模板的一个新”实例“。  </p>
<p>3.模板的类型参数T可以用来指定返回类型和函数的参数类型，以及在函数体内用于变量声明或类型转换。  </p>
<p>4.类型参数前必须使用关键字class或typename。这个两个关键字的含义完全相同。eg:  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">class</span> <span class="title class_">U</span>&gt; <span class="built_in">calc</span> (<span class="type">const</span> T&amp;, <span class="type">const</span> U&amp;);</span><br></pre></td></tr></table></figure>

<p>5.除了定义类型参数外，还可以使用模板定义非类型参数（nontype parameter）,一个非类型实参是一个值而非一个类型，非类型实参使用一个特定的类型名而非关键字class或typename来指定。传递给非类型实参的值必须是常量表达式。eg:  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//N和M可以是任意两个能被编译器推断出类型的常量表达式</span></span><br><span class="line"><span class="comment">//由于不能拷贝数组，所以将类型定义为const的引用</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="type">unsigned</span> N, <span class="type">unsigned</span> M&gt;  <span class="comment">//该行与下一行不强制换行</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">compare</span><span class="params">(<span class="type">const</span> <span class="type">char</span> (&amp;p1)[N], <span class="type">const</span> <span class="type">char</span> (&amp;p2)[M])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">strcmp</span>(p1, p2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line"><span class="comment">//编译器将自动推断出所需要的N和M是字符串的大小+1</span></span><br><span class="line"><span class="built_in">compare</span>(<span class="string">&quot;hi&quot;</span>, <span class="string">&quot;mom&quot;</span>);</span><br><span class="line"><span class="comment">//编译器实例化的版本如下</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">compare</span><span class="params">(<span class="type">const</span> <span class="type">char</span> (&amp;p1)[<span class="number">3</span>], <span class="type">const</span> <span class="type">char</span> (&amp;p2)[<span class="number">3</span>])</span></span></span><br></pre></td></tr></table></figure>

<p>6.一个非类型实参可以是一个整型，或者是一个指向对象或函数类型的指针或（左值）引用。但必须是一个常量表达式。  </p>
<p>7.函数模板可以声明为inline或constexpr的，这两个关键字必须放在模板参数列表之后，返回类型之前。eg:  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> T <span class="title">min</span><span class="params">(<span class="type">const</span> T&amp;, <span class="type">const</span> T&amp;)</span></span>;</span><br></pre></td></tr></table></figure>

<p>8.模板程序应该尽量减少对实参类型的要求，例如可以考虑使用functional头文件中支持比较指针的比较模板。</p>
<p>9.函数模板和类模板成员函数的定义通常放在头文件中。当编译器遇到一个模板定义时，它并不生成代码，只有当实例化出一个特定版本时，编译器才会生成模板。</p>
<p>10.保证传递给模板的实参支持模板所要求的操作，以及这些操作在模板中能正确工作是调用者的责任。  </p>
<h2 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h2><p>1.类模板的定义与使用和函数模板类似，注意在类模板的继承关系中，子类模板不能直接访问父类的成员，需要使用this指针，或者间接访问运算符。所以定义如下：  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">class</span> <span class="title class_">Base_temp</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base_temp</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Base_temp</span>(T i, T j) : <span class="built_in">x</span>(i), <span class="built_in">y</span>(j) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T x;</span><br><span class="line">    T y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">class</span> <span class="title class_">Driv</span> : <span class="keyword">public</span> Base_temp&lt;T&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Driv</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Driv</span>(T i, T j, T k) : <span class="built_in">Base_temp</span>&lt;T&gt;(i, j), <span class="built_in">z</span>(k) &#123;&#125;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(std::ostream &amp;os)</span> </span>&#123; os &gt;&gt; <span class="keyword">this</span>-&gt;i &gt;&gt; Base_temp&lt;T&gt;::j &gt;&gt; k; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T z;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>2.编译器不能为类模板推断类型，所是使用时需要通过尖括号提供类型信息，例如<code>Driv&lt;int&gt; driv(1, 2, 3);</code></p>
<p>3.定义在类模板之外的成员函数必须以template开始，后接类模板参数列表，并且类名后面也要有尖括号提供类型信息，形如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">ret-type class_name&lt;T&gt;::member-<span class="built_in">name</span>(parm-list)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> Blob&lt;T&gt;::<span class="built_in">check</span>(size_type i, <span class="type">const</span> std::string &amp;msg) <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (i &gt;= data-&gt;<span class="built_in">size</span>())</span><br><span class="line">      <span class="keyword">throw</span> std::<span class="built_in">out_of_range</span>(msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4.默认情况下，对于一个实例化了的类模板，其成员只有在使用时才被实例化。</p>
<p>5.在类模板的作用域内，可以直接使用模板名而不必指定模板实参。eg:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">BlobPtr&lt;T&gt; BlobPtr&lt;T&gt;::<span class="keyword">operator</span>++(<span class="type">int</span>)</span><br><span class="line">&#123;</span><br><span class="line">  BlobPtr ret = *<span class="keyword">this</span>;  <span class="comment">//直接使用模板名，而无需提供模板实参</span></span><br><span class="line">  ++*<span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="模板与友元"><a href="#模板与友元" class="headerlink" title="模板与友元"></a>模板与友元</h2><p>1.当一个类包含友元声明时，类与友元各自是否是模板是相互无关的。如果一个类模板包含一个非模板友元，则友元被授权可以访问所有模板实例。如果友元自身是模板，类可以授权给所有友元模板实例，也可以只授权给特定实例。<br>为了引用（类或函数）模板的一个特定实例，必须首先声明模板自身。如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//前置声明，在Blob中声明友元所需要的</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>&gt; <span class="keyword">class</span> <span class="title class_">BlobPtr</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>&gt; <span class="keyword">class</span> <span class="title class_">Blob</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">  <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> Blob&lt;T&gt;&amp;, <span class="type">const</span> Blob&lt;T&gt;&amp;);</span><br><span class="line"><span class="comment">//类及其友元声明</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">class</span> <span class="title class_">Blob</span> &#123;</span><br><span class="line">  <span class="comment">//每个Blob实例将访问权限授予用相同类型实例化的BlobPtr和相等运算符</span></span><br><span class="line">  <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">BlobPtr</span>&lt;T&gt;;</span><br><span class="line">  <span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span>==&lt;T&gt;(<span class="type">const</span> Blob&lt;T&gt;&amp;, <span class="type">const</span> Blob&lt;T&gt;&amp;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>注意:每个Blob实例将访问权限授予用相同类型实例化的BlobPtr和相等运算符，即一对一的友好关系</strong></p>
<p>2.一个类也可以将另一个模板的每个实例都声明为自己的友元，或者限定特定的实例为友元。如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//前置声明，后面将用类C实例化的pal声明为C的一个友元</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">class</span> <span class="title class_">Pal</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> &#123; <span class="comment">//C是一个普通的非模板类</span></span><br><span class="line">  <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">Pal</span>&lt;C&gt;;  <span class="comment">//用类C实例化的Pal是C的一个友元</span></span><br><span class="line">  <span class="comment">// Pal2的所有实例都是C的友元，这种情况无法前置声明</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">Pal2</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">class</span> <span class="title class_">C2</span> &#123; <span class="comment">//C2本身是一个类模板</span></span><br><span class="line"><span class="comment">//C2的每个实例将相同实例化的Pal声明为友元</span></span><br><span class="line">  <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">Pal</span>&lt;T&gt;; <span class="comment">//Pal的模板声明必须在作用域之内</span></span><br><span class="line">  <span class="comment">//Pal2的所有实例都是C2的每个实例的友元，不需要前置声明</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> X&gt; <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">Pal2</span>;</span><br><span class="line">  <span class="comment">//Pal3是一个非模板类，它是C2所有实例的友元</span></span><br><span class="line">  <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">Pal3</span>;   <span class="comment">//不需要Pal3的前置声明</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>为了让所有实例成为友元，友元声明中必须使用与类模板本身不同的模板参数。</strong><br>3.令模板自己的类型参数成为友元（C++11）：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Type&gt; <span class="keyword">class</span> <span class="title class_">Bar</span> &#123;</span><br><span class="line"><span class="keyword">friend</span> Type;  <span class="comment">//将访问权限授予用来实例化Bar的类型</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>如对于某个类型名Foo，Foo将成为Bar<Foo>的友元</p>
<p>4.模板类型别名<br>可以使用typedef方式来引用补货化的类：<code>typedef Bolb&lt;string&gt; StrBlob;</code>，但由于模板不是类型，所以不能定义一个typedef引用一个模板,即无法定义一个typedef引用Blob<T>。但C++11中可以使用using为类模板定义一个类型别名：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">using</span> twin = pair&lt;T, T&gt;;</span><br><span class="line">twin&lt;string&gt; authors; <span class="comment">//authors是一个pair&lt;string, string&gt;</span></span><br></pre></td></tr></table></figure>
<p>当定义一个模板类型别名时，可以固定一个或多个模板参数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">using</span> partNo = pair&lt;T, <span class="type">unsigned</span>&gt;;</span><br><span class="line">partNo&lt;string&gt; books; <span class="comment">//books是一个pair&lt;T, unsigned&gt;</span></span><br></pre></td></tr></table></figure>
<p>这种情况下必须指定pair的first成员，但不能指定pair的second成员</p>
<p>5.<strong>类模板可以定义static成员</strong>，当定义类模板的static成员时，该类模板实例化的每个实例类型都有一个独有的static对象，该实例类型的所有对象共有static成员。static成员的定义与定义模板的成员函数类似，定义的开始部分模板参数列表：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">size_t</span> Foo&lt;T&gt;::ctr = <span class="number">0</span>; <span class="comment">//定义并初始化ctr</span></span><br></pre></td></tr></table></figure>
<h2 id="模板参数"><a href="#模板参数" class="headerlink" title="模板参数"></a>模板参数</h2><p>1.类似函数参数的名字，模板参数的名字T并没有任何内存意义，可以使用任何合法的名字。</p>
<p>2.模板参数遵循普通的作用域规则，例如同样存在内层同名类型隐藏外层同名类型的情况</p>
<p>3.模板声明必须包含模板参数，与函数参数类似的是声明中的模板参数的名字不必与定义中相同：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//声明但不定义compare和Blob</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="type">int</span> <span class="title">compare</span><span class="params">(<span class="type">const</span> T&amp;, <span class="type">const</span> T&amp;)</span></span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">class</span> <span class="title class_">Blob</span>;</span><br></pre></td></tr></table></figure>
<p><strong>一个特定文件所需要的所有模板的声明通常一起放置在文件开始位置，出现于任何使用这些模板的代码之前.</strong><br>4.默认情况下，C++语言假定通过作用域运算符访问的名字不是类型，所以如果希望使用一个模板类型参数的类型成员，就必须显式告诉编译器该名字是一个类型，通过关键字typename来实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;  <span class="comment">//类型T含有成员value_type</span></span><br><span class="line"><span class="function"><span class="keyword">typename</span> T::value_type <span class="title">top</span><span class="params">(<span class="type">const</span> T&amp; c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!c.<span class="built_in">empty</span>())</span><br><span class="line">    <span class="keyword">return</span> c.<span class="built_in">back</span>();</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typename</span> T::value_type <span class="built_in">type</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当我们希望通知编译器一个名字表示类型时，必须使用关键字typename，而不能使用class</p>
<p>5.类似可以为函数参数提供默认实参一样，也可以提供<strong>默认模板实参</strong>，C++11中可以为函数和类模板提供默认实参，早期的C++只允许为类模板提供默认实参。eg:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//compare有一个默认默认实参less&lt;T&gt;和一个默认函数实参F()</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> F = less&lt;T&gt;&gt;</span><br><span class="line"><span class="type">int</span> <span class="built_in">compare</span>(<span class="type">const</span> T &amp;v1, <span class="type">const</span> T &amp;v2, F f = <span class="built_in">F</span>())  <span class="comment">//默认函数实参指出f将绑定到一个函数对象</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">f</span>(v1, v2)) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">if</span> (v2, v1) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用方法为：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> i = <span class="built_in">compare</span>(<span class="number">0</span>, <span class="number">42</span>);  <span class="comment">//使用less, i 为-1</span></span><br><span class="line"><span class="type">bool</span> j = <span class="built_in">compare</span>(item1, item2, compareIsbn);  <span class="comment">//item1和item2为自定义类型，compareIsbn为函数对象</span></span><br></pre></td></tr></table></figure>

<p>6.<strong>类模板的默认模板实参</strong>：无论何时使用类模板，都必须在模板名之后接上尖括号，尖括号指出类必须从一个模板实例化而来，特别是如果一个类模板为其所有模板参数都提供了默认实参，且我们希望使用这些默认实参，就必须在模板名之后跟一个空尖括号对：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span> = <span class="type">int</span>&gt; <span class="keyword">class</span> Numbers &#123;  <span class="comment">//T默认为int</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Numbers</span>(T v = <span class="number">0</span>): <span class="built_in">va</span>(v) &#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  T val;</span><br><span class="line">&#125;;</span><br><span class="line">Numbers&lt;<span class="type">long</span> <span class="type">double</span>&gt; lots_of_precision;</span><br><span class="line">Numbers&lt;&gt; average_precision;  <span class="comment">//使用默认类型int</span></span><br></pre></td></tr></table></figure>
<h2 id="成员模板"><a href="#成员模板" class="headerlink" title="成员模板"></a>成员模板</h2><p>1.一个类（无论是普通类还是类模板）可以包含本身是模板的成员函数，这种成员函数被称为成员模板（member template）。成员模板不能是虚函数。</p>
<h3 id="普通（非模板）类的成员模板"><a href="#普通（非模板）类的成员模板" class="headerlink" title="普通（非模板）类的成员模板"></a>普通（非模板）类的成员模板</h3><p>正常定义成员模板即可，如下定义一个类DebugDelete来封装delete操作，使delete操作之前打印一打消息。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DebugDelete</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">DebugDelete</span>(std::ostream &amp;s = std::cerr) : <span class="built_in">os</span>(s) &#123;&#125;</span><br><span class="line">  <span class="comment">//与任何函数模板相同，T的类型由编译器推断</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(T *p)</span> <span class="type">const</span> </span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    os &lt;&lt; <span class="string">&quot;deleting ptr&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  std::ostream &amp;os;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> *p = <span class="keyword">new</span> <span class="type">double</span>;</span><br><span class="line">DebugDelete d;</span><br><span class="line"><span class="built_in">d</span>(p); <span class="comment">//调用DebugDelete::operator()(double*),释放p</span></span><br><span class="line"><span class="type">int</span> *ip = <span class="keyword">new</span> <span class="type">int</span>;</span><br><span class="line"><span class="built_in">DebugDelete</span>()(ip); <span class="comment">//在一个临时对象上调用函数对象</span></span><br></pre></td></tr></table></figure>

<h3 id="类模板的成员模板"><a href="#类模板的成员模板" class="headerlink" title="类模板的成员模板"></a>类模板的成员模板</h3><p>对于类模板，类和成员各自有自己的、独立的模板参数。定义方法如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">class</span> <span class="title class_">Blob</span> &#123;  <span class="comment">//定义模板类</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> It&gt; <span class="built_in">Blob</span>(It b, It e);  <span class="comment">//声明类模板的成员模板</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在模板类外定义成员模板时，必须同时提供类模板和成员模板的参数列表：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;  <span class="comment">//类的类型参数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> It&gt;  <span class="comment">//构造函数的类型参数</span></span><br><span class="line">  Blob&lt;T&gt;::<span class="built_in">Blob</span>(It b, It e):<span class="built_in">data</span>(std::make_shared&lt;std::vector&lt;T&gt;&gt;(b, e)) &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>实例化成员模板时，必须同时提供类和函数模板的实参，如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> ia[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="function">Blob&lt;<span class="type">int</span>&gt; <span class="title">a1</span><span class="params">(begin(ia), end(ia))</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="使用extern控制实例化"><a href="#使用extern控制实例化" class="headerlink" title="使用extern控制实例化"></a>使用extern控制实例化</h2><p>由于模板被使用时才会进行实例化，意味着相同的实例可以出现在多个对象文件中，当两个或多个独立编译的源文件使用了相同的模板时，并提供了相同的模板参数时，每个文件都会有一个该模板的实例。C++11中可以通过extern来显式实例化(explicit instantiation)来避免这种开销。显示实例化形如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">template</span> declaration;  <span class="comment">//实例化声明</span></span><br><span class="line"><span class="keyword">template</span> declaration;  <span class="comment">//实例化定义</span></span><br></pre></td></tr></table></figure>
<p>declaration是一个类或函数声明，其中所有模板参数已被替换为模板实参，例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//实例化声明与定义</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">template</span> <span class="keyword">class</span> <span class="title class_">Blob</span>&lt;string&gt;;   <span class="comment">//声明</span></span><br><span class="line"><span class="function"><span class="keyword">template</span> <span class="type">int</span> <span class="title">compare</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp;, <span class="type">const</span> <span class="type">int</span>&amp;)</span></span>;  <span class="comment">//定义</span></span><br></pre></td></tr></table></figure>
<p>当编译器遇到extern模板声明时，它不会在本文件中生成实例化代码，将一个实例化声明为extern就表示承诺在程序其他位置有文件实例化的一个非extern声明（定义）。对于一个给定的实例化版本，可能有多个extern声明，但必须只有一个定义。<br>由于编译器在使用一个模板时自动对其实例化，因此extern声明必须出现在任何使用些实例版本的代码之前。</p>
<h2 id="模板实参推断"><a href="#模板实参推断" class="headerlink" title="模板实参推断"></a>模板实参推断</h2><h3 id="指定显式模板实参"><a href="#指定显式模板实参" class="headerlink" title="指定显式模板实参"></a>指定显式模板实参</h3><p>可以为函数模板指定显式模板实参，以控制函数的返回类型与实例化<br>如下面定义的sum函数模板，接受两个不同类型的参数，并返回一个不同类型的结果：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2, <span class="keyword">typename</span> T3&gt;</span><br><span class="line"><span class="function">T1 <span class="title">sum</span><span class="params">(T2, T3)</span></span>; <span class="comment">//由于参数列表中没有T1，所以编译器无法推断T1的类型，必须显式提供</span></span><br></pre></td></tr></table></figure>
<p>用法:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> val3 = <span class="built_in">sum</span>&lt;<span class="type">double</span>&gt;(<span class="number">42</span>, <span class="number">33.2f</span>);  <span class="comment">//double sum(int, float)</span></span><br></pre></td></tr></table></figure>
<p>显式模板实参按由左至右的顺序与对应的模板参数匹配，只有尾部（最右）参数的显式模板实参才可以忽略，而且前提是它们可以从函数参数推断出来。如果sum函数模板中这样写<code>T3 sum(T2, T1)</code>，其他不变，则此时必须同时指定3个实参：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> val2 = <span class="built_in">sum</span>&lt;<span class="type">double</span>, <span class="type">int</span>, <span class="type">float</span>&gt;(<span class="number">42</span>, <span class="number">33.2f</span>);</span><br></pre></td></tr></table></figure>
<p>对于指定了模板类型实参的函数实参会发生正常的类型转换。</p>
<h3 id="尾置返回类型与类型转换"><a href="#尾置返回类型与类型转换" class="headerlink" title="尾置返回类型与类型转换"></a>尾置返回类型与类型转换</h3><p><strong>通过尾置返回类型返回引用</strong><br>由于尾置返回出现在参数列表之后，它可以使用函数的参数，尾置返回允许我们在参数列表之后声明返回类型，并可以使用decltype来推断返回类型。例如编写一个函数，接受表示序列的一对迭代器，并返回序列中一个元素的引用，由于此时并不知道引用的类型，引用的类型只有在确定迭代器之后才能知道，这种情况就可以使用尾置返回，如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">fcn</span><span class="params">(It beg, It end)</span> -&gt; <span class="title">decltype</span><span class="params">(*beg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">//处理序列</span></span><br><span class="line">  <span class="keyword">return</span> *beg;  <span class="comment">//返回序列中一个元素的引用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>通过标准库的类型转换模板返回元素的值</strong><br>类似上面的情况，假如要返回元素的值，由于上述情况下迭代器的操作都不会生成元素，只能生成元素的引用，所以无法返回元素的值。可以使用标准库的类型转换模板来获得元素的类型，然后再返回一个值。该模板定义在头文件type_traits中。可以使用其中的remove_reference来获得元素的类型，该模板有一个模板类型参数和一个名为type的类型成员，如remove_reference&lt;int&amp;&gt;，则type成员将是int。如上例返回值而非引用，改写为：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">fcn2</span><span class="params">(It beg, It end)</span> -&gt;</span></span><br><span class="line"><span class="function">  <span class="keyword">typename</span> remove_reference&lt;<span class="title">decltype</span><span class="params">(*beg)</span>&gt;::type</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> *beg;  <span class="comment">//返回序列中一个元素的拷贝</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="函数指针与实参推断"><a href="#函数指针与实参推断" class="headerlink" title="函数指针与实参推断"></a>函数指针与实参推断</h3><p>当用一个函数模板初始化一个函数指名或为一个函数指针赋值时，编译器使用指针的类型来推断模板实参。如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="type">int</span> <span class="title">compare</span><span class="params">(<span class="type">const</span> T&amp;, <span class="type">const</span> T&amp;)</span></span>;</span><br><span class="line"><span class="comment">//pf1指向实例int compare(const int&amp;, const int&amp;)</span></span><br><span class="line"><span class="built_in">int</span> (*pf1)(<span class="type">const</span> <span class="type">int</span>&amp;, <span class="type">const</span> <span class="type">int</span>&amp;) = compare;</span><br></pre></td></tr></table></figure>

<h3 id="函数模板实参推断与引用"><a href="#函数模板实参推断与引用" class="headerlink" title="函数模板实参推断与引用"></a>函数模板实参推断与引用</h3><p>1.对于带有引用类型的模板类型参数推断，首先需要明白两点：编译器会应用正常的引用绑定规则（即&amp;绑定到左值，const &amp;即可绑定到左值，又可绑定到右值，&amp;&amp;绑定到右值）；const是底层的，不是顶层的（即const是类型的一部分）。<br><strong>从左值引用函数参数推断类型</strong><br>当函数参数是模板类型参数的一个普通（左值）引用时（即，形如T&amp;），绑定规则告诉我们，只能传递给它一个左值（如，一个变量或一个返回引用类型的表达式）。实参可以是const类型，也可以不是。如果实参是const类型，则T将被推断为const类型。如：<br>f1为非const的普通引用</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">(T&amp;)</span></span>; <span class="comment">//实参必须是一个左值</span></span><br><span class="line"><span class="built_in">f1</span>(i);  <span class="comment">//i是一个int，则T为int</span></span><br><span class="line"><span class="built_in">f1</span>(ci); <span class="comment">//ci是一个const int;则T为const int</span></span><br><span class="line"><span class="built_in">f1</span>(<span class="number">5</span>);  <span class="comment">//错误，传递给&amp;的必须是左值</span></span><br></pre></td></tr></table></figure>
<p>f2为const的普通引用</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="type">void</span> <span class="title">f2</span><span class="params">(<span class="type">const</span> T&amp;)</span></span>; <span class="comment">//实参是一个左值或右值</span></span><br><span class="line"><span class="built_in">f2</span>(i);  <span class="comment">//i是一个int，则T为int</span></span><br><span class="line"><span class="built_in">f2</span>(ci); <span class="comment">//ci是一个const int;则T为int</span></span><br><span class="line"><span class="built_in">f2</span>(<span class="number">5</span>);  <span class="comment">//正确，T是一个int</span></span><br></pre></td></tr></table></figure>

<p><strong>从右值引用函数参数推断类型</strong><br>右值引用的类型推断类似左值引用。如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="type">void</span> <span class="title">f3</span><span class="params">(T&amp;&amp;)</span></span>;</span><br><span class="line"><span class="built_in">f3</span>(<span class="number">42</span>); <span class="comment">//实参是一个int类型的右值；模板参数T是int</span></span><br></pre></td></tr></table></figure>
<p><strong>将右值引用绑定到左值的例外</strong><br>通常不能将一个右值引用绑定到一个左值上，但C++在正常的绑定规则下定义了两个例外规则：一个是当将一个左值（如变量i）传递给函数的右值引用参数，且此右值引用指向模板类型参数（如T&amp;&amp;）时，编译器推断模板类型参数为实参的左值引用类型，如f3(i)中T类型为int&amp;，而非int。另一个是 <strong>引用折叠</strong>产生的例外使我们可以在模板类型参数上，将一个右值引用绑定到一个左值上，通常不能创建引用的引用，但可以通过类型别名或模板类型参数间接定义引用的引用。当间接创建一个引用的引用时，这些引用将发生“折叠”，除了右值引用的右值引用会折叠成右值引用之外，其他所有情况下，引用的引用都会折叠成一个普通的左值引用。如：</p>
<ul>
<li>X&amp; &amp;、X&amp; &amp;&amp;和X&amp;&amp; &amp;都折叠成类型X&amp;</li>
<li>类型X&amp;&amp; &amp;&amp;折叠成X&amp;&amp;<br>如上面定义的变量及f3：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">f3</span>(i);   <span class="comment">//T将为int&amp;</span></span><br><span class="line"><span class="built_in">f3</span>(ci);     <span class="comment">//T是一个const int&amp;</span></span><br></pre></td></tr></table></figure>
这种右值引用的例外将导致：</li>
<li><em>如果一个函数参数是指向模板参数类型的右值引用（如，T&amp;&amp;），则可以传递给它任意类型的实参。如果将一个左值传递给这样的参数，则函数参数被实例化为一个普通的左值引用（T&amp;）。*</em><br>右值引用通常用于两种情况：模板转发其实参或模板被重载</li>
</ul>
<p>C++11中 <strong>std::move的工作方式表明可以使用static_cast显式地将一个左值转换为一个右值引用</strong>，通常情况下static_cast只能用于合法的类型转换，所以这也是一条针对右值引用的特许规则。使用方法如std::move的定义：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在返回类型和类型转换中需要用typename指明成员是一个类型而不是成员变量名称</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> remove_reference&lt;T&gt;::<span class="function">type&amp;&amp; <span class="title">move</span><span class="params">(T&amp;&amp; t)</span>  <span class="comment">//前面的typename是告诉编译器type是个类型而不是成员变量名</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">typename</span> remove_reference&lt;T&gt;::type&amp;&amp;&gt;(t);  <span class="comment">//typename同样是告诉编译器type是一个类型而不是成员变量名</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>当通过模板使用模板类中的类型时，需要使用typename指定此时引用的是个类型，而不是成员变量名</strong><br>例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::vector&lt;T&gt; vec;</span><br><span class="line"><span class="keyword">typename</span> std::vector&lt;T&gt;::iterator it = vec.<span class="built_in">begin</span>();  <span class="comment">//此时需要通过typename指定iterator是个类型，而不是一个变量名</span></span><br></pre></td></tr></table></figure>

<h3 id="参数转发"><a href="#参数转发" class="headerlink" title="参数转发"></a>参数转发</h3><p>1.参数转发即指将函数的一个或多个实参连同类型等所有性质保持不变地转发给其他函数，包括实参类型是否是const，以及实参是左值还是右值。<br><strong>如果一个函数参数是指向模板类型参数的右值引用（如T&amp;&amp;），它对应的实参的const属性和左传/右值属性将得到保持</strong></p>
<p>2.C++11中可以使用std::forward保持类型信息。std::forward类似move，定义在头文件utility中，与move不同的时，forward必须通过显式模板实参来调用，forward返回该显式实参类型的右值引用，即forward<T>的返回类型是T&amp;&amp;。<br><strong>当用于一个指向模板参数类型的右值引用函数参数（T&amp;&amp;）时，forward会保持实参类型的所有细节</strong><br>如下面的函数flip将其参数t1、t2传递给函数f：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">flip</span><span class="params">(F f, T1 &amp;&amp;t1, T2 &amp;&amp;t2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">f</span>(std::forward&lt;T2&gt;(t2), std::forward&lt;T1&gt;(t1));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用：<code>flip(g, i, 42);</code>，i将以int&amp;类型传递给g，42将以int&amp;&amp;类型传递给g</p>
<h2 id="重载与模板"><a href="#重载与模板" class="headerlink" title="重载与模板"></a>重载与模板</h2><p>函数模板可以被另一个模板或一个普通模板函数重载。<br>涉及有函数模板的重载，在函数匹配时，如果即有非模板函数又有模板函数时，会优先选择非模板函数。当有多个函数模板可选择时，会在类型转换的情况下，优先选择更特例化的模板。<br><strong>在定义任何函数之前，记得声明所有重载的函数版本。这样就不必担心编译器由于未遇到你希望调用的函数而实例化一个并非你需要的版本</strong></p>
<h2 id="可变参数模板"><a href="#可变参数模板" class="headerlink" title="可变参数模板"></a>可变参数模板</h2><p>1.一个可变参数模板就是一个可以接受可变数目参数的模板函数或模板类，当然这里我们只会用到模板函数。可变数目的参数被称为参数包，包括模板参数包（由0个多或多个类型组成）和函数参数包（由0个或多个函数参数组成）。可变参数的函数模板声明通常形如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Args是一个模板参数包，rest是一个函数参数包</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> ... Args&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">const</span> T &amp;t, <span class="type">const</span> Args&amp; ... rest)</span></span>;  <span class="comment">//扩展Args</span></span><br></pre></td></tr></table></figure>
<p>用一个省略号来指出一个模板参数或函数参数表示一个包。在一个模板参数列表中，class…或typename…指出接下来的参数表示0个或多个类型的列表；一个类型名后面跟一个省略号表示零个或多个给定类型的非类型参数的列表。<br>也就是<code>typename 省略号（...） 模板参数包名字</code>来定义一个模板参数包，<code>扩展模式 模板包名字 省略号（...） 函数参数包名字</code>来将模板包扩展成相应模式下的函数参数包，同样当将函数参数包名字后跟省略号时，即可扩展函数参数包。当编译器在对模板特例化时，会自动按照提供给参数包的模式进行扩展包，扩展之后的参数相当于一个以逗号分隔的参数列表，如上例中const Arg&amp;会应用到模板参数包Args中的每一个元素，也就是最终rest中包含的所有元素都将是const的引用，类型由编译器根据传递的参数进行自动推断。</p>
<p>2.与可变参数模板对应的还有一个sizeof…运算符，用于返回参数包中的参数个数，当然可以用它来配合递归函数访问各参数。<br>注意可变参数模板的使用不需要再指定类型，具体类型由编译器根据传递给函数的实参进行推断。<br>3.当需要在函数内部访问各参数列表中的参数时，直接对函数参数包进行扩展即可，通常是采用递归的方式访问各参数，为了终止递归就需要定义一个重载的函数用于终止递归<br>下面还是以一个计算和的例子分析：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">const</span> T &amp;t, <span class="type">const</span> Args&amp; ... args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;sizeof...(Args): &quot;</span> &lt;&lt; <span class="keyword">sizeof</span>...(Args) &lt;&lt; std::endl;  <span class="comment">//输出模板参数Args的个数</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;sizeof...(args): &quot;</span> &lt;&lt; <span class="keyword">sizeof</span>...(args) &lt;&lt; std::endl; <span class="comment">//输出函数参数args的个数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">std::ostream&amp; <span class="title">print</span><span class="params">(std::ostream &amp;os, <span class="type">const</span> T &amp;t)</span>    <span class="comment">//用于结束递归，当参数个数为2个时调用</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> os &lt;&lt; t &lt;&lt; std::endl;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> ... Args&gt;</span><br><span class="line"><span class="function">std::ostream&amp; <span class="title">print</span><span class="params">(std::ostream &amp;os, <span class="type">const</span> T &amp;t, Args ... rest)</span>  <span class="comment">//当参数个数大于2个时调用</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    os &lt;&lt; t &lt;&lt; <span class="string">&quot;, &quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">print</span>(os, rest...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">sum_template</span><span class="params">(<span class="type">const</span> T &amp;t)</span>   <span class="comment">//声明一个重载的固定参数数目的函数，用于结束递归</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function">T <span class="title">sum_template</span><span class="params">(<span class="type">const</span> T &amp;t, <span class="type">const</span> Args&amp;... args)</span>   <span class="comment">//该函数通过调用仅含一个参数的重载函数来结束递归</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span>  <span class="built_in">sum_template</span>(args...) + t;  <span class="comment">//展开函数参数包args中的实参</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">foo</span>(<span class="string">&#x27;a&#x27;</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="string">&quot;ssl&quot;</span>);</span><br><span class="line">    <span class="built_in">print</span>(std::cout, <span class="string">&#x27;a&#x27;</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="string">&quot;ssl&quot;</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">sum_template</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">sum_template</span>(<span class="number">1.1</span>, <span class="number">2.5</span>, <span class="number">3</span>, <span class="number">4.4</span>, <span class="number">5</span>) &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sizeof...(Args): 3</span><br><span class="line">sizeof...(args): 3</span><br><span class="line">a, 2, 3, ssl</span><br><span class="line">15</span><br><span class="line">15.6</span><br></pre></td></tr></table></figure>
<p>根据后面的求和输出结果可见，对于将double与int混合计算时结果是错误的，因为计算过程中发生了double到int的转换，导致精度损失，所以对于这种情况要注意类型转换问题。</p>
<h3 id="包扩展"><a href="#包扩展" class="headerlink" title="包扩展"></a>包扩展</h3><p>1.对于一个参数包，除了获取其大小外，唯一对它能做的就是扩展（expand），当扩展一个包时，需要提供用于每个扩展元素的模式（pattern），扩展一个包就是将它分解为构成的元素，对每个元素应用模式，获得扩展后的列表。通过在模式右边放一个省略号（…）来触发扩展操作。<br>2.包扩展除了上面用到的将函数参数包中的每个元素应用模式const &amp;这类属性之外，还支持更复杂的扩展，例如对每个元素调用某个函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function">ostream &amp;<span class="title">errorMsg</span><span class="params">(ostream &amp;os, <span class="type">const</span> Args&amp;... rest)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">print</span>(os, <span class="built_in">debug_rep</span>(rest)...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对rest参数包中的每个元素调用函数debug_rep</p>
<p><strong>转发参数包</strong><br>C++11中可以使用forward转发参数包。如<code>std::forward&lt;Args&gt;(args)...</code>转发类型为Args的参数包args中的类型参数。</p>
<h2 id="模板特例化"><a href="#模板特例化" class="headerlink" title="模板特例化"></a>模板特例化</h2><p>1.一个模板特例化（template specialization）版本就模板的一个独立的定义，在其中一个或多个模板参数被指定为特定的类型</p>
<h3 id="函数模板特例化"><a href="#函数模板特例化" class="headerlink" title="函数模板特例化"></a>函数模板特例化</h3><p>2.定义函数模板的特例化版本时，必须为原模板中的每个模板参数都提供实参。为了指定我们正在实例化一个模板，应使用template后跟一个空尖括号对（<code>&lt;&gt;</code>），空尖括号指出我们将为原模板的所有模板参数提供实参:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//原模板</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="type">int</span> <span class="title">compare</span><span class="params">(<span class="type">const</span> T&amp;, <span class="type">const</span> T&amp;)</span></span>;</span><br><span class="line"><span class="comment">//compare的特殊版本，处理字符数组的指针</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">compare</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* <span class="type">const</span> &amp;p1, <span class="type">const</span> <span class="type">char</span>* <span class="type">const</span> &amp;p2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">strcmp</span>(p1, p2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>特例化的本质是实例化一个模板，而非重载它，因此特例化不影响函数匹配</strong><br>为了特例化一个模板，原模板的声明必须在作用域中，所以模板及其特例化版本应该声明在同一个头文件中。所有同名模板的声明应该放在前面，然后是这些模板的特例化版本。</p>
<h3 id="类模板特例化"><a href="#类模板特例化" class="headerlink" title="类模板特例化"></a>类模板特例化</h3><p>1.类模板特例化时，必须在原模板定义所在命名空间中特例化它。当特例化类模板的所有模板参数时，定义方式与函数模板特例化类似。<br>2.<strong>类模板支持部分特例化</strong>。一个类模板的部分特例化（partial specialization）本身是一个模板，所以使用时必须提供那个未指定的模板参数。如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//原始的通常版本</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; strcut remove_reference &#123;</span><br><span class="line">  <span class="keyword">typedef</span> T type;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//部分特例化版本，将用于左值引用和右值引用</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; strcut remove_reference&lt;T&amp;&gt; &#123; <span class="comment">//左值引用</span></span><br><span class="line">  <span class="keyword">typedef</span> T type;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; strcut remove_reference&lt;T&amp;&amp;&gt; &#123; <span class="comment">//右值引用</span></span><br><span class="line">  <span class="keyword">typedef</span> T type;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>调用：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">remove_reference&lt;(<span class="keyword">decltype</span>(<span class="number">42</span>))&gt;::type a;  <span class="comment">//使用原始版本</span></span><br><span class="line">remove_reference&lt;(<span class="keyword">decltype</span>(i))&gt;::type b;  <span class="comment">//i为int类型变量，使用第一个部分特例化版本</span></span><br><span class="line">remove_reference&lt;(<span class="keyword">decltype</span>(std::<span class="built_in">move</span>(i)))&gt;::type c;  <span class="comment">//i为int类型变量，使用第二个部分特例化版本</span></span><br></pre></td></tr></table></figure>
<p>也可以只 <strong>特例化成员而不是类</strong>，如下Foo是一个模板，包含一个成员Bar，后面将只特例化该成员：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">struct</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">  <span class="built_in">Foo</span>(<span class="type">const</span> T &amp;t = <span class="built_in">T</span>()) : <span class="built_in">mem</span>(t) &#123;&#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Bar</span><span class="params">()</span> </span>&#123;<span class="comment">/*...*/</span>&#125;</span><br><span class="line">  T mem;</span><br><span class="line">  <span class="comment">//other member</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//特例化成员Bar</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;    <span class="comment">//表示正在特例化一个模板</span></span><br><span class="line"><span class="type">void</span> Foo&lt;<span class="type">int</span>&gt;::<span class="built_in">Bar</span>()  <span class="comment">//表示正在特例化Foo&lt;int&gt;的成员Bar</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//其他应用于int的特例化处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>Notes</tag>
        <tag>CPP-OOP</tag>
      </tags>
  </entry>
  <entry>
    <title>C++学习笔记之面向对象程序设计</title>
    <url>/2016/01/13/cpp-oop-object-oriented/</url>
    <content><![CDATA[<p>1.面向对象编程的核心思想是数据抽象、继承和动态绑定。  </p>
<h2 id="派生类"><a href="#派生类" class="headerlink" title="派生类"></a>派生类</h2><p>2.C++中，基类将类型相关的函数（即派生类可能需要改变的函数）与派生类不做改变直接继承的函数区分对待。对于基类希望它的派生类各自定义适合自身版本的函数，基类需要将这些函数声明为虚函数（virtual function）。  </p>
<span id="more"></span>
<p>3.派生类必须通过使用类派生列表明确指定它从哪个基础派生而来，类派生列表即类名后面跟冒号，然后是基类列表，每个基类前面可以有访问说明符。派生类必须在其内部对所有重新定义的虚函数进行声明。声明方式可以在函数前加关键字virtual，或者使用C++11中的在后面添加override。但派生类不需要桥头所有继承而来的虚函数，如果派生类没有覆盖其基类中的某个虚函数，则该虚函数的行为类似其他普通成员，派生类会直接继承其在基类中的版本。eg:  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Quote</span> &#123;</span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">  <span class="function">std::string <span class="title">isbn</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">net_price</span><span class="params">(std::<span class="type">size_t</span> n)</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bulk_quote</span> : <span class="keyword">public</span> Quote &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">double</span> <span class="title">net_price</span><span class="params">(std::<span class="type">size_t</span> n)</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>4.使用基类的引用（或指针）调用一个虚函数时将发生运行时动态绑定。即当某个函数形参是基类的引用时，可以为其传递一个基类的引用，也可以为其传递一个派生类的引用，在该函数内部调用虚函数时，将在运行时根据传递的是基类还是派生类来决定调用的是基类的虚函数还是派生类的虚函数。  </p>
<p>5.基类通常都应该定义一个虚析构函数，即使该函数不执行任何实际操作。  </p>
<p>6.任何构造函数之外的非静态函数都可以是虚函数，关键字virtual只能出现在类内部的声明语句之前而不能用于类外部的函数定义。如果基类把一个函数声明为虚函数，则该函数在派生类中也将隐式地成为虚函数。当使用指针或引用调用虚函数时，该调用将被动态绑定。成员函数如果没被声明为虚函数，则其解析过程将发生在编译时而非运行时。  </p>
<p>9.编译器可以隐式地执行派生类到基类的转换，所以之所有可以将基类的指针或引用绑定到了派生类，实际上是发生了动态转换。eg:  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Quote item;             <span class="comment">//基类</span></span><br><span class="line">Bulk_quote bulk;        <span class="comment">//派生类</span></span><br><span class="line">Quote *p = &amp;item;       <span class="comment">//p指向Quote对象</span></span><br><span class="line">p = &amp;bulk;              <span class="comment">//p指向bulk的Quote部分</span></span><br><span class="line">Quote &amp;r = bulk;        <span class="comment">//r绑定到bulk的Quote部分</span></span><br></pre></td></tr></table></figure>

<p>10.每个类控制它自己的成员初始化。尽管派生类对象中含有从基类继承而来的成员，但派生类并不能直接初始化这些成员。派生类必须使用基类的构造函数来初始化它的基类部分。eg:  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Bulk_quote构造函数</span></span><br><span class="line"><span class="built_in">Bulk_quote</span>(<span class="type">const</span> std::string&amp; book, <span class="type">double</span> p, std::<span class="type">size_t</span> qty, <span class="type">double</span> disc) : <span class="built_in">Quote</span>(book, p), <span class="built_in">min_qty</span>(qty), <span class="built_in">discount</span>(disc) &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>初始化过程：首先初始化基类的部分，然后按照声明的顺序依次初始化派生类的成员。  </p>
<p>11.如果基类定义了一个静态成员，则整个继承体系中只存在该成员的唯一定义。不论从基类派生出多少个派生类，对于每个静态成员来说都只存在唯一实例。也就是说调用时派生类和派生类对象可以直接调用基类中定义的静态成员。  </p>
<p>12.派生类的声明不包含派生列表（class Bulk_quote;）。但被用作基类的类必须定义而非仅仅声明。  </p>
<p>13.派生类也可以被继承。如果D为基类，D1继承自D，D2继承自D1，则D是D1的直接基类（direct base），同时是D2的间接基类（indirect base）。但类不能继承自它自己  </p>
<p>14.C++11中可以在类名后面跟关键字final来指定某个类不能被继承。  </p>
<p>15.派生类向基类的类型转换中存在静态类型与动态类型的问题。静态类型（static type）是指在编译时就已知其类型，它是变量声明时的类型或表达式生成的类型，如果表达式即不是指针也不是引用，则它的动态类型与静态类型永远一致。动态类型（dynamic type）是指变量或表达式在内存中的对象的类型，动态类型只到运行时才可知。例如派生类的对象可以赋给基类的指针或引用，此时基类的指针或引用在声明时便是静态类型，但在运行时却是动态类型，因为此时该指针或引用即可以接受一个派生类对象，也可以接受一个基类对象。所以只有基类的指针或引用的静态类与动态类型才有可能不一致。  </p>
<p>16.不存在从基类向派生类的隐式类型转换，因为每个派生类对象中都包含一个基类部分，而基类对象中并不一定包含派生类的部分，当将一个基类的指针或引用绑定到派生类时，实际上是绑定到该派生类对象的基类部分上。派生类向基类的自动类型转换只针对指针或引用 有效。  </p>
<h2 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h2><p>通过虚函数可以实现通过基类的引用来访问派生类中通过基类继承而来的虚函数。其中一个用处就是可以定义一个基类的变量，这个变量即可以指向基类对象，又可以指向派生类对象，那么通过该变量也就即可以访问基类成员又可以访问派生类的成员。<br>1.必须为每一个虚函数都提供定义，因为基类的引用或指针调用一个虚成员函数时会执行动态绑定，直到运行时才能知道到底调用了哪个版本的虚函数，因为在运行时用户可以根据需要来确定给虚函数提供的参数是基类的对象还是派生类的对象。  </p>
<p>2.OOP的核心思想是多态性(polymorphism)。其含义是多种形式，具有继承关系的多个类型称为多态性，因为我们能使用这些类型的“多种形式”而无须在意它们之间的差异。例如基类的引用或指针可以动态绑定到派生类，从而通过虚函数来执行派生类的相应函数，在该情况下该引用或指针所绑定的对象可能是一个基类的对象也可能是一个派生类的对象，相应的执行的虚函数也就有可能是基类的版本，也有可能是派生类的版本。引用或指针的静态类型与动态类型不同这一事实是C++支持多态性的根本所在。  </p>
<p>3.一个函数一旦被声明成了虚函数，则在有派生类中它都是虚函数。如果在派生类的覆盖了某个继承而来的虚函数，而它的形参类型和函数返回值必须与被它覆盖的基类函数完全一致。返回值的一个例外是当类的虚函数返回类型时类本身的指针或引用时，此时基类返回的类型肯定是基类的，派生类自然也可以返回派生类自己的。注意此处与函数重载是完全不一样的，重载只发生在同一个作用域之内。当然派生类中可以声明与基类形参列表不同但同名的函数，但此时该函数将与基类函数是相互独立的，且编译器不会报错，解决这个问题需要使用override关键字。  </p>
<p>4.C++11中可以在派生类的虚函数中使用override关键字用来表明该函数将会覆盖基类中的虚函数，如果此时形参列表不致，编译将报错。<br>举例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Base</span>(<span class="type">const</span> Base&amp;) = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Base</span>(<span class="type">int</span> i) : <span class="built_in">x</span>(i) &#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">return_val</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> x; &#125;; <span class="comment">//虚函数</span></span><br><span class="line">    ~<span class="built_in">Base</span>() = <span class="keyword">default</span>;</span><br><span class="line"><span class="keyword">protected</span>:  <span class="comment">//为了使派生类可以访问该成员，需要声明为受保护的</span></span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derive</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Derive</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Derive</span>(<span class="type">const</span> Derive&amp;) = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Derive</span>(<span class="type">int</span> i) : <span class="built_in">Base</span>(i), <span class="built_in">y</span>(i) &#123;&#125;;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">return_val</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> x * y; &#125;; </span><br><span class="line">    ~<span class="built_in">Derive</span>() = <span class="keyword">default</span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> y; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//形参item将即可接受Base对象，又可以接受其派生类对象</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_val</span><span class="params">(<span class="type">const</span> Base &amp;item, std::ostream &amp;os = std::cout)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    os &lt;&lt; item.<span class="built_in">return_val</span>() &lt;&lt; std::endl;  <span class="comment">//return_val将根据item所指向的不同对象调用不同类的虚函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Base <span class="title">b1</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">    <span class="function">Derive <span class="title">d1</span><span class="params">(<span class="number">6</span>)</span></span>;</span><br><span class="line">    <span class="comment">//使用同一个函数print_val分别输出b1和d1的值</span></span><br><span class="line">    <span class="built_in">print_val</span>(b1);</span><br><span class="line">    <span class="built_in">print_val</span>(d1);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5.当把某个函数声明为final时，则之后任何尝试覆盖该函数的操作都将引发编译错误。final和override说明符出现在形参列表（包括任何const或引用修饰符）以及尾置返回类型之后。  </p>
<p>6.如果在虚函数中使用默认实参，则通过基类的引用或指针调用函数时，不管派生类中定义的默认实参值是什么，都将使用基类的默认实参。所以基类和派生类的默认最好一致。  </p>
<p>7.可以通过使用作用域运算符来强制回避虚函数的动态绑定。如：  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//强行调用基类中定义的函数版本而不管baseP的动态类型是什么</span></span><br><span class="line"><span class="type">double</span> undiscounted = baseP-&gt;Quote::<span class="built_in">net_price</span>(<span class="number">42</span>);</span><br></pre></td></tr></table></figure>

<p>8.如果一个派生类的虚函数需要调用它的基类版本，而没有使用作用域运算符明确指定，则在动行时该调用将被解析为对派生类版本自身的调用 ，从而导致无限递归。eg:  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">print</span><span class="params">(ostream &amp;os)</span> <span class="type">const</span>  </span>&#123; os &lt;&lt; <span class="string">&quot;hi&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">//下面的定义将导致无限递归，因为默认调用的将是B自己的print函数</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(ostream &amp;os)</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;<span class="built_in">print</span>(os); os &lt;&lt; <span class="string">&quot;world&quot;</span>; &#125;</span><br><span class="line">  <span class="comment">//修改为</span></span><br><span class="line">  <span class="comment">//void print(ostream &amp;os) const override &#123; A::print(os); os &lt;&lt; &quot;world&quot;; &#125;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>9.关于虚函数表/虚表(vtable)，当类中包含有虚成员函数时，在用该类实例化对象时，对象的第一个成员将是一个指向虚函数表的指针，gdb打印显示为_vptr。该虚函数表记录运行过程中实际应该调用的所有虚函数的入口地址。eg:  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">b</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">b</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">b</span>(<span class="type">int</span> i) : <span class="built_in">x</span>(i) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">print</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;  <span class="comment">//纯虚函数</span></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">b</span>() = <span class="keyword">default</span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//派生类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">d</span> : <span class="keyword">public</span> b &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">d</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">d</span>(<span class="type">int</span> i, <span class="type">int</span> j) : <span class="built_in">b</span>(i), <span class="built_in">y</span>(j) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;std::cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; y &lt;&lt; std::endl;&#125;  <span class="comment">//重写纯虚函数</span></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">d</span>() = <span class="keyword">default</span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//普通类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">a</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">a</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">a</span>(<span class="type">int</span> i) : <span class="built_in">x</span>(i) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> <span class="type">const</span> </span>&#123;std::cout &lt;&lt; x &lt;&lt; std::endl;&#125;</span><br><span class="line">    ~<span class="built_in">a</span>() = <span class="keyword">default</span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">d <span class="title">dd</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;     <span class="comment">//含有虚函数的派生类的对象</span></span><br><span class="line">    dd.<span class="built_in">print</span>();</span><br><span class="line">    <span class="function">a <span class="title">aa</span><span class="params">(<span class="number">1</span>)</span></span>;        <span class="comment">//普通类的对象</span></span><br><span class="line">    aa.<span class="built_in">print</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用gdb调试时，分别打印dd和aa，发现dd的第一个成员是一个指向虚表的指针。  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">(gdb) info locals </span><br><span class="line">dd = &#123;&lt;b&gt; = &#123;_vptr.b = <span class="number">0x400e30</span> &lt;vtable <span class="keyword">for</span> d+<span class="number">16</span>&gt;, x = <span class="number">1</span>&#125;, y = <span class="number">2</span>&#125;</span><br><span class="line">aa = &#123;x = <span class="number">1</span>&#125;</span><br></pre></td></tr></table></figure>

<p>10.虚析构函数的意义主要是为了防止内存泄漏。因为当一个基类的指针指向派生类的对象时，如果基类的析构函数不是虚函数，则通过该指针来delete派生类对象，系统将只执行基类的析构函数。因为只有通过虚函数实现的多态才能使用基类的指针访问派生类的成员。所以为了避免由于这种情况引起的无法正常析构派生类，往往将析构函数声明为虚函数，这样，执行delete时，系统将先执行派生类对象的析构函数，再执行基类的析构函数。  </p>
<h2 id="抽象基类-纯虚函数"><a href="#抽象基类-纯虚函数" class="headerlink" title="抽象基类-纯虚函数"></a>抽象基类-纯虚函数</h2><p>可以通过将类定义成抽象基类来禁止用户创建该类的对象，通过在函数内部定义纯虚函数即可将一个类定义成抽象基类，无法创建抽象基类的对象。<br>1.纯虚函数（pure virtual）无须定义，只需要在函数体的位置（即声明语句的分号之前）添加<code>=0</code>即可将一个虚函数声明为纯虚函数。<code>=0</code>只能出现的类内部的虚函数声明语句处，当然这个虚函数可以是从基类继承而来的，此时可以不写函数声明前面的virtual关键字。如果在基类中定义纯虚函数，则必须带上virtual关键字。纯虚函数也可以有定义，但定义必须在类的外部，即不能在函数内部为一个=0的函数提供函数体。eg:  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">net_price</span><span class="params">(std::<span class="type">size_t</span> n)</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>2.含有纯虚函数的类是抽象基类（abstract base class），抽象基类负责定义接口，后续的其他类可以覆盖该接口提供具体实现。如果一个派生自抽象基类的派生类不给纯虚函数提供定义，则该派生类仍将是抽象基类。  </p>
<p>3.派生类的构造函数只初始化它的直接基类，即不管继承多少次，派生类的构造函数都只负责初始化它自己新定义的成员，基类的成员将由基类的构造函数来初始化。eg:  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">A</span>() = <span class="keyword">default</span>;</span><br><span class="line">  <span class="built_in">A</span>(<span class="type">int</span> x) : <span class="built_in">xa</span>(x) &#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span> xa;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//派生类B将参数x传递给A的构造函数，由A的构造函数来初始xa，它只负责初始化自己新增加的xb</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">B</span>() = <span class="keyword">default</span>;</span><br><span class="line">  <span class="built_in">B</span>(<span class="type">int</span> x, <span class="type">int</span> y) : <span class="built_in">A</span>(x), <span class="built_in">xb</span>(y) &#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span> xb;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4.抽象类的指针可以指向它的所有派生类对象，并调用派生类中的虚函数。  </p>
<h2 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h2><ul>
<li>public成员：      可以被该类中的函数、友元函数、子类中的函数、类的对象访问  </li>
<li>protected成员：   可以被该类中的函数、友元函数、子类中的函数访问  </li>
<li>private成员：     可以被该类中的函数、友元函数访问</li>
</ul>
<p>protected成员对于类的用户来说与私有成员一样，无法被类的用户访问，但对于派生类的成员和友元来说是可访问的。但派生类的成员或友元只能通过派生类对象来访问基类的protected成员，而派生类对于基类对象中的受保护成员没有任何访问权限，也就是说派生类的成员和友元只能访问派生类对象中的基类部分的受保护成员，因为派生类是继承而类的受保护成员。eg:  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="type">int</span> prot;  <span class="comment">//protected成员</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dri</span> : <span class="keyword">public</span> B &#123;</span><br><span class="line">  <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">clob</span><span class="params">(Dri&amp;)</span></span>;  <span class="comment">//能访问Dri::prot</span></span><br><span class="line">  <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">clob</span><span class="params">(B&amp;)</span></span>;    <span class="comment">//不能访问B::prot</span></span><br><span class="line">  <span class="type">int</span> j;  <span class="comment">//默认是private</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//正确：clob可以访问Dri对象的private和protected成员</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clob</span><span class="params">(Dri &amp;d)</span> </span>&#123;d.j = d.prot = <span class="number">0</span>;&#125;</span><br><span class="line"><span class="comment">//错误：clob不能访问基类的protected成员  </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clob</span><span class="params">(B &amp;b)</span> </span>&#123;b.prot = <span class="number">0</span>;&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意：访问权限是针对类外部对类对象数据的访问权限</strong><br>如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Bass</span>(<span class="type">int</span> num = <span class="number">0</span>) : <span class="built_in">a</span>(num) &#123;&#125;</span><br><span class="line">    <span class="built_in">Bass</span>(<span class="type">const</span> Bass &amp;b);</span><br><span class="line">    ~<span class="built_in">Bass</span>() = <span class="keyword">default</span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Bass::<span class="built_in">Bass</span>(<span class="type">const</span> Bass &amp;b)</span><br><span class="line">&#123;</span><br><span class="line">    a = b.a;   <span class="comment">//这里b可以直接引用其私有变量a，因为这是在类内部，a也是同一个类的变量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="function">Bass <span class="title">b</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">   std::cout &lt;&lt; b.a;   <span class="comment">//错误，a是b的私有变量，cout无法访问其私有变量</span></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="继承权限"><a href="#继承权限" class="headerlink" title="继承权限"></a>继承权限</h2><p>1.某个类对于它继承而来的成员的访问权限受两个因素影响：一是基类中该成员的访问说明符，二是派生类的派生列表中的访问说明符<br>SOF上的解答：<a href="http://stackoverflow.com/questions/860339/difference-between-private-public-and-protected-inheritance">Difference between private, public, and protected inheritance</a><br>继承权限主要影响派生类中继承自基类的成员的被访问权限（即这些继承而来的成员是对否派生类的用户可见），而派生访问说明符对于派生类的成员（及友元）能否访问其直接基类的成员没有影响，对基类成员的访问权限只与基类中的访问说明符有关。根据基类的访问说明符可以有public、protected、private三种情况，子类中相应的权限有：  </p>
<ul>
<li>public： 基类中的public、protected成员在子类中依然不变，当然private成员子类没有权限访问（这也是不指定继承权限时的默认情况）  </li>
<li>protected：基类中的public、protected成员在子类中都将变成protected。</li>
<li>private： 基类中的三种访问权限的成员在子类中都将变成private。  </li>
</ul>
<p>2.如果派生是公有的，则基类的公有成员也是派生接口的组成部分，这样就可以将公有派生类型的对象绑定到基类的引用或指针上，即实现动态绑定。<br>也就是说只有当派生是公有的时候，对于用户代码来说才能使用派生类向基类的类型转换。如果派生方式是私有的或者是受保护的，则用户代码不能使用该转换。  </p>
<p>3.不论派生类以什么方式继承自基类，派生类的成员函数和友元都能使用派生类向基类的转换。  </p>
<p>4.类的设计建议：基类应该将其接口成员声明为公有的，同时将属于其实现的部分分成两组：一组可供派生类访问，即将该组声明为受保护的，这样派生类就能在实现自己的功能时使用基类的这些受保护的操作和数据；另一组只能由基类及基类的友元访问，即将该组声明为私有的。  </p>
<p>5.友元与继承权限：<br>友元关系不能传递，同样友元关系也不能继承，基类的友元在访问派生类的成员时不具有特殊性，类似的，派生类的友元也不能随意访问基类的成员。但基类友的元可以访问内嵌在其派生类对象中的情况（因为每个派生类都包含一个完整的基类，那么基类的友元就可以通过派生类的对象来访问基类的成员，当然该基类成员也是派生类的成员）。</p>
<p>6.可以使用using指令来修改派生类继承的个别名字的访问级别。通过在类的内部使用using声明语句，可以将该类的直接或间接基类中的任何可访问成员（例如，非私有成员）标记出来，从而改变派生类中该基类成员的被访问权限。using声明语句中名字的访问权限由该using声明语句之前的访问说明符来决定。即，如果一条using声明语句出现在类的private部分，则该名字只能被类的成员和友元访问；相应的可以将其放在public和protected部分从而改变其被访问权限。<br>派生类只能为那些它可以访问的名字提供using声明。eg:  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> n;&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> : <span class="keyword">private</span> B &#123;  <span class="comment">//注意private继承</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">using</span> B:size;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="keyword">using</span> B::n;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>7.默认的继承保护级别由定义派生类所用的关键字来决定。默认情况下使用class关键字定义的派生类当省略继承权限控制关键字时是私有继承，而使用struct关键字定义的派生类是公有继承。eg: </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;<span class="comment">/*...*/</span> &#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">D1</span> : B &#123;<span class="comment">/*...*/</span> &#125;;  <span class="comment">//默认public继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D2</span> : B &#123;<span class="comment">/*...*/</span> &#125;;  <span class="comment">//默认private继承</span></span><br></pre></td></tr></table></figure>
<p>使用struct还是class定义类之间的唯一差别就是默认成员访问说明符及默认派生访问说明符。   </p>
<h2 id="继承中的类作用域"><a href="#继承中的类作用域" class="headerlink" title="继承中的类作用域"></a>继承中的类作用域</h2><p>1.当存在继承关系时，派生类的作用域嵌套到其基类的作用域之内。所以如果一个名字在派生类中无法正确解析，编译器将在外层的基类作用域内查找。<br>2.一个对象、引用或指针的静态类型决定了该对象的哪些成员是可见的，即使静态类型与动态类型可能不一致。当发生动态绑定时，由于形参使用的是基类的引用或指针，在使用该引用或指针的函数内部调用虚函数时将发生动态绑定，也就是在运行时才会解析该调用是使用派生类的虚函数还是基类的虚函数（注意此时派生类中的虚函数是继承自基类的）。但如果将一个基类的指针绑定到一个派生类，然后直接使用该指针调用派生类中新定义的成员将是非法的，因为此时实际上是产生了派生类向基类的隐式类型转换，所以在该指针所指的对象中只有基类的成员，并不存在派生类的成员。</p>
<p>3.派生类的成员将隐藏同名的基类成员，所以除了覆盖继承而来的虚函数之外，派生类最好不要重用其他定义在基类中的名字。</p>
<p>4.可以使用域运算符<code>::</code>通过基类来调用被隐藏的虚函数。  </p>
<p>5.成员函数无论是否是虚函数都能被重载，派生类可以覆盖重载函数的0个或多个实例，如果派生类希望基类中所有的重载版本对于它来说都是可见的，那么它就需要覆盖所有的版本，或者一个也不覆盖。由于<code>using</code>声明语句可以指定一个名字，所以可以使用一条基类成员函数的using声明语句来把该函数的所有重载实例添加到派生类作用域中，此时派生类只需要定义其特有的函数就可以了。注意using声明作用的成员必须是派生类可访问的。  </p>
<h2 id="继承体系中的拷贝控制"><a href="#继承体系中的拷贝控制" class="headerlink" title="继承体系中的拷贝控制"></a>继承体系中的拷贝控制</h2><p>1.如果基类的析构函数不是虚函数，则delete一个指向派生类对象的基类指针将产生未定义的行为，所以为了能够动态分配继承体系中的对象需要把函数声明为虚函数。虚函数将阻止合成默认的移动操作，即使通过=default的形式使用了合成的版本，编译器也不会为这个类合成移动操作。  </p>
<p>2.在默认情况下，基类默认构造函数初始化派生类对象的基类部分，如果我们想拷贝或移动基类部分，则必须在派生类的构造函数初始值列表中显式地使用基类的拷贝或移动构造函数。同样，派生类的赋值运算符也必须显式地为其基类部分赋值。但派生类的析构函数只负责销毁由派生类自己分配 的资源，对象的基类部分将由基类的析构函数隐式销毁。eg:  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;<span class="comment">/*...*/</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> : <span class="keyword">public</span> B &#123;</span><br><span class="line"><span class="keyword">public</span>::</span><br><span class="line">    <span class="comment">//默认情况下，基类的默认构造函数初始化对象的基类部分</span></span><br><span class="line">    <span class="comment">//要想使用拷贝或移动构造函数，我们必须在构造函数初始化列表中显式地调用该构造函数</span></span><br><span class="line">    <span class="built_in">D</span>(<span class="type">const</span> D&amp; d) : <span class="built_in">B</span>(d)   <span class="comment">//拷贝基类成员</span></span><br><span class="line">                        <span class="comment">/*D的成员初始值*/</span> &#123;<span class="comment">/*...*/</span>&#125;</span><br><span class="line">    <span class="built_in">D</span>(D&amp;&amp; d) : <span class="built_in">B</span>(std::<span class="built_in">move</span>(d))   <span class="comment">//移动基类成员</span></span><br><span class="line">                        <span class="comment">/*D的成员初始值*/</span> &#123;<span class="comment">/*...*/</span>&#125;</span><br><span class="line">    D&amp; <span class="keyword">operator</span>=(<span class="type">const</span> D &amp;rhs) </span><br><span class="line">    &#123;</span><br><span class="line">      B::<span class="keyword">operator</span>=(rhs);  <span class="comment">//为基类部分赋值</span></span><br><span class="line">      <span class="comment">//按照过去的方式为派生类的成员赋值</span></span><br><span class="line">      <span class="comment">//记得处理自赋值及释放已有资源等情况</span></span><br><span class="line">      <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//B::~B()被隐式自动调用</span></span><br><span class="line">    ~<span class="built_in">D</span>() &#123;<span class="comment">/*清除派生类成员的操作*/</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>3.C++11中派生类能够重用直接基类定义的构造函数，相当于一种特殊的继承。类不能继承默认、拷贝和移动构造函数，如果派生类没有直接定义这些构造函数，编译器将为派生类合成它们。派生类继承基类构造函数的方式是提供一条注明了直接基类类名的using声明语句。eg:  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bulk_quote</span> : <span class="keyword">public</span> Dis_quote &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">using</span> Dis_quote::Dis_quote;  <span class="comment">//继承Dis_quote的构造函数，不需要再自己定义这构造函数</span></span><br><span class="line">  <span class="function"><span class="type">double</span> <span class="title">net_price</span><span class="params">(std::<span class="type">size_t</span>)</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>如果派生类含有自己的数据成员，继承构造函数之后，这些成员将被默认初始化。<br>和普通成员的using声明不一样，构造函数的using声明不会改变该构造函数的访问级别。且using声明语句不能指定explicit和constexpr，如果基类的构造函数是explicit或者constexpr，则继承的构造函数也拥有相同的属性。</p>
<p>4.如果派生类定义的构造函数与基类的构造函数具有相同的参数列表，则该构造函数将不会被继承，定义在派生类中的构造函数将替换继承而来的构造函数。  </p>
<h2 id="容器与继承"><a href="#容器与继承" class="headerlink" title="容器与继承"></a>容器与继承</h2><p>1.当派生类对象被赋值给基类对象时，其中的派生类部分将被“切掉”，因此容器和存在继承关系的类型无法兼容。  </p>
<p>2.可以在容器中放置基类的指针从而实现动态绑定，更好的选择是智能指针。eg:  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;Quote&gt; basket_q;</span><br><span class="line">basket_q.<span class="built_in">push_back</span>(<span class="built_in">Bulk_quote</span>(<span class="string">&quot;cpp&quot;</span>, <span class="number">66.6</span>, <span class="number">10</span>, <span class="number">0.8</span>));  </span><br><span class="line">cout &lt;&lt; basket_q.<span class="built_in">back</span>()-&gt;<span class="built_in">net_price</span>(<span class="number">15</span>) &lt;&lt; endl;  <span class="comment">//将按原价打印，因为Bulk_quote会被隐式转换为Quote</span></span><br><span class="line"></span><br><span class="line">vector&lt;shared_ptr&lt;Quote&gt;&gt; basket;</span><br><span class="line">basket.<span class="built_in">push_back</span>(<span class="built_in">make_shared</span>&lt;Bulk_quote&gt;(<span class="string">&quot;cpp&quot;</span>, <span class="number">66.6</span>, <span class="number">10</span>, <span class="number">0.8</span>));  </span><br><span class="line">cout &lt;&lt; basket.<span class="built_in">back</span>()-&gt;<span class="built_in">net_price</span>(<span class="number">15</span>) &lt;&lt; endl;  <span class="comment">//将可以正常调用Bulk_quote的net_price来打折扣</span></span><br></pre></td></tr></table></figure>

<p>3.C++面向对象编程的一个悖论是无法直接使用对象进行面向对象编程，而是必须使用指针和引用，由于指针会增加程序的复杂性，所以最好是定义一些辅助的类的来处理指针问题。</p>
<p>4.如果使用G++编译时出现<code>undefined reference to &quot;vtable...&quot;</code>需要检查是不是有某个类的虚函数没有提供定义，C++要求所有非纯虚函数（=0）的虚函数都必须有定义，也就是要有函数体，或者使用=default指定。  </p>
<p>5.可以采用模拟虚拷贝的方式来实现在容器中所存储指针的动态绑定。即为基类定义一个虚函数，该虚函数返回*this的拷贝，其派生类重新定义该虚函数返回自己的拷贝。然后定义一个存放该基类静态类型指针的容器，则该容器中的指针便可动态绑定到基类及其派生类的对象。eg:  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Quote</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Quote* <span class="title">clone</span><span class="params">()</span> <span class="type">const</span> &amp; </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Quote</span>(*<span class="keyword">this</span>);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Quote* <span class="title">clone</span><span class="params">()</span>  &amp;&amp; </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Quote</span>(std::<span class="built_in">move</span>(*<span class="keyword">this</span>));&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//派生类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bulk_quote</span> : <span class="keyword">public</span> Quote &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Bulk_quote* <span class="title">clone</span><span class="params">()</span> <span class="type">const</span> &amp; </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Bulk_quote</span>(*<span class="keyword">this</span>);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Bulk_quote* <span class="title">clone</span><span class="params">()</span>  &amp;&amp; </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Bulk_quote</span>(std::<span class="built_in">move</span>(*<span class="keyword">this</span>));&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//存放基类指针的类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Basket</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Basket使用合成的默认构造函数和拷贝控制成员</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add_item</span><span class="params">(<span class="type">const</span> Quote &amp;sale)</span>  <span class="comment">//拷贝给定的对象</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        items.<span class="built_in">insert</span>(std::<span class="built_in">shared_ptr</span>&lt;Quote&gt;(sale.<span class="built_in">clone</span>()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add_item</span><span class="params">(<span class="type">const</span> Quote &amp;&amp;sale)</span>  <span class="comment">//移动给定的对象</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        items.<span class="built_in">insert</span>(std::<span class="built_in">shared_ptr</span>&lt;Quote&gt;(std::<span class="built_in">move</span>(sale).<span class="built_in">clone</span>()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">total_receipt</span><span class="params">(std::ostream&amp;)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">compare</span><span class="params">(<span class="type">const</span> std::shared_ptr&lt;Quote&gt; &amp;lhs, <span class="type">const</span> std::shared_ptr&lt;Quote&gt; &amp;rhs)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rhs-&gt;<span class="built_in">isbn</span>() &gt; lhs-&gt;<span class="built_in">isbn</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//存放动态指针的容器</span></span><br><span class="line">    <span class="comment">//multiset用于保存多个报价，按照compare成员排序。这样就可以保存同一本书的多条交易信息</span></span><br><span class="line">    <span class="comment">//定义一个指向Quote对象的shared_ptr的multiset。这个multiset将使用一个与compare成员类型相同的</span></span><br><span class="line">    <span class="comment">//函数来对其中的元素进行排序。multiset成员的名字是items，通过类内初始值调用比较函数compare来初始化items</span></span><br><span class="line">    std::multiset&lt;std::shared_ptr&lt;Quote&gt;, <span class="keyword">decltype</span>(compare)*&gt; items&#123;compare&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">Basket::total_receipt</span><span class="params">(std::ostream&amp; os)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="type">double</span> sum = <span class="number">0</span>;</span><br><span class="line">   <span class="comment">//iter指向ISBN相同的一批元素中的第一个，upper_bound返回一个迭代器</span></span><br><span class="line">   <span class="comment">//该迭代器指向这批元素的尾后位置</span></span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">auto</span> iter = items.<span class="built_in">cbegin</span>(); iter != items.<span class="built_in">cend</span>(); iter = items.<span class="built_in">upper_bound</span>(*iter)) &#123;</span><br><span class="line">      <span class="comment">//multiset的成员函数count返回键值相同的元素的个数 </span></span><br><span class="line">       sum += <span class="built_in">print_total</span>(os, **iter, items.<span class="built_in">count</span>(*iter));</span><br><span class="line">   &#125;</span><br><span class="line">   os &lt;&lt; <span class="string">&quot;Total Sale: &quot;</span> &lt;&lt; sum &lt;&lt; std::endl;</span><br><span class="line">   <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="文本查询再探"><a href="#文本查询再探" class="headerlink" title="文本查询再探"></a>文本查询再探</h2><p>相关总结后补  </p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>Notes</tag>
        <tag>CPP-OOP</tag>
      </tags>
  </entry>
  <entry>
    <title>C++学习笔记之重载运算符与类型转换</title>
    <url>/2015/12/23/cpp-oop-overloaded-operator/</url>
    <content><![CDATA[<p>重载运算符的定义方式通常为（以+运算符举例）<code>type operator+(argu1, argu2,..) &#123;&#125;</code>  </p>
<p>1.如果一个重载的运算符是成员函数，则它的第一个（左侧）运算对象绑定到隐式的this指针上。成员运算符函数的（显式）参数数量比运算对象的数量少一个。<br>运算符的调用通常是调用重载的运算符函数，所以可以像调用普通函数一样直接调用运算符函数。eg:  </p>
<span id="more"></span>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//一个非成员运算符函数的等价调用</span></span><br><span class="line">data1 + data2;  <span class="comment">//普通表达式</span></span><br><span class="line"><span class="keyword">operator</span>+(data1, data2);  <span class="comment">//等价的函数调用 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//成员运算符的等价调用，函数参数比实际少一个</span></span><br><span class="line">data1 += data2;  <span class="comment">//普通表达式</span></span><br><span class="line">data1.<span class="keyword">operator</span>+=(data2);  <span class="comment">//对成员运算符函数的等价调用</span></span><br></pre></td></tr></table></figure>

<p>2.运算符重载时，具有关联的运算符应该通过调用进行重载。例如在定义<code>==</code>和<code>!=</code>时，可以先定义<code>==</code>，然后定义<code>!=</code>时调用<code>==</code>的重载运算符。  </p>
<p>3.赋值（=）、下标（[]）、调用（()）和成员访问箭头（-&gt;）运算符必须是成员函数。复合赋值运算符通常应该是成员，改变对象状态的运算符如递增、递减和解引用通常也应该是成员。而具有对称性的运算符有可能在调用时需要转换任意一端的运算对象，如算术、相等性、关系和位运算等通常应该为非成员函数。  </p>
<p>4.不能对两个基本的内置变量进行运算符重载，如<code>int operator+(int, int)</code>是错误的。</p>
<h2 id="输入（-gt-gt-）输出（-lt-lt-）运算符"><a href="#输入（-gt-gt-）输出（-lt-lt-）运算符" class="headerlink" title="输入（&gt;&gt;）输出（&lt;&lt;）运算符"></a>输入（&gt;&gt;）输出（&lt;&lt;）运算符</h2><p>5.重载输出运算符时应尽可以的减少对格式控制的操作。输入输出运算符必须是非成员函数，且IO对象必须是引用，通常返回也是引用，输出对象应该是const引用，因为不应该修改输出对象。输入运算符还应该检查并处理可能的输入出错情况，如有效性。eg:  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//重载输出运算符</span></span><br><span class="line">ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;os, <span class="type">const</span> Sales_data &amp;item)</span><br><span class="line">&#123;</span><br><span class="line">    os &lt;&lt; item.<span class="built_in">isbn</span>() &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; item.units_sold &lt;&lt; item.<span class="built_in">price</span>();</span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重载输入运算符</span></span><br><span class="line">istream &amp;<span class="keyword">operator</span>&gt;&gt;(istream &amp;is, Sales_data &amp;item)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">double</span> price;</span><br><span class="line">    is &gt;&gt; item.bookNo &gt;&gt; item.units_sold &gt;&gt; price;</span><br><span class="line">    <span class="keyword">if</span> (is) <span class="comment">//检查输入是否成功</span></span><br><span class="line">      item.revenue = item.units_sold * price;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      item = <span class="built_in">Sales_data</span>();  <span class="comment">//输入失败，则将对象赋予默认的状态</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h2><p>关系运算符通常应该定义一个同时也定义关联和其他运算符，如定义了<code>&lt;</code>，应该也定义<code>&gt;</code>等<br>6.相等和不等运算符举例：  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//先重载==运算符</span></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> Sales_data &amp;item1, <span class="type">const</span> Sales_data &amp;item2)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> item1.<span class="built_in">isbn</span>() == item2.<span class="built_in">isbn</span>() &amp;&amp;</span><br><span class="line">           item1.units_sold == item2.units_sold &amp;&amp;</span><br><span class="line">           item1.revenue == item2.revenue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> Sales_data &amp;item1, <span class="type">const</span> Sales_data &amp;item2)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> !(item1 == item2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//利用已经重载过的==运算符来定义!=运算符</span></span><br></pre></td></tr></table></figure>

<p>7.赋值运算=的重载方式与拷贝赋值运算符类似，定义时也必须先释放当前的内存空间，再创建新的空间，以解决自赋值的问题，且必须是成员函数。  </p>
<h2 id="下标运算符"><a href="#下标运算符" class="headerlink" title="下标运算符"></a>下标运算符</h2><p>如果一个类定义了下标运算符，则它通常应该有两版本：一个返回普通引用，另一个是类的常量成员并且返回常量引用。eg:  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">strVec</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  std::string&amp; <span class="keyword">operator</span>[](std::<span class="type">size_t</span> n)</span><br><span class="line">    &#123; <span class="keyword">return</span> elements[n]; &#125;</span><br><span class="line">  <span class="type">const</span> std::string&amp; <span class="keyword">operator</span>[](std::<span class="type">size_t</span> n) <span class="type">const</span> </span><br><span class="line">    &#123; <span class="keyword">return</span> elements[n]; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  std::string *elements;  <span class="comment">//指向数组首元素的指针</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="递增递减运算符"><a href="#递增递减运算符" class="headerlink" title="递增递减运算符"></a>递增递减运算符</h2><p>定义递增和递减运算符的类应该同时定义其前置和后置版本，<code>operator++()</code>默认情况下为前置版本（++obj），区分后置版本则需要额外提供一个不被使用的int类型的形参，编译器会为该形参提供一个值为0的实参。递增递减应该检查索引值的有效性，当定义了前置版本之后，就可以利用前置版本来完成后置版本的实际工作。eg:  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//StrBolbPtr类是一个指针类，其成员curr保存当前对象所表示的元素的下标，check成员函数用来检查解引用StrBlobPtr是否安全</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StrBolbptr</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">//前置递增递减运算符</span></span><br><span class="line">  StrBlobPtr&amp; <span class="keyword">operator</span>++();</span><br><span class="line">  StrBlobPtr&amp; <span class="keyword">operator</span>--();</span><br><span class="line">  <span class="comment">//后置递增递减运算符</span></span><br><span class="line">  StrBlobPtr&amp; <span class="keyword">operator</span>++(<span class="type">int</span>);</span><br><span class="line">  StrBlobPtr&amp; <span class="keyword">operator</span>--(<span class="type">int</span>);</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//相应的定义</span></span><br><span class="line">StrBlobPtr&amp; StrBlobPtr::<span class="keyword">operator</span>++()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//如果curr已经指向了容器的尾后位置，则无法递增它</span></span><br><span class="line">  <span class="built_in">check</span>(curr, <span class="string">&quot;increment past end of StrBolbPtr&quot;</span>);</span><br><span class="line">  ++curr;  <span class="comment">//将curr在当前状态下向前移动一个位置</span></span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">StrBlobPtr&amp; StrBlobPtr::<span class="keyword">operator</span>--()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//如果curr是0，则继续递减它将产生一个无效的下标</span></span><br><span class="line">  --curr;  <span class="comment">//将curr的当前状态向后移动一个位置</span></span><br><span class="line">  <span class="built_in">check</span>(curr, <span class="string">&quot;decrment past begin of StrBlobPtr&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//后置版本需要返回原值，所以调用之前需要先记录对象的原值</span></span><br><span class="line"><span class="comment">//由于不需要用到int形参，所以不需要为其命名</span></span><br><span class="line">StrBlobPtr&amp; StrBlobPtr::<span class="keyword">operator</span>++(<span class="type">int</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//此处无需检查有效性，因为实际递增工作将由前置++完成，而前置运算中将会检查有效性</span></span><br><span class="line">  StrBlobPtr ret = *<span class="keyword">this</span>;</span><br><span class="line">  ++*<span class="keyword">this</span>;  <span class="comment">//使用已经定义的前置版本的++运算符来完成工作</span></span><br><span class="line">  <span class="keyword">return</span> ret;  <span class="comment">//返回之前的记录</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//后置版本需要返回原值，所以调用之前需要先记录对象的原值</span></span><br><span class="line">StrBlobPtr&amp; StrBlobPtr::<span class="keyword">operator</span>--(<span class="type">int</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//此处无需检查有效性，因为实际递增工作将由前置--完成，而前置运算中将会检查有效性</span></span><br><span class="line">  StrBlobPtr ret = *<span class="keyword">this</span>;</span><br><span class="line">  --*<span class="keyword">this</span>;  <span class="comment">//使用已经定义的前置版本的++运算符来完成工作</span></span><br><span class="line">  <span class="keyword">return</span> ret;  <span class="comment">//返回之前的记录</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>显式调用前置和后置递增运算符的方式：  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">StrBlobPtr <span class="title">p</span><span class="params">(a1)</span></span>;  <span class="comment">//p指向a1中的vector</span></span><br><span class="line">p.<span class="keyword">operator</span>++(<span class="number">0</span>);   <span class="comment">//调用后置版本的operator++</span></span><br><span class="line">p.<span class="keyword">operator</span>++();    <span class="comment">//调用前置版本的operator++</span></span><br></pre></td></tr></table></figure>

<h2 id="重载成员访问运算符-和-gt"><a href="#重载成员访问运算符-和-gt" class="headerlink" title="重载成员访问运算符*和-&gt;"></a>重载成员访问运算符*和-&gt;</h2><p>箭头运算符必须是类的成员，解引用运算符通常也是类的成员。可以先定义解引用运算符，然后箭头运算符由解引用来完成：  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StrBlobPtr</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  std::string&amp; <span class="keyword">operator</span>*() <span class="type">const</span></span><br><span class="line">  &#123; </span><br><span class="line">    <span class="keyword">auto</span> p = <span class="built_in">check</span>(curr, <span class="string">&quot;dereference past end&quot;</span>);  <span class="comment">//检查有效性，并返回元素索引</span></span><br><span class="line">    <span class="keyword">return</span> (*p)[curr];  <span class="comment">//返回的是一个引用，(*p)是对角所指的元素</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  std::string* <span class="keyword">operator</span>-&gt;() <span class="type">const</span>  <span class="comment">//返回对象本身，即指针，因为该类是指针类</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//实际工作由解引用运算符操作</span></span><br><span class="line">    <span class="keyword">return</span> &amp; <span class="keyword">this</span>-&gt;<span class="keyword">operator</span>*();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="函数调用运算符"><a href="#函数调用运算符" class="headerlink" title="函数调用运算符()"></a>函数调用运算符()</h2><p>如果类定义了调用运算符，则该类的对象就称作函数对象。一个类可以定义多个函数调用运算符，只需要在参数数量和类型上有区别。eg:  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//absInt的函数对象将返回实参的绝对值</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">absInt</span> &#123;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> val &lt; <span class="number">0</span> ? -val : val;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>调用：  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">-42</span>;</span><br><span class="line">absInt absobj;    <span class="comment">//absobj为含有函数调用运算符的对象</span></span><br><span class="line"><span class="type">int</span> ui = <span class="built_in">absobj</span>(i);  <span class="comment">//将i传递给absobj.operator()</span></span><br></pre></td></tr></table></figure>

<p>如果函数对象类中含有一些数据成员，且这些数据成员被用于定制函数调用运算中的操作，这样的类称为含有状态的函数对象类，也就是说这种类的函数对象可以带有状态。eg:  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//PrintString将打印string，每个string之间使用空格隔开</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PrintString</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">PrintString</span>(ostream &amp;o = cout, <span class="type">char</span> c = <span class="string">&#x27; &#x27;</span>) : <span class="built_in">os</span>(o), <span class="built_in">sep</span>(c) &#123;&#125;  <span class="comment">//默认构造函数</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> string &amp;s)</span> <span class="type">const</span> </span>&#123; os &lt;&lt; s &lt;&lt; sep; &#125;       <span class="comment">//重载函数调用运算符</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  ostream &amp;os;  <span class="comment">//用于写入的目的流</span></span><br><span class="line">  <span class="type">char</span> sep;     <span class="comment">//分隔符</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>调用：  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">PrintString printer;  <span class="comment">//调用默认构造函数，目的流为cout，分隔符为空格</span></span><br><span class="line"><span class="built_in">printer</span>(s);  <span class="comment">//向cout打印s，后面跟一个空格</span></span><br><span class="line"><span class="function">PrintString <span class="title">errors</span><span class="params">(cerr, <span class="string">&#x27;\n&#x27;</span>)</span></span>;  </span><br><span class="line"><span class="built_in">errors</span>(s);  <span class="comment">//向cerr中打印s，后面跟一个换行符</span></span><br></pre></td></tr></table></figure>

<h3 id="lambda是函数对象"><a href="#lambda是函数对象" class="headerlink" title="lambda是函数对象"></a>lambda是函数对象</h3><p>lambda表达式实际是一个含有重载函数调用运算符的类，该类只含有重载的函数调用运算符，不含默认构造函数、赋值运算符及默认析构函数。eg:  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获得第一个指向满足条件元素的迭代器，该元素满足size() 是否 &gt;= sz</span></span><br><span class="line"><span class="keyword">auto</span> wc = <span class="built_in">find_if</span>(words.<span class="built_in">begin</span>(), words.<span class="built_in">end</span>(), [sz](<span class="type">const</span> string &amp;s) &#123; <span class="keyword">return</span> s.<span class="built_in">size</span>() &gt;= sz; &#125;)</span><br><span class="line"><span class="comment">//上面的lambda表达式产生的类形如：</span></span><br><span class="line"><span class="keyword">class</span> SizeCmp &#123;</span><br><span class="line">  <span class="built_in">SizeCmp</span>(<span class="type">size_t</span> n) : <span class="built_in">sz</span>(n) &#123;&#125;  <span class="comment">//该形参对应捕获的变量</span></span><br><span class="line">  <span class="type">bool</span> <span class="built_in">operator</span>()(<span class="type">const</span> string &amp;s) <span class="type">const</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> s.<span class="built_in">size</span>() &gt;= sz;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">size_t</span> sz;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">auto</span> wc = <span class="built_in">find_if</span>(words.<span class="built_in">begin</span>(), words.<span class="built_in">end</span>(), <span class="built_in">SizeCmp</span>(sz));</span><br><span class="line">上述调用可改写为：</span><br></pre></td></tr></table></figure>

<h3 id="标准库定义的函数对象"><a href="#标准库定义的函数对象" class="headerlink" title="标准库定义的函数对象"></a>标准库定义的函数对象</h3><p>标准库的头文件functional中定义了一组表示算术运算符、关系运算符和逻辑运算符的类，每个类分别定义了一个执行命命操作的调用运算符。例如<code>plus&lt;Type&gt;</code>类定义了一个函数调用运算符用于对一对运算对象执行+操作。还有minus<Type>、equal_to<Type>、greater<Type>等。用法：  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">plus&lt;<span class="type">int</span>&gt; intAdd;  <span class="comment">//可以执行int加法的函数对</span></span><br><span class="line"><span class="type">int</span> sum = <span class="built_in">intAdd</span>(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//传入一个临时的函数对象用于执行两个string对象的&gt;比较运算</span></span><br><span class="line"><span class="built_in">sort</span>(svec.<span class="built_in">begin</span>(), svec.<span class="built_in">end</span>(), <span class="built_in">greater</span>&lt;string&gt;());</span><br></pre></td></tr></table></figure>
<p>对两个无关指针的比较将产生未定义的行为，但标准库的函数对象也可以用于对指针进行比较。eg:  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sort</span>(nameTab.<span class="built_in">begin</span>(), nameTab.<span class="built_in">end</span>(), <span class="built_in">less</span>&lt;string*&gt;());</span><br></pre></td></tr></table></figure>

<h3 id="标准库的function类型"><a href="#标准库的function类型" class="headerlink" title="标准库的function类型"></a>标准库的function类型</h3><p>C++11中新增的function是一个模板类，利用该模板，可以将不同类型但具有相同调用形式的函数放到同一个函数指针变量中。例如定义接受两个int参数，返回一个int参数的计算函数（加，减，乘，除），声明为<code>function&lt;int(int, int)&gt; f = add;</code> ，此时f可以指向任意符合接受两个int返回一个int的函数。<br>C++中的可调用对象有：函数、函数指针、lambda表达式、bind创建的对象以及重载了函数调用运算符的类。<br>function举例：  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//计算器程序，其中map中存放函数列表</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span></span>&#123; <span class="keyword">return</span> i + j; &#125;  <span class="comment">//普通函数</span></span><br><span class="line"><span class="keyword">auto</span> mod = [](<span class="type">int</span> i, <span class="type">int</span> j)&#123; <span class="keyword">return</span> i % j; &#125;;  <span class="comment">//lambda表达式</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Div</span>&#123; <span class="function"><span class="type">int</span> <span class="title">operator</span> <span class="params">()</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> i / j; &#125; &#125;;  <span class="comment">//函数对象类</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> binops = std::map&lt;std::string, std::function&lt;<span class="built_in">int</span>(<span class="type">int</span>, <span class="type">int</span>)&gt;&gt;</span><br><span class="line">&#123;</span><br><span class="line">    &#123; <span class="string">&quot;+&quot;</span>, add &#125;,                               <span class="comment">// 函数指针</span></span><br><span class="line">    &#123; <span class="string">&quot;-&quot;</span>, std::<span class="built_in">minus</span>&lt;<span class="type">int</span>&gt;() &#125;,                 <span class="comment">// 标准库函数对象</span></span><br><span class="line">    &#123; <span class="string">&quot;/&quot;</span>, <span class="built_in">Div</span>() &#125;,                             <span class="comment">// 用户定义的函数对象</span></span><br><span class="line">    &#123; <span class="string">&quot;*&quot;</span>, [](<span class="type">int</span> i, <span class="type">int</span> j) &#123; <span class="keyword">return</span> i*j; &#125; &#125;,  <span class="comment">// 未命名的lambda</span></span><br><span class="line">    &#123; <span class="string">&quot;%&quot;</span>, mod &#125;                                <span class="comment">// 命名了的lambda</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> ( std::cout &lt;&lt; <span class="string">&quot;Pls enter as: num operator num :\n&quot;</span>, <span class="literal">true</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> lhs, rhs; std::string op;</span><br><span class="line">        std::cin &gt;&gt; lhs &gt;&gt; op &gt;&gt; rhs;</span><br><span class="line">        std::cout &lt;&lt; binops[op](lhs, rhs) &lt;&lt; std::endl;  <span class="comment">//函数调用形式形如binops[&quot;+&quot;](10, 5);将调用add(10, 5);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当使用重载的函数与function时，应该使用函数指针，以免由于同名函数名引起二义性。eg:  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123;<span class="keyword">return</span> i + j&#125;</span><br><span class="line">Sales_data <span class="built_in">add</span>(<span class="type">const</span> Sales_data&amp;, <span class="type">const</span> Sales_data&amp;);</span><br><span class="line">map&lt;string, function&lt;<span class="type">int</span>(<span class="type">int</span>, <span class="type">int</span>)&gt;&gt; binops;</span><br><span class="line">binops.<span class="built_in">insert</span>(&#123;<span class="string">&quot;+&quot;</span>, add&#125;);  <span class="comment">//错误，因为无法区别是哪个add</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//可以使用函数指针</span></span><br><span class="line"><span class="built_in">int</span> (*fp)(<span class="type">int</span>, <span class="type">int</span>) = add;  <span class="comment">//指针指向的add是接受两个int的版本</span></span><br><span class="line">binops.<span class="built_in">insert</span>(&#123;<span class="string">&quot;+&quot;</span>, fp&#125;);</span><br><span class="line"><span class="comment">//或者使用lambda表达式</span></span><br><span class="line">binops.<span class="built_in">insert</span>(&#123;<span class="string">&quot;+&quot;</span>, [](<span class="type">int</span> a, <span class="type">int</span> b)&#123; <span class="keyword">return</span> <span class="built_in">add</span>(a, b); &#125; &#125;);</span><br></pre></td></tr></table></figure>

<h2 id="类型转换运算符"><a href="#类型转换运算符" class="headerlink" title="类型转换运算符"></a>类型转换运算符</h2><p>类型转换运算符是类的一种特殊成员函数，它负责将一个类类型的值转换成其他类型。形如：<code>operator type() const;</code><br>类型转换运算符可以面向任意类型（void除外）进行定义，只要该类型能作为函数的返回类型，所以不允许转换成数组或者函数类型。但允许转换成指针（如数组指针和函数指针）或者引用类型。<br>一个类型转换函数必须是类的成员函数，它不能声明返回类型，形参列表也必须为空，类型转换函数通常应该是const。eg:  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//SmallInt表示0-255之间的整数类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SmallInt</span> &#123;</span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">  <span class="built_in">SmallInt</span>(<span class="type">int</span> i = <span class="number">0</span>) : <span class="built_in">val</span>(i)   <span class="comment">//构造函数将int转换为SmallInt对象</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt; <span class="number">255</span>)</span><br><span class="line">      <span class="keyword">throw</span> std::<span class="built_in">out_of_range</span>(<span class="string">&quot;Bad SmallInt value&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> val;&#125;  <span class="comment">//重载类型转换运算符，将SmallInt向int转换，注意实际val必须可以隐式转换为int类型</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//错误示例</span></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> <span class="type">const</span></span>; <span class="comment">//错误：指定了返回类型</span></span><br><span class="line">  <span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">(<span class="type">int</span> = <span class="number">0</span>)</span> <span class="type">const</span></span>;  <span class="comment">//错误：参数列表不为空</span></span><br><span class="line">  <span class="keyword">operator</span> <span class="type">int</span>*() <span class="type">const</span> &#123; <span class="keyword">return</span> <span class="number">42</span>; &#125;  <span class="comment">//错误：42不是指针</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  std::<span class="type">size_t</span> val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该SmallInt类即定义了向类类型的转换，也定义了从类类型向其他类型的转换。  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">SmallInt si;</span><br><span class="line">si = <span class="number">4</span>;  <span class="comment">//首先将4隐式转换为SmallInt，然后调用SmallInt::operator=</span></span><br><span class="line">si + <span class="number">3</span>;  <span class="comment">//首先将si隐式转换成int，然后执行整数的加法</span></span><br></pre></td></tr></table></figure>

<p>C++11中引入了显式的类型转换运算符（explicit conversion operator）: </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SmallInt</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">//编译器不会自动执行这一类型转换</span></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> val; &#125;</span><br><span class="line">&#125;</span><br><span class="line">SmallInt si = <span class="number">3</span>;  <span class="comment">//正确：SmallInt的构造函数不是显示的，即没有使用explicit修饰</span></span><br><span class="line">si + <span class="number">3</span>; <span class="comment">//错误：此处需要隐式的类型转换，但类的运算符是显式的</span></span><br><span class="line"><span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(si) + <span class="number">3</span>;  <span class="comment">//正确：显式地强制类型转换</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>Notes</tag>
        <tag>CPP-OOP</tag>
      </tags>
  </entry>
  <entry>
    <title>C++学习笔记之拷贝控制</title>
    <url>/2015/12/13/cpp-oop-copy-control/</url>
    <content><![CDATA[<p>1.一个类通过定义五种特殊的成员函数来控制这些操作，包括：拷贝构造函数（copy constructor）、拷贝赋值运算符（copy-assignment operator）、移动构造函数（move constructor）、移动赋值运算符（move-assignment operator）和析构函数（destructor）。拷贝和移动构造函数定义了当用同类型的另一个对象初始化本对象时做什么。拷贝和移动赋值运算符定义了将一个对象赋予同类型的另一个对象时做什么。析构函数定义了当此类型对象销毁时做什么。其中移动操作都是在新标准中引用的。如果我们没有手动定义这些操作，则编译器会为我们自动生成。  </p>
<span id="more"></span>  

<p>2.拷贝构造函数：该构造函数的第一个参数是自身类类型的引用（该参数几乎总是一个const的引用），且任何额外参数都有默认值，则此构造函数是拷贝构造函数。编译器会默认为所有类定义一个合成拷贝构造函数。    </p>
<p>3.以下情况下会调用拷贝构造函数：  </p>
<ul>
<li>使用<code>=</code>进行定义并初始化变量时</li>
<li>将一个对象作为实参传递给一个非引用类型的形参</li>
<li>从一个返回类型为非引用类型的函数返回一个对象</li>
<li>用花括号列表初始化一个数组中的元素或一个聚合类中的成员</li>
</ul>
<p>4.构造函数中，成员的初始化是在函数体执行之前完成的，且按照它们在类中出现的顺序进行初始化。</p>
<p>5.拷贝赋值运算符就相当于重载赋值运算符，赋值运算符就是一个名为operator=的函数，如果一个运算符是一个成员函数，其左侧运算对象就绑定到隐式的this参数，其右侧运算对象作为显式参数传递。拷贝赋值运算符接受一个与其所在类相同类型的参数：  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  Foo&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Foo&amp;);<span class="comment">//赋值运算符  </span></span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>为了与内置类型的赋值保持一致，赋值运算符通常返回一个指针向其左侧运算对象的引用。  </p>
<p>6.析构函数执行与构造函数相反的操作：构造函数初始化对象的非static数据成员，还可能做一些其他工作；析构函数释放对象使用的资源，并销毁对象的非static数据成员。析构函数是类的一个成员函数，名字由波浪号接类名构成。它没有返回值，也不接受参数：  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">Foo</span>(); <span class="comment">//析构函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>析构函数不接受参数，所以无法被重载，对于一个给定类，只会有唯一一个析构函数。  </p>
<p>7.析构函数中，首先执行函数体，然后销毁成员，成员按初始化顺序的逆序销毁。在对象最后一次使用之后，析构函数的函数体可以执行类设计者希望执行的任何收尾工作，通常析构函数释放对象在生存期分配的所有资源。而析构函数不存在类似构造函数中初始化列表的东西来控制成员如何销毁，析构部分是隐式的。所以成员的销毁完成依赖于成员的类型，销毁类类型的成员时需要执行成员自己的析构函数，内置类型没有析构函数，所以销毁内置类型成员时什么也不需要做。    </p>
<p>8.无论何时一个对象被销毁时，都会自动调用其析构函数，具体有：  </p>
<ul>
<li>变量在离开其作用域时被销毁。</li>
<li>当一个对象被销毁时，其成员被销毁</li>
<li>容器（无论是标准库容器还是数组）被销毁时，其元素被销毁</li>
<li>对于动态分配的对象，当对指向它的指针应用delete运算符时被销毁</li>
<li>对于临时对象，当创建它的完整表达式结束时被销毁  </li>
</ul>
<h2 id="拷贝控制函数举例"><a href="#拷贝控制函数举例" class="headerlink" title="拷贝控制函数举例"></a>拷贝控制函数举例</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HasPtr</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//构造函数，使用传递的string初始ps,0初始化i </span></span><br><span class="line">        <span class="built_in">HasPtr</span>(<span class="type">const</span> std::string &amp;s = std::<span class="built_in">string</span>()) : <span class="built_in">ps</span>(<span class="keyword">new</span> std::<span class="built_in">string</span>(s)), <span class="built_in">i</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">	<span class="comment">//拷贝构造函数，动态分配一个新的string将值拷贝到ps指向的位置，而不是ps本身的位置  </span></span><br><span class="line">        <span class="built_in">HasPtr</span>(<span class="type">const</span> HasPtr&amp; hp) : <span class="built_in">ps</span>(<span class="keyword">new</span> std::<span class="built_in">string</span>(*hp.ps)), <span class="built_in">i</span>(hp.i) &#123;&#125;</span><br><span class="line">	<span class="comment">//拷贝赋值运算符  </span></span><br><span class="line">        HasPtr&amp; <span class="keyword">operator</span>=(<span class="type">const</span> HasPtr&amp; hp) &#123;</span><br><span class="line">            <span class="comment">//拷贝底层的string，即新建一个string对象，并将来的this.ps指向新的string对象</span></span><br><span class="line">            std::string* new_ps = <span class="keyword">new</span> std::<span class="built_in">string</span>(*hp.ps);</span><br><span class="line">            <span class="keyword">delete</span> ps; <span class="comment">//释放旧内存</span></span><br><span class="line">            ps = new_ps;  <span class="comment">//从右侧运算对象拷贝数据到本对象</span></span><br><span class="line">            i = hp.i;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>; <span class="comment">//返回本对象</span></span><br><span class="line">        &#125;</span><br><span class="line">	<span class="comment">//析构函数  </span></span><br><span class="line">	~<span class="built_in">HasPtr</span>() &#123; <span class="keyword">delete</span> ps; &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        std::string *ps;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>赋值运算符需要注意：  </p>
<ul>
<li>如果将一个对象赋予它自身，赋值运算符必须能正确工作。</li>
<li>大多数赋值运算符组合了析构函数和拷贝构造函数的工作。<br>所以编写一个赋值运算符的好模式是先将右侧运算对象拷贝到一个局部临时对象中，当拷贝完成后，销毁左侧运算对象的现有成员就是安全的了，然后将数据从临时对象拷贝到左侧运算对象的成员中即可。  </li>
</ul>
<p>10.如果一个类需要自定义析构函数，几乎可以肯定它也需要自定义拷贝赋值运算符和拷贝构造函数。  </p>
<p>11.可能通过将拷贝控制成员定义为=default来显式地要求编译器生成合成的版本。eg:  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Sales_data</span> &#123;</span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">  <span class="built_in">Sales_data</span>() = <span class="keyword">default</span>;</span><br><span class="line">  <span class="built_in">Sales_data</span>(<span class="type">const</span> Sales_data&amp;) = <span class="keyword">default</span>;</span><br><span class="line">  Sales_data&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Sales_data &amp;);</span><br><span class="line">  ~<span class="built_in">Sales_data</span>() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line">Sales_data&amp; Sales_data::<span class="keyword">operator</span>=(<span class="type">const</span> Sales_data&amp;) = <span class="keyword">default</span>;</span><br></pre></td></tr></table></figure>
<p>类内定义的成员函数默认都会被隐式地声明为内联的，所以如果不希望合成的成员是内联函数，那么就只对成员的类外定义使用=default。  </p>
<p>12.为了阻止拷贝，大多数类应该定义默认构造函数、拷贝构造函数和拷贝赋值运算符，无论是隐式地还是显式地。因为如果不手动定义，编译器会为它生成合成的版本。</p>
<p>13.在C++11中可以手动在函数的参数列表后面加上=delete来指出我们希望将它定义为删除的，将拷贝构造函数和拷贝赋值运算符定义为删除的函数可以阻止拷贝。因为删除函数是这样一种函数：我们虽然声明了它们，但不能以任何方式使用它们，所以它可以阻止合成的拷贝构造函数。析构函数不能是删除的成员。新标准发布之前，类是通过将拷贝构造函数和拷贝赋值运算符声明为private来阻止拷贝，但现在推荐使用=delete而不是private。    </p>
<p>15.对于行为像值的类，在类管理的资源中，每个对象都应该拥有一份自己的拷贝。</p>
<h2 id="行为像指针的类"><a href="#行为像指针的类" class="headerlink" title="行为像指针的类"></a>行为像指针的类</h2><p>对于行为类似指针的类，我们需要为其定义拷贝构造函数和拷贝赋值运算符，来拷贝指针成员本身而不是它指向的string。eg:  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用use记录拷贝次数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HasPtr</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//构造函数分配新的string和新的计数器，将计数器置为1</span></span><br><span class="line">    <span class="built_in">HasPtr</span>(<span class="type">const</span> std::string &amp;s = std::<span class="built_in">string</span>()) : <span class="built_in">ps</span>(<span class="keyword">new</span> std::<span class="built_in">string</span>(s)), <span class="built_in">i</span>(<span class="number">0</span>), <span class="built_in">use</span>(<span class="keyword">new</span> std::<span class="built_in">size_t</span>(<span class="number">1</span>)) &#123;&#125;</span><br><span class="line">    <span class="comment">//拷贝构造函数拷贝所有三个数据成员，并递增计数器</span></span><br><span class="line">    <span class="built_in">HasPtr</span>(<span class="type">const</span> HasPtr &amp;p) : <span class="built_in">ps</span>(p.ps), <span class="built_in">i</span>(p.i), <span class="built_in">use</span>(p.use) &#123;++*use;&#125;</span><br><span class="line">    HasPtr&amp; <span class="keyword">operator</span>=(<span class="type">const</span> HasPtr&amp;);</span><br><span class="line">    ~<span class="built_in">HasPtr</span>();</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string *ps;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    std::<span class="type">size_t</span> *use;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">HasPtr::~<span class="built_in">HasPtr</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (--*use == <span class="number">0</span>) &#123;  <span class="comment">//如果引用计数变为0</span></span><br><span class="line">        <span class="keyword">delete</span> ps;      <span class="comment">//释放string内存</span></span><br><span class="line">        <span class="keyword">delete</span> use;     <span class="comment">//释放计数器内存</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">HasPtr&amp; HasPtr::<span class="keyword">operator</span>=(<span class="type">const</span> HasPtr &amp;rhs)</span><br><span class="line">&#123;</span><br><span class="line">    ++*rhs.use; <span class="comment">//递增右侧运算对象的引用计数</span></span><br><span class="line">    <span class="keyword">if</span> (--*use == <span class="number">0</span>) &#123;  <span class="comment">//然后递减本对象的引用计数</span></span><br><span class="line">        <span class="keyword">delete</span> ps; <span class="comment">//如果没有其他用户</span></span><br><span class="line">        <span class="keyword">delete</span> use;  <span class="comment">//释放本对象分配的成员</span></span><br><span class="line">    &#125;</span><br><span class="line">    ps = rhs.ps; <span class="comment">//将数据从rhs拷贝到本对象</span></span><br><span class="line">    i = rhs.i;</span><br><span class="line">    use = rhs.use;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;  <span class="comment">//返回本对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="使用swap实现拷贝赋值运算符"><a href="#使用swap实现拷贝赋值运算符" class="headerlink" title="使用swap实现拷贝赋值运算符"></a>使用swap实现拷贝赋值运算符</h2><p>使用拷贝和交换的赋值运算符自动就是异常安全的，且能正确处理自赋值。  eg:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HasPtr</span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">swap</span><span class="params">(HasPtr&amp;, HasPtr&amp;)</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  HasPtr&amp; <span class="keyword">operator</span>=(<span class="type">const</span> HasPtr);</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">swap</span><span class="params">(HasPtr &amp;lhs, HasPtr &amp;rhs)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">using</span> std::swap;</span><br><span class="line">  <span class="built_in">swap</span>(lhs.ps, rhs.ps); <span class="comment">//交换指针，而不是string数据</span></span><br><span class="line">  <span class="built_in">swap</span>(lhs.i, rhs.i);   <span class="comment">//交换int成员</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//注意rhs是按值传递的，意味着HasPtr的拷贝构造函数将右侧运算对象中的string拷贝到rhs</span></span><br><span class="line">HasPtr&amp; HasPtr::<span class="keyword">operator</span>=(HasPtr rhs)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//交换左侧运算对象和局部变量rhs的内容</span></span><br><span class="line">  <span class="built_in">swap</span>(*<span class="keyword">this</span>, rhs);  <span class="comment">//rhs现在指向本对象曾经使用的内存</span></span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;     <span class="comment">//rhs被销毁，从而delete了rhs中的指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="拷贝控制实例"><a href="#拷贝控制实例" class="headerlink" title="拷贝控制实例"></a>拷贝控制实例</h2><p><code>Message_Folder.h</code>  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Message_Folder.h</span></span><br><span class="line"><span class="comment"> * Copyright (C) 2016  &lt;@BLUEYI-PC&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Distributed under terms of the MIT license.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MESSAGE_FOLDER_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MESSAGE_FOLDER_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Folder</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Message</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">swap</span><span class="params">(Message &amp;, Message &amp;)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">swap</span><span class="params">(Folder &amp;, Folder &amp;)</span></span>;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">Folder</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Message</span><span class="params">(<span class="type">const</span> std::string str = <span class="string">&quot;&quot;</span>)</span> : contents(str) &#123;</span>&#125;</span><br><span class="line">    <span class="built_in">Message</span>(<span class="type">const</span> Message&amp;);</span><br><span class="line">    Message &amp; <span class="keyword">operator</span>=(<span class="type">const</span> Message&amp;);</span><br><span class="line">    ~<span class="built_in">Message</span>();</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">save</span><span class="params">(Folder&amp;)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(Folder&amp;)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printtxt</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printfolders</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string contents;</span><br><span class="line">    std::set&lt;Folder *&gt; folders;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add_to_folders</span><span class="params">(<span class="type">const</span> Message&amp;)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">remove_from_folders</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addFldr</span><span class="params">(Folder *f)</span> </span>&#123;folders.<span class="built_in">insert</span>(f);&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">remFldr</span><span class="params">(Folder *f)</span> </span>&#123;folders.<span class="built_in">erase</span>(f);&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(Message &amp;, Message &amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(Folder &amp;, Folder &amp;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Folder</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">swap</span><span class="params">(Message &amp;, Message &amp;)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">swap</span><span class="params">(Folder &amp;, Folder &amp;)</span></span>;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">Message</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Folder</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Folder</span>(<span class="type">const</span> Folder&amp;);</span><br><span class="line">    Folder &amp; <span class="keyword">operator</span>=(<span class="type">const</span> Folder&amp;);</span><br><span class="line">    ~<span class="built_in">Folder</span>();</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printmsg</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::set&lt;Message *&gt; messages;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add_to_messages</span><span class="params">(<span class="type">const</span> Folder&amp;)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">remove_from_messages</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addMsg</span><span class="params">(Message *m)</span> </span>&#123;messages.<span class="built_in">insert</span>(m);&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">remMsg</span><span class="params">(Message *m)</span> </span>&#123;messages.<span class="built_in">erase</span>(m);&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* !MESSAGE_FOLDER_H */</span></span></span><br></pre></td></tr></table></figure>

<p><code>Message_Folder.cpp</code>  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Message_Folder.cpp</span></span><br><span class="line"><span class="comment"> * Copyright (C) 2016  &lt;@BLUEYI-PC&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Distributed under terms of the MIT license.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Message_Folder.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(Message &amp;lhs, Message &amp;rhs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> std::swap;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> f : lhs.folders)</span><br><span class="line">        f-&gt;<span class="built_in">remMsg</span>(&amp;lhs);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> f : rhs.folders)</span><br><span class="line">        f-&gt;<span class="built_in">remMsg</span>(&amp;rhs);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">swap</span>(lhs.folders, rhs.folders);</span><br><span class="line">    <span class="built_in">swap</span>(lhs.contents, rhs.contents);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> f : lhs.folders)</span><br><span class="line">        f-&gt;<span class="built_in">addMsg</span>(&amp;lhs);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> f : rhs.folders)</span><br><span class="line">        f-&gt;<span class="built_in">addMsg</span>(&amp;rhs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(Folder &amp;lhs, Folder &amp;rhs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> std::swap;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> m : lhs.messages)</span><br><span class="line">        m-&gt;<span class="built_in">remFldr</span>(&amp;lhs);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> m : rhs.messages)</span><br><span class="line">        m-&gt;<span class="built_in">remFldr</span>(&amp;rhs);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">swap</span>(lhs.messages, rhs.messages);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> m : lhs.messages)</span><br><span class="line">        m-&gt;<span class="built_in">addFldr</span>(&amp;lhs);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> m : rhs.messages)</span><br><span class="line">        m-&gt;<span class="built_in">addFldr</span>(&amp;rhs);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Message::save</span><span class="params">(Folder &amp;f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    folders.<span class="built_in">insert</span>(&amp;f);</span><br><span class="line">    f.<span class="built_in">addMsg</span>(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Message::remove</span><span class="params">(Folder &amp;f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    folders.<span class="built_in">erase</span>(&amp;f);</span><br><span class="line">    f.<span class="built_in">remMsg</span>(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Message::add_to_folders</span><span class="params">(<span class="type">const</span> Message &amp;m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> f : m.folders)</span><br><span class="line">        f-&gt;<span class="built_in">addMsg</span>(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Message::remove_from_folders</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> f : folders)</span><br><span class="line">        f-&gt;<span class="built_in">remMsg</span>(<span class="keyword">this</span>);</span><br><span class="line">    folders.<span class="built_in">clear</span>();</span><br><span class="line">&#125;</span><br><span class="line">Message::<span class="built_in">Message</span>(<span class="type">const</span> Message &amp;m) : <span class="built_in">contents</span>(m.contents), <span class="built_in">folders</span>(m.folders)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">add_to_folders</span>(m);</span><br><span class="line">&#125;</span><br><span class="line">Message::~<span class="built_in">Message</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">remove_from_folders</span>();</span><br><span class="line">&#125;</span><br><span class="line">Message &amp;Message::<span class="keyword">operator</span>=(<span class="type">const</span> Message &amp;rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">remove_from_folders</span>();</span><br><span class="line">    contents = rhs.contents;</span><br><span class="line">    folders = rhs.folders;</span><br><span class="line">    <span class="built_in">add_to_folders</span>(rhs);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Folder::add_to_messages</span><span class="params">(<span class="type">const</span> Folder &amp;f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> m : f.messages)</span><br><span class="line">        m-&gt;<span class="built_in">addFldr</span>(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">Folder::<span class="built_in">Folder</span>(<span class="type">const</span> Folder &amp;f) : <span class="built_in">messages</span>(f.messages)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="built_in">add_to_messages</span>(f);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Folder::remove_from_messages</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> m : messages)</span><br><span class="line">        m-&gt;<span class="built_in">remFldr</span>(<span class="keyword">this</span>);</span><br><span class="line">    messages.<span class="built_in">clear</span>();</span><br><span class="line">&#125;</span><br><span class="line">Folder::~<span class="built_in">Folder</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">remove_from_messages</span>();</span><br><span class="line">&#125;</span><br><span class="line">Folder &amp;Folder::<span class="keyword">operator</span>=(<span class="type">const</span> Folder &amp;rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">remove_from_messages</span>();</span><br><span class="line">    messages = rhs.messages;</span><br><span class="line">    <span class="built_in">add_to_messages</span>(rhs);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Message::printtxt</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   std::cout &lt;&lt; <span class="string">&quot;contents: &quot;</span> &lt;&lt; contents &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Message::printfolders</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="function">std::string <span class="title">str</span><span class="params">(<span class="string">&quot;************************&quot;</span>)</span></span>;</span><br><span class="line">   std::cout &lt;&lt; str &lt;&lt; std::endl;</span><br><span class="line">   std::cout &lt;&lt; <span class="string">&quot;All folders messages: &quot;</span> &lt;&lt; std::endl;</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">auto</span> f : folders)</span><br><span class="line">   &#123;</span><br><span class="line">      f-&gt;<span class="built_in">printmsg</span>();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Folder::printmsg</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   std::cout &lt;&lt; <span class="string">&quot;Msg: &quot;</span> &lt;&lt; std::endl;</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">auto</span> m : messages)</span><br><span class="line">      std::cout &lt;&lt; m-&gt;contents &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="function">Message <span class="title">me</span><span class="params">(<span class="string">&quot;Hello world!&quot;</span>)</span></span>;</span><br><span class="line">   Folder* tags = <span class="keyword">new</span> <span class="built_in">Folder</span>();</span><br><span class="line">   me.<span class="built_in">save</span>(*tags);</span><br><span class="line">   me.<span class="built_in">printtxt</span>();</span><br><span class="line">   me.<span class="built_in">printfolders</span>();</span><br><span class="line">   tags-&gt;<span class="built_in">printmsg</span>();</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>19.定义动态内存管理类需要使用到allocator类及其成员函数construct，allocate，deallocate等。  </p>
<p>20.C++11增加了右值引用来支持对象移动。头文件utility中的move函数可以显示地来获得绑定到左值上的右值引用。    </p>
<h2 id="左值引用"><a href="#左值引用" class="headerlink" title="左值引用"></a>左值引用</h2><p>通过一个&amp;符号定义的引用即为左值引用，所有的变量都是左值。左值引用只能绑定到左值上，具体左值有返回左值引用的函数，连同赋值、下标、解引用和前置递增递减运行符，我们可以将左值引用绑定到这类表达式上。而右值引用刚好相反</p>
<h2 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h2><p>1.右值引用与左值引用相反，例如返回非引用类型的函数，连同算法、关系、位以及后置递增/递减运算符都生成右值，我们不能将一个左值引用绑定这类表达式上，但可以将一个const的左值引用或一个右值引用绑定到这类表达式上。同样右值引用只能绑定到右值上。左值有持久的状态，如变量。而右值要么是字面常量，要么是在表达式求值过程中创建的临时对象。如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">4</span>;  <span class="comment">//变量i是个左值</span></span><br><span class="line"><span class="type">int</span> &amp;ri = i; <span class="comment">//将一个左值引用绑定到一个左值上，变量ri同样为左值</span></span><br><span class="line"><span class="type">int</span> &amp;&amp;rri = ri; <span class="comment">//错误：不能将右值引用绑定到一个左值</span></span><br><span class="line"><span class="type">int</span> &amp;r2 = i * <span class="number">3</span>; <span class="comment">//错误：i * 3是一个右值</span></span><br><span class="line"><span class="type">int</span> &amp;&amp;rr2 = i * <span class="number">3</span>; <span class="comment">//正确：将一个右值引用绑定右值</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;r3 = i * <span class="number">3</span>; <span class="comment">//正确：将一个const的引用绑定到右值</span></span><br><span class="line"><span class="type">int</span> &amp;&amp;rr4 = rr2; <span class="comment">//错误：变量rr2为左值，虽然rr2为右值引用，但其本身是个变量，变量是左值</span></span><br></pre></td></tr></table></figure>
<p>2.通过标准库move函数可以获得一个绑定到左值上的右值引用，如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> li= <span class="number">23</span>;</span><br><span class="line"><span class="type">int</span> &amp;&amp;rli = std::<span class="built_in">move</span>(li);</span><br></pre></td></tr></table></figure>
<p>调用move就意味着承诺：除了对li赋值或销毁外，我们不再使用它，调用move后，我们不能对移后源对象的值做任何假设，也就是说移动之后，最好不要再使用源对象。move定义在头文件utility中。</p>
<p>区分一个左值与右值的一个简单方法是：看能不能对表达式取地址，如果能，就是左值，如果不能，就是右值。</p>
<h2 id="移动构造函数"><a href="#移动构造函数" class="headerlink" title="移动构造函数"></a>移动构造函数</h2><p>移动构造函数类似拷贝构造函数，不同的是它们从给定对象移动资源而不是拷贝资源。移动构造函数的定义为第一个参数是该类类型的一个引用，不同地拷贝构造函数的是这个引用参数在移动构造函数中是一个右值引用，与拷贝构造函数相同的是任何额外的参数都必须有默认实参。除了完成移动，移动构造函数还必须确保移后源对象处于这样一个状态：销毁它是无害的，特别是一旦完成移动，源对象必须不再指向被移动的资源，即这些资源的所有权已经归属新创建的对象。因为移动后新对象将使用源对象指向的内存。eg:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">StrVec::<span class="built_in">StrVec</span>(StrVec &amp;&amp;s) <span class="keyword">noexcept</span>  <span class="comment">//移动操作不应该抛出任何异常</span></span><br><span class="line"><span class="comment">//成员初始化器接管s中的资源</span></span><br><span class="line">  : <span class="built_in">elements</span>(s.elements), <span class="built_in">first_free</span>(s.first_free), <span class="built_in">cap</span>(s.cap)</span><br><span class="line">&#123;</span><br><span class="line">  s.elements = s.first_free = s.cap = <span class="literal">nullptr</span>;  <span class="comment">//令s进入这样的状态——对其调用析构函数是安全的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与拷贝构造函数不同，移动构造函数不分配任何新内存，它接管给定的StrVec中的内存，接管后它将约定对象中的指针都置为nullptr。<br>关于noexcept，noexcept出现在参数列表和初始化列表开始的冒号之间。我们必须在类头文件的声明和定义中都指定noexcept，不抛出异常的移动构造函数和移动赋值运算符都必须标记为noexcept。这两个函数并不是必须指定为noexcept，只是为了与标准库进行交互。例如标准库容器能对异常发生时其自身的行为提供保障，也就是说以vector举例，除非vector知道元素类型的移动构造函数不会抛出异常，否则在重新分配内存的过程中，它就必须使用拷贝构造函数而不是移动构造函数。因为移动一个对象通常会改变它的值，如果新分配过程中使用移动构造函数，且在移动了部分元素之后抛出一个异常，此时旧空间中的移动源元素已经改变了，而新空间中未构造的元素可能还不存在，此时vector将不能满足自身保存不变的要求。但同样的情况下拷贝构造函数却可以，所以拷贝构造函数可以不需要noexcept。另外一点移动操作通常也不会抛出异常。所以 为了标准库能够正常调用移动构造函数，必须显示地告诉标准库我们的移动构造函数可以安全地使用。</p>
<h2 id="移动赋值运算符"><a href="#移动赋值运算符" class="headerlink" title="移动赋值运算符"></a>移动赋值运算符</h2><p>与赋值运算符类似，只是传递的对象需要是右值引用，并应该标记为noexcept</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">StrVec &amp;StrVec::<span class="keyword">operator</span>=(StrVec &amp;&amp;rhs) <span class="keyword">noexcept</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//检测自赋值</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;rhs) &#123;</span><br><span class="line">    <span class="built_in">free</span>(); <span class="comment">//释放已有元素</span></span><br><span class="line">    elements = rhs.elements;  <span class="comment">//从rhs接管资源</span></span><br><span class="line">    first_free = rhs.first_free;</span><br><span class="line">    cap = rhs.cap;</span><br><span class="line">    <span class="comment">//将rhs置于可析构状态</span></span><br><span class="line">    rhs.elements = rhs.first_free = rhs.cap = <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在移动操作之后，移后源对象必须保持有效的、可析构的状态，但是用户不能对其值做任何假设</p>
<h2 id="合成的移动操作"><a href="#合成的移动操作" class="headerlink" title="合成的移动操作"></a>合成的移动操作</h2><p>只有当一个类没有定义任何自己版本的拷贝控制成员，且它的所有数据成员都能够移动构造或移动赋值时，编译器才会为它合成移动构造函数或移动赋值运算符。与拷贝操作不同，移动操作永远不会隐式定义为删除的函数。但如果显示地要求编译器生成=default的移动操作，且编译器不能移动所有成员时，编译器会将移动操作定义为删除的函数。<br>定义了一个移动构造函数或移动赋值运算符的类必须也定义自己的拷贝操作。否则，这些成员默认地被定义为删除的。</p>
<p>如果一个类既有移动构造函数，也有拷贝构造函数，编译器使用普通的函数匹配规则来确定使用哪个构造函数。如果一个类有一个可用的拷贝构造函数而没有移动构造函数，则其对象是通过拷贝构造函数来进行“移动”的，移动赋值运算符的情况类似。</p>
<h2 id="移动迭代器"><a href="#移动迭代器" class="headerlink" title="移动迭代器"></a>移动迭代器</h2><p>1.C++11中定义了一种移动迭代器适配器，一个移动迭代器通过改变给定迭代器的解引用运算符的行为来适配此迭代器，移动迭代器的解引用运算符生成一个右值引用。标准库头文件iterator中的make_move_iterator函数可将一个普通迭代器转换为一个移动迭代器，些函数接受一个迭代器参数，返回一个移动迭代器。由于移动迭代器支持正常的迭代器操作，所以可以将一个移动迭代器传递给算法。memory头文件中的uninitialized_copy函数可以对元素进行拷贝。eg:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">StrVec::rellocate</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> newcapacity = <span class="built_in">size</span>() ? <span class="number">2</span> * <span class="built_in">size</span>() : <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">auto</span> first = alloc.<span class="built_in">allocate</span>(newcapacity);</span><br><span class="line">  <span class="comment">//移动元素</span></span><br><span class="line">  <span class="keyword">auto</span> last = <span class="built_in">uninitialized_copy</span>(<span class="built_in">make_move_iterator</span>(<span class="built_in">begin</span>()), <span class="built_in">make_move_iterator</span>(<span class="built_in">end</span>()), first);</span><br><span class="line">  <span class="built_in">free</span>(); /释放旧空间</span><br><span class="line">  elements = first; <span class="comment">//更新指针</span></span><br><span class="line">  first_free = last;</span><br><span class="line">  cap = elements + newcapacity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="右值引用的其他用法"><a href="#右值引用的其他用法" class="headerlink" title="右值引用的其他用法"></a>右值引用的其他用法</h2><p>1.可以为成员函数提供拷贝和移动版本，既可以同时提供两个版本，一个版本接受一个指向const的左值引用，另一个版本接受一个指向非const的右值引用。eg:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(<span class="type">const</span> std::string&amp;)</span></span>;   <span class="comment">//拷贝元素</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(std::string&amp;&amp;)</span></span>;    <span class="comment">//移动元素</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>2.可以通过向成员函数参数列表后面放置引用限定符（&amp;或&amp;&amp;）来分别指出this可以指向一个左值或右值，类似const限定符，引用限定符只能用于（非static）成员函数，且必须同时现出在函数的声明和定义中。如果一个函数同时用const和引用限定符，则引用限定符必须出现在const的后面。</p>
<p>3.引用限定符也可以用于区分重载版本，与const不同的是const用于区分时是根据是否有const来区分，而引用限定符则是通过是左值引用还是右值引用，即是&amp;还是&amp;&amp;来区分。如果我们定义两个或两个以上具有相同名字和相同参数列表的成员函数，就必须对所有函数都加上引用限定符，可以是&amp;或&amp;&amp;，或者所有都不加，不能有的加，有的不加。</p>
<p>4.非常量引用的初始值必须为左值，如果要传递给函数引用类型的形参一个右值，必须以const &amp;的形式，将形参定义为常量。如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">fun</span><span class="params">(<span class="type">int</span> &amp;)</span></span>;</span><br></pre></td></tr></table></figure>
<p>这样调用是错误的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fun(0);</span><br></pre></td></tr></table></figure>
<p>但定义为形如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp;)</span></span>;</span><br></pre></td></tr></table></figure>
<p>调用：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">func</span>(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>没有问题</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>Notes</tag>
        <tag>CPP-OOP</tag>
      </tags>
  </entry>
  <entry>
    <title>vim中的正则表达式匹配规则</title>
    <url>/2015/12/13/vim-regexp/</url>
    <content><![CDATA[<p>内容来源<code>:help regexp</code><br>实例场景为在写总结时，经常习惯于一条条的以序号开头列出。例如:  </p>
<blockquote>
<ol>
<li>first</li>
<li>second test 1.first</li>
<li>third  </li>
</ol>
</blockquote>
<p>由于坏习惯每次打完数字之后总是习惯给个空格，然后markdown渲染时就会出问题，会把这个前面内容序号当时所需渲染的序号，显然此处我们不需要渲染。那么就需要去掉这个多余的空格，假如刚好想到使用正则。正常情况下很简单嘛，使用零宽断言匹配数字之后跟的点号和空白，然后替换为一个点号即可。正则为<code>(?&lt;=^\d+)\.\s+</code>，但在vim下无法使用，vim下的完整替换命令应该为<code>:%s /\(^\d\+\)\@&lt;=\.\s\+/\./g</code>。简单解释如下：<br>vim下面的<code>\+</code>与我们正常regex中的<code>+</code>含义一样，<code>\(\)</code>用于分组，<code>\@&lt;=</code>表示零宽正回顾后发断言。不像正常见到的那种<code>=</code>号后面表达想要匹配的表达式，VIM中<code>\@=</code>中的=号仅仅表示需要匹配前面括号中的内容。例如<code>foo\(bar\)\@=</code>会匹配foobar中的foo，而<code>foo\(bar\)\@!</code>中<code>\@!</code>表示foo后面不匹配bar的位置，即会匹配所有后面不跟bar的foo。<code>\@=</code>等价于<code>\&amp;</code>，使用<code>\&amp;</code>时不需要带括号，如<code>\(foo\)\@=</code>等价于<code>foo\&amp;</code></p>
<span id="more"></span>
<p>详情如下:  </p>
<h1 id="vim中正则模式说明"><a href="#vim中正则模式说明" class="headerlink" title="vim中正则模式说明"></a>vim中正则模式说明</h1><p>Some characters in the pattern are taken literally.  They match with the same character in the text.  When preceded with a backslash however, these characters get a special meaning.<br>Other characters have a special meaning without a backslash.  They need to be preceded with a backslash to match literally.<br>If a character is taken literally or not depends on the ‘magic’ option and the items mentioned next.<br>Use of “\m” makes the pattern after it be interpreted as if ‘magic’ is set, ignoring the actual value of the ‘magic’ option.<br>Use of “\M” makes the pattern after it be interpreted as if ‘nomagic’ is used.<br>Use of “\v” means that in the pattern after it all ASCII characters except ‘0’-‘9’, ‘a’-‘z’, ‘A’-‘Z’ and ‘_’ have a special meaning.  “very magic”<br>Use of “\V” means that in the pattern after it only the backslash has a special meaning.  “very nomagic”  </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">after:	  \v	   \m	    \M	     \V		matches ~</span><br><span class="line">		&#x27;magic&#x27; &#x27;nomagic&#x27;</span><br><span class="line"><span class="meta prompt_">	  $</span><span class="language-bash">	   $	    $	     \$		matches end-of-line</span></span><br><span class="line">	  .	   .	    \.	     \.		matches any character</span><br><span class="line">	  *	   *	    \*	     \*		any number of the previous atom</span><br><span class="line">	  ()	   \(\)     \(\)     \(\)	grouping into an atom</span><br><span class="line">	  |	   \|	    \|	     \|		separating alternatives</span><br><span class="line">	  \a	   \a	    \a	     \a		alphabetic character</span><br><span class="line">	  \\	   \\	    \\	     \\		literal backslash</span><br><span class="line">	  \.	   \.	    .	     .		literal dot</span><br><span class="line">	  \&#123;	   &#123;	    &#123;	     &#123;		literal &#x27;&#123;&#x27;</span><br><span class="line">	  a	   a	    a	     a		literal &#x27;a&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>{only Vim supports \m, \M, \v and \V}<br>It is recommended to always keep the ‘magic’ option at the default setting, which is ‘magic’.  This avoids portability problems.  To make a pattern immune to the ‘magic’ option being set or not, put “\m” or “\M” at the start of the pattern.  </p>
<h1 id="vim匹配规则概览"><a href="#vim匹配规则概览" class="headerlink" title="vim匹配规则概览"></a>vim匹配规则概览</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">       &#x27;magic&#x27; &#x27;nomagic&#x27;	`matches of the preceding atom`</span><br><span class="line">|/star|	*	\*	0 or more	as many as possible</span><br><span class="line">|/\+|	\+	\+	1 or more	as many as possible (*)</span><br><span class="line">|/\=|	\=	\=	0 or 1		as many as possible (*)</span><br><span class="line">|/\?|	\?	\?	0 or 1		as many as possible (*)</span><br><span class="line">|/\&#123;|	\&#123;n,m&#125;	\&#123;n,m&#125;	n to m		as many as possible (*)</span><br><span class="line">	\&#123;n&#125;	\&#123;n&#125;	n		exactly (*)</span><br><span class="line">	\&#123;n,&#125;	\&#123;n,&#125;	at least n	as many as possible (*)</span><br><span class="line">	\&#123;,m&#125;	\&#123;,m&#125;	0 to m		as many as possible (*)</span><br><span class="line">	\&#123;&#125;	\&#123;&#125;	0 or more	as many as possible (same as *) (*)</span><br><span class="line"></span><br><span class="line">|/\&#123;-|	\&#123;-n,m&#125;	\&#123;-n,m&#125;	n to m		as few as possible (*)</span><br><span class="line">	\&#123;-n&#125;	\&#123;-n&#125;	n		exactly (*)</span><br><span class="line">	\&#123;-n,&#125;	\&#123;-n,&#125;	at least n	as few as possible (*)</span><br><span class="line">	\&#123;-,m&#125;	\&#123;-,m&#125;	0 to m		as few as possible (*)</span><br><span class="line">	\&#123;-&#125;	\&#123;-&#125;	0 or more	as few as possible (*)</span><br><span class="line"></span><br><span class="line">|/\@&gt;|	\@&gt;	\@&gt;	1, like matching a whole pattern (*)</span><br><span class="line">|/\@=|	\@=	\@=	nothing, requires a match |/zero-width| (*)</span><br><span class="line">|/\@!|	\@!	\@!	nothing, requires NO match |/zero-width| (*)</span><br><span class="line">|/\@&lt;=|	\@&lt;=	\@&lt;=	nothing, requires a match behind |/zero-width| (*)</span><br><span class="line">|/\@&lt;!|	\@&lt;!	\@&lt;!	nothing, requires NO match behind |/zero-width| (*)  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="Overview-of-ordinary-atoms"><a href="#Overview-of-ordinary-atoms" class="headerlink" title="Overview of ordinary atoms"></a>Overview of ordinary atoms</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">      &#x27;magic&#x27;   &#x27;nomagic&#x27;	&#x27;matches&#x27;</span><br><span class="line">|/^|	^	^	start-of-line (at start of pattern) |/zero-width|</span><br><span class="line">|/\^|	\^	\^	literal &#x27;^&#x27;</span><br><span class="line">|/\_^|	\_^	\_^	start-of-line (used anywhere) |/zero-width|</span><br><span class="line">|/$|	$	$	end-of-line (at end of pattern) |/zero-width|</span><br><span class="line">|/\$|	\$	\$	literal &#x27;$&#x27;</span><br><span class="line">|/\_$|	\_$	\_$	end-of-line (used anywhere) |/zero-width|</span><br><span class="line">|/.|	.	\.	any single character (not an end-of-line)</span><br><span class="line">|/\_.|	\_.	\_.	any single character or end-of-line</span><br><span class="line">|/\&lt;|	\&lt;	\&lt;	beginning of a word |/zero-width|</span><br><span class="line">|/\&gt;|	\&gt;	\&gt;	end of a word |/zero-width|</span><br><span class="line">|/\zs|	\zs	\zs	anything, sets start of match</span><br><span class="line">|/\ze|	\ze	\ze	anything, sets end of match</span><br><span class="line">|/\%^|	\%^	\%^	beginning of file |/zero-width|		</span><br><span class="line">|/\%$|	\%$	\%$	end of file |/zero-width|</span><br><span class="line">|/\%V|	\%V	\%V	inside Visual area |/zero-width|</span><br><span class="line">|/\%#|	\%#	\%#	cursor position |/zero-width|</span><br><span class="line">|/\%&#x27;m|	\%&#x27;m	\%&#x27;m	mark m position |/zero-width|</span><br><span class="line">|/\%l|	\%23l	\%23l	in line 23 |/zero-width|</span><br><span class="line">|/\%c|	\%23c	\%23c	in column 23 |/zero-width|</span><br><span class="line">|/\%v|	\%23v	\%23v	in virtual column 23 |/zero-width|</span><br></pre></td></tr></table></figure>
<p>Character classes {not in Vi}:                <em>/character-classes</em></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">|/\i|	\i	\i	identifier character (see &#x27;isident&#x27; option)</span><br><span class="line">|/\I|	\I	\I	like &quot;\i&quot;, but excluding digits</span><br><span class="line">|/\k|	\k	\k	keyword character (see &#x27;iskeyword&#x27; option)</span><br><span class="line">|/\K|	\K	\K	like &quot;\k&quot;, but excluding digits</span><br><span class="line">|/\f|	\f	\f	file name character (see &#x27;isfname&#x27; option)</span><br><span class="line">|/\F|	\F	\F	like &quot;\f&quot;, but excluding digits</span><br><span class="line">|/\p|	\p	\p	printable character (see &#x27;isprint&#x27; option)</span><br><span class="line">|/\P|	\P	\P	like &quot;\p&quot;, but excluding digits</span><br><span class="line">|/\s|	\s	\s	whitespace character: &lt;Space&gt; and &lt;Tab&gt;</span><br><span class="line">|/\S|	\S	\S	non-whitespace character; opposite of \s</span><br><span class="line">|/\d|	\d	\d	digit:				[0-9]</span><br><span class="line">|/\D|	\D	\D	non-digit:			[^0-9]</span><br><span class="line">|/\x|	\x	\x	hex digit:			[0-9A-Fa-f]</span><br><span class="line">|/\X|	\X	\X	non-hex digit:			[^0-9A-Fa-f]</span><br><span class="line">|/\o|	\o	\o	octal digit:			[0-7]</span><br><span class="line">|/\O|	\O	\O	non-octal digit:		[^0-7]</span><br><span class="line">|/\w|	\w	\w	word character:			[0-9A-Za-z_]</span><br><span class="line">|/\W|	\W	\W	non-word character:		[^0-9A-Za-z_]</span><br><span class="line">|/\h|	\h	\h	head of word character:		[A-Za-z_]</span><br><span class="line">|/\H|	\H	\H	non-head of word character:	[^A-Za-z_]</span><br><span class="line">|/\a|	\a	\a	alphabetic character:		[A-Za-z]</span><br><span class="line">|/\A|	\A	\A	non-alphabetic character:	[^A-Za-z]</span><br><span class="line">|/\l|	\l	\l	lowercase character:		[a-z]</span><br><span class="line">|/\L|	\L	\L	non-lowercase character:	[^a-z]</span><br><span class="line">|/\u|	\u	\u	uppercase character:		[A-Z]</span><br><span class="line">|/\U|	\U	\U	non-uppercase character		[^A-Z]</span><br><span class="line">|/\_|	\_x	\_x	where x is any of the characters above: character class with end-of-line included (end of character classes)</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">|/\e|	\e	\e	&lt;Esc&gt;</span><br><span class="line">|/\t|	\t	\t	&lt;Tab&gt;</span><br><span class="line">|/\r|	\r	\r	&lt;CR&gt;</span><br><span class="line">|/\b|	\b	\b	&lt;BS&gt;</span><br><span class="line">|/\n|	\n	\n	end-of-line</span><br><span class="line">|/~|	~	\~	last given substitute string</span><br><span class="line">|/\1|	\1	\1	same string as matched by first \(\) &#123;not in Vi&#125;</span><br><span class="line">|/\2|	\2	\2	Like &quot;\1&quot;, but uses second \(\)</span><br><span class="line">	   ...</span><br><span class="line">|/\9|	\9	\9	Like &quot;\1&quot;, but uses ninth \(\)</span><br><span class="line">								*E68*</span><br><span class="line">|/\z1|	\z1	\z1	only for syntax highlighting, see |:syn-ext-match|</span><br><span class="line">	   ...</span><br><span class="line">|/\z1|	\z9	\z9	only for syntax highlighting, see |:syn-ext-match|</span><br><span class="line"></span><br><span class="line">	x	x	a character with no special meaning matches itself</span><br><span class="line"></span><br><span class="line">|/[]|	[]	\[]	any character specified inside the []</span><br><span class="line">|/\%[]|	\%[]	\%[]	a sequence of optionally matched atoms</span><br><span class="line"></span><br><span class="line">|/\c|	\c	\c	ignore case, do not use the &#x27;ignorecase&#x27; option</span><br><span class="line">|/\C|	\C	\C	match case, do not use the &#x27;ignorecase&#x27; option</span><br><span class="line">|/\Z|	\Z	\Z	ignore differences in Unicode &quot;combining characters&quot;.</span><br><span class="line">			Useful when searching voweled Hebrew or Arabic text.</span><br><span class="line"></span><br><span class="line">|/\m|	\m	\m	&#x27;magic&#x27; on for the following chars in the pattern</span><br><span class="line">|/\M|	\M	\M	&#x27;magic&#x27; off for the following chars in the pattern</span><br><span class="line">|/\v|	\v	\v	the following chars in the pattern are &quot;very magic&quot;</span><br><span class="line">|/\V|	\V	\V	the following chars in the pattern are &quot;very nomagic&quot;</span><br><span class="line">|/\%#=|   \%#=1   \%#=1   select regexp engine |/zero-width|</span><br><span class="line"></span><br><span class="line">|/\%d|	\%d	\%d	match specified decimal character (eg \%d123)</span><br><span class="line">|/\%x|	\%x	\%x	match specified hex character (eg \%x2a)</span><br><span class="line">|/\%o|	\%o	\%o	match specified octal character (eg \%o040)</span><br><span class="line">|/\%u|	\%u	\%u	match specified multibyte character (eg \%u20ac)</span><br><span class="line">|/\%U|	\%U	\%U	match specified large multibyte character (eg</span><br><span class="line">			\%U12345678)</span><br><span class="line">|/\%C|	\%C	\%C	match any composing characters</span><br></pre></td></tr></table></figure>
<p>Example</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">\&lt;\I\i*		or</span><br><span class="line">\&lt;\h\w*</span><br><span class="line">\&lt;[a-zA-Z_][a-zA-Z0-9_]*</span><br><span class="line">			An identifier (e.g., in a C program).</span><br><span class="line"></span><br><span class="line">\(\.$\|\. \)		A period followed by &lt;EOL&gt; or a space.</span><br><span class="line"></span><br><span class="line">[.!?][])&quot;&#x27;]*\($\|[ ]\)	A search pattern that finds the end of a sentence,</span><br><span class="line">			with almost the same definition as the &quot;)&quot; command.</span><br><span class="line"></span><br><span class="line">cat\Z			Both &quot;cat&quot; and &quot;càt&quot; (&quot;a&quot; followed by 0x0300)</span><br><span class="line">			Does not match &quot;càt&quot; (character 0x00e0), even</span><br><span class="line">			though it may look the same.</span><br></pre></td></tr></table></figure>

<h1 id="vim中的零宽断言举例"><a href="#vim中的零宽断言举例" class="headerlink" title="vim中的零宽断言举例"></a>vim中的零宽断言举例</h1><p>@=    Matches the preceding atom with zero width. {not in Vi}<br>    Like “(?=pattern)” in Perl.<br>    Example            matches ~<br>    foo(bar)@=        “foo” in “foobar”<br>    foo(bar)@=foo    nothing<br>                            <em>/zero-width</em><br>    When using “@=” (or “^”, “$”, “&lt;“, “&gt;“) no characters are included<br>    in the match.  These items are only used to check if a match can be<br>    made.  This can be tricky, because a match with following items will<br>    be done in the same position.  The last example above will not match<br>    “foobarfoo”, because it tries match “foo” in the same position where<br>    “bar” matched.</p>
<pre><code>Note that using &quot;\&amp;&quot; works the same as using &quot;\@=&quot;: &quot;foo\&amp;..&quot; is the
same as &quot;\(foo\)\@=..&quot;.  But using &quot;\&amp;&quot; is easier, you don&apos;t need the
braces.


                        */\@!*</code></pre><p>@!    Matches with zero width if the preceding atom does NOT match at the<br>    current position. |/zero-width| {not in Vi}<br>    Like “(?!pattern)” in Perl.<br>    Example            matches ~<br>    foo(bar)@!        any “foo” not followed by “bar”<br>    a.{-}p@!        “a”, “ap”, “app”, “appp”, etc. not immediately<br>                followed by a “p”<br>    if ((then)@!.)*$    “if “ not followed by “then”</p>
<pre><code>Using &quot;\@!&quot; is tricky, because there are many places where a pattern
does not match.  &quot;a.*p\@!&quot; will match from an &quot;a&quot; to the end of the
line, because &quot;.*&quot; can match all characters in the line and the &quot;p&quot;
doesn&apos;t match at the end of the line.  &quot;a.\&#123;-&#125;p\@!&quot; will match any
&quot;a&quot;, &quot;ap&quot;, &quot;app&quot;, etc. that isn&apos;t followed by a &quot;p&quot;, because the &quot;.&quot;
can match a &quot;p&quot; and &quot;p\@!&quot; doesn&apos;t match after that.

You can&apos;t use &quot;\@!&quot; to look for a non-match before the matching
position: &quot;\(foo\)\@!bar&quot; will match &quot;bar&quot; in &quot;foobar&quot;, because at the
position where &quot;bar&quot; matches, &quot;foo&quot; does not match.  To avoid matching
&quot;foobar&quot; you could use &quot;\(foo\)\@!...bar&quot;, but that doesn&apos;t match a
bar at the start of a line.  Use &quot;\(foo\)\@&lt;!bar&quot;.

Useful example: to find &quot;foo&quot; in a line that does not contain &quot;bar&quot;: &gt;
    /^\%(.*bar\)\@!.*\zsfoo</code></pre><p>&lt;    This pattern first checks that there is not a single position in the<br>    line where “bar” matches.  If “.*bar” matches somewhere the @! will<br>    reject the pattern.  When there is no match any “foo” will be found.<br>    The “\zs” is to have the match start just before “foo”.</p>
<pre><code>*/\@&lt;=*</code></pre><p>@&lt;=    Matches with zero width if the preceding atom matches just before what<br>    follows. |/zero-width| {not in Vi}<br>    Like “(?&lt;=pattern)” in Perl, but Vim allows non-fixed-width patterns.<br>    Example            matches ~<br>    (an_s+)@&lt;=file    “file” after “an” and white space or an<br>                end-of-line<br>    For speed it’s often much better to avoid this multi.  Try using “\zs”<br>    instead |/\zs|.  To match the same as the above example:<br>        an_s+\zsfile<br>    At least set a limit for the look-behind, see below.</p>
<pre><code>&quot;\@&lt;=&quot; and &quot;\@&lt;!&quot; check for matches just before what follows.
Theoretically these matches could start anywhere before this position.
But to limit the time needed, only the line where what follows matches
is searched, and one line before that (if there is one).  This should
be sufficient to match most things and not be too slow.

In the old regexp engine the part of the pattern after &quot;\@&lt;=&quot; and
&quot;\@&lt;!&quot; are checked for a match first, thus things like &quot;\1&quot; don&apos;t work
to reference \(\) inside the preceding atom.  It does work the other
way around:
Bad example            matches ~
\%#=1\1\@&lt;=,\([a-z]\+\)        &quot;,abc&quot; in &quot;abc,abc&quot;

However, the new regexp engine works differently, it is better to not
rely on this behavior, do not use \@&lt;= if it can be avoided:
Example                matches ~
\([a-z]\+\)\zs,\1        &quot;,abc&quot; in &quot;abc,abc&quot;</code></pre><p>@123&lt;=<br>    Like “@&lt;=” but only look back 123 bytes. This avoids trying lots<br>    of matches that are known to fail and make executing the pattern very<br>    slow.  Example, check if there is a “&lt;” just before “span”:<br>        /&lt;@1&lt;=span<br>    This will try matching “&lt;” only one byte before “span”, which is the<br>    only place that works anyway.<br>    After crossing a line boundary, the limit is relative to the end of<br>    the line.  Thus the characters at the start of the line with the match<br>    are not counted (this is just to keep it simple).<br>    The number zero is the same as no limit.</p>
<pre><code>*/\@&lt;!*</code></pre><p>@&lt;!    Matches with zero width if the preceding atom does NOT match just<br>    before what follows.  Thus this matches if there is no position in the<br>    current or previous line where the atom matches such that it ends just<br>    before what follows.  |/zero-width| {not in Vi}<br>    Like “(?&lt;!pattern)” in Perl, but Vim allows non-fixed-width patterns.<br>    The match with the preceding atom is made to end just before the match<br>    with what follows, thus an atom that ends in “.*” will work.<br>    Warning: This can be slow (because many positions need to be checked<br>    for a match).  Use a limit if you can, see below.<br>    Example            matches ~<br>    (foo)@&lt;!bar        any “bar” that’s not in “foobar”<br>    (//.*)@&lt;!in    “in” which is not after “//“</p>
<p>@123&lt;!<br>    Like “@&lt;!” but only look back 123 bytes. This avoids trying lots of<br>    matches that are known to fail and make executing the pattern very<br>    slow.</p>
<pre><code>*/\@&gt;*</code></pre><p>@&gt;    Matches the preceding atom like matching a whole pattern. {not in Vi}<br>    Like “(?&gt;pattern)” in Perl.<br>    Example        matches ~<br>    (a<em>)@&gt;a    nothing (the “a</em>“ takes all the “a”‘s, there can’t be<br>            another one following)</p>
<pre><code>This matches the preceding atom as if it was a pattern by itself.  If
it doesn&apos;t match, there is no retry with shorter sub-matches or
anything.  Observe this difference: &quot;a*b&quot; and &quot;a*ab&quot; both match
&quot;aaab&quot;, but in the second case the &quot;a*&quot; matches only the first two
&quot;a&quot;s.  &quot;\(a*\)\@&gt;ab&quot; will not match &quot;aaab&quot;, because the &quot;a*&quot; matches
the &quot;aaa&quot; (as many &quot;a&quot;s as possible), thus the &quot;ab&quot; can&apos;t match.</code></pre>]]></content>
      <categories>
        <category>vim</category>
      </categories>
      <tags>
        <tag>Regex</tag>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title>vim的一些实用技巧</title>
    <url>/2015/12/13/vim-tips/</url>
    <content><![CDATA[<p>日常不常见，但又经常会用到的一些技巧或方法，不断补充</p>
<span id="more"></span>

<p>1.插入或命令模式下使用<code>ctrl+v</code>+按键来插入你的按键，例如插入tab，则按下ctrl+v，然后再出现的<code>^</code>符后面按下tab键即可。例如想全文搜索或替换tab，则可以在搜索模式下输入<code>ctrl+v</code>+tab键进行搜索即可。对于那烦人的windows换行符<code></code>，同样可以，任何按键都可以。</p>
<p>2.markdown文档中将从网上复制的表格中从当前行到最后一行的行首和行尾加上<code>|</code>，并将tab替换为<code>|</code>：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">:,$ s /^\|^I\|$/|/g</span><br></pre></td></tr></table></figure>
<p>其中<code>^I</code>是通过1中所说的方式插入的tab键，<code>\|</code>表示或的意思，可以在最后的g后面加个c，表示conform，即让你确定是否进行替换。</p>
]]></content>
      <categories>
        <category>vim</category>
      </categories>
      <tags>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title>Fortran 95快速学习笔记</title>
    <url>/2015/12/02/Fortran-study-notes/</url>
    <content><![CDATA[<p>仅仅实现能看懂Fortran代码，简单实现，所以主要是与C/C++进行对比语法差异，基于Fortran95/2003版本，Fortran的各版本保持着向下兼容。  </p>
<h2 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h2><figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="comment">!后面的基本语法处一一解释其含义</span></span><br><span class="line"><span class="function"><span class="keyword">PROGRAM</span></span> First_Fortran</span><br><span class="line"><span class="keyword">IMPLICIT</span> <span class="keyword">NONE</span></span><br><span class="line"><span class="built_in">WRITE</span>(*,*), &amp;</span><br><span class="line"><span class="string">&#x27;Hello World&#x27;</span></span><br><span class="line"><span class="keyword">PAUSE</span> <span class="comment">!暂停程序，enter后继续</span></span><br><span class="line"><span class="keyword">STOP</span></span><br><span class="line"><span class="keyword">END</span> <span class="function"><span class="keyword">PROGRAM</span></span> First_Fortran</span><br></pre></td></tr></table></figure>
<span id="more"></span>

<h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><p>1.Fortran对大小写不敏感。使用语句行来表示语句的开始和结束而不是分号。<br>2.长语句需要分两行时需要在第一行的行尾使用&amp;来结束<br>3.可以使用1~99999之间的任意数字放在行Fortran语句行的行首作为该语句的语句标号，可以在程序的其他地方通过该数字引用这条语句，语句标号必须是惟一的。<br>4.感叹号!开始到行尾的字符为注释，将被编译忽略。注释可以放在程序的任何位置。<br>5.PROGRAM语句对编译器指定程序的名字，名字命名类似C，但必须以字母开头，该语句必须放在第一个语句行，相当于指定程序的执行入口。<br>6.WRITE表示向输出写入数据，两个参数与READ中的意思相同。eg： </p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="built_in">WRITE</span> (*,*) output_list <span class="comment">!output_list是输出项列表，多个数据项应使用逗号隔开</span></span><br></pre></td></tr></table></figure>
<p>WRITE的表控输出语句等价于<code>PRINT *, output_list</code><br>7.READ为从输入读取数据，其中的第一个参数指明从哪个输入/输出单元读入数据，星号表示标准输入，第二个参数指明读入数据的格式，星号表示使用表控输入，即意味着为变量列表中的变量类型决定输入数据需要的格式。eg：  </p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">READ (*,*) input_list <span class="comment">!将数据读入的变量列表中</span></span><br></pre></td></tr></table></figure>
<p>每一条READ将始终从一个新行开始读取，如果上一行输入有剩余则会自动被清除<br>8.STOP告诉计算机停止运行，END PROGRAM告诉编译器程序中不再有语句需要编译，当STOP紧挨着END PROGRAM语句时，它是可选的。<br>9.Fortran程序书写风格：  </p>
<ul>
<li>1.保留字都大写  </li>
<li>2.程序的变量用小写字母表示    </li>
<li>3.常量名最好也使用大写，如PI(3.14159)  </li>
<li>4.名字中的下划线出现在两个字之间<br>10.Fortran的语句分为可执行语句（executable）和不可执行语句（unexecutable），声明即是不可执行语句，应放在程序的开头<br>11.IMPLICIT NONE语句表示使Fortran中默认提供输入值类型的功能失效，该语句应该出现在PROGRAM语句之后和类型声明语句之前。默认输入值类型是指在Fortran中，变量可以不经定义直接使用，而变量的类型是以变量名的第一个字母来区分的，例如<code>IMPLICIT real*8(A-H,O-Z)</code>即表壳A到H开头的变量类型都是浮点型。使用<code>IMPLICIT NONE</code>之后而所有变量必须在使用之前定义。     </li>
</ul>
<h2 id="基本数据类型及其运算"><a href="#基本数据类型及其运算" class="headerlink" title="基本数据类型及其运算"></a>基本数据类型及其运算</h2><p>1.Fortran有5个内置的数据类型，其中三个对数字有效(INTEGER, REAL, COMPLEX)，一个逻辑相关(LOGICAL)，另一个是字符串(CHARACTER)。<br>2.字符文本可以使用单引号’，也可以使用双引号”<br>3.有两种方式可以定义变量的类型：默认式和显式。如果在程序中没有明确指定变量类型，那么就是默认式定义变量类型，默认方式为：任何以字母I，J，K，L，M或N开头变量名都假定为INTEGER，其他字母开头的变量名假定为REAL，注意Fortran对大小写不敏感。例如默认情况inc的变量为整形，big为实型。<br>IMPLICIT NONE语句将使默认变量类型功能失效。<br>显式声明方式为<code>INTEGER :: var1 [, var2, var3, ...]</code>，其中[]表示其中的内容可选，只声明不初始化的话双冒号也是可选的。<br>4.字符串的声明方式：  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">CHARACTER</span>(len=<span class="number">10</span>) :: first, last !声明两个长度为<span class="number">10</span>的字符变量</span><br><span class="line">CHARACTER :: initial !声明一个长度为<span class="number">1</span>的字符变量  </span><br><span class="line"><span class="built_in">CHARACTER</span>(<span class="number">15</span>) :: id !id长度为<span class="number">15</span>  </span><br></pre></td></tr></table></figure>
<p>5.使用PARAMETER属性创建常数类型，方式为<code>type, PARAMETER :: name=value [, name2=value2, ...]</code>其中type的类型可以是整形，实型，逻辑型或字符型。eg: </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">REAL , PARAMETER :: PI = <span class="number">3.141593</span></span><br></pre></td></tr></table></figure>
<p>6.**表示指数运算。<br>7.Fortran95/2003中含有5个强制类型转换函数：  </p>
<ul>
<li>INT(X) 将REAL类型的X转换其整数部分</li>
<li>NINT(X) 返回REAL类型的X的四舍五入结果  </li>
<li>CEILING(X) 大于或等于X的最小整数值，X为REAL</li>
<li>FLOOR(X) 小于或等于X的最大整数值，X为REAL</li>
<li>REAL(I) 将整数转换为实数<br>8.变量不会被默认初始化<br>9.逻辑数据类型只有两个可能的值：true和false，分别对应的内置逻辑常数是<code>.TRUE.</code>和<code>.FALSE.</code>(注意两连的句点)，逻辑变量声明方式<code>LOGICAL :: var1, [, var2, var3, ...]</code>，所有声明都应该放在第一条执行语句之前，PROGRAM语句之后。<br>10.关系运算符中<code>/=</code>表示不等于，对应的旧形式为<code>.NE.</code>，所有运算符：  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">新形式：==   /=	    &gt;    &gt;=    &lt;    &lt;= </span><br><span class="line">旧形式：EQ.  .NE.  .GT.  .GE. .LT. .LE.</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>11.组合逻辑运算符：  </p>
<ul>
<li><code>.AND.</code> 逻辑与  </li>
<li><code>.OR.</code> 逻辑或  </li>
<li><code>.NOT.</code> 逻辑非  </li>
<li><code>.EQV.</code> 逻辑等值，相同为真  </li>
<li><code>.NEQV.</code> 逻辑非等值，不相同为真  </li>
</ul>
<p>12.当逻辑变量出现在以READ开头的语句中时，相应的输入值必须以T或F开头的一个或一组字符，相应的值被设置为<code>.TRUE.</code>或<code>.FALSE</code>，输入其他字符开头将产生运行时错误。当逻辑变量或表达式出现在以WRITE开头的语句中时，相应输出将为单个字符T或F。<br>13.字符串声明与赋值：  </p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CHARACTER</span>(len=<span class="number">3</span>) :: str</span><br><span class="line">str = <span class="string">&#x27;f&#x27;</span></span><br></pre></td></tr></table></figure>
<p>当字符串长度小于变量长度时，默认使用空格填充<br>14.Fortran中的数组首元素是从1而不是0开始，子串抽取与python一样。例如若str=’12345’，则str(2:4)为<code>234</code>。<br>15.连接操作符<code>//</code>可以将两个子串连接成一个大串。<br>16.可以在定义类型里手动指定变量所占用的字节大小。方法如下：<code>TYPE(kind) :: var</code>，其中kind为正整数，表示该变量所占字节数，如果不指定默认为长整型4或浮点型的8。例如<code>INTEGER(4) :: var</code>，var为占用4个字节的整型。Fortran90之前的编译器声明方式为<code>INTEGER*4 var</code><br>16.<code>real(8) var</code> <code>var = 0.0_8</code>  表示为var初始化值为0.0，且占8个字节。  </p>
<h2 id="控制语句"><a href="#控制语句" class="headerlink" title="控制语句"></a>控制语句</h2><p>1.IF语句与C中类似，形式如下：  </p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">[名称: ]<span class="keyword">IF</span> (logical_expr) <span class="keyword">THEN</span></span><br><span class="line">  statement <span class="number">1</span></span><br><span class="line">  statement <span class="number">2</span></span><br><span class="line"><span class="keyword">ELSE</span> <span class="keyword">IF</span> (logical_expr_2) <span class="keyword">THEN</span> [名称]</span><br><span class="line">  statement <span class="number">1</span></span><br><span class="line">  statement <span class="number">2</span></span><br><span class="line"><span class="keyword">ELSE</span> [名称]</span><br><span class="line">  statement <span class="number">1</span></span><br><span class="line">  statement <span class="number">2</span></span><br><span class="line">  ...</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">IF</span> [名称]</span><br></pre></td></tr></table></figure>
<p>其中IF THEN必须在同一行，且其下面一行必须紧跟可执行语句，ELSE，ELSE IF和END IF也必须独占一行，END IF前面面不能有行号<br>其中名称是可选的，但如果IF前面有名称那么END IF后面也必须有，且同名<br>当IF语句块中只有一行语句时，等价于<code>IF (logical_expr) expression</code><br>2.当嵌套使用IF语句时，最好为其命名<br>3.<code>SELECT CASE</code>语句类似于C中每个case都带有break语句的switch，用法如下：  </p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">[<span class="keyword">name</span>: ]<span class="keyword">SELECT</span> <span class="keyword">CASE</span> (case_expr)</span><br><span class="line"><span class="keyword">CASE</span> (case1) [<span class="keyword">name</span>]</span><br><span class="line">  statement <span class="number">1</span></span><br><span class="line">  statement <span class="number">2</span></span><br><span class="line">  ...</span><br><span class="line"><span class="keyword">CASE</span> (case2, case3, case4) [<span class="keyword">name</span>]</span><br><span class="line">  statement <span class="number">1</span></span><br><span class="line">  statement <span class="number">2</span></span><br><span class="line">  ...</span><br><span class="line"><span class="keyword">CASE</span> <span class="keyword">DEFAULT</span> [<span class="keyword">name</span>]</span><br><span class="line">  statement <span class="number">1</span></span><br><span class="line">  statement <span class="number">2</span></span><br><span class="line">  ...</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">SELECT</span> [<span class="keyword">name</span>]</span><br></pre></td></tr></table></figure>
<p>其中case_expr可以是任意的整数、字符或逻辑表达式。对应的每个子case必须是整数、字符或逻辑数值，或数值范围，所有子case必须相互独立。其中数值范围是指以冒号隔开的一个范围，与python中的范围表示方式一样，如(1:10)表示1~10。  </p>
<p>4.DO循环： </p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DO</span> </span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">IF</span> (logical_expr) <span class="keyword">EXIT</span></span><br><span class="line">  ...</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">DO</span></span><br></pre></td></tr></table></figure>

<p>5.DO WHILE循环：  </p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DO</span> <span class="keyword">WHILE</span> (logical_expr)</span><br><span class="line">  statement <span class="number">1</span></span><br><span class="line">  ...</span><br><span class="line">  statement n</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">DO</span></span><br></pre></td></tr></table></figure>

<p>6.迭代DO循环，类型C中的for循环：  </p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DO</span> <span class="built_in">index</span>=istart,<span class="keyword">end</span>,incr</span><br><span class="line">  statement <span class="number">1</span></span><br><span class="line">  ...</span><br><span class="line">  statement n</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">DO</span></span><br></pre></td></tr></table></figure>
<p>其中index是一个整数变量，作为循环计数器使用，整数istart，iend和incr分别表示计数起始值，结束值和步长，它们可以是常量、变量或表达式，当incr省略时，步长默认为1。如果<code>index*incr &lt;= iend*incr</code>。  </p>
<p>7.控制语句中的CYCLE相当于C中的continue，EXIT相当于C中的break。<br>8.循环语句也可以被命名，规则与IF命名一样。  </p>
<h2 id="IO操作"><a href="#IO操作" class="headerlink" title="IO操作"></a>IO操作</h2><p>1.格式化的WRITE输出：  </p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="built_in">WRITE</span> (*,<span class="number">100</span>) i, result</span><br><span class="line"><span class="number">100</span> <span class="keyword">FORMAT</span> (<span class="string">&#x27; The result for iteration &#x27;</span>, I3, <span class="string">&#x27; is &#x27;</span>, F7<span class="number">.3</span>)</span><br></pre></td></tr></table></figure>
<p>意思是输出i和result，使用100做为语句标号，相当于一个大的占位符，用于代替WRITE语句的第二个控制输出方式的参数，输出结果即是字符串正常输出，带有占位符的地方，使用对应值替换。例如I3表示以占用3个字符宽度的方式输出INTEGER类型的i，F7.3表示以占用7个字符宽度且保留小数点后3位方式输出REAL类型的result。  </p>
<p>2.以下三个输出结果是等价：  </p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="built_in">WRITE</span> (*, <span class="number">100</span>) i, x	    <span class="comment">!使用FORMAT控制格式</span></span><br><span class="line"><span class="number">100</span> <span class="keyword">FORMAT</span> (<span class="number">1</span>X, I6, F10<span class="number">.2</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">CHARACTER</span> (len = <span class="number">20</span>) :: string <span class="comment">!使用字符变量控制格式</span></span><br><span class="line">string = <span class="string">&#x27;(1X, I6, F10.2)&#x27;</span></span><br><span class="line"><span class="built_in">WRITE</span> (*, string) i, x</span><br><span class="line"></span><br><span class="line"><span class="built_in">WRITE</span> (*, <span class="string">&#x27;(1X, I6, F10.2)&#x27;</span>) i, x  <span class="comment">!在字符常量中的格式</span></span><br></pre></td></tr></table></figure>

<p>3.老式的Fortran编译器的格式控制字符中的第一个字符将起到控制输出格式的作用，所以上面1例中FORMAT的内容以空格开头，但在Fortran2003之后的版本中并没有这个限制。具体控制字符的作用如下：  </p>
<ul>
<li>1    跳转到新页  </li>
<li>空格    单行间距   </li>
<li>0     双行间距   </li>
<li><ul>
<li>没有间距（在前一行上打印）  </li>
</ul>
</li>
</ul>
<p>下面的两句是等价的，都表示在新的一页的开头打印输出 </p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="built_in">WRITE</span> (*,<span class="string">&quot;(&#x27;1&#x27;, &#x27;Count = &#x27;, I3)&quot;</span>) icount</span><br><span class="line"><span class="built_in">WRITE</span> (*,<span class="string">&quot;(&#x27;1Count = &#x27;, I3)&quot;</span>) icount</span><br></pre></td></tr></table></figure>

<p>4.控制格式描述的符号如下：  </p>
<ul>
<li>c 列号  </li>
<li>d 实数输入或输出小数位右边的位数  </li>
<li>m 要显示的最小位数  </li>
<li>n 要跳过的空格数  </li>
<li>r 重复计数——一个描述符或一组描述符的使用次数  </li>
<li>w 域宽——输入或输出使用的字符数  </li>
</ul>
<p>5.常见的输出控制格式：  </p>
<ul>
<li>整数输入——I描述符的一般格式为<code>rIw</code>或<code>rIw.m</code>  </li>
<li>实数输出——F描述符一般格式为<code>rFw.d</code>  </li>
<li>实数输出——E描述符一般格式为<code>rEw.d</code>  </li>
<li>真正的科学计数输出——ES描述符一般格式为<code>rESw.d</code>  </li>
<li>逻辑输出——L描述符一般格式为<code>rLw</code>  </li>
<li>字符输出——A描述符一般格式为<code>rA</code>或<code>rAw</code>  </li>
<li>X描述符用于在缓冲区中插入间距，用法为<code>nX</code>  </li>
<li>T描述符用于在缓冲区中跳过特定列，用法为<code>Tc</code>，其中c为要转到的列号  </li>
<li>改变输出行——斜线（/）描述符，类似C中的<code>\n</code>，用于换行  </li>
</ul>
<p>举例，以下两条语句是等价的：  </p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="number">320</span> <span class="keyword">FORMAT</span> ( <span class="number">1</span>X, I6, I6, F10<span class="number">.2</span>, F10<span class="number">.2</span>, I6, F10<span class="number">.2</span>, F10<span class="number">.2</span> )</span><br><span class="line"><span class="number">320</span> <span class="keyword">FORMAT</span> ( <span class="number">1</span>X, I6, <span class="number">2</span>(I6, <span class="number">2</span>F10<span class="number">.2</span>) )</span><br></pre></td></tr></table></figure>
<p>当格式控制字符中的宽度无法表示所要输出的数字时，不像C中直接全部输出，Fortran会输出为星号<code>*</code>，例如格式控制字符<code>I1</code>,输出10的时候，会输出一个<code>*</code></p>
<p>6.输出格式要与输出变量严格对应，否则会有运行时错误<br>7.READ的读取格式控制与WRITE一一对应<br>8.Fortran的I/O读写语句的第一个参数就是用于指定读写设备。该位置的星号即表示标准输出或输入，如果使用其他设备则需要指定I/O单元号，单元号必须为整数类型。<br>9.常用的I/O语句：  </p>
<ul>
<li>OPEN        将指定的文件与指定的I/O单元号关联  </li>
<li>CLOSE       取消指定的文件与指定的I/O单元号的关联  </li>
<li>READ        从指定的I/O单元读取数据  </li>
<li>WRITE       向指定的I/O单元写入数据  </li>
<li>REWIND      移动到文件的开头  </li>
<li>BACKSPACE   在当前打开的文件中向后移动一个位置      </li>
</ul>
<p>10.OPEN用法为<code>OPEN (open_list)</code>，期中open_list包含一组子句，分别指定I/O单元代号、文件名和关于如何存取文件的信息，这些列表使用逗号隔开。<br>11.<code>open_list</code>中最重要的六项内容：  </p>
<ul>
<li><code>UNIT=int_expr</code>     指明与文件关联的I/O单元代号，int_expr可以是非负的整数值  </li>
<li><code>FILE=char_expr</code>    指定要打开的文件名，char_expr是一个包含要打开文件的名称的字符值  </li>
<li><code>STATUS=char_expr</code>  指定要打开的文件状态，char_expr为下列值中的一个：<code>&#39;OLD&#39;</code>，<code>&#39;NEW&#39;</code>，<code>&#39;REPLACE&#39;</code>，<code>&#39;SCRATCH&#39;</code>或<code>&#39;UNKNOW&#39;</code>。</li>
<li><code>ACTION=char_expr</code>  指定一个文件是以只读、只写或读写方式打开。char_expr为下列值中的一个：<code>&#39;READ&#39;</code>，<code>&#39;WRITE&#39;</code>或<code>&#39;READWRITE&#39;</code>，如果没有指定任何操作，则默认以读写方式打开。  </li>
<li><code>IOSTAT=int_var</code>  指定一个整数变量名，打开操作的状态可以返回到这个变量中。如果OPEN语句成功执行，则返回给这个整数变量的值为0。  </li>
<li><code>IOMSG=chart_var</code> 指定一个字符变量名，如果发生错误，则该错误信息将返回给这个变量。如果OPEN语句成功执行，则该变量的内容不变。<br>示例：  <figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="comment">!打开一个名为EXAMPLE.DAT的文件，并将其连接到I/O单元8上</span></span><br><span class="line"><span class="keyword">INTEGER</span> :: ierror</span><br><span class="line">OPEN (<span class="keyword">UNIT</span>=<span class="number">8</span>, <span class="keyword">FILE</span>=<span class="string">&#x27;EXAMPLE.DAT&#x27;</span>, <span class="keyword">STATUS</span>=<span class="string">&#x27;OLD&#x27;</span>, <span class="keyword">ACTION</span>=<span class="string">&#x27;READ&#x27;</span>, &amp;<span class="keyword">IOSTAT</span>=ierror)  </span><br><span class="line"><span class="comment">!以自由格式从文件中读取值到x,y,z</span></span><br><span class="line">OPEN (<span class="keyword">UNIT</span>=<span class="number">8</span>, <span class="keyword">FILE</span>=<span class="string">&#x27;INPUT.DAT&#x27;</span>, <span class="keyword">STATUS</span>=<span class="string">&#x27;OLD&#x27;</span>, <span class="keyword">IOSTAT</span>=ierror)</span><br><span class="line">READ (<span class="number">8</span>,*)  x, y, z</span><br><span class="line"><span class="comment">!以特定的格式向文件OUTPUT.DAT中写入变量x,y,z的值</span></span><br><span class="line">OPEN (<span class="keyword">UNIT</span>=<span class="number">9</span>, <span class="keyword">FILE</span>=<span class="string">&#x27;OUTPUT.DAT&#x27;</span>, <span class="keyword">STATUS</span>=<span class="string">&#x27;REPLACE&#x27;</span>, <span class="keyword">IOSTAT</span>=ierror)</span><br><span class="line"><span class="built_in">WRITE</span> (<span class="number">9</span>,<span class="number">100</span>) x, y, z</span><br><span class="line"><span class="number">100</span> <span class="keyword">FORMAT</span> (<span class="string">&#x27; X = &#x27;</span>, F10<span class="number">.2</span>, <span class="string">&#x27; Y = &#x27;</span>, F10<span class="number">.2</span>, <span class="string">&#x27; Z = &#x27;</span>, F10<span class="number">.2</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
<p>12.BACKSPACE和REWIND语句的功能相当于修改文件指针所指向的位置  </p>
<p>13.READ在按行读取文件时会自动跳过空行  </p>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>1.Fortran中的数组元素从下标1开始，通过小括号()访问<br>2.数组声明方式如下：  </p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="comment">!声明一个含有16个元素的实型数组voltage</span></span><br><span class="line"><span class="keyword">REAL</span>, <span class="keyword">DIMENSION</span>(<span class="number">16</span>) :: voltage</span><br><span class="line"><span class="comment">!等价于</span></span><br><span class="line"><span class="keyword">REAL</span> :: voltage(<span class="number">16</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">!声明一个含有50个长度为20位字符的数组变量last_name</span></span><br><span class="line"><span class="keyword">CHARACTER</span> (len=<span class="number">20</span>), <span class="keyword">DIMENSION</span>(<span class="number">50</span>) :: last_name</span><br></pre></td></tr></table></figure>
<p>DIMENSION属性说明被定义数组的大小<br>3.通过(/…/) 可以构建常量数组，如<code>(/ 1, 2, 3, 4, 5 /)</code>构建了一个含有5个整型元素的数组常量<br>4.数组的初始化可以先声明然后使用赋值的方式初始化，或者使用数组构建器初始化，也可以通过给数组名赋值将所有元素初始化同一个值，或者在声明时直接初始化。eg: </p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">REAL</span>, <span class="keyword">DIMENSION</span>(<span class="number">10</span>) :: array1</span><br><span class="line"><span class="keyword">DO</span> i = <span class="number">1</span>, <span class="number">10</span></span><br><span class="line">  array1(i) = <span class="keyword">REAL</span>(i)</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">DO</span></span><br><span class="line"><span class="comment">!等价于  </span></span><br><span class="line">array1 = (/<span class="number">1.</span>, <span class="number">2.</span>, <span class="number">3.</span>, <span class="number">4.</span>, <span class="number">5.</span>, ..., <span class="number">10.</span>/)</span><br><span class="line"><span class="comment">!等价于</span></span><br><span class="line"><span class="keyword">REAL</span>, <span class="keyword">DIMENSION</span>(<span class="number">10</span>) :: array1 = (/<span class="number">1.</span>, <span class="number">2.</span>, <span class="number">3.</span>, <span class="number">4.</span>, <span class="number">5.</span>, ..., <span class="number">10.</span>/)</span><br><span class="line"><span class="comment">!将所有的array1初始化为0</span></span><br><span class="line">array1 = <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>5.可以使用隐式DO循环初始化数组，形式为<code>(arg1, arg2, ..., index = istart, iend, incr)</code>，其中arg1, arg2等是每次循环执行时估算的值，隐式DO循环支持嵌套。eg:  </p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="comment">!上面声明并初始化array1的等价形式</span></span><br><span class="line"><span class="keyword">REAL</span>, <span class="keyword">DIMENSION</span>(<span class="number">10</span>) :: array1 = (/ (<span class="keyword">REAL</span>(i), i=<span class="number">1</span>, <span class="number">5</span>) /)</span><br></pre></td></tr></table></figure>
<p>6.可以使用以下方式在声明时指定下标取舍范围：  </p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="comment">!该数组的大小为upper_bound - lower_bound + 1</span></span><br><span class="line"><span class="keyword">REAL</span>, <span class="keyword">DIMENSION</span>(lower_bound : upper_bound)  :: array</span><br></pre></td></tr></table></figure>
<p>7.声明常量名来作为数组大小：  </p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INTEGER</span>, <span class="keyword">PARAMETER</span> :: MAX_SIZE = <span class="number">1000</span></span><br><span class="line"><span class="keyword">REAL</span> :: array1(MAX_SIZE)</span><br></pre></td></tr></table></figure>
<p>8.当两个数组元素类型和大小相同时，对数组名的运算相当于对数组的每个元素分别进行运算，如：  </p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">REAL</span>, <span class="keyword">DIMENSION</span>(<span class="number">10</span>) :: a, b, c</span><br><span class="line">c = a + b <span class="comment">!等价于c(i) = a(i) + b(i)</span></span><br></pre></td></tr></table></figure>
<p>9.可以使用下标三元组或向量下标的形式来使用数组的部分变量，称为部分数组（section array），三元组的使用方式为<code>subscript_1 : subscript_2 : stride</code>，当stride省略时，表示默认步长为1，当subscript_1省略时默认表示从第一个元素开始，当subscript_2省略时默认到最后一个元素，与python的包前不包后不同，Fortran这种局部数组前后都包。<br>10.向量下标的使用方式如下：  </p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INTEGER</span>, <span class="keyword">DIMENSION</span>(<span class="number">5</span>) :: vec = (/<span class="number">1</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">9</span>/)</span><br><span class="line"><span class="keyword">REAL</span>, <span class="keyword">DIMENSION</span>(<span class="number">10</span>)  :: a = (/<span class="number">1.</span>, -<span class="number">2.</span>, <span class="number">3.</span>, -<span class="number">4.</span>, <span class="number">5.</span>, -<span class="number">6.</span>, <span class="number">7.</span>, -<span class="number">8.</span>, <span class="number">9.</span>, -<span class="number">10.</span>/)</span><br><span class="line"><span class="comment">!a(vec)的内容是数组[1., -6., -4., 1., 9.]</span></span><br></pre></td></tr></table></figure>
<p>11.读写数组时可以使用隐式DO循环，形式如下：  </p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="built_in">WRITE</span> (<span class="keyword">unit</span>, <span class="keyword">format</span>) ( arg1, arg2, ... , <span class="built_in">index</span> = istart, iend, incr)</span><br><span class="line">READ (<span class="keyword">unit</span>, <span class="keyword">format</span>) ( arg1, arg2, ... , <span class="built_in">index</span> = istart, iend, incr)</span><br><span class="line"><span class="comment">!以下打印前5个元素的方法等价</span></span><br><span class="line"><span class="built_in">WRITE</span> (*,<span class="number">100</span>) a(<span class="number">1</span>), a(<span class="number">2</span>), a(<span class="number">3</span>), a(<span class="number">4</span>), a(<span class="number">5</span>)</span><br><span class="line"><span class="number">100</span> <span class="keyword">FORMAT</span> (<span class="number">1</span>X, <span class="string">&#x27;a = &#x27;</span>, <span class="number">5</span>F10<span class="number">.2</span>)</span><br><span class="line"><span class="comment">!等价于</span></span><br><span class="line"><span class="built_in">WRITE</span> (*,<span class="number">100</span>), (a(i), i = <span class="number">1</span>, <span class="number">5</span>)</span><br><span class="line"><span class="number">100</span> <span class="keyword">FORMAT</span> (<span class="number">1</span>X, <span class="string">&#x27;a = &#x27;</span>, <span class="number">5</span>F10<span class="number">.2</span>)</span><br></pre></td></tr></table></figure>
<p>12.隐式DO循环可以嵌套使用<br>13.</p>
<h2 id="Fortran过程控制"><a href="#Fortran过程控制" class="headerlink" title="Fortran过程控制"></a>Fortran过程控制</h2><p>1.Fortran的有两种方式实现调用外部过程，分别是子程序(subroutine)和函数之程序(function subprogram)。子程序通过CALL语句调用，并且可以通过调用参数来返回多个结果。函数子程序则通过在表达式中引入函数名来进行调用，它的结果是单个数值，该值用来为表达式赋值，就像数学中的函数那样。  </p>
<h3 id="子程序"><a href="#子程序" class="headerlink" title="子程序"></a>子程序</h3><p>2.子程序的声明格式如下：  </p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">SUBROUTINE</span></span> subtine_name(argument_list)</span><br><span class="line">  ...</span><br><span class="line">  (Declaration section)</span><br><span class="line">  ...</span><br><span class="line">  (Execution section)</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">RETURN</span></span><br><span class="line"><span class="keyword">END</span> <span class="function"><span class="keyword">SUBROUTINE</span></span> [<span class="keyword">name</span>]</span><br></pre></td></tr></table></figure>
<p>其中argument_list中不能附带参数类型，但在子程序内容的声明部分必须要为相应的参数声明类型<br>子程序就相当于一个独立的程序，只是可以带参数，所以在声明部分的前面同样需要单独加上<code>IMPLICIT NONE</code><br>3.子程序的调用格式如下：  </p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CALL</span> subroutine_name(argument_list)</span><br></pre></td></tr></table></figure>
<p>4.子程序的参数传递方式为传址传递，相当于C语言中传递指针，所以子程序会直接修改原变量的值，如果想在子程序内部不对传递进来的参数进行修改，可以在声明部分使用INTENT属性声明，相当于在子程序内容将相应参数修改为const类型，eg:  </p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="comment">!加法子程序，并改变传递进去的某个变量的值</span></span><br><span class="line"><span class="function"><span class="keyword">SUBROUTINE</span></span> add(a, b, c)</span><br><span class="line">  <span class="keyword">IMPLICIT</span> <span class="keyword">NONE</span></span><br><span class="line">  <span class="keyword">REAL</span> :: a</span><br><span class="line">  <span class="keyword">REAL</span>, <span class="keyword">INTENT</span>(<span class="keyword">IN</span>) :: b <span class="comment">!添加IN发生后b将不能作为左值，且不能被修改</span></span><br><span class="line">  <span class="keyword">REAL</span>, <span class="keyword">INTENT</span>(<span class="keyword">OUT</span>) :: c <span class="comment">!添加OUT属性后，c将可以作为左值，且可以被修改</span></span><br><span class="line">  c = a + b</span><br><span class="line">  a = <span class="number">5.0</span> <span class="comment">!调用后原程序对应的变量值将变成5.0，但不能以同样的方式修改b，否则会编译报错</span></span><br><span class="line">  <span class="keyword">RETURN</span></span><br><span class="line"><span class="keyword">END</span> <span class="function"><span class="keyword">SUBROUTINE</span></span> add</span><br></pre></td></tr></table></figure>
<p>调用时参数类型必须一致<br>5.INTENT的所有属性：  </p>
<ul>
<li>INTENT(IN)    形参仅用于向子程序传递输入数据  </li>
<li>INTENT(OUT)    形参仅用于将结果返回给调用程序</li>
<li>INTENT(INOUT)/INTENT(IN OUT)    形参即用来向子程序输入数据，也用来将结果返回给调用程序</li>
</ul>
<p>6.与C中一样，为子程序传递数组时，需要传递数组的大小<br>7.传递字符变量给子程序时可以使用*声明字符变量的长度，当在子程序内容需要使用到字符串的长度时可以使用LEN()函数来获取字符串长度，声明方式如下：  </p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">SUBROUTINE</span></span> sample (string)</span><br><span class="line"><span class="keyword">CHARACTER</span> ( len=* ), <span class="keyword">INTENT</span>(<span class="keyword">IN</span>)  :: string</span><br></pre></td></tr></table></figure>

<h3 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h3><p>8.Fortran可以使用模块来在不同的程序之间共享数据，模块相当于C中的头文件，它可以用来共享数据，同样可以用于共享子程序，声明方式是使用MODULE，引用方法是使用USE module_name。下面例子说明使用其共享数据。eg: </p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">MODULE</span> shared_data</span><br><span class="line"><span class="keyword">IMPLICIT</span> <span class="keyword">NONE</span></span><br><span class="line"><span class="keyword">SAVE</span></span><br><span class="line"><span class="keyword">INTEGER</span>, <span class="keyword">PARAMETER</span> :: num_vals = <span class="number">5</span> </span><br><span class="line"><span class="keyword">REAL</span>, <span class="keyword">DIMENSION</span>(num_vals) :: values</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">MODULE</span> shared_data</span><br><span class="line"></span><br><span class="line"><span class="comment">!使用模块</span></span><br><span class="line"><span class="function"><span class="keyword">PROGRAM</span></span> test_module</span><br><span class="line"><span class="keyword">USE</span> shared_data</span><br><span class="line"><span class="keyword">IMPLICIT</span> <span class="keyword">NONE</span></span><br><span class="line">values = <span class="number">2</span></span><br><span class="line"><span class="keyword">CALL</span> sub</span><br><span class="line"><span class="keyword">END</span> <span class="function"><span class="keyword">PROGRAM</span></span> test_module</span><br><span class="line"></span><br><span class="line"><span class="comment">!SUBROUTINE</span></span><br><span class="line"><span class="function"><span class="keyword">SUBROUTINE</span></span> sub</span><br><span class="line"><span class="keyword">USE</span> shared_data</span><br><span class="line"><span class="keyword">IMPLICIT</span> <span class="keyword">NONE</span></span><br><span class="line"><span class="built_in">WRITE</span> (*,*) values</span><br><span class="line"><span class="keyword">END</span> <span class="function"><span class="keyword">SUBROUTINE</span></span> sub</span><br></pre></td></tr></table></figure>
<p>SAVE语句能够保证在模块中声明的数据被保护在不同的过程间的引用中。<br>sub子程序中的values将全部为2，因为该变量是与主程序共享的<br>9.模块中需要定义子程序和函数时必须使用关键字CONTAINS，这些子程序和过程被称作模块过程。eg:  </p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">MODULE</span> my_subs</span><br><span class="line"><span class="keyword">IMPLICIT</span> <span class="keyword">NONE</span></span><br><span class="line">(Declare <span class="keyword">shared</span> <span class="keyword">data</span> here)</span><br><span class="line"><span class="keyword">CONTAINS</span></span><br><span class="line">  <span class="function"><span class="keyword">SUBROUTINE</span></span> sub (a, b, c, k, error)</span><br><span class="line">  <span class="keyword">IMPLICIT</span> <span class="keyword">NONE</span></span><br><span class="line">  <span class="keyword">REAL</span>, <span class="keyword">DIMENSION</span>(<span class="number">3</span>), <span class="keyword">INTENT</span>(<span class="keyword">IN</span>) :: a</span><br><span class="line">  <span class="keyword">REAL</span>, <span class="keyword">INTENT</span>(<span class="keyword">IN</span>) :: b, c</span><br><span class="line">  <span class="keyword">REAL</span>, <span class="keyword">INTENT</span>(<span class="keyword">OUT</span>) :: x</span><br><span class="line">  <span class="keyword">LOGICAL</span>, <span class="keyword">INTENT</span>(<span class="keyword">OUT</span>) :: error</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">END</span> <span class="function"><span class="keyword">SUBROUTINE</span></span> sub</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">MODULE</span> my_subs</span><br></pre></td></tr></table></figure>

<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>1.Fortran函数是这样一个过程：它的结果只能是单个数值、逻辑值、字符串或数组之一。有两种不同类型的函数：内部函数（intrinsic function）和用户自定义的函数（user-defined function，或函数子程序function subprograms)。其中内部函数即是指Fortran自带的SIN(X)、LOG(X)等。<br>2.自定义Fortran函数的通用格式如下：  </p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">[<span class="keyword">TYPE</span>] <span class="function"><span class="keyword">FUNCTION</span></span> <span class="keyword">name</span> (argument_list)</span><br><span class="line">  ...</span><br><span class="line">  (Declaration section must declare <span class="keyword">type</span> of <span class="keyword">name</span>)</span><br><span class="line">  ...</span><br><span class="line">  (Execution section)</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">name</span> = expr</span><br><span class="line">  <span class="keyword">RETURN</span></span><br><span class="line"><span class="keyword">END</span> <span class="function"><span class="keyword">FUNCTION</span></span> [<span class="keyword">name</span>]</span><br></pre></td></tr></table></figure>
<p>其中，TYPE表示函数的返回值类型，使用IMPLICIT NONE语句时，必须要指名函数的返回类型，如果有使用IMPLICIT NONE语句，那么函数的返回类型将默认使用Fortran的内置规则。RETURN语句只是表示结束本函数，将执行权限归还给调用函数，所以RETURN并不是必须有。函数的返回值是通过给函数名赋值而实现，所以函数中必须至少有一次让函数名出现在赋值语句的左侧来指定函数的返回值。  </p>
<p>2.函数的声明可以采用以下两种等价格式之一：  </p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INTEGER</span> <span class="function"><span class="keyword">FUNCTION</span></span> my_function(i, j)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">FUNCTION</span></span> my_function(i,j)</span><br><span class="line"><span class="keyword">INTEGER</span> :: my_function</span><br></pre></td></tr></table></figure>
<p>3.函数在被调用时，也必须在调用函数前面对其进行类型声明，声明方式如下：  </p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">TYPE</span> :: function_name</span><br></pre></td></tr></table></figure>
<p>4.使用函数计算两个实数之和的例子：  </p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">PROGRAM</span></span> test_func</span><br><span class="line">    <span class="keyword">IMPLICIT</span> <span class="keyword">NONE</span></span><br><span class="line">    <span class="keyword">REAL</span> :: func</span><br><span class="line">    <span class="keyword">REAL</span> :: i = <span class="number">2</span>, j = <span class="number">5</span></span><br><span class="line">    <span class="built_in">WRITE</span>(*,*) func(i,j)</span><br><span class="line">    <span class="keyword">PAUSE</span></span><br><span class="line"><span class="keyword">END</span> <span class="function"><span class="keyword">PROGRAM</span></span> test_func</span><br><span class="line"></span><br><span class="line"><span class="keyword">REAL</span> <span class="function"><span class="keyword">FUNCTION</span></span> func(a,b)</span><br><span class="line">    <span class="keyword">IMPLICIT</span> <span class="keyword">NONE</span></span><br><span class="line">    <span class="keyword">REAL</span>, <span class="keyword">INTENT</span>(<span class="keyword">IN</span>) :: a, b</span><br><span class="line">    func = a + b</span><br><span class="line"><span class="keyword">END</span> <span class="function"><span class="keyword">FUNCTION</span></span> func</span><br></pre></td></tr></table></figure>
<p>5.函数的参数传递过程也是传址传递。<br>6.过程名相当于也是个指针，包含子程序和函数。所以可以将过程作为参数传递给其他过程，类似C中的函数指针。<br>7.必须在被调用函数(或子程序)和主程序中使用EXTERNEL关键字来声明的用户自定义函数（或过程）才可以当作调用参数传递。EXTERNEL发生的使用方法与其他属性一样，但也有一个自己的专有格式，如下：  </p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">REAL</span>, EXTERNEL :: func_1, func_2</span><br><span class="line"><span class="comment">!专有格式</span></span><br><span class="line">EXTERNEL func_1, func_2</span><br></pre></td></tr></table></figure>

<h2 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h2><p>1.二维数组的声明方式举例：  </p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="comment">!声明一个由3行6列构成的实数数组，总共有18个元素。第一个下标从1~3，第二个下标是1~6</span></span><br><span class="line"><span class="keyword">REAL</span>, <span class="keyword">DIMENSION</span>(<span class="number">3</span>,<span class="number">6</span>) :: <span class="built_in">sum</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">!声明一个101行21列的整数数组，总共2121个元素，第一个下标有效值是0~100，第二个是0~20</span></span><br><span class="line"><span class="keyword">INTEGER</span>, <span class="keyword">DIMENSION</span>(<span class="number">0</span>:<span class="number">100</span>, <span class="number">0</span>:<span class="number">20</span>) :: hist</span><br><span class="line"></span><br><span class="line"><span class="comment">!声明一个7行10列的数组，总共70个元素。数组的类型是字符型，每个数组元素包含6个字符。第一个下标从-3到3，第二个1到10</span></span><br><span class="line"><span class="keyword">CHARACTER</span> (len=<span class="number">6</span>), <span class="keyword">DIMENSION</span>(-<span class="number">3</span>:<span class="number">3</span>, <span class="number">10</span>) :: counts</span><br></pre></td></tr></table></figure>
<p>2.Fortran中的数组存储方式是列优先，与CUDA的网络线程分配是类似的，而C/C++则是以行优先。也就是说Fortran中二给数组的内存在分配时是先为第一列分配内存，然后是第二列…<br>3.二维数组初始化方式：赋值语句、类型声明语句或是Fortran的READ语句。<br>4.赋值语句初始化二维数组方式：  </p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INTEGER</span>, <span class="keyword">DIMENSION</span>(<span class="number">4</span>,<span class="number">3</span>) :: istat</span><br><span class="line"><span class="keyword">DO</span> i=<span class="number">1</span>,<span class="number">4</span></span><br><span class="line">  <span class="keyword">DO</span> j=<span class="number">1</span>,<span class="number">3</span></span><br><span class="line">    istat(i,j) = j</span><br><span class="line">  <span class="keyword">END</span> <span class="keyword">DO</span></span><br><span class="line"><span class="keyword">END</span> <span class="keyword">DO</span></span><br><span class="line"><span class="comment">!等价于下面使用数组构造器生成赋值的数组</span></span><br><span class="line">istat = <span class="built_in">RESHAPE</span>((/<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>/), (/<span class="number">4</span>,<span class="number">3</span>/))</span><br></pre></td></tr></table></figure>
<p>内置的RESHAPE函数的使用格式为<code>output = RESHAPE(array1, array2)</code>，它会改变一个数组的结构。其中array1包含了要被改变结构的数据，array2是一个描述新结构的一维数组。array2中元素的个数是输出数组的维数，其元素值是每个维度的宽度，且array1中元素个数必须与array2所描述的元素个数相同。<br>由于数组生成器只能产生一维数组，所以需要使用这种方式。上例中就是将一个一维数据，改变成一个4行3列的二维数组，注意数组存储是列优先。  </p>
<p>5.声明时直接初始化数组时初始值必须按列序优先排列，即首先是第一列的4个元素，然后第二列。eg:  </p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INTEGER</span>, <span class="keyword">DIMENSION</span>(<span class="number">4</span>,<span class="number">3</span>) :: istat(<span class="number">4</span>,<span class="number">3</span>) = <span class="built_in">RESHAPE</span>((/<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>/), (/<span class="number">4</span>,<span class="number">3</span>/))</span><br></pre></td></tr></table></figure>
<p>6.用READ语句初始化二维数组。如果在一条READ语句的参数列表中出现了没有下标的数组名，那么程序将会按照数组元素在计算机内存中的逻辑顺序为数组的所有元素赋值。eg:  </p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="comment">!如果文件INITIAL.DAT中含有数据1 1 1 1 2 2 2 2 3 3 3 3</span></span><br><span class="line"><span class="keyword">INTEGER</span>, <span class="keyword">DIMENSION</span>(<span class="number">4</span>,<span class="number">3</span>) :: istat</span><br><span class="line">OPEN(<span class="number">7</span>, <span class="keyword">FILE</span>=<span class="string">&#x27;INITIAL.DAT&#x27;</span>, <span class="keyword">STATUS</span>=<span class="string">&#x27;OLD&#x27;</span>,<span class="keyword">ACTION</span>=<span class="string">&#x27;READ&#x27;</span>)</span><br><span class="line">READ(<span class="number">7</span>,*) istat</span><br><span class="line"></span><br><span class="line"><span class="comment">!等价于使用嵌套的隐式DO循环实现的例子</span></span><br><span class="line"><span class="comment">!假设INITIAL.DAT中含有数据1 2 3 1 2 3 1 2 3 1 2 3 </span></span><br><span class="line"><span class="keyword">INTEGER</span> :: i,j</span><br><span class="line"><span class="keyword">INTEGER</span>, <span class="keyword">DIMENSION</span>(<span class="number">4</span>,<span class="number">3</span>) :: istat</span><br><span class="line">OPEN(<span class="number">7</span>, <span class="keyword">FILE</span>=<span class="string">&#x27;INITIAL.DAT&#x27;</span>, <span class="keyword">STATUS</span>=<span class="string">&#x27;OLD&#x27;</span>,<span class="keyword">ACTION</span>=<span class="string">&#x27;READ&#x27;</span>)</span><br><span class="line">READ(<span class="number">7</span>,*) ((istat(i,j), j=<span class="number">1</span>,<span class="number">3</span>), i=<span class="number">1</span>,<span class="number">4</span>)</span><br></pre></td></tr></table></figure>
<p>7.二维数组也可以使用下标三元组或下标向量的方式使用部分数组元素。例如a(:,1)表示选用的是数组的第一列，a(1,:)选用数组的第一行，a(1:3, 1:3:5)选用数组的第一到第三行，和第一、三、五列。<br>8.Fortran最多可支持到7维数组。使用方式与二维一样，分配方式是按列优先。<br>9.很多函数都支持对整个数组操作，即将一个数组名传递给函数时，相当于对数组中的每一个元素都执行该函数。<br>10.加掩码的数组赋值：where结构使用方法如下：  </p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">[<span class="keyword">name</span>:] <span class="keyword">WHERE</span> (mask_expr1)</span><br><span class="line">  Array Assignment Statement(s) <span class="comment">!Block 1</span></span><br><span class="line"><span class="keyword">ELSEWHERE</span> (mask_expr2) [<span class="keyword">name</span>]</span><br><span class="line">  Array Assignment Statement(s) <span class="comment">!Block 2</span></span><br><span class="line"><span class="keyword">ELSEWHERE</span></span><br><span class="line">  Array Assignment Statement(s) <span class="comment">!Block 3</span></span><br><span class="line"><span class="keyword">END</span> <span class="keyword">WHERE</span> [<span class="keyword">name</span>]</span><br></pre></td></tr></table></figure>
<p>这里的每个mask_expr是一个逻辑数组，它和数组执行语句中处理的数组具有同样的结构。该结构使得Block1中的操作或操作集用于mask_expr1为TRUE的所有数组元素上。当mask_expr1为FALSE而mask_expr2为TRUE时，Block2的操作将应用于所有数组元素上，同理操作Block3。Fortran90中不允许有ELSEWHERE子句。例如：  </p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="comment">!对数组value中值大于0的元素求对数</span></span><br><span class="line"><span class="keyword">WHERE</span>(<span class="keyword">value</span> &gt; <span class="number">0.</span>)</span><br><span class="line">  logval = <span class="built_in">LOG</span>(<span class="keyword">value</span>)</span><br><span class="line"><span class="keyword">ELSEWHERE</span></span><br><span class="line">  logval = -<span class="number">99999.</span></span><br><span class="line"><span class="keyword">END</span> <span class="keyword">WHERE</span></span><br></pre></td></tr></table></figure>
<p>11.也可以使用单行WHERE语句：  </p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">WHERE</span> (mask_expr) Array Assignment Statement</span><br></pre></td></tr></table></figure>
<p>12.Fortran95/2003中FORALL的用法</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="comment">!求nxm数组work中所有元素的倒数  </span></span><br><span class="line"><span class="keyword">FORALL</span>(i=<span class="number">1</span>:n, j=<span class="number">1</span>:m, work(i,j)/=<span class="number">0.</span>)</span><br><span class="line">  work(i,j) = <span class="number">1.</span>/work(i,j)</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">FORALL</span></span><br></pre></td></tr></table></figure>
<p>FORALL语句中的每个索引都是通过下标三元组的形式的来指定的：<code>subscript_1 : subscript_2 : stride</code>  </p>
<h3 id="动态数组"><a href="#动态数组" class="headerlink" title="动态数组"></a>动态数组</h3><p>1.动态数组需要在定义是使用ALLOCATABLE属性来说明，然后使用ALLOCATE语句来实际分配内存，使用DEALLOCATE语句来释放分配的内存。例如：  </p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="comment">!声明一个100x11的数组，其中第二维下标从0~10</span></span><br><span class="line"><span class="keyword">REAL</span>, <span class="keyword">ALLOCATABLE</span>, <span class="keyword">DIMENSION</span>(:, :) :: arr</span><br><span class="line"><span class="built_in">ALLOCATE</span>(arr(<span class="number">100</span>,<span class="number">0</span>:<span class="number">10</span>), STAT=<span class="keyword">status</span>)</span><br></pre></td></tr></table></figure>
<p>其中STAT=子句是可选的，用于检查返回值状态，如果分配成功，状态为0，如果失败则返回一个基于编译器的正数。<br>2.可以使用内置函数ALLOCATED()在使用前测试数据是否已经成功分配空间，在没有分配空间之前，对其进行的任何操作都是非法的。用法：  </p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">REAL</span>, <span class="keyword">ALLOCATABLE</span>, <span class="keyword">DIMENSION</span>(:)  :: input_data</span><br><span class="line">...</span><br><span class="line"><span class="keyword">IF</span>(<span class="built_in">ALLOCATED</span>(input_data)) <span class="keyword">THEN</span></span><br><span class="line">  READ(<span class="number">8</span>,*) input_data</span><br><span class="line"><span class="keyword">ELSE</span></span><br><span class="line">  <span class="built_in">WRITE</span>(*,*) <span class="string">&#x27;Warning:Array not allocated!&#x27;</span></span><br><span class="line"><span class="keyword">END</span> <span class="keyword">IF</span></span><br></pre></td></tr></table></figure>
<p>3.DEALLOCATE用法：<code>DEALLOCATE(list of arrays to deallocate, STAT=status)</code>，例如：  </p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="built_in">DEALLOCATE</span>(arr1, STAT=<span class="keyword">status</span>) </span><br></pre></td></tr></table></figure>

<h2 id="派生数据类型-结构体"><a href="#派生数据类型-结构体" class="headerlink" title="派生数据类型-结构体"></a>派生数据类型-结构体</h2><p>1.<code>Fortran</code>中的派生数据类型相当于C/C++中的结构体变量，注意只是相当于，因为在其派生数据类型中，只能由基本的内置数据类型或者已定义的用户定义数据类型，但不能包含有函数或子程序，只能用于存放数据。<br>派生数据类型使用关键字<code>TYPE</code>来定义，定义方式为：  </p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="keyword">TYPE</span> [::] type_name</span><br><span class="line">  component definitions</span><br><span class="line">  ...</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">TYPE</span> [type_name]</span><br></pre></td></tr></table></figure>

<p>2.派生数据类型的类型成员通过百分号<code>%</code>来引用，其相当于C/C++中的间接引用运算符<code>-&gt;</code>，例如：  </p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line"><span class="comment">!定义派生数据类型person</span></span><br><span class="line"><span class="keyword">TYPE</span> :: person</span><br><span class="line">  <span class="keyword">CHARACTER</span>(len=<span class="number">14</span>) :: first_name</span><br><span class="line">  <span class="keyword">CHARACTER</span> :: middle_initial</span><br><span class="line">  <span class="keyword">CHARACTER</span>(len=<span class="number">14</span>) :: last_name</span><br><span class="line">  <span class="keyword">INTEGER</span> :: age</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">TYPE</span> person</span><br><span class="line"><span class="comment">!声明类型为person的变量john</span></span><br><span class="line"><span class="keyword">TYPE</span> (person) :: john</span><br><span class="line"><span class="comment">!将john的age元素设置为28</span></span><br><span class="line">John%age = <span class="number">28</span></span><br></pre></td></tr></table></figure>

<h2 id="其他常见问题"><a href="#其他常见问题" class="headerlink" title="其他常见问题"></a>其他常见问题</h2><h3 id="date-and-time函数的使用"><a href="#date-and-time函数的使用" class="headerlink" title="date_and_time函数的使用"></a>date_and_time函数的使用</h3><p>DATE_AND_TIME(DATE, TIME, ZONE, VALUES) gets the corresponding date and time information from the real-time system clock. DATE is INTENT(OUT) and has form ccyymmdd. TIME is INTENT(OUT) and has form hhmmss.sss. ZONE is INTENT(OUT) and has form (+-)hhmm, representing the difference with respect to Coordinated Universal Time (UTC).<br>使用方法是直接使用CALL调用  </p>
<h3 id="Fortran90中的内置子程序"><a href="#Fortran90中的内置子程序" class="headerlink" title="Fortran90中的内置子程序"></a>Fortran90中的内置子程序</h3><p>一共有5个内置子程序：DATE_AND_TIME, MVBITS,<br><code>RANDOM_NUMBER</code>, <code>RANDOM_SEED</code>, and <code>SYSTEM_ CLOCK</code>. These are referenced in the same way as any other subroutine.None of these intrinsic subroutines may be used as actual arguments  </p>
<ul>
<li><code>DATE_AND_TIME</code>： This subroutine returns date and time information in several INTENT (OUT) arguments.  </li>
<li><code>MVBITS</code>： This subroutine copies a sequence of bits from one integer data object to another. It is the only elemental intrinsic subroutine.  </li>
<li><code>RANDOM_NUMBER</code>： This subroutine returns a pseudorandom number or an array of pseudorandom numbers as the value of its argument. It is a subroutine rather than a function because its execution has the side effect of changing the value of the underlying random number generator seed; intrinsic functions have no side effects.产生一个0~1之间的REAL伪随机数，或者返回给一个数组，基本调用方式为<code>CALL RANDOM_NUMBER(pesounum)</code>，pesounu中即为其返回的伪随机数。  </li>
<li><code>RANDOM_SEED</code>： This subroutine allows the value of the random number generator seed value to be initialized or retrieved。就是产生一个伪随机数给RANDOM_NUMBER使用，不带参数时的调用方式为<code>RANDOM_SEED()</code></li>
<li><code>SYSTEM_CLOCK</code>： This subroutine returns data from the processor’s real-time system clock in various formats in several INTENT (OUT) arguments.  </li>
</ul>
<h2 id="Fortran常见函数"><a href="#Fortran常见函数" class="headerlink" title="Fortran常见函数"></a>Fortran常见函数</h2><p>Function  Value returned<br>ABS The absolute value of the argument<br>ACOS The arc cosine of the argument<br>ASIN The arc sine of the argument<br>ATAN The arc tangent of the argument<br>ATAN2 The angle in radians of a complex argument (X,Y)<br>CEILING The smallest integer greater than or equal to the argument value<br>COS The cosine of the argument<br>COSH The hyperbolic cosine of the argument<br>DIM The difference of two values, if positive, or zero otherwise<br>DOT_PRODUCT The dot product of two vectors<br>DPROD The double precision product of two single precision values<br>EXP The natural exponential function<br>FLOOR The greatest integer less than or equal to the argument value<br>LOG The natural logarithm function<br>LOG10 The logarithm to the base 10<br>MATMUL Matrix multiplication<br>MAX The maximum of a set of values<br>MIN The minimum of a set of values<br>MOD The remainder function, having the sign of the first argument<br>MODULO The remainder function, having the sign of the second argument<br>SIGN Apply a given sign to a given value<br>SIN The sine of the argument<br>SINH The hyperbolic sine of the argument<br>SQRT The square root of the argument<br>TAN The tangent of the argument<br>TANH The hyperbolic tangent of the argument<br>Function Value returned<br>ADJUSTL Remove leading blanks (and place them on the right)<br>ADJUSTR Remove trailing blanks (and place them on the left)<br>INDEX Find the location of a given substring in a character string<br>LEN_TRIM Length of a string after trailing blanks have been removed<br>LGE Greater than or equal to comparison based on ASCII<br>LGT Greater than comparison based on ASCII<br>LLE Less than or equal to comparison based on ASCII<br>LLT Less than comparison based on ASCII<br>REPEAT Concatenate several copies of a character string<br>SCAN Scan a string for any one of a given set of characters<br>TRIM The argument with trailing blank characters removed<br>VERIFY Location of a character in a string that is not one of a given set<br>BTEST The bit value of a specified position in an integer argument<br>IAND Logical AND of two integer arguments<br>IBCLR Clear a specified bit to zero in the integer argument<br>IBSET Set a specified bit to one in the integer argument<br>IEOR Logical exclusive-OR of two integer arguments<br>IOR Logical inclusive-OR of two integer arguments<br>ISHFT Logical end-off shift of the bits in the argument<br>ISHFTC Logical circular shift of the bits in the argument<br>NOT Logical complement of an integer argument</p>
<p>All of these functions, in all three groups, are generic except for LGE, LGT, LLE, and LLT, and all are elemental except DOT_PRODUCT, MATMUL, REPEAT, and TRIM. Note that the bit computation function cannot produce portable results.</p>
<h2 id="参考资源"><a href="#参考资源" class="headerlink" title="参考资源"></a>参考资源</h2><p>1.Fortran_95_2003程序设计（第三版），电子版自行查找，注意是那个140多Mb的<br>2.强烈推荐这个，很好很强大，虽然没有书签，但可以通过搜索快速定位：<a href="http://micro.ustc.edu.cn/Fortran/Fortran%2090%20Handbook.pdf">Fortran 90 Handbook.pdf</a>  </p>
]]></content>
      <categories>
        <category>Fortran</category>
      </categories>
      <tags>
        <tag>Notes</tag>
        <tag>Fortran</tag>
      </tags>
  </entry>
  <entry>
    <title>使用winsock2的sockets进行文件发送</title>
    <url>/2015/11/21/winsock/</url>
    <content><![CDATA[<p>了解socket编程过程，根据MSDN上的Windows Sockets 2文档实现通过socket来发送和接受文件。MSDN上的具体说明：<a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms740673%28v=vs.85%29.aspx">https://msdn.microsoft.com/en-us/library/windows/desktop/ms740673%28v=vs.85%29.aspx</a>   </p>
<p>对于C++实现的服务端和客户端过程大致如下：<br>服务端：  </p>
<ul>
<li>初始化Winsock  </li>
<li>创建一个socket作为侦听服务  </li>
<li>绑定socket到系统  </li>
<li>侦听端口等待客户端连接  </li>
<li>接受客户端连接  </li>
<li>接收和发送数据  </li>
<li>断开连接  </li>
</ul>
<p>客户端：  </p>
<ul>
<li>初始化Winsock  </li>
<li>创建用于连接到服务端的socket对象  </li>
<li>连接到服务端  </li>
<li>发送数据后关闭socket连接，释放资源  </li>
<li>将该socket用于接收数据  </li>
<li>断开连接  </li>
</ul>
<span id="more"></span>
<p>具体代码如下：  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/***************服务端*********************/</span></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> UNICODE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WIN32_LEAN_AND_MEAN</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;WinSock2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;WS2tcpip.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//需要连接的库</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment (lib, <span class="string">&quot;Ws2_32.lib&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义默认接受数据缓冲区大小及侦听的端口</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEFAULT_BUFFLEN 1024</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEFAULT_PORT <span class="string">&quot;27015&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//创建WSADATA对象，WSADATA中包含windows sockets 的实现信息</span></span><br><span class="line">	WSADATA wsaData;</span><br><span class="line">	<span class="comment">//接收相应函数的返回值</span></span><br><span class="line">	<span class="type">int</span> iResult;</span><br><span class="line">	<span class="comment">//声明侦听socket和连接服务端的socket</span></span><br><span class="line">	SOCKET ListenSocket = INVALID_SOCKET;</span><br><span class="line">	SOCKET ClientSocket = INVALID_SOCKET;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//声明存放ip地址信息的结构体</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">addrinfo</span> *result = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">addrinfo</span> hints;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//存放接收到的内容</span></span><br><span class="line">	<span class="type">char</span> recvFileName[DEFAULT_BUFFLEN];</span><br><span class="line">	<span class="type">char</span> recvFile[DEFAULT_BUFFLEN];</span><br><span class="line">	std::string fileName;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//初始化WINSOCK</span></span><br><span class="line">	iResult = <span class="built_in">WSAStartup</span>(<span class="built_in">MAKEWORD</span>(<span class="number">2</span>, <span class="number">2</span>), &amp;wsaData);</span><br><span class="line">	<span class="keyword">if</span> (iResult != <span class="number">0</span>) &#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;WSAStartup failed with error:&quot;</span> &lt;&lt;  iResult &lt;&lt; std::endl;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//分配IP地址存放的结构体空间</span></span><br><span class="line">	<span class="built_in">ZeroMemory</span>(&amp;hints, <span class="built_in">sizeof</span>(hints));</span><br><span class="line">	hints.ai_family = AF_INET; <span class="comment">//指定使用IPV4网址地址</span></span><br><span class="line">	hints.ai_socktype = SOCK_STREAM;  <span class="comment">//指定socket流</span></span><br><span class="line">	hints.ai_protocol = IPPROTO_TCP;  <span class="comment">//指定使用TCP协议</span></span><br><span class="line">	hints.ai_flags = AI_PASSIVE;  <span class="comment">//指定一个标志位</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//获取本地IP地址信息</span></span><br><span class="line">	iResult = <span class="built_in">getaddrinfo</span>(<span class="literal">NULL</span>, DEFAULT_PORT, &amp;hints, &amp;result);</span><br><span class="line">	<span class="keyword">if</span> (iResult != <span class="number">0</span>) &#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;WSAStartup failed with error:&quot;</span> &lt;&lt;  iResult &lt;&lt; std::endl;</span><br><span class="line">		<span class="built_in">WSACleanup</span>();</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//创建一个socket用于侦听服务器</span></span><br><span class="line">	ListenSocket = <span class="built_in">socket</span>(result-&gt;ai_family, result-&gt;ai_socktype, result-&gt;ai_protocol);</span><br><span class="line">	<span class="keyword">if</span> (ListenSocket == INVALID_SOCKET) &#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;socket failed with error:&quot;</span> &lt;&lt;  <span class="built_in">WSAGetLastError</span>() &lt;&lt; std::endl;</span><br><span class="line">		<span class="built_in">freeaddrinfo</span>(result);</span><br><span class="line">		<span class="built_in">WSACleanup</span>();</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//将侦听socket绑定到系统以用于侦听服务器</span></span><br><span class="line">	iResult = <span class="built_in">bind</span>(ListenSocket, result-&gt;ai_addr, (<span class="type">int</span>)result-&gt;ai_addrlen);</span><br><span class="line">	<span class="keyword">if</span> (iResult == SOCKET_ERROR)  &#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;bind failed with error:&quot;</span> &lt;&lt;  <span class="built_in">WSAGetLastError</span>() &lt;&lt; std::endl;</span><br><span class="line">		<span class="built_in">freeaddrinfo</span>(result);</span><br><span class="line">		<span class="built_in">closesocket</span>(ListenSocket);</span><br><span class="line">		<span class="built_in">WSACleanup</span>();</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">freeaddrinfo</span>(result);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//侦听端口</span></span><br><span class="line">	iResult = <span class="built_in">listen</span>(ListenSocket, SOMAXCONN);</span><br><span class="line">	<span class="keyword">if</span> (iResult == SOCKET_ERROR) &#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;listen failed with error:&quot;</span> &lt;&lt; <span class="built_in">WSAGetLastError</span>() &lt;&lt; std::endl;</span><br><span class="line">		<span class="built_in">closesocket</span>(ListenSocket);</span><br><span class="line">		<span class="built_in">WSACleanup</span>();</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; std::endl;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;等待客户端连接...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">		<span class="comment">//接收客户端的连接，即让客户端socket与侦听socket建立连接</span></span><br><span class="line">		ClientSocket = <span class="built_in">accept</span>(ListenSocket, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">		<span class="keyword">if</span> (ClientSocket == INVALID_SOCKET) &#123;</span><br><span class="line">			std::cout &lt;&lt; <span class="string">&quot;accept failed with error:&quot;</span> &lt;&lt; <span class="built_in">WSAGetLastError</span>() &lt;&lt; std::endl;</span><br><span class="line">			<span class="built_in">closesocket</span>(ListenSocket);</span><br><span class="line">			<span class="built_in">WSACleanup</span>();</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//接收文件名</span></span><br><span class="line">		std::ofstream out;</span><br><span class="line">		iResult = <span class="built_in">recv</span>(ClientSocket, recvFileName, DEFAULT_BUFFLEN, <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">if</span> (iResult &gt; <span class="number">0</span>) &#123;</span><br><span class="line">			recvFileName[iResult] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">			fileName = recvFileName;</span><br><span class="line">			std::cout &lt;&lt; <span class="string">&quot;接收文件名为： &quot;</span> &lt;&lt; fileName &lt;&lt; std::endl;</span><br><span class="line">			out.<span class="built_in">open</span>(fileName, std::ofstream::out);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			std::cout &lt;&lt; <span class="string">&quot;Receive file name error!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">		<span class="comment">//接收文件内容直到连接关闭</span></span><br><span class="line">		<span class="keyword">do</span> &#123;</span><br><span class="line">			iResult = <span class="built_in">recv</span>(ClientSocket, recvFile, DEFAULT_BUFFLEN, <span class="number">0</span>);</span><br><span class="line">			<span class="keyword">if</span> (iResult == DEFAULT_BUFFLEN) &#123;</span><br><span class="line">				<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; DEFAULT_BUFFLEN; ++i) &#123;</span><br><span class="line">					out.<span class="built_in">put</span>(recvFile[i]);</span><br><span class="line">					count++;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (iResult &gt; <span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; iResult; ++i) &#123;</span><br><span class="line">					out.<span class="built_in">put</span>(recvFile[i]);</span><br><span class="line">					count++;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (iResult == <span class="number">0</span>)</span><br><span class="line">				std::cout &lt;&lt; <span class="string">&quot;接收文件完成&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				std::cout &lt;&lt; <span class="string">&quot;recv failed with error:&quot;</span> &lt;&lt; <span class="built_in">WSAGetLastError</span>() &lt;&lt; std::endl;</span><br><span class="line">				<span class="built_in">closesocket</span>(ClientSocket);</span><br><span class="line">				<span class="built_in">WSACleanup</span>();</span><br><span class="line">				<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">while</span> (iResult &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">		out.<span class="built_in">close</span>();</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;接收文件大小: &quot;</span> &lt;&lt; count &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//接收完成后关闭连接</span></span><br><span class="line">		iResult = <span class="built_in">shutdown</span>(ClientSocket, SD_SEND);</span><br><span class="line">		<span class="keyword">if</span> (iResult == SOCKET_ERROR) &#123;</span><br><span class="line">			std::cout &lt;&lt; <span class="string">&quot;shutdown failed with error:&quot;</span> &lt;&lt; <span class="built_in">WSAGetLastError</span>() &lt;&lt; std::endl;</span><br><span class="line">			<span class="built_in">closesocket</span>(ClientSocket);</span><br><span class="line">			<span class="built_in">WSACleanup</span>();</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">		<span class="comment">//清空连接并释放资源</span></span><br><span class="line">		<span class="built_in">closesocket</span>(ClientSocket);</span><br><span class="line">		<span class="built_in">WSACleanup</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/***************客户端*********************/</span></span><br><span class="line"><span class="comment">//接受两个输入参数，分别表示远程IP和传输文件名，不输入任何参数时，默认使用”127.0.0.1”和”a.txt”</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> WIN32_LEAN_AND_MEAN</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WIN32_LEAN_AND_MEAN</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;winsock2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ws2tcpip.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iphlpapi.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//需要连接的库</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;Ws2_32.lib&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;Mswsock.lib&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;AdvApi32.lib&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//远程端口</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEFAULT_PORT  <span class="string">&quot;27015&quot;</span></span></span><br><span class="line"><span class="comment">//默认缓冲区大小</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEFAULT_BUFLEN 1024</span></span><br><span class="line"><span class="function"><span class="type">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//创建WSADATA对象，WSADATA中包含windows sockets 的实现信息</span></span><br><span class="line">	WSADATA wsaData;</span><br><span class="line">	<span class="comment">// 声明连接到服务端的socket对象</span></span><br><span class="line">	SOCKET ConnectSocket = INVALID_SOCKET;</span><br><span class="line">	<span class="comment">//声明addrinfo对象，其中包括sockaddr结构体值</span></span><br><span class="line">	<span class="comment">//result和ptr将指向相应的主机地址信息,hints存放socket属性信息</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">addrinfo</span> *result = <span class="literal">NULL</span>, *ptr = <span class="literal">NULL</span>, hints;</span><br><span class="line">	<span class="comment">//向服务器发送的数据内容</span></span><br><span class="line">	<span class="type">char</span> sendBuff[DEFAULT_BUFLEN];</span><br><span class="line">	std::string fileName = <span class="string">&quot;a.txt&quot;</span>;</span><br><span class="line">	<span class="comment">//设置接收数据的缓冲区大小</span></span><br><span class="line">	<span class="type">int</span> recvbuflen = DEFAULT_BUFLEN;</span><br><span class="line">	<span class="type">char</span> recvbuf[DEFAULT_BUFLEN];</span><br><span class="line">	<span class="type">int</span> iResult;</span><br><span class="line">	std::string ip;</span><br><span class="line">	<span class="comment">//确定参数是否有效</span></span><br><span class="line">	<span class="keyword">if</span> (argc == <span class="number">2</span>) &#123;</span><br><span class="line">		ip = argv[<span class="number">1</span>];</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;远程服务器IP:  &quot;</span> &lt;&lt; ip &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (argc == <span class="number">3</span>) &#123;</span><br><span class="line">		ip = argv[<span class="number">1</span>];</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;远程服务器IP:  &quot;</span> &lt;&lt; ip &lt;&lt; std::endl;</span><br><span class="line">		fileName = argv[<span class="number">2</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		ip = <span class="string">&quot;127.0.0.1&quot;</span>;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;远程服务器IP:  &quot;</span> &lt;&lt; ip &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 初始化winsock </span></span><br><span class="line">	iResult = <span class="built_in">WSAStartup</span>(<span class="built_in">MAKEWORD</span>(<span class="number">2</span>, <span class="number">2</span>), &amp;wsaData);</span><br><span class="line">	<span class="keyword">if</span> (iResult != <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;WSAStartup failed: &quot;</span> &lt;&lt; iResult &lt;&lt; std::endl;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//为hints分配空间</span></span><br><span class="line">	<span class="built_in">ZeroMemory</span>(&amp;hints, <span class="built_in">sizeof</span>(hints));</span><br><span class="line">	hints.ai_family = AF_UNSPEC;</span><br><span class="line">	hints.ai_socktype = SOCK_STREAM;</span><br><span class="line">	hints.ai_protocol = IPPROTO_TCP;</span><br><span class="line">	<span class="comment">//指定服务器地址和端口,argv[1]为IPV4或者IPV6地址</span></span><br><span class="line">	iResult = <span class="built_in">getaddrinfo</span>(ip.<span class="built_in">c_str</span>(), DEFAULT_PORT, &amp;hints, &amp;result);</span><br><span class="line">	<span class="keyword">if</span> (iResult != <span class="number">0</span>) &#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;getaddrinfo failed: &quot;</span> &lt;&lt; iResult &lt;&lt; std::endl;</span><br><span class="line">		<span class="built_in">WSACleanup</span>();</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//尝试连接到服务器直到连接成功</span></span><br><span class="line">	<span class="keyword">for</span> (ptr = result; ptr != <span class="literal">NULL</span>; ptr = ptr-&gt;ai_next) &#123;</span><br><span class="line">		<span class="comment">//初始化连接到服务器的socket对象</span></span><br><span class="line">		ConnectSocket = <span class="built_in">socket</span>(ptr-&gt;ai_family, ptr-&gt;ai_socktype, ptr-&gt;ai_protocol);</span><br><span class="line">		<span class="comment">//创建失败则释放资源</span></span><br><span class="line">		<span class="keyword">if</span> (ConnectSocket == INVALID_SOCKET) &#123;</span><br><span class="line">			std::cout &lt;&lt; <span class="string">&quot;Error at socket(): &quot;</span> &lt;&lt; <span class="built_in">WSAGetLastError</span>() &lt;&lt; std::endl;</span><br><span class="line">			<span class="built_in">freeaddrinfo</span>(result);</span><br><span class="line">			<span class="built_in">WSACleanup</span>();</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//连接到服务器</span></span><br><span class="line">		iResult = <span class="built_in">connect</span>(ConnectSocket, ptr-&gt;ai_addr, (<span class="type">int</span>)ptr-&gt;ai_addrlen);</span><br><span class="line">		<span class="keyword">if</span> (iResult == SOCKET_ERROR) &#123;</span><br><span class="line">			<span class="built_in">closesocket</span>(ConnectSocket);</span><br><span class="line">			ConnectSocket = INVALID_SOCKET;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//连接完成后释放地址信息占用的内存</span></span><br><span class="line">	<span class="built_in">freeaddrinfo</span>(result);</span><br><span class="line">	<span class="comment">//如果连接失败则返回</span></span><br><span class="line">	<span class="keyword">if</span> (ConnectSocket == INVALID_SOCKET) &#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;Unable to connect to server!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">		<span class="built_in">WSACleanup</span>();</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//发送文件名</span></span><br><span class="line">	iResult = <span class="built_in">send</span>(ConnectSocket, fileName.<span class="built_in">c_str</span>(), (<span class="type">int</span>)fileName.<span class="built_in">length</span>(), <span class="number">0</span>);</span><br><span class="line">	<span class="comment">//发送失败则关闭连接</span></span><br><span class="line">	<span class="keyword">if</span> (iResult == SOCKET_ERROR) &#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;send failed: &quot;</span> &lt;&lt; <span class="built_in">WSAGetLastError</span>() &lt;&lt; std::endl;</span><br><span class="line">		<span class="built_in">closesocket</span>(ConnectSocket);</span><br><span class="line">		<span class="built_in">WSACleanup</span>();</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;文件名所占字节数: &quot;</span> &lt;&lt; iResult &lt;&lt; std::endl;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;发送文件名: &quot;</span> &lt;&lt; fileName &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//发送文件内容</span></span><br><span class="line">	<span class="function">std::ifstream <span class="title">in</span><span class="params">(fileName, std::ifstream::in)</span></span>;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (in.<span class="built_in">get</span>(sendBuff[i % DEFAULT_BUFLEN])) &#123;</span><br><span class="line">		i++;</span><br><span class="line">		<span class="keyword">if</span> (i % DEFAULT_BUFLEN == <span class="number">0</span>) &#123;</span><br><span class="line">			iResult = <span class="built_in">send</span>(ConnectSocket, sendBuff, <span class="built_in">sizeof</span>(sendBuff), <span class="number">0</span>);</span><br><span class="line">			<span class="comment">//发送失败则关闭连接</span></span><br><span class="line">			<span class="keyword">if</span> (iResult == SOCKET_ERROR) &#123;</span><br><span class="line">				std::cout &lt;&lt; <span class="string">&quot;send failed: &quot;</span> &lt;&lt; <span class="built_in">WSAGetLastError</span>() &lt;&lt; std::endl;</span><br><span class="line">				<span class="built_in">closesocket</span>(ConnectSocket);</span><br><span class="line">				<span class="built_in">WSACleanup</span>();</span><br><span class="line">				<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	iResult = <span class="built_in">send</span>(ConnectSocket, sendBuff, i % DEFAULT_BUFLEN, <span class="number">0</span>);</span><br><span class="line">	<span class="comment">//发送失败则关闭连接</span></span><br><span class="line">	<span class="keyword">if</span> (iResult == SOCKET_ERROR) &#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;send failed: &quot;</span> &lt;&lt; <span class="built_in">WSAGetLastError</span>() &lt;&lt; std::endl;</span><br><span class="line">		<span class="built_in">closesocket</span>(ConnectSocket);</span><br><span class="line">		<span class="built_in">WSACleanup</span>();</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;发送文件大小: &quot;</span> &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">	in.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//当没有数据需要发送时，首先关闭当前用于发送数据的socket,以便服务端释放资源，并将该socket用于接收数据</span></span><br><span class="line">	iResult = <span class="built_in">shutdown</span>(ConnectSocket, SD_SEND);</span><br><span class="line">	<span class="keyword">if</span> (iResult == SOCKET_ERROR) &#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;shutdown failed: &quot;</span> &lt;&lt; <span class="built_in">WSAGetLastError</span>() &lt;&lt; std::endl;</span><br><span class="line">		<span class="built_in">closesocket</span>(ConnectSocket);</span><br><span class="line">		<span class="built_in">WSACleanup</span>();</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//从服务端接收数据直到服务器关闭连接</span></span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		iResult = <span class="built_in">recv</span>(ConnectSocket, recvbuf, recvbuflen, <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">if</span> (iResult &gt; <span class="number">0</span>) &#123;</span><br><span class="line">			std::cout &lt;&lt; <span class="string">&quot;Bytes received: &quot;</span> &lt;&lt; iResult &lt;&lt; std::endl;</span><br><span class="line">			recvbuf[iResult] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">			std::cout &lt;&lt; <span class="string">&quot;Bytes received: &quot;</span> &lt;&lt; recvbuf &lt;&lt; std::endl;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (iResult == <span class="number">0</span>)</span><br><span class="line">			std::cout &lt;&lt; <span class="string">&quot;断开连接...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			std::cout &lt;&lt; <span class="string">&quot;recv failed: &quot;</span> &lt;&lt; <span class="built_in">WSAGetLastError</span>() &lt;&lt; std::endl;</span><br><span class="line">	&#125; <span class="keyword">while</span> (iResult &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//当接收完数据之后关闭socket并释放连接资源</span></span><br><span class="line">	<span class="built_in">closesocket</span>(ConnectSocket);</span><br><span class="line">	<span class="built_in">WSACleanup</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Network</category>
      </categories>
      <tags>
        <tag>winsock2</tag>
      </tags>
  </entry>
  <entry>
    <title>图像处理相关总结及.NET的BitmapData类</title>
    <url>/2015/11/10/image-BitmapData/</url>
    <content><![CDATA[<h2 id="关于位图图像的深度"><a href="#关于位图图像的深度" class="headerlink" title="关于位图图像的深度"></a>关于位图图像的深度</h2><p>这里只涉及位图图像<br>　　首先图像总像素个数=宽 * 高，每个像素的颜色深浅信息是通过图像的位深度来决定的。所以位深度也直接影响着一个图像占用的总字节数，常见的图像多数都是位图。<br>　　位深度的解释：在记录数字图像的颜色时，计算机实际上是用每个像素需要的位深度来表示的。黑白二色的图像是数字图像中最简单的一种，它只有黑、白两种颜色，也就是说它的 每个像素只有1位颜色，位深度是1，用2的一次幂来表示；考虑到位深度平均分给R, G, B和Alpha，而只有RGB可以相互组合成颜色。所以4位颜色的图，它的位深度是4，只有2的4次幂种颜色，即16种颜色或16种灰度等级 ) 。8位颜色的图，位深度就是8，用2的8次幂表示，它含有256种颜色 ( 或256种灰度等级 )。24位颜色可称之为真彩色，位深度是24，它能组合成2的24次幂种颜色，即：16777216种颜色 ( 或称千万种颜色 )，超过了人眼能够分辨的颜色数量。当我们用24位来记录颜色时，实际上是以2^（8×3），即红、绿、蓝 ( RGB ) 三基色各以2的8次幂，256种颜色而存在的，三色组合就形成一千六百万种颜色。  </p>
<span id="more"></span>

<p>注意1个字节8位<br>所以常见图像中的位深与像素的关系可以理解为：<br>24位深：一个像素占24/8=3个字节，通常的彩色图片是24位深<br>8位深：一个像素占8/8=1个字节，灰度图<br>1位深：一个像素占1/8个字节，二值图  </p>
<h2 id="关于图像宽度和图像扫描宽度"><a href="#关于图像宽度和图像扫描宽度" class="headerlink" title="关于图像宽度和图像扫描宽度"></a>关于图像宽度和图像扫描宽度</h2><p>　　此处以.NET Framework下的BitmapData类来解释，关于BitmapData类的详细信息看官网<a href="https://msdn.microsoft.com/zh-cn/library/system.drawing.imaging.bitmapdata%28v=vs.110%29.aspx">https://msdn.microsoft.com/zh-cn/library/system.drawing.imaging.bitmapdata%28v=vs.110%29.aspx</a><br>　　在BitmapData类中图像宽度即为Bitmap.Width，图像扫描宽度是BitmapData.Stride。<br>　　首先需要知道使用BitmapData类对图像进行操作时的扫描行宽度并不是图像宽度，而是等于离图像宽度最近的4的整数倍，也就是这个数字必须是4的倍数，所以在计算实际处理的字节数时也必须使用扫描宽度，即Stride。当然如果图像宽度刚好是4的倍数，那么此时BitmapData.Stride = Bitmap.Width。具体为什么要这样处理，有人说是考虑性能问题。<br>假设有一张宽度为6的位图，其格式为Format24bppRgb，即24位深，从上面可以知道，它一个像素占3个字节。那么每一行需要6*3=18字节存储，由于在BitmapData中Stride必须是离宽度最近的4的整数倍且，所以Stride应该为20，在内存中可以理解为：  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-----｜－－－－－－－ Ｓｔｒｉｄｅ －－－－－－－｜</span><br><span class="line">-----｜－－－－－－－ Ｗｉｄｔｈ－－－－－－｜ </span><br><span class="line">Scan0：</span><br><span class="line">-----ＢＧＲ ＢＧＲ ＢＧＲ ＢＧＲ ＢＧＲ ＢＧＲ ＸＸ</span><br><span class="line">-----ＢＧＲ ＢＧＲ ＢＧＲ ＢＧＲ ＢＧＲ ＢＧＲ ＸＸ</span><br><span class="line">-----ＢＧＲ ＢＧＲ ＢＧＲ ＢＧＲ ＢＧＲ ＢＧＲ ＸＸ</span><br></pre></td></tr></table></figure>

<p>常用到的计算：<br>在使用BitmapData类对图像扫描时，整个图像的存储所占的字节数即为扫描宽度乘以图像高度，即BitmapData.Stride x Bitmap.height，它们都是int类型。<br>扫描间隙即一行中未使用的字节 = 扫描宽度 - 图像宽度 * (位深 / 8) = (4 - (图像宽度 * (位深 / 8) % 4)<br>扫描宽度=图像宽度 * 一个像素所占的字节数 + (4 - (图像宽度*(位深/8)%4)</p>
]]></content>
      <categories>
        <category>Image</category>
      </categories>
      <tags>
        <tag>image</tag>
        <tag>Bitmap</tag>
      </tags>
  </entry>
  <entry>
    <title>Awesome</title>
    <url>/2015/10/10/Awesome/</url>
    <content><![CDATA[<p>收藏的一些Awesome站点链接  </p>
<span id="more"></span>

<ol>
<li><p>各种Awesome汇聚的网站：<br><img data-src="awesome-zeef.jpg" alt=""><br><a href="https://awesome-awesomeness.zeef.com/alexander.bayandin">https://awesome-awesomeness.zeef.com/alexander.bayandin</a>  </p>
</li>
<li><p>对应1中的github列表： <a href="https://github.com/bayandin/awesome-awesomeness">https://github.com/bayandin/awesome-awesomeness</a>  </p>
</li>
<li><p>VimAwesome:<br><img data-src="awesome-vim.jpg" alt=""><br><a href="http://vimawesome.com/">http://vimawesome.com/</a>  </p>
</li>
<li><p>Collecting All Cheat Sheets:<br><img data-src="portal.jpg" alt=""><br><a href="http://overapi.com/">http://overapi.com/</a>  </p>
</li>
<li><p>github上人气最高，各类最全的Awesome集合：<br><img data-src="awesome-github.svg" alt=""><br><a href="https://github.com/sindresorhus/awesome">https://github.com/sindresorhus/awesome</a>  </p>
</li>
<li><p>各种让你爽歪歪的icon——Font Awesome：<br><img data-src="fontawesome.jpg" alt=""><br><a href="http://fortawesome.github.io/Font-Awesome/">http://fortawesome.github.io/Font-Awesome/</a></p>
</li>
</ol>
]]></content>
      <categories>
        <category>Summary</category>
      </categories>
      <tags>
        <tag>Awesome</tag>
      </tags>
  </entry>
  <entry>
    <title>C++中使用正则表达式</title>
    <url>/2015/10/10/Regex-in-cpp/</url>
    <content><![CDATA[<p>这里有一个博客链接，介绍的比较详细<a href="http://www.johndcook.com/blog/cpp_regex/">http://www.johndcook.com/blog/cpp_regex/</a><br>C++11中对正则表达式语法兼容以下6个：</p>
<ul>
<li>ECMA-262 (ECMAScript) regular expressions (slightly modified?)</li>
<li>Basic POSIX regular expressions</li>
<li>Extended POSIX regular expressions</li>
<li>awk regular expressions</li>
<li>grep regular expressions</li>
<li>egrep regular expressions</li>
</ul>
<p>首先，编译器需要开启对C++11的支持，例如如果使用的是GNU的g++添加编译参数<code>-std=c++11</code>即可。  </p>
<span id="more"></span>
<p>C++内建的对正则表达式的支持是通过头文件regex。所以头文件中需要添加regex。下面举例：  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;regex&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::string str = <span class="string">&quot;Hello world&quot;</span>;</span><br><span class="line">    <span class="function">std::regex <span class="title">pattern</span><span class="params">(<span class="string">&quot;\\w+(?=ld)&quot;</span>)</span></span>;  <span class="comment">//声明正则表达式匹配规则  </span></span><br><span class="line">    <span class="comment">//此处regex_match返回false，因为regex_search只有整个字符串全部匹配时才返回true。</span></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">regex_match</span>(str, pattern) &lt;&lt; std::endl;  </span><br><span class="line">    <span class="comment">//此处返回true</span></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">regex_match</span>(str, std::<span class="built_in">regex</span>(<span class="string">&quot;.*ld&quot;</span>)) &lt;&lt; std::endl;  </span><br><span class="line">    <span class="comment">//regex_search返回true，因为它只要能够成功匹配就会返回true</span></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">regex_search</span>(str, pattern) &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>更多关于regex的参考可以查看这里：<a href="http://www.cplusplus.com/reference/regex/">http://www.cplusplus.com/reference/regex/</a>   </p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>CPP</tag>
        <tag>Regex</tag>
      </tags>
  </entry>
  <entry>
    <title>正则表达式练习题</title>
    <url>/2015/10/06/Regex-practice/</url>
    <content><![CDATA[<p>正则表达式的练习题，多数来源于网络收集，由于网络上很多人给出的答案在我的测试用例中会有各种错误匹配，所以本文答案全部为我自己给出的答案，尽量保持题目难度由易到难。由于初学者，水平有所欠缺，难免有错误之处，所以如果你有更好的答案，如能给出，非常感谢！也非常欢迎指出错误！<br>测试文本可以通过在网上搜索邮箱，或者电话大全然后获取其网页源码作为测试文本，然后缺什么再加什么。<br>或者直接使用我练习时使用的一个文本<a href="Test.txt">Test.txt</a><br>国外某网站提供的两个测试文件可供使用：<br>英文单词列表：<a href="http://qntm.org/files/re/words.zip">http://qntm.org/files/re/words.zip</a><br>英语电子书<code>The Time Machine by H. G. Wells</code>: <a href="http://www.gutenberg.org/cache/epub/35/pg35.txt">http://www.gutenberg.org/cache/epub/35/pg35.txt</a><br>如果该网站无法访问，可以从网站搜索任意英文电子书的一部分作为测试用例。  </p>
<span id="more"></span>

<h2 id="数字相关"><a href="#数字相关" class="headerlink" title="数字相关"></a>数字相关</h2><p>以下浮点数与存储无关，仅指带小数点的数  </p>
<ol>
<li><p>匹配非负整数: <code>((?!&lt;-)[1-9]\d+)|((?&lt;=\D)0(?=\D))</code> 不能包含000和-1.2的情况       </p>
</li>
<li><p>匹配正整数： <code>(?!&lt;-|0)\d+</code> 不包含0开头的数字    </p>
</li>
<li><p>区配非正整数：<code>(-\d+)|((?&lt;=\D)0(?=\D))</code> 需要包含单独0的情况    </p>
</li>
<li><p>匹配负整数： <code>-[1-9]\d*</code> 不包括-012  </p>
</li>
<li><p>匹配整数： <code>-?\d+</code>  当然它会将1.2匹配为1和2  </p>
</li>
<li><p>非负浮点数： <code>(?&lt;!-)(((?&lt;!\d)[1-9]\d*)|(?&lt;!\d)0)\.\d+</code> 不能包含-1.2, 02.2, 2., .2的情况,但有0.00  </p>
</li>
<li><p>正浮点数： <code>(?&lt;!-)(((?&lt;!\d)[1-9]\d*\.\d+)|((?&lt;!0)0\.\d*[1-9]\d*))</code> 不能包含0.00,带有额外前导0及上述情况，但有0.00200  </p>
</li>
<li><p>非正浮点数：<code>((?&lt;!0)0\.0+(?!\d))|-([1-9]\d*|0)\.\d+</code> 包含-0.0，但不能包括-00.0     </p>
</li>
<li><p>负浮点数： <code>-(([1-9]\d*\.\d+)|(0\.\d*[1-9]\d*))</code> 应该包括2.00的情况，但不包含0.00  </p>
</li>
<li><p>浮点数： <code>-?(((?&lt;!\d)[1-9]\d*)|(?&lt;!\d)0)\.\d+</code>  </p>
</li>
<li><p>由数字、字母组成的字符串A：<code>^[\w]+$</code></p>
</li>
</ol>
<h2 id="字符串相关"><a href="#字符串相关" class="headerlink" title="字符串相关"></a>字符串相关</h2><p>提示：<code>\w</code>包含有汉字字符，当然也包括繁体等其他语系，汉字字符区间是[\u4e00-\u9fa5]   </p>
<ol>
<li><p>身份证号码验证：<code>\d&#123;17&#125;[\dX]|\d&#123;15&#125;</code>   </p>
</li>
<li><p>长度为8-10位的用户密码，以字母开头，包含字母、数字、下划线的组合：<code>[a-zA-Z]([a-zA-Z]|\d|_)&#123;7,9&#125;</code>  </p>
</li>
<li><p>验证输入的只能是汉字：<code>\b[\u4e00-\u9fa5]+\b</code>  </p>
</li>
<li><p>验证电子邮箱，由字母a～z(不区分大小写)、数字0～9、点、减号或下划线组成；只能以数字或字母开头和结尾，例如：beijing.2008；用户名长度为4～18个字符。域名由各国文字的特定字符集、英文字母、数字及“-”(即连字符或减号)任意组合而成, 但开头及结尾均不能含有“-”。 域名中字母不分大小写。域名最长可达67个字节。此处以英文域名举例，当然邮箱还没有支持中文用户名的。  </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(\d|[a-zA-Z])+((\d|[a-zA-Z])|\.|\-|_)*(\d|[a-zA-Z])+@(\d|[a-zA-Z])+(\d|[a-zA-Z]|\-)*(\d|[a-zA-Z])+\.[a-zA-Z]+</span><br><span class="line">```  </span><br><span class="line">当然现在已经支持中文顶级域名了  </span><br><span class="line">```shell   </span><br><span class="line">(\d|[a-zA-Z])+((\d|[a-zA-Z])|\.|\-|_)*(\d|[a-zA-Z])+@[\w]+[\w-]*[\w]+\.[\w]+</span><br></pre></td></tr></table></figure>
<p>这个匹配串效率较低，但准确度还算高，希望有更多更好的提出  </p>
</li>
<li><p>匹配URL地址：<code>http://[\w-]+\.[\w-]+.[\w]+[/\w.#&amp;%?=-]*</code>  </p>
</li>
<li><p>匹配大陆11位的手机号码，忽略1后面跟的特定数字，或者4位区号+7/8位本地号的固话，不含短号，号码可以由<code>-</code>或者<code>()</code>连接  </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">((?&lt;!\d)1\d&#123;10&#125;(?!\d))|((?&lt;!\d)\d&#123;4&#125;-?\d&#123;7,8&#125;(?!\d))|((?&lt;!\d)\(\d&#123;4&#125;\)\d&#123;7,8&#125;(?!\d))</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>7.匹配所有的空行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">^[\s]*\n</span><br></pre></td></tr></table></figure>


<p>如果能把以上这几个题都写完整并且能够通过我提供的文本校验，应该算是已经会用基础了，日常使用应该够用了。<br>如果还想练习更多问题，可以到一些社区搜索相应标签，比如：stackoverflow, quora, csdn等  </p>
<h2 id="平衡组-递归匹配"><a href="#平衡组-递归匹配" class="headerlink" title="平衡组/递归匹配"></a>平衡组/递归匹配</h2><p>暂时还不会使用，留空以后需要时再学习了来补充  </p>
]]></content>
      <categories>
        <category>Regular-Expressions</category>
      </categories>
      <tags>
        <tag>Regex</tag>
      </tags>
  </entry>
  <entry>
    <title>正则表达式学习笔记</title>
    <url>/2015/10/04/Regular-Expression-Study-Note/</url>
    <content><![CDATA[<h2 id="关于"><a href="#关于" class="headerlink" title="关于"></a>关于</h2><p>正则表达式即一种功能强大的针对字符串的匹配规则。它在匹配时将匹配字符与匹配数量分开表示。比如一些元字符的匹配一次全部都只匹配一个，而通过专门的方式来表示匹配数量或者重复匹配。<code>\\</code>同样还是表示转义字符。本文没有特殊说明的情况下默认举例的单词是针对英文，不包含汉字。<br>本文如无特殊说明，使用的正则表达式语法指的是兼容Perl的正则语法，因为Perl语言的正则表达式是支持最广泛的，包括PHP、Python、Java的大量正则包，还有微软的.NET Framework、Tcl以及C/C++的类库。</p>
<span id="more"></span>
<p>参考资源：      </p>
<ol>
<li>(正则表达式30分钟入门教程)[<a href="http://deerchao.net/tutorials/regex/regex.htm]">http://deerchao.net/tutorials/regex/regex.htm]</a>      </li>
<li>《精通正则表达式》  </li>
<li>一个介绍正则表达式资料的网站：<a href="http://www.regular-expressions.info/">http://www.regular-expressions.info/</a>    </li>
<li>正则表达式工具Regexbuddy附带的帮助： <a href="http://www.regexbuddy.com">http://www.regexbuddy.com</a>  </li>
<li>微软MSDN上.NET的正则表达式语言-快速参考：<a href="https://msdn.microsoft.com/zh-cn/library/az24scfc.aspx">https://msdn.microsoft.com/zh-cn/library/az24scfc.aspx</a>  </li>
<li>Python的正则表达式在线编辑器：<a href="http://www.pyregex.com/">http://www.pyregex.com/</a>     </li>
<li>Ruby的正则表达式在线编辑器： <a href="http://rubular.com/">http://rubular.com/</a>    </li>
<li>国外一个正则表达式库： <a href="http://www.regexlib.com">http://www.regexlib.com</a>    </li>
<li>正则表达式的debug工具： <a href="https://www.debuggex.com/">https://www.debuggex.com/</a>    </li>
<li>包含各种语言的在线正则表达式测试工具： <a href="http://www.regexplanet.com/">http://www.regexplanet.com/</a>  </li>
<li>很新颖的正则表达式编辑、高亮、debug工具： <a href="https://regex101.com/">https://regex101.com/</a>  </li>
</ol>
<h2 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h2><p>元字符即其本身有就着的特殊含义，而不是表示其字符本身。  </p>
<ul>
<li><code>.</code>  匹配除换行符以外的任意一个字符，所有匹配没有特别说明都表示匹配一个。  </li>
<li><code>\w</code> 匹配字母、数字、下划线、汉字、繁体等字符  </li>
<li><code>\s</code> 匹配任意的空白符  </li>
<li><code>\d</code> 匹配数字  </li>
<li><code>\b</code> 匹配单词的开始或结束，它相当于匹配的是个位置   </li>
<li><code>^</code>  匹配字符串的开始，同样相当于匹配的是个位置   </li>
<li><code>$</code>  匹配字符串的结束  </li>
<li><code>()</code> 用于分组<br>表达式中想匹配元字符就必须使用转义字符<code>\</code>，例如匹配<code>.</code>,<code>(</code>,<code>)</code>,<code>\</code>需要使用<code>\.</code>,<code>\(</code>,<code>\)</code>,<code>\\</code>  </li>
</ul>
<h2 id="表示数量的限定符"><a href="#表示数量的限定符" class="headerlink" title="表示数量的限定符"></a>表示数量的限定符</h2><ul>
<li><code>*</code> 重复零次或更多次  </li>
<li><code>+</code> 重复一次或更多次  </li>
<li><code>?</code> 重复零次或一次  </li>
<li><code>&#123;n&#125;</code> 重复n次   </li>
<li><code>&#123;n,&#125;</code> 重复n次或更多次   </li>
<li><code>&#123;n,m&#125;</code> 重复n到m次，即n到m次之间任意多次都进行匹配，例如<code>\d&#123;1,3&#125;</code>可以匹配999以内的任意数字    </li>
</ul>
<h2 id="限定字符范围"><a href="#限定字符范围" class="headerlink" title="限定字符范围"></a>限定字符范围</h2><p>通过<code>[]</code>可以限定只有<code>[]</code>中包含的某个才能被匹配。例如如果我想匹配某个单词开头必须是元音字母，就可以这样<code>\b[aeiou]\w+\b</code>，当然这个会把<code>a2dw</code>也匹配进去。<code>[]</code>中可以使<code>-</code>来表示某一范围内的字符,例如<code>[0-9]</code>表示匹配0-9之间的任意一个数字，与<code>\d</code>含义一样。同时可以这样使用<code>[a-z0-9A-Z]</code>，它与<code>\w</code>含义一样，如果只考虑英文，即只匹配一个数字或字母。所以<code>[]</code>中的短线<code>-</code>是有着特殊含义的，但当<code>-</code>放在<code>[]</code>中，且短线前后不同时是单一的字母或数字时不需要加转义字符，如<code>[a-\d]</code>表示从<code>a</code>,<code>-</code>或数字中任意选择一个，但有些情况却会出错，例如<code>[?-=]</code>意思可以跟你想的不一样，最好是将含有单一<code>-</code>的情况时将短线放在最后面，如<code>[?=-]</code>。   </p>
<h2 id="反义"><a href="#反义" class="headerlink" title="反义"></a>反义</h2><p>反义就是匹配相反的内容，即跟上面的元字符匹配内容相反的情况，只是将对应的小写字母改成大写。  </p>
<ul>
<li><code>\W</code>  匹配任意不是字母、数字、下划线、汉字的字符  </li>
<li><code>\S</code>  匹配任意不是空白符的字符  </li>
<li><code>\D</code>  匹配任意非数字的字符  </li>
<li><code>\B</code>  匹配不是单词开头或结束的位置</li>
<li><code>[^x]</code>  匹配除了x以外的任意字符  </li>
<li><code>[^aeiou]</code>  匹配除了aeiou这几个字母以外的任意字符<br>eg:<br><code>\S+</code>匹配不包含空白符的字符串<br><code>&lt;m[^&gt;]+&gt;</code>匹配用尖括号括起来的以m开头的字符串，中间可以有空白等任意字符，与<code>&lt;m.+&gt;</code>的区别是当一行中有多个<code>&gt;</code>时它只会匹配到第一个<code>&gt;</code>位置处。   </li>
</ul>
<h2 id="分支条件"><a href="#分支条件" class="headerlink" title="分支条件"></a>分支条件</h2><p>分支条件即可以使用分隔符<code>|</code>起到<code>或</code>的作用，即多个表达式通过<code>|</code>连接在一起，满足任意一个表达式即进行匹配。如通过<code>\(0\d&#123;2&#125;[)]\d&#123;8&#125;|\d&#123;3&#125;-\d&#123;8&#125;</code>可以同时匹配到以下两种电话号码<code>010-12345678</code>和<code>(010)12345678</code><br>注意分支条件的匹配是有顺序的，即从左到右测试，如果测试成功，则停止测试，不再进行后续的测试，所以使用分支条件连接多个表达式时应将限制条件较多的表达式放在前面。eg: <code>\d&#123;5&#125;-\d&#123;4&#125;|\d&#123;5&#125;</code>与<code>\d&#123;5&#125;|\d&#123;5&#125;-\d&#123;4&#125;</code>的匹配结果是不一样的，明显前一个的较精确，因为它的将限制较多的表达式放在了前面，而后一个在匹配时会忽略掉后一个分支限制。  </p>
<h2 id="分组-的用法"><a href="#分组-的用法" class="headerlink" title="分组()的用法"></a>分组()的用法</h2><p>分组即通过<code>()</code>将多个匹配作为一组，然后对这整个组进行操作。例如将匹配成功的某个需要字串进行重复、再匹配等。一个简单的匹配IP的表达式<code>(\d&#123;3&#125;.)&#123;3&#125;\d&#123;3&#125;</code>，即将后面跟有一个点的3位数字进行3次重复，然后面再跟上一个三位的数字。显示这个匹配漏洞很多。下面是一个较为精确的例子，仔细分析，然后尝试写出其它方式的IP匹配，将会收获很多，<code>((2[0-4]\d|25[0-5]|[01]?\d\d?)\.)&#123;3&#125;(2[0-4]\d|25[0-5]|[01]?\d\d?)</code>。<br>当对表达式进行分组时会默认分配一个组号，该组号从<code>\0</code>开始，<code>\0</code>代表整个表达式匹配的内容，<code>\1</code>代表第一个分组表达式匹配的内容。例如<code>\b(\w+)\b\s+\1\b</code>可以匹配<code>&quot;go go&quot;</code>这样的单词，其中<code>\1</code>就代表<code>(\w+)</code>匹配到的内容。可以通过<code>?&lt;name&gt;exp</code>或者<code>?</code>name<code>exp</code>对分组进行重命名。例如前面的表达式等价于<code>\b(?&lt;word&gt;\w+)\b\s+\k&lt;word&gt;\b</code>。<br>关于常用分组的语法  </p>
<ul>
<li>捕获  <ul>
<li><code>(exp)</code>        匹配exp,并捕获文本到自动命名的组里  </li>
<li><code>(?&lt;name&gt;exp)</code>  匹配exp,并捕获文本到名称为name的组里，也可以写成(?’name’exp)  </li>
<li><code>(?:exp)</code>       匹配exp,不捕获匹配的文本，也不给此分组分配组号，只是进行正常的匹配   </li>
</ul>
</li>
<li>零宽断言  <ul>
<li><code>(?=exp)</code>     匹配exp前面的位置    </li>
<li><code>(?&lt;=exp)</code>     匹配exp后面的位置  </li>
<li><code>(?!exp)</code>     匹配后面跟的不是exp的位置  </li>
<li><code>(?&lt;!exp)</code>     匹配前面不是exp的位置  </li>
</ul>
</li>
<li>注释<ul>
<li><code>(?#comment)</code> 这种类型的分组不对正则表达式的处理产生任何影响，用于提供注释方便阅读  </li>
</ul>
</li>
</ul>
<h3 id="零宽断言"><a href="#零宽断言" class="headerlink" title="零宽断言"></a>零宽断言</h3><p>所谓零宽断言即进行位置匹配，以找到该位置前面或者后面所需要的匹配内容。  </p>
<ol>
<li><p><code>(?=exp)</code>也叫零宽度正预测先行断言，它断言自身出现的位置的后面能匹配表达式exp。 eg:<br><code>\b\w+(?=ing\b)</code>,匹配以<code>ing</code>结尾的单词的前面部分，不包含<code>ing</code>，如<code>singing and dancing</code>只会匹配出来<code>sing</code>和<code>danc</code>。  </p>
</li>
<li><p><code>(?&lt;=exp)</code>即零宽度正回顾后发断言，它断言自身出现的位置的前面能匹配表达式exp。eg:<br><code>(?&lt;=\bre\w+\b)</code>会匹配以re开头的单词的后半部分，如<code>reading a book</code>，只会匹配到<code>ading</code>。<br>举例：<code>(?&lt;=\s)\d+(?=\s)</code>匹配以空白符间隔的数字(再次强调，不包括这些空白符)。    </p>
</li>
<li><p><code>(?!exp)</code>即零宽度负预测先行断言，断言此位置的后面不能匹配表达式exp。例如：如果想查找某个单词，它里面出现了字母q，但q后面跟的不是字母u，通常可能会这样写<code>\b\w*q[^u]\w*\b</code>，多数时间好用，但它会匹配<code>qq.com</code>，<code>faq ask</code>这样的字串，因为匹配时<code>[^u]</code>也会消耗掉一个字符。如果使用位置来匹配，如<code>\b\w*q(?!u)\w*\b</code>便可以完美解决。eg: <code>\d&#123;3&#125;(?!\d)</code>匹配三位数字，而这三位数字的后面不能是数字；<code>\b((?!abc)\w)+\b</code>匹配不包含连续字符串abc的单词。  </p>
</li>
<li><p><code>(?&lt;!exp)</code>即零宽度负回顾后发断言，断言此位置的前面不能匹配表达式exp。如<code>(?&lt;![a-z]&gt;)\d&#123;7&#125;</code>匹配前面不是小写字母的七位数字。  </p>
</li>
</ol>
<p>举例：<code>(?&lt;=&lt;(\w+)&gt;).*(?=&lt;\/\1&gt;)</code>匹配不包含属性的简单HTML标签内里的内容。<code>(?&lt;=&lt;(\w+)&gt;)</code>指定了这样的前缀：被尖括号括起来的单词(比如可能是<code>&lt;b&gt;</code>)，然后是<code>.*</code>(任意的字符串),最后是一个后缀<code>(?=&lt;\/\1&gt;)</code>。注意后缀里的<code>\/</code>，它用到了前面提过的字符转义；<code>\1</code>则是一个反向引用，引用的正是捕获的第一组，前面的<code>(\w+)</code>匹配的内容，这样如果前缀实际上是<code>&lt;b&gt;</code>的话，后缀就是<code>&lt;/b&gt;</code>了。整个表达式匹配的是<code>&lt;b&gt;</code>和<code>&lt;/b&gt;</code>之间的内容(再次提醒，不包括前缀和后缀本身)。</p>
<h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>使用(?#comment)来添加注释，eg: <code>2[0-4]\d(?#200-249)|25[0-5](?#250-255)|[01]?\d\d?(?#0-199)</code>。这个非特殊情况估计很少用，不过这里作者的举例很好：要包含注释的话，最好是启用“忽略模式里的空白符”选项，这样在编写表达式时能任意的添加空格，Tab，换行，而实际使用时这些都将被忽略。启用这个选项后，在#后面到这一行结束的所有文本都将被当成注释忽略掉。例如，我们可以前面的一个表达式写成这样：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(?&lt;=    # 断言要匹配的文本的前缀</span><br><span class="line">&lt;(\w+)&gt; # 查找尖括号括起来的字母或数字(即HTML/XML标签)</span><br><span class="line">)       # 前缀结束</span><br><span class="line">.*      # 匹配任意文本</span><br><span class="line">(?=     # 断言要匹配的文本的后缀</span><br><span class="line">&lt;\/\1&gt;  # 查找尖括号括起来的内容：前面是一个&quot;/&quot;，后面是先前捕获的标签</span><br><span class="line">)       # 后缀结束</span><br></pre></td></tr></table></figure>
<p><code>regexbuddy</code>中<code>Free-spacing</code>模式即忽略空格。  </p>
<h2 id="贪婪与懒惰模式"><a href="#贪婪与懒惰模式" class="headerlink" title="贪婪与懒惰模式"></a>贪婪与懒惰模式</h2><p>当正则表达式中包含能接受重复的限定符时，通常的行为是（在使整个表达式能得到匹配的前提下）匹配尽可能多的字符。以这个表达式为例：<code>a.*b</code>，它将会匹配最长的以a开始，以b结束的字符串。如果用它来搜索aabab的话，它会匹配整个字符串aabab。这被称为贪婪匹配。 有时，我们更需要懒惰匹配，也就是匹配尽可能少的字符。前面给出的限定符都可以被转化为懒惰匹配模式，只要在它后面加上一个问号<code>?</code>。这样<code>.*?</code>就意味着匹配任意数量的重复，但是在能使整个匹配成功的前提下使用最少的重复。<br>现在看看懒惰版的例子吧：<code>a.*?b</code>匹配最短的，以a开始，以b结束的字符串。如果把它应用于aabab的话，它会匹配aab（第一到第三个字符）和ab（第四到第五个字符）。<br>懒惰限定符  </p>
<ul>
<li><code>*?</code>     重复任意次，但尽可能少重复  </li>
<li><code>+?</code>     重复1次或更多次，但尽可能少重复  </li>
<li><code>??</code>     重复0次或1次，但尽可能少重复  </li>
<li><code>&#123;n,m&#125;?</code>重复n到m次，但尽可能少重复  </li>
<li><code>&#123;n,&#125;?</code>    重复n次以上，但尽可能少重复</li>
</ul>
<h2 id="Net常用的正则表达式处理选项"><a href="#Net常用的正则表达式处理选项" class="headerlink" title=".Net常用的正则表达式处理选项"></a>.Net常用的正则表达式处理选项</h2><p>在C#中，你可以使用<code>Regex(String, RegexOptions)</code>构造函数来设置正则表达式的处理选项。如：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">Regex regex = <span class="keyword">new</span> Regex(<span class="string">@&quot;\ba\w&#123;6&#125;\b&quot;</span>, RegexOptions.IgnoreCase);  </span><br></pre></td></tr></table></figure>

<p>常用的处理选项  </p>
<ul>
<li><code>IgnoreCase</code>(忽略大小写)    匹配时不区分大小写。  </li>
<li><code>Multiline</code>(多行模式)            更改<code>^</code>和<code>$</code>的含义，使它们分别在任意一行的行首和行尾匹配，而不仅仅在整个字符串的开头和结尾匹配。(在此模式下,<code>$</code>的精确含意是:匹配<code>\n</code>之前的位置以及字符串结束前的位置.)  </li>
<li><code>Singleline</code>(单行模式)    更改<code>.</code>的含义，使它与每一个字符匹配（包括换行符\n）。  </li>
<li><code>IgnorePatternWhitespace</code>(忽略空白) 忽略表达式中的非转义空白并启用由<code>#</code>标记的注释。  </li>
<li><code>ExplicitCapture</code>(显式捕获) 仅捕获已被显式命名的组。  </li>
</ul>
<h2 id="平衡组-递归匹配"><a href="#平衡组-递归匹配" class="headerlink" title="平衡组/递归匹配"></a>平衡组/递归匹配</h2><p>仅试用于.Net框架，其他平台略有不同<br>使用场景：有时我们需要匹配像( 100 * ( 50 + 15 ) )这样的可嵌套的层次性结构，这时简单地使用<code>\(.+\)</code>则只会匹配到最左边的左括号和最右边的右括号之间的内容(这里我们讨论的是贪婪模式，懒惰模式也有下面的问题)。假如原来的字符串里的左括号和右括号出现的次数不相等，比如( 5 / ( 3 + 2 ) ) )，那我们的匹配结果里两者的个数也不会相等。有没有办法在这样的字符串里匹配到最长的，配对的括号之间的内容呢？  </p>
<ul>
<li><code>(?&#39;group&#39;)</code> 把捕获的内容命名为group,并压入堆栈(Stack)  </li>
<li><code>(?&#39;-group&#39;)</code> 从堆栈上弹出最后压入堆栈的名为group的捕获内容，如果堆栈本来为空，则本分组的匹配失败  </li>
<li><code>(?(group)yes|no)</code> 如果堆栈上存在以名为group的捕获内容的话，继续匹配yes部分的表达式，否则继续匹配no部分  </li>
<li><code>(?!)</code> 零宽负向先行断言，由于没有后缀表达式，试图匹配总是失败，即此表达式始终为false。 </li>
</ul>
<p>我们需要做的是每碰到了左括号，就在压入一个”Open”,每碰到一个右括号，就弹出一个，到了最后就看看堆栈是否为空－－如果不为空那就证明左括号比右括号多，那匹配就应该失败。正则表达式引擎会进行回溯(放弃最前面或最后面的一些字符)，尽量使整个表达式得到匹配。   </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;                         #最外层的左括号</span><br><span class="line">    [^&lt;&gt;]*                #最外层的左括号后面的不是括号的内容</span><br><span class="line">    (</span><br><span class="line">        (</span><br><span class="line">            (?&#x27;Open&#x27;&lt;)    #碰到了左括号，在黑板上写一个&quot;Open&quot;</span><br><span class="line">            [^&lt;&gt;]*       #匹配左括号后面的不是括号的内容</span><br><span class="line">        )+</span><br><span class="line">        (</span><br><span class="line">            (?&#x27;-Open&#x27;&gt;)   #碰到了右括号，擦掉一个&quot;Open&quot;</span><br><span class="line">            [^&lt;&gt;]*        #匹配右括号后面不是括号的内容</span><br><span class="line">        )+</span><br><span class="line">    )*</span><br><span class="line">    (?(Open)(?!))         #在遇到最外层的右括号前面，判断黑板上还有没有没擦掉的&quot;Open&quot;；如果还有，则匹配失败</span><br><span class="line">&gt;                         #最外层的右括号</span><br></pre></td></tr></table></figure>

<p>平衡组的一个最常见的应用就是匹配HTML,下面这个例子可以匹配嵌套的<div>标签：<code>&lt;div[^&gt;]*&gt;[^&lt;&gt;]*(((?&#39;Open&#39;&lt;div[^&gt;]*&gt;)[^&lt;&gt;]*)+((?&#39;-Open&#39;&lt;/div&gt;)[^&lt;&gt;]*)+)*(?(Open)(?!))&lt;/div&gt;</code>  </p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>正则表达式在匹配时，除了位置匹配外都会在字符匹配过程中占用一个字符的位置，例如负向零宽断言中的举例。  </li>
<li>Cheat-sheet:<br><img data-src="re1.png" alt=""><br><img data-src="re2.png" alt=""><br><img data-src="re3.png" alt=""><br><img data-src="re4.jpg" alt=""><br><img data-src="re5.png" alt="">  </li>
</ol>
<h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><p>1.正则表达式语法有多个版本，主要有以下几个版本:</p>
<ul>
<li>ECMA-262 (ECMAScript) regular expressions (slightly modified?)</li>
<li>Basic POSIX regular expressions</li>
<li>Extended POSIX regular expressions</li>
<li>awk regular expressions</li>
<li>grep regular expressions</li>
<li>egrep regular expressions</li>
</ul>
<p>关于正则表达式引擎介绍，可以看wikipedia，超详细<a href="https://en.wikipedia.org/wiki/Comparison_of_regular_expression_engines">https://en.wikipedia.org/wiki/Comparison_of_regular_expression_engines</a></p>
<p>POSIX的语法中使用[:xxx:]来进行元字符匹配，其他基本都一样，不同的实现平台，需要根据相应手册来进行实现。</p>
]]></content>
      <categories>
        <category>Regular-Expressions</category>
      </categories>
      <tags>
        <tag>Notes</tag>
        <tag>Regular-Expressions</tag>
      </tags>
  </entry>
  <entry>
    <title>C-sharp-study-notes</title>
    <url>/2015/09/11/C-sharp-study-notes/</url>
    <content><![CDATA[<h2 id="参考资源"><a href="#参考资源" class="headerlink" title="参考资源"></a>参考资源</h2><ol>
<li><a href="https://msdn.microsoft.com/zh-cn/library/aa664628%28v=vs.71%29.aspx">msdn上的C#语言规范中文版</a>  </li>
<li><a href="https://msdn.microsoft.com/zh-cn/library/x53a06bb.aspx">C#中的所有关键字</a>   </li>
<li><a href="https://msdn.microsoft.com/zh-cn/library/gg145045%28v=vs.110%29.aspx">.NET Framework类库</a>     <span id="more"></span>

</li>
</ol>
<h2 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h2><ol>
<li>C#与C/C++很多地方都很类似，对于Hello World程序来说，程序入口是<code>Main()</code>函数，注意首字母是大写。C#的编译环境在VS中附带的有，编译器名称为<code>csc</code>，C#的源程序后缀通常为<code>.cs</code>。例如以下程序名为hello.cs，则最简单的编译方法为<code>csc hello.cs</code>，会在同目录中生成<code>hello.exe</code>的可执行程序。  <figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//引用一个名为System的命名空间，它由Microsoft.NET.Frameworld类库定义。该命名空间下包含`Main`方法引用的`Console`类。</span></span><br><span class="line"><span class="keyword">using</span> System;  </span><br><span class="line"><span class="keyword">class</span> <span class="title">Hello</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*程序的入口点总是名为Main的静态方法，Main方法是Hello类的成员，它是相对于类Hello本身而不是相对于此类的实例*/</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span>&#123;</span><br><span class="line">      Console.WriteLine(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>C#中的注释方法与C++一样。  </li>
<li>C#中的基本输入输出<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line">Console.Read(); <span class="comment">// 读一个字符</span></span><br><span class="line">Console.ReadLine(); <span class="comment">// 读一行</span></span><br><span class="line">Console.Write(); <span class="comment">// 不换行写</span></span><br><span class="line">Console.WriteLine(); <span class="comment">// 写并换行</span></span><br></pre></td></tr></table></figure>
C#中不使用<code>%</code>号作为输出变量，而是使用类似<code>python</code>中的占位符<code>&#123;&#125;</code>,eg: <code>System.Console.Write(&quot;&#123;0&#125;&quot;, a);</code><br><code>@</code>相当于<code>python</code>中的<code>r</code>，即按原始文本输出。eg: <code>System.Console.WriteLine(@&quot;hello\tworld&quot;);</code>输出结果为<code>hello\tworld</code>。   </li>
</ol>
<h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><ol>
<li><p>C#中的数据类型分为值类型和引用类型。<br>值类型包括：简单类型(bool、char、int、float、double)，枚举类型()，结构体类型()，有符号整型，无符号整型  等。<br>引用类型包括：字符串类型(string)，object类型，类类型(Class)，数组类型，委托类型()，接口类型等。<br>值类型即每个变量都有其自己的数据副本，引用类型则可能多个变量共用同一个对象。  </p>
</li>
<li><p>C#提供了一组预定义类型<br>预定义的类型中，属于引用类型的有 object 和 string 两类。object 类型是所有其他类型的最终基类型。string 类型用于表示 Unicode 字符串值。string 类型的值是不可变的。<br>预定义的值类型包括有符号整型、无符号整型、浮点型以及 bool、char 和 decimal 等类型。属有符号整型的有 sbyte、short、int 和 long；属无符号整型的有 byte、ushort、uint 和 ulong；属浮点型的有 float 和 double。<br>bool 类型用于表示布尔值，即仅有真、假两个值。且bool类型无法与int类型进行类型转换。<br>其中C/C++中没有类型为<code>sbyte</code>表示8位有符号整型，ushort、uint、ulong分别对应于相应的无符号型，decimal表示精确的小数类型，具有28个有效数字。<br>每个预定义类型都是一个在System命名空间下的类型的简写形式。例如关键字int所指的实际上是结构类型<code>System.Int32</code>。</p>
</li>
<li><p>C#中的类型转换同样分为强制转换与隐式转换。隐式转换只用于那些不需要仔细检查就可以安全地实现转换的类型，如从int到long,eg:  </p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> intVal = <span class="number">123</span>;</span><br><span class="line"><span class="built_in">long</span> longVal = intVal;</span><br></pre></td></tr></table></figure>
<p>与C++类似通过使用(type)来强制类型转换，eg:  </p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">long</span> longVal = Int64.MaxValue;</span><br><span class="line"><span class="built_in">int</span> intVal = (<span class="built_in">int</span>) longVal;</span><br></pre></td></tr></table></figure></li>
<li><p>数组：<br>C#中的数组类型是用一个非数组类型名称后跟一个或多个秩说明符来表示的。eg: int[]表示整型类型的数组，short[]表示短整型，其他类似。<br>C#数组根据形状可分为矩形数组和交错数组。数组的元素类型和数组的形状是数组类型定义的组成部分，但数组的大小却不是数组类型定义的组成部分。C#的语法明确地规定数组的每个维的长度需要在数组创建表达式中指定。数组类型为引用类型，所以数组变量的声明只是为数组引用留出空间。数组实例是通过数组初始值设定项和数组创建表达式创建的。eg:  </p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span>[] a; <span class="comment">//声明一个一维的整型数组a，但并未创建数组</span></span><br><span class="line"><span class="built_in">int</span>[] b = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">5</span>]; <span class="comment">//声明并创建含有5个元素的一维数组b</span></span><br><span class="line"><span class="built_in">int</span>[] c = <span class="keyword">new</span> <span class="built_in">int</span>[] &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;; <span class="comment">//声明、创建并初始化一维整型数组c</span></span><br><span class="line"><span class="built_in">int</span>[] d = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;  <span class="comment">//等价于c，对于局部变量和字段的声明，允许使用简写形式</span></span><br></pre></td></tr></table></figure></li>
<li><p>多维数组<br>注意C#的多维数组就是多维数组，而不是像C/C++中的多维数组就是数组的数组。而交错数组也就是数组的数组。eg:</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Test</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span> &#123;</span><br><span class="line">      <span class="built_in">int</span>[] a1;         <span class="comment">// single-dimensional array of int</span></span><br><span class="line">      <span class="built_in">int</span>[,] a2;         <span class="comment">// 2-dimensional array of int</span></span><br><span class="line">      <span class="built_in">int</span>[,,] a3;         <span class="comment">// 3-dimensional array of int</span></span><br><span class="line">      <span class="built_in">int</span>[][] j2;         <span class="comment">// &quot;jagged&quot; array: array of (array of int)</span></span><br><span class="line">      <span class="built_in">int</span>[][][] j3;      <span class="comment">// array of (array of (array of int))</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">//下面为对应的初始化</span></span><br><span class="line">      <span class="built_in">int</span>[] a1 = <span class="keyword">new</span> <span class="built_in">int</span>[] &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">      <span class="built_in">int</span>[,] a2 = <span class="keyword">new</span> <span class="built_in">int</span>[,] &#123;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;, &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;&#125;;  <span class="comment">//a2的大小为3x3</span></span><br><span class="line">      <span class="built_in">int</span>[,,] a3 = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>];  <span class="comment">//a3的三维大小分别是10，20，30</span></span><br><span class="line">      <span class="built_in">int</span>[][] j2 = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">3</span>][];  <span class="comment">//j2中含有3个int[]类型的数组，数组长度在下面声明，分别为3,6,9</span></span><br><span class="line">      j2[<span class="number">0</span>] = <span class="keyword">new</span> <span class="built_in">int</span>[] &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">      j2[<span class="number">1</span>] = <span class="keyword">new</span> <span class="built_in">int</span>[] &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line">      j2[<span class="number">2</span>] = <span class="keyword">new</span> <span class="built_in">int</span>[] &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>数组在声明并创建后如果不手动初始化，各元素会被自动初始化为0。但变量必须先赋值，然后才能使用。</p>
</li>
<li><p>类型系统统一化<br>C# 提供了一个“统一类型系统”。所有类型（包括值类型）都是从 object 类型派生的。这样，类型 Object 中定义的方法就可以在任何值类型的值（甚至是像 int 这样的“基元”类型的值）上调用。eg:</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Test</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span> &#123;</span><br><span class="line">      Console.WriteLine(<span class="number">3.</span>ToString());</span><br><span class="line">      <span class="built_in">int</span> i = <span class="number">123</span>;</span><br><span class="line">      <span class="built_in">object</span> o = i;      <span class="comment">// boxing</span></span><br><span class="line">      <span class="built_in">int</span> j = (<span class="built_in">int</span>) o;   <span class="comment">// unboxing</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个 int 值可以转换为 object，并可再次转换回 int。此示例同时显示了“装箱”和“取消装箱”。当值类型的变量需要转换为引用类型时，执行“装箱”，即设置一个对象箱来保存值这个值（该值被复制到箱中）。“取消装箱”则正好相反。当对象箱被强制转换回其原来的值类型时，该值就从箱中取出并复制到适当的存储位置。  </p>
</li>
</ol>
<p>此类型系统统一化为值类型提供了对象性的优点，并且不会带来不必要的系统开销。对于不需要 int 值的行为与对象一样的程序，int 值只是 32 位值。对于需要 int 值的行为与对象一样的程序，可以根据需要使用此功能。这种将值类型作为对象处理的能力弥补了大多数语言中存在的值类型与引用类型之间的差距。例如，Stack 类可以提供 Push 和 Pop 方法，这些方法获得并返回一个 object 值。  </p>
<ol start="7">
<li>委托：委托类型使用<code>delegate</code>进行声明，有一个返回值和任意数目任意类型的参数。委托是一种可用于封装命名或匿名方法的引用类型。 委托类似于 C++ 中的函数指针；但是，委托是类型安全和可靠的。 委托是事件的基础。 通过将委托与命名方法或匿名方法关联，可以实例化委托。必须使用具有兼容返回类型和输入参数的方法或 lambda 表达式实例化委托。  eg:<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="comment">// Declare delegate -- defines required signature:</span></span><br><span class="line"><span class="function"><span class="built_in">delegate</span> <span class="built_in">double</span> <span class="title">MathAction</span>(<span class="params"><span class="built_in">double</span> num</span>)</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title">DelegateTest</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Regular method that matches signature:</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="built_in">double</span> <span class="title">Double</span>(<span class="params"><span class="built_in">double</span> input</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> input * <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Instantiate delegate with named method:</span></span><br><span class="line">        MathAction ma = Double;</span><br><span class="line">        <span class="comment">// Invoke delegate ma:</span></span><br><span class="line">        <span class="built_in">double</span> multByTwo = ma(<span class="number">4.5</span>);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;multByTwo: &#123;0&#125;&quot;</span>, multByTwo);</span><br><span class="line">        <span class="comment">// Instantiate delegate with anonymous method:</span></span><br><span class="line">        MathAction ma2 = <span class="built_in">delegate</span>(<span class="built_in">double</span> input)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> input * input;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">double</span> square = ma2(<span class="number">5</span>);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;square: &#123;0&#125;&quot;</span>, square);</span><br><span class="line">        <span class="comment">// Instantiate delegate with lambda expression</span></span><br><span class="line">        MathAction ma3 = s =&gt; s * s * s;</span><br><span class="line">        <span class="built_in">double</span> cube = ma3(<span class="number">4.375</span>);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;cube: &#123;0&#125;&quot;</span>, cube);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Output:</span></span><br><span class="line">    <span class="comment">// multByTwo: 9</span></span><br><span class="line">    <span class="comment">// square: 25</span></span><br><span class="line">    <span class="comment">// cube: 83.740234375</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="变量和参数"><a href="#变量和参数" class="headerlink" title="变量和参数"></a>变量和参数</h3><ol>
<li>变量必须先赋值，然后才能使用它的值。<br>字段（第 10.4 节）是与类或结构或与类或结构的实例关联的变量。用 static 修饰符声明的字段定义静态变量，不用此修饰符声明的字段则定义实例变量。静态字段与类型关联，而实例变量与实例关联。  <figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//具有一个私有静态变量和两个公共实例变量的 Employee 类</span></span><br><span class="line"><span class="keyword">using</span> Personnel.Data;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Employee</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> DataSet ds;</span><br><span class="line">   <span class="keyword">public</span> <span class="built_in">string</span> Name;</span><br><span class="line">   <span class="keyword">public</span> <span class="built_in">decimal</span> Salary;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>C#有四种类型的参数：值参数，引用参数，输出参数和参数数组  <ul>
<li>值参数：即通过传值来传递参数，即传入的变量的副本。  </li>
<li>引用参数：通过关键字<code>ref</code> 来声明和调用引用参数，即传递的是变量本身</li>
<li>输出参数：通过关键字<code>out</code>来声明输出参数，即一个函数可以有多个输出值</li>
<li>参数数组：即通过关键字<code>params</code>将一维数组作为参数传递给函数，这样可以实现可变长的参数列表   </li>
</ul>
</li>
</ol>
<p>eg:<br>值参数：   </p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">F</span>(<span class="params"><span class="built_in">int</span> p</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;p = &#123;0&#125;&quot;</span>, p);</span><br><span class="line">        p++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> a = <span class="number">0</span>;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Pre: a = &#123;0&#125;&quot;</span>, a);</span><br><span class="line">        F(a);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;New: a = &#123;0&#125;&quot;</span>, a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果为全为0<br>引用参数：   </p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">F</span>(<span class="params"><span class="keyword">ref</span> <span class="built_in">int</span> p</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;p = &#123;0&#125;&quot;</span>, p);</span><br><span class="line">        p++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> a = <span class="number">0</span>;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Pre: a = &#123;0&#125;&quot;</span>, a);</span><br><span class="line">        F(<span class="keyword">ref</span> a);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;New: a = &#123;0&#125;&quot;</span>, a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果后面的a变成了0。   </p>
<p>输出参数：   </p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">F</span>(<span class="params"><span class="keyword">ref</span> <span class="built_in">int</span> p, <span class="keyword">out</span> <span class="built_in">int</span> result</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;p = &#123;0&#125;&quot;</span>, p);</span><br><span class="line">        p++;</span><br><span class="line">        result = p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> a = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">int</span> res;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Pre: a = &#123;0&#125;&quot;</span>, a);</span><br><span class="line">        F(<span class="keyword">ref</span> a, <span class="keyword">out</span> res);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;New: a = &#123;0&#125;, res = &#123;1&#125;&quot;</span>, a, res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>显然输出参数关键字<code>out</code>与引用参数<code>ref</code>的功能非常像，其实也基本上确实是一要的。但不同的是引用参数在使用前必须初始化，而输出参数不需要，也就是在调用函数之前并没有给输出参数分配空间。就像上例中如果将<code>int res;</code>改为<code>int res = 0;</code>,则将所有的<code>out</code>替换为<code>ref</code>之后结果也完成正确。  </p>
<p>数组参数：参数数组用 params 修饰符声明。一个给定的方法只能有一个参数数组，而且它必须始终是最后一个指定的参数。参数数组的类型总是一维数组类型。调用方可以传递一个属同一类型的数组变量，或任意多个与该数组的元素属同一类型的自变量。  </p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">F</span>(<span class="params"><span class="keyword">params</span> <span class="built_in">int</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;arguments:&#123;0&#125; &quot;</span>, args.Length);</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; args.Length; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;\targs[&#123;0&#125;]=&#123;1&#125; &quot;</span>, i, args[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        F();</span><br><span class="line">        F(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">        F(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">        F(<span class="keyword">new</span> <span class="built_in">int</span> []&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li><p>C#中的常量关键字有两个：<code>const</code>和<code>readonly</code>。 使用 const 关键字来声明某个常量字段或常量局部变量。 常量字段和常量局部变量不是变量并且不能修改， 常量可以为数字、布尔值、字符串或 null 引用。 <code>readonly</code>关键字是可以在字段上使用的修饰符。 当字段声明包括 <code>readonly</code>修饰符时，该声明引入的字段赋值只能作为声明的一部分出现，或者出现在同一类的构造函数中。<br>它们的不同之处： const 字段只能在该字段的声明中初始化，且编译时确定。 readonly 字段可以在声明或构造函数中初始化。 因此，根据所使用的构造函数，readonly 字段可能具有不同的值。即<code>readonly</code>声明的变量可以在声明之后赋值但在运行时是确定的。</p>
</li>
<li><p>C#的命令行参数与C/C++不同，它的第一个参数不是程序名，而是你输入的第一个参数。</p>
</li>
</ol>
<h3 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h3><p>C#中除了C/C++常见的表达式外，增加了<code>checked</code>, <code>unchecked</code>, <code>(T)x</code>, <code>is</code>, <code>as</code>等。  </p>
<ol>
<li><p><code>checked</code>, <code>unchecked</code>: checked 和 unchecked关键字用来限定检查或者不检查数学运算溢出的；如果使用了checked发生数学运算溢出时会抛出OverflowException；如果使用了unchecked则不会检查溢出，算错了也不会报错。eg:</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> a = <span class="built_in">int</span>.MaxValue * <span class="number">2</span>;  <span class="comment">//编译报错</span></span><br><span class="line"><span class="built_in">int</span> temp = <span class="built_in">int</span>.MaxValue;</span><br><span class="line"><span class="built_in">int</span> a = temp * <span class="number">2</span>;  <span class="comment">//编译通过，显然结果不正确，因为编译时的溢出检查仅限于使用常量的表达式。</span></span><br><span class="line"><span class="comment">//使用checked溢出检查</span></span><br><span class="line"><span class="built_in">int</span> temp = <span class="built_in">int</span>.MaxValue;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">   <span class="built_in">int</span> a = checked(temp * <span class="number">2</span>); <span class="comment">//checked也可以用于代码块</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (OverflowException) &#123;</span><br><span class="line">   Console.WriteLine(<span class="string">&quot;OverFlow&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用unchecked不检查溢出</span></span><br><span class="line"><span class="built_in">int</span> a = <span class="keyword">unchecked</span>(<span class="built_in">int</span>.MaxValue * <span class="number">2</span>);  <span class="comment">//这种不检查的可以用于不需要正确结果的计算，比如hasecode</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>(T)x</code>: </p>
</li>
<li><p><code>is</code> : is检查一个对象是否兼容于指定的类型，即提供类型检查功能。如果所提供的表达式非空，并且所提供的对象可以强制转换为所提供的类型而不会导致引发异常，则 is 表达式的计算结果将是 true。注意，is操作符永远不会抛出异常，且如果对象引用是null时，is操作符总是返回false  eg:</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">Object a = <span class="keyword">new</span> Object();</span><br><span class="line">Boolean b = (a <span class="keyword">is</span> Object); <span class="comment">// b is true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>as</code>: 提供检查并转换为可兼容的类型，如果类型相同，就返回一个非空的引用，否则就返回一个空引用。以下<code>is</code>和<code>as</code>实现的功能相同，但使用as的性能更好。eg:  </p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//此处需要首先检查一次，然后在强制转换时CLR会再次进行检查类型是否兼容</span></span><br><span class="line"><span class="keyword">if</span> (o <span class="keyword">is</span> Employee) &#123;</span><br><span class="line">   Employee e = (Employee) o;</span><br><span class="line">   <span class="comment">//对e进行操作</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//此处只需要一次类型检查并转换</span></span><br><span class="line">Employee e = o <span class="keyword">as</span> Employee;</span><br><span class="line"><span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">   <span class="comment">//对e进行操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h3><p>C#中增加的语句有：  </p>
</li>
<li><p><code>foreach, in</code>语句：功能是遍历array或者object collection中的元素，使用方法为<code>foreach (type identifier in expression) statement;</code>，该语句在使用时应只读数据，避免在遍历过程中对数据进行修改，以免出现不可预测的结果。 eg:</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="built_in">string</span> s <span class="keyword">in</span> args)</span><br><span class="line">        Console.WriteLine(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><code>checked</code> 和 <code>unchecked</code> 语句 eg:</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span> &#123;</span><br><span class="line">    <span class="built_in">int</span> x = Int32.MaxValue;</span><br><span class="line"></span><br><span class="line">    Console.WriteLine(x + <span class="number">1</span>);      <span class="comment">// Overflow</span></span><br><span class="line"></span><br><span class="line">    checked &#123;</span><br><span class="line">        Console.WriteLine(x + <span class="number">1</span>);  <span class="comment">// Exception</span></span><br><span class="line">    &#125;     </span><br><span class="line"></span><br><span class="line">    <span class="keyword">unchecked</span> &#123;</span><br><span class="line">        Console.WriteLine(x + <span class="number">1</span>);  <span class="comment">// Overflow</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><code>lock</code>语句：关键字将语句块标记为临界区，方法是获取给定对象的互斥锁，执行语句，然后释放该锁。 lock 关键字可确保当一个线程位于代码的临界区时，另一个线程不会进入该临界区。 如果其他线程尝试进入锁定的代码，则它将一直等待（即被阻止），直到该对象被释放。官方示例  </p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//只要lock语句存在，语句块就是临界区并且balance永远不会是负数</span></span><br><span class="line">    <span class="comment">// using System.Threading;</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title">Account</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span> Object thisLock = <span class="keyword">new</span> Object();</span><br><span class="line">        <span class="built_in">int</span> balance;</span><br><span class="line"></span><br><span class="line">        Random r = <span class="keyword">new</span> Random();</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Account</span>(<span class="params"><span class="built_in">int</span> initial</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            balance = initial;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="built_in">int</span> <span class="title">Withdraw</span>(<span class="params"><span class="built_in">int</span> amount</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// This condition never is true unless the lock statement</span></span><br><span class="line">            <span class="comment">// is commented out.</span></span><br><span class="line">            <span class="keyword">if</span> (balance &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;Negative Balance&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Comment out the next line to see the effect of leaving out </span></span><br><span class="line">            <span class="comment">// the lock keyword.</span></span><br><span class="line">            <span class="keyword">lock</span> (thisLock)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (balance &gt;= amount)</span><br><span class="line">                &#123;</span><br><span class="line">                    Console.WriteLine(<span class="string">&quot;Balance before Withdrawal :  &quot;</span> + balance);</span><br><span class="line">                    Console.WriteLine(<span class="string">&quot;Amount to Withdraw        : -&quot;</span> + amount);</span><br><span class="line">                    balance = balance - amount;</span><br><span class="line">                    Console.WriteLine(<span class="string">&quot;Balance after Withdrawal  :  &quot;</span> + balance);</span><br><span class="line">                    <span class="keyword">return</span> amount;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// transaction rejected</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DoTransactions</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                Withdraw(r.Next(<span class="number">1</span>, <span class="number">100</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title">Test</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            Thread[] threads = <span class="keyword">new</span> Thread[<span class="number">10</span>];</span><br><span class="line">            Account acc = <span class="keyword">new</span> Account(<span class="number">1000</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                Thread t = <span class="keyword">new</span> Thread(<span class="keyword">new</span> ThreadStart(acc.DoTransactions));</span><br><span class="line">                threads[i] = t;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                threads[i].Start();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
<li><p><code>using</code>语句：<br>using 关键字有两个主要用途：<br> 作为指令，用于为命名空间创建别名或导入其他命名空间中定义的类型。<br>   using 指令有三种用途：</p>
<pre><code>允许在命名空间中使用类型，这样无需在该命名空间中限定某个类型的使用：  
`using System.Text;`
允许访问类型的静态成员，而无需限定使用类型名称进行访问：  
`using static System.Math;`
为命名空间或类型创建别名。 这称为 using 别名指令。  
`using Project = PC.MyCompany.Project;`</code></pre><p> 作为语句，用于定义一个范围，在此范围的末尾将释放对象。提供能确保正确使用 IDisposable 对象的方便语法。    </p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> (Font font1 = <span class="keyword">new</span> Font(<span class="string">&quot;Arial&quot;</span>, <span class="number">10.0f</span>)) </span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">byte</span> charset = font1.GdiCharSet;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="自动内存管理"><a href="#自动内存管理" class="headerlink" title="自动内存管理"></a>自动内存管理</h2><p>C#提供自动内存管理，也就是说当某些变量或者对象不再需要时，会被垃圾回收器自动回收。当需要精确的内存控制时则需要使用关键字<code>unsafe</code>来创建不安全代码快，从而可以在其中编写直接操纵内存的代码。例如直接处理指针类型和对象地址。eg:  </p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">WriteLocations</span>(<span class="params"><span class="built_in">byte</span>[] arr</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">unsafe</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">fixed</span> (<span class="built_in">byte</span>* pArray = arr)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">byte</span>* pElem = pArray;</span><br><span class="line">                <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; arr.Length; i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">byte</span> <span class="keyword">value</span> = *pElem;</span><br><span class="line">                    Console.WriteLine(<span class="string">&quot;arr[&#123;0&#125;] at 0x&#123;1:X&#125; is &#123;2&#125;&quot;</span>,</span><br><span class="line">                       i, (<span class="built_in">uint</span>)pElem, <span class="keyword">value</span>);</span><br><span class="line">                    pElem++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">byte</span>[] arr = <span class="keyword">new</span> <span class="built_in">byte</span>[] &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line">        WriteLocations(arr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译时记得添加<code>/unsafe</code>参数。VS则需要在项目属性中勾选“允许不安全代码”。<br>fixed 语句禁止垃圾回收器重定位可移动的变量。 fixed 语句只在不安全的上下文中是允许的。 Fixed 还可用于创建固定大小缓冲区。 fixed 语句设置指向托管变量的指针，并在执行该语句期间“固定”此变量。 如果没有 fixed 语句，则指向可移动托管变量的指针的作用很小，因为垃圾回收可能不可预知地重定位变量。 C# 编译器只允许在 fixed 语句中分配指向托管变量的指针。    </p>
<h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><ol>
<li>类成员可以包括：常数、字段、方法、属性、事件、索引器、运算符、实例构造函数、析构函数、静态构造函数和嵌套类型声明。每个成员都有关联的可访问性，一共有5种可访问性，分别为：  </li>
</ol>
<ul>
<li>public 不限制访问。  </li>
<li>protected 访问限于该成员所属的类或从该类派生来的类型。  </li>
<li>internal 访问限于此程序。  </li>
<li>protected internal 访问限于此程序或从该成员所属的类派生的类型。  </li>
<li>private 访问限于该成员所属的类型。  </li>
<li><code>partial</code> 分部类型定义允许将类、结构或接口的定义拆分到多个文件中。  </li>
</ul>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">class</span> <span class="title">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">MyClass</span>()</span> &#123;</span><br><span class="line">      Console.WriteLine(<span class="string">&quot;Instance constructor&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">MyClass</span>(<span class="params"><span class="built_in">int</span> <span class="keyword">value</span></span>)</span> &#123;</span><br><span class="line">      MyField = <span class="keyword">value</span>;</span><br><span class="line">      Console.WriteLine(<span class="string">&quot;Instance constructor&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   ~MyClass() &#123;</span><br><span class="line">      Console.WriteLine(<span class="string">&quot;Destructor&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">const</span> <span class="built_in">int</span> MyConst = <span class="number">12</span>; <span class="comment">//常数成员，即可以在编译时确定的值</span></span><br><span class="line">   <span class="keyword">public</span> <span class="built_in">int</span> MyField = <span class="number">34</span>;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">MyMethod</span>()</span>&#123;</span><br><span class="line">      Console.WriteLine(<span class="string">&quot;MyClass.MyMethod&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="built_in">int</span> MyProperty &#123;</span><br><span class="line">      <span class="keyword">get</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> MyField;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">set</span> &#123;</span><br><span class="line">         MyField = <span class="keyword">value</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="built_in">int</span> <span class="keyword">this</span>[<span class="built_in">int</span> index] &#123;</span><br><span class="line">      <span class="keyword">get</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">set</span> &#123;</span><br><span class="line">         Console.WriteLine(<span class="string">&quot;this[&#123;0&#125;] = &#123;1&#125;&quot;</span>, index, <span class="keyword">value</span>);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">event</span> EventHandler MyEvent;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> MyClass <span class="keyword">operator</span>+(MyClass a, MyClass b) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> MyClass(a.MyField + b.MyField);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">MyNestedClass</span></span><br><span class="line">   &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Test</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span> &#123;</span><br><span class="line">      <span class="comment">// Instance constructor usage</span></span><br><span class="line">      MyClass a = <span class="keyword">new</span> MyClass();</span><br><span class="line">      MyClass b = <span class="keyword">new</span> MyClass(<span class="number">123</span>);</span><br><span class="line">      <span class="comment">// Constant usage</span></span><br><span class="line">      Console.WriteLine(<span class="string">&quot;MyConst = &#123;0&#125;&quot;</span>, MyClass.MyConst);</span><br><span class="line">      <span class="comment">// Field usage</span></span><br><span class="line">      a.MyField++;</span><br><span class="line">      Console.WriteLine(<span class="string">&quot;a.MyField = &#123;0&#125;&quot;</span>, a.MyField);</span><br><span class="line">      <span class="comment">// Method usage</span></span><br><span class="line">      a.MyMethod();</span><br><span class="line">      <span class="comment">// Property usage</span></span><br><span class="line">      a.MyProperty++;</span><br><span class="line">      Console.WriteLine(<span class="string">&quot;a.MyProperty = &#123;0&#125;&quot;</span>, a.MyProperty);</span><br><span class="line">      <span class="comment">// Indexer usage</span></span><br><span class="line">      a[<span class="number">3</span>] = a[<span class="number">1</span>] = a[<span class="number">2</span>];</span><br><span class="line">      Console.WriteLine(<span class="string">&quot;a[3] = &#123;0&#125;&quot;</span>, a[<span class="number">3</span>]);</span><br><span class="line">      <span class="comment">// Event usage</span></span><br><span class="line">      a.MyEvent += <span class="keyword">new</span> EventHandler(MyHandler);</span><br><span class="line">      <span class="comment">// Overloaded operator usage</span></span><br><span class="line">      MyClass c = a + b;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">MyHandler</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span> &#123;</span><br><span class="line">      Console.WriteLine(<span class="string">&quot;Test.MyHandler&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">MyNestedClass</span></span><br><span class="line">   &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>字段：  字段是一种成员，它表示与对象或类相关联的一个变量。 readonly 关键字是可以在字段上使用的修饰符。 当字段声明包括 readonly 修饰符时，该声明引入的字段赋值只能作为声明的一部分出现，或者出现在同一类的构造函数中。静态 readonly 字段可以在静态构造函数中赋值，而非静态 readonly 字段可以在实例构造函数中赋值。    <figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Color</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//4个实例字段</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">readonly</span> Color Red = <span class="keyword">new</span> Color(<span class="number">0xFF</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">readonly</span> Color Blue = <span class="keyword">new</span> Color(<span class="number">0</span>, <span class="number">0xFF</span>, <span class="number">0</span>);</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">readonly</span> Color Green = <span class="keyword">new</span> Color(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0xFF</span>);</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">readonly</span> Color White = <span class="keyword">new</span> Color(<span class="number">0xFF</span>, <span class="number">0xFF</span>, <span class="number">0xFF</span>);</span><br><span class="line">   <span class="comment">//声明3个内部实例字段</span></span><br><span class="line">   <span class="keyword">internal</span> <span class="built_in">ushort</span> redPart;</span><br><span class="line">   <span class="keyword">internal</span> <span class="built_in">ushort</span> bluePart;</span><br><span class="line">   <span class="keyword">internal</span> <span class="built_in">ushort</span> greenPart;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Color</span>(<span class="params"><span class="built_in">ushort</span> red, <span class="built_in">ushort</span> blue, <span class="built_in">ushort</span> green</span>)</span> &#123;</span><br><span class="line">      redPart = red;</span><br><span class="line">      bluePart = blue;</span><br><span class="line">      greenPart = green;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
字段可以直接在声明类的时候初始化。eg:  <figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">Color newCol = <span class="keyword">new</span> Color() &#123;redPart = red, bluePart = blue&#125;;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="3">
<li><p>方法：方法是一种成员，它用于实现可由对象或类执行的计算或操作。方法有一个形参表（可能是空的）、一个返回值（除非方法的返回类型为 void），它不是静态的，就是非静态的。通过类访问静态方法。通过类的实例访问非静态方法（也称为实例方法）。  要扩展或修改继承的方法、属性、索引器或事件的抽象实现或虚实现，必须使用 override 修饰符。  </p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Stack</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//只有静态方法才可以直接通过类访问，非静态方法必须首先创建实例，然后通过实例调用。</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Stack <span class="title">Clone</span>(<span class="params">Stack s</span>)</span> &#123;...&#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Stack <span class="title">Flip</span>(<span class="params">Stack s</span>)</span> &#123;...&#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="built_in">object</span> <span class="title">Pop</span>()</span> &#123;...&#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Push</span>(<span class="params"><span class="built_in">object</span> o</span>)</span> &#123;...&#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">string</span> <span class="title">ToString</span>()</span> &#123;...&#125;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Test</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span> &#123;</span><br><span class="line">      Stack s = <span class="keyword">new</span> Stack();</span><br><span class="line">      <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">         s.Push(i);</span><br><span class="line">      Stack flipped = Stack.Flip(s);</span><br><span class="line">      Stack cloned = Stack.Clone(s);</span><br><span class="line">      Console.WriteLine(<span class="string">&quot;Original stack: &quot;</span> + s.ToString());</span><br><span class="line">      Console.WriteLine(<span class="string">&quot;Flipped stack: &quot;</span> + flipped.ToString());</span><br><span class="line">      Console.WriteLine(<span class="string">&quot;Cloned stack: &quot;</span> + cloned.ToString());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>属性： 属性是一种成员，可用它来访问对象或类的某个特性。属性的示例包括字符串的长度、字体的大小、窗口的标题、客户的名称，等等。属性是字段的自然扩展。属性和字段都是命名的成员，都具有相关的类型，且用于访问字段和属性的语法也相同。属性用属性声明定义。属性声明的第一部分看上去与字段声明非常相似。第二部分包含一个 get 访问器和/或一个 set 访问器。可读取并写入的属性同时包含 get 和 set 访问器。当读取属性值时调用 get 访问器；当写入属性值时则调用 set 访问器。在 set 访问器中，属性的新值是通过一个名为 value 的隐式参数来赋值的。 属性声明相对直接一些，但是属性的实际值在它们被使用时才可见。在下面的示例中，Button 类定义一个 Caption 属性。 读取和写入 Caption 属性的方式可以与读取和写入字段相同：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Button</span> </span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="built_in">string</span> caption;</span><br><span class="line">   <span class="keyword">public</span> <span class="built_in">string</span> Caption &#123;</span><br><span class="line">      <span class="keyword">get</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> caption;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">set</span> &#123;</span><br><span class="line">         caption = <span class="keyword">value</span>;</span><br><span class="line">         Repaint();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">Button b = <span class="keyword">new</span> Button();</span><br><span class="line">b.Caption = <span class="string">&quot;ABC&quot;</span>;      <span class="comment">// set; causes repaint</span></span><br><span class="line"><span class="built_in">string</span> s = b.Caption;   <span class="comment">// get</span></span><br><span class="line">b.Caption += <span class="string">&quot;DEF&quot;</span>;      <span class="comment">// get &amp; set; causes repaint</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>事件： 事件是一种成员，对象或类能够通过它发送通知。类通过提供事件声明来定义事件。事件声明类似于字段声明，但它增加了 event 关键字和一组可选的事件访问器。用于声明事件的类型必须是某种委托类型。<br>一个委托类型的实例封装了一个或多个“可调用实体”。对于实例方法，可调用实体由一个实例和该实例的方法组成。对于静态方法，可调用实体仅由一个方法组成。当用一组合适的参数调用某个委托实例时，该委托实例所封装的每个可调用实体都会被逐个调用，且都使用给定的同一组参数。如下实例中， Button 类定义一个 EventHandler 类型的 Click 事件。在 Button 类的内部，Click 成员如同一个 EventHandler 类型的私有字段。而在 Button 类的外部，Click 成员只能用在 += 和 -= 运算符的左侧。+= 运算符为 Click 事件添加一个事件处理程序，而 -= 运算符则为它移除一个事件处理程序。   </p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">EventHandler</span>(<span class="params"><span class="built_in">object</span> sender, System.EventArgs e</span>)</span>;  <span class="comment">//delegate 用户定义委托</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Button</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">event</span> EventHandler Click;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Reset</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Click = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Form1</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Form1</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Add Button1_Click as an event handler for Button1&#x27;s Click event</span></span><br><span class="line">        Button1.Click += <span class="keyword">new</span> EventHandler(Button1_Click);</span><br><span class="line">    &#125;</span><br><span class="line">    Button Button1 = <span class="keyword">new</span> Button();</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Button1_Click</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Button1 was clicked!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Disconnect</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Button1.Click -= <span class="keyword">new</span> EventHandler(Button1_Click);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Form1 f = <span class="keyword">new</span> Form1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>运算符：运算符是一种成员，它用来定义表达式运算符的含义，使其能应用于属于类的实例。可以定义三种运算符：一元运算符、二元运算符和转换运算符。所有运算符都必须声明为公共的和静态的。<br>下面的示例定义一个表示十进制数字（介于 0 和 9 之间的整数值）的 Digit 类型。<br>此 Digit 类型定义下列运算符：  </p>
<ul>
<li>从 Digit 到 byte 的隐式转换运算符。  </li>
<li>从 byte 到 Digit 的显式转换运算符。  </li>
<li>将两个 Digit 值相加并返回一个 Digit 值的加法运算符。  </li>
<li>从一个 Digit 值中减去另一个 Digit 值并返回一个 Digit 值的减法运算符。  </li>
<li>相等 (==) 和不相等 (!=) 运算符，它们对两个 Digit 值进行比较。  <figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> Digit</span><br><span class="line">&#123;</span><br><span class="line">   <span class="built_in">byte</span> <span class="keyword">value</span>;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Digit</span>(<span class="params"><span class="built_in">byte</span> <span class="keyword">value</span></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">value</span> &lt; <span class="number">0</span> || <span class="keyword">value</span> &gt; <span class="number">9</span>) <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentException();</span><br><span class="line">      <span class="keyword">this</span>.<span class="keyword">value</span> = <span class="keyword">value</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Digit</span>(<span class="params"><span class="built_in">int</span> <span class="keyword">value</span></span>): <span class="title">this</span>(<span class="params">(<span class="built_in">byte</span></span>) <span class="keyword">value</span>)</span> &#123;&#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">implicit</span> <span class="keyword">operator</span> <span class="title">byte</span>(<span class="params">Digit d</span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> d.<span class="keyword">value</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="title">Digit</span>(<span class="params"><span class="built_in">byte</span> b</span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Digit(b);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> Digit <span class="keyword">operator</span>+(Digit a, Digit b) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Digit(a.<span class="keyword">value</span> + b.<span class="keyword">value</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> Digit <span class="keyword">operator</span>-(Digit a, Digit b) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Digit(a.<span class="keyword">value</span> - b.<span class="keyword">value</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">bool</span> <span class="keyword">operator</span>==(Digit a, Digit b) &#123;</span><br><span class="line">      <span class="keyword">return</span> a.<span class="keyword">value</span> == b.<span class="keyword">value</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">bool</span> <span class="keyword">operator</span>!=(Digit a, Digit b) &#123;</span><br><span class="line">      <span class="keyword">return</span> a.<span class="keyword">value</span> != b.<span class="keyword">value</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">bool</span> <span class="title">Equals</span>(<span class="params"><span class="built_in">object</span> <span class="keyword">value</span></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">value</span> == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">if</span> (GetType() == <span class="keyword">value</span>.GetType()) <span class="keyword">return</span> <span class="keyword">this</span> == (Digit)<span class="keyword">value</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">int</span> <span class="title">GetHashCode</span>()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">value</span>.GetHashCode();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">string</span> <span class="title">ToString</span>()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">value</span>.ToString();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Test</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span> &#123;</span><br><span class="line">      Digit a = (Digit) <span class="number">5</span>;</span><br><span class="line">      Digit b = (Digit) <span class="number">3</span>;</span><br><span class="line">      Digit plus = a + b;</span><br><span class="line">      Digit minus = a - b;</span><br><span class="line">      <span class="built_in">bool</span> <span class="keyword">equals</span> = (a == b);</span><br><span class="line">      Console.WriteLine(<span class="string">&quot;&#123;0&#125; + &#123;1&#125; = &#123;2&#125;&quot;</span>, a, b, plus);</span><br><span class="line">      Console.WriteLine(<span class="string">&quot;&#123;0&#125; - &#123;1&#125; = &#123;2&#125;&quot;</span>, a, b, minus);</span><br><span class="line">      Console.WriteLine(<span class="string">&quot;&#123;0&#125; == &#123;1&#125; = &#123;2&#125;&quot;</span>, a, b, <span class="keyword">equals</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<code>operator</code>关键字：使用 operator 关键字来重载内置运算符，或提供类或结构声明中的用户定义转换。  </li>
</ul>
</li>
<li><p>索引器：索引器是一种成员，它使对象能够用与数组相同的方式进行索引。属性启用类似字段的访问，而索引器启用类似数组的访问。<br>例如，请看一下前面研究过的 Stack 类。该类的设计者可能想提供类似数组的访问，以便不必执行 Push 和 Pop 操作，就可以检查或改变堆栈上的各个项。也就是说，使 Stack 类既是链接表，又可像数组一样方便地对它进行访问。<br>索引器声明类似于属性声明，主要区别是索引器是无名称的（由于 this 被索引，因此在声明中使用的“名称”为 this），而且索引器包含索引参数。索引参数在方括号中提供。示例 </p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Stack</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="function"><span class="keyword">private</span> Node <span class="title">GetNode</span>(<span class="params"><span class="built_in">int</span> index</span>)</span> &#123;</span><br><span class="line">      Node temp = first; </span><br><span class="line">      <span class="keyword">while</span> (index &gt; <span class="number">0</span> &amp;&amp; temp != <span class="literal">null</span>) &#123;</span><br><span class="line">         temp = temp.Next;</span><br><span class="line">         index--;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (index &lt; <span class="number">0</span> || temp == <span class="literal">null</span>)</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;Index out of range.&quot;</span>);      <span class="keyword">return</span> temp;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="built_in">object</span> <span class="keyword">this</span>[<span class="built_in">int</span> index] &#123;</span><br><span class="line">      <span class="keyword">get</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> GetNode(index).Value;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">set</span> &#123;</span><br><span class="line">         GetNode(index).Value = <span class="keyword">value</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Test</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span> &#123;</span><br><span class="line">      Stack s = <span class="keyword">new</span> Stack();</span><br><span class="line">      s.Push(<span class="number">1</span>);</span><br><span class="line">      s.Push(<span class="number">2</span>);</span><br><span class="line">      s.Push(<span class="number">3</span>);</span><br><span class="line">      s[<span class="number">0</span>] = <span class="number">33</span>;   <span class="comment">// Changes the top item from 3 to 33</span></span><br><span class="line">      s[<span class="number">1</span>] = <span class="number">22</span>;   <span class="comment">// Changes the middle item from 2 to 22</span></span><br><span class="line">      s[<span class="number">2</span>] = <span class="number">11</span>;   <span class="comment">// Changes the bottom item from 1 to 11</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>实例构造函数是一种成员，用来实现初始化一个类的实例时所需的操作。如果没有为某个类提供任何实例构造函数，则将自动提供一个不带参数的空实例构造函数。  </p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Point</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="built_in">double</span> x, y;</span><br><span class="line">   <span class="comment">//无参数的构造函数</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Point</span>()</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.x = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">this</span>.y = <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//带参数的构造函数</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Point</span>(<span class="params"><span class="built_in">double</span> x, <span class="built_in">double</span> y</span>)</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.x = x;</span><br><span class="line">      <span class="keyword">this</span>.y = y;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">double</span> <span class="title">Distance</span>(<span class="params">Point a, Point b</span>)</span> &#123;</span><br><span class="line">      <span class="built_in">double</span> xdiff = a.x + b.x;</span><br><span class="line">      <span class="built_in">double</span> ydiff = a.y + b.y;</span><br><span class="line">      <span class="keyword">return</span> Math.Sqrt(xdiff * xdiff + ydiff * ydiff);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">string</span> <span class="title">ToString</span>()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">string</span>.Format(<span class="string">&quot;(&#123;0&#125;, &#123;1&#125;)&quot;</span>, x, y);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Test</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span> &#123;</span><br><span class="line">      Point a = <span class="keyword">new</span> Point();</span><br><span class="line">      Point b = <span class="keyword">new</span> Point(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">      <span class="built_in">double</span> d = Point.Distance(a, b);</span><br><span class="line">      Console.WriteLine(<span class="string">&quot;Distance from &#123;0&#125; to &#123;1&#125; is &#123;2&#125;&quot;</span>, a, b, d);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>析构函数是一种成员，用来实现析构一个类实例所需的操作。析构函数不能带参数，不能具有可访问性修饰符，也不能被显式调用。垃圾回收期间会自动调用所涉及实例的析构函数。 </p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Point</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="built_in">double</span> x, y;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Point</span>(<span class="params"><span class="built_in">double</span> x, <span class="built_in">double</span> y</span>)</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.x = x;</span><br><span class="line">      <span class="keyword">this</span>.y = y;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//析构函数</span></span><br><span class="line">   ~Point() &#123;</span><br><span class="line">      Console.WriteLine(<span class="string">&quot;Destructed &#123;0&#125;&quot;</span>, <span class="keyword">this</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">string</span> <span class="title">ToString</span>()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">string</span>.Format(<span class="string">&quot;(&#123;0&#125;, &#123;1&#125;)&quot;</span>, x, y);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>静态构造函数是一种成员，用来实现初始化一个类所需的操作。静态构造函数不能带参数，不能具有可访问性修饰符，也不能被显式调用。类的静态构造函数是自动地被调用的。   </p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> Personnel.Data;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Employee</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> DataSet ds;</span><br><span class="line">   <span class="function"><span class="keyword">static</span> <span class="title">Employee</span>()</span> &#123;</span><br><span class="line">      ds = <span class="keyword">new</span> DataSet(...);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="built_in">string</span> Name;</span><br><span class="line">   <span class="keyword">public</span> <span class="built_in">decimal</span> Salary;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>继承：类支持单一继承，而类型 object 是所有类的最终基类。 也就是说只要你声明了一个新类，默认地他继承于<code>object</code>类。eg:  </p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="comment">//类A隐式地从object派生的类A。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">A</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">F</span>()</span> &#123; Console.WriteLine(<span class="string">&quot;A.F&quot;</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//类B显式地继承于A，即从A派生的类B，B也继承了A的F方法，并添加了方法G</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">B</span>: <span class="title">A</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">G</span>()</span> &#123; Console.WriteLine(<span class="string">&quot;B.G&quot;</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Test</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span> &#123;</span><br><span class="line">      B b = <span class="keyword">new</span> B();</span><br><span class="line">      b.F();         <span class="comment">// Inherited from A</span></span><br><span class="line">      b.G();         <span class="comment">// Introduced in B</span></span><br><span class="line">      A a = b;         <span class="comment">// Treat a B as an A</span></span><br><span class="line">      a.F();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//显示了一个包含虚方法 F 的类 A 和一个类 B（它重写了 F）。B 中的重写方法包含一个调用 base.F()，它调用 A 中被重写的方法。 一个类可以使用 abstract 修饰符来指示它自己是不完整的，只打算用作其他类的基类。这样的类称为抽象类。抽象类可以指定抽象成员，即非抽象派生类必须实现的成员。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//在抽象类 A 中引入了抽象方法 F。非抽象类 B 提供此方法的实现。</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">A</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">F</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">B</span>: <span class="title">A</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">F</span>()</span> &#123; Console.WriteLine(<span class="string">&quot;B.F&quot;</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Test</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span> &#123;</span><br><span class="line">      B b = <span class="keyword">new</span> B();</span><br><span class="line">      b.F();</span><br><span class="line">      A a = b;</span><br><span class="line">      a.F();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要扩展或修改继承的方法、属性、索引器或事件的抽象实现或虚实现，必须使用<code>override</code>修饰符。   </p>
</li>
<li><p>函数的默认可见必为<code>private</code>，<code>internal</code>为命名空间内可见。</p>
</li>
</ol>
<h2 id="结构"><a href="#结构" class="headerlink" title="结构　"></a>结构　</h2><p>类与结构有很多相似之处：结构可以实现接口，并且可以具有与类相同的成员类型。然而，结构在几个重要方面不同于类：结构为值类型而不是引用类型，并且结构不支持继承。结构的值存储在“在堆栈上”或“内联”。细心的程序员有时可以通过聪明地使用结构来增强性能。    eg:   </p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//通过类实现的Point</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Point</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="built_in">int</span> x, y;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Point</span>(<span class="params"><span class="built_in">int</span> x, <span class="built_in">int</span> y</span>)</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.x = x;</span><br><span class="line">      <span class="keyword">this</span>.y = y;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Test</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span> &#123;</span><br><span class="line">      Point[] points = <span class="keyword">new</span> Point[<span class="number">100</span>];</span><br><span class="line">      <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">         points[i] = <span class="keyword">new</span> Point(i, i*i);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过结构实现的Point</span></span><br><span class="line"><span class="comment">//如果将其应用于上述Test,则只出现一个实例对象（用于数组的对象）。Point 实例在数组中内联分配。此优化可能会被误用。使用结构而不是类还会使应用程序运行得更慢或占用更多的内存，因为将结构实例作为值参数传递会导致创建结构的副本。  </span></span><br><span class="line"><span class="keyword">struct</span> Point</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="built_in">int</span> x, y;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Point</span>(<span class="params"><span class="built_in">int</span> x, <span class="built_in">int</span> y</span>)</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.x = x;</span><br><span class="line">      <span class="keyword">this</span>.y = y;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>接口使用关键字<code>interface</code>定义，一个接口定义一个协定。实现接口的类或结构必须遵守其协定。接口可以包含方法、属性、索引器和事件作为成员。   实现接口的类或结构必须实现接口定义中指定的接口成员。  接口可以使用多重继承。类和结构可以实现多个接口。    </p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//声明了一个包含索引器、事件E、方法F和属性P的接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title">IExample</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="built_in">string</span> <span class="keyword">this</span>[<span class="built_in">int</span> index] &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">   <span class="keyword">event</span> EventHandler E;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">F</span>(<span class="params"><span class="built_in">int</span> <span class="keyword">value</span></span>)</span>;</span><br><span class="line">   <span class="built_in">string</span> P &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">EventHandler</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//接口实现的多重继承，接口 IComboBox 同时从 ITextBox 和 IListBox 继承。</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title">IControl</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">Paint</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title">ITextBox</span>: <span class="title">IControl</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">SetText</span>(<span class="params"><span class="built_in">string</span> text</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title">IListBox</span>: <span class="title">IControl</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">SetItems</span>(<span class="params"><span class="built_in">string</span>[] items</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title">IComboBox</span>: <span class="title">ITextBox</span>, <span class="title">IListBox</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//类实现的多个接口，类 EditBox 从类 Control 派生，并且同时实现 IControl 和 IDataBound。 </span></span><br><span class="line"><span class="keyword">interface</span> <span class="title">IDataBound</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">Bind</span>(<span class="params">Binder b</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">EditBox</span>: <span class="title">Control</span>, <span class="title">IControl</span>, <span class="title">IDataBound</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Paint</span>()</span> &#123;...&#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Bind</span>(<span class="params">Binder b</span>)</span> &#123;...&#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">在前面的示例中，IControl 接口中的 Paint 方法和 IDataBound 接口中的 Bind 方法是使用 EditBox 类的公共成员实现的。</span></span><br><span class="line"><span class="comment">C# 提供了另一种方式来实现这些方法，使得实现类避免将这些成员设置成公共的。</span></span><br><span class="line"><span class="comment">这就是：接口成员可以用限定名来实现。例如，在 EditBox 类中将 Paint 方法命名为</span></span><br><span class="line"><span class="comment">IControl.Paint，将 Bind 方法命名为 IDataBound.Bind 方法。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">EditBox</span>: <span class="title">IControl</span>, <span class="title">IDataBound</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">void</span> IControl.Paint() &#123;...&#125;</span><br><span class="line">   <span class="keyword">void</span> IDataBound.Bind(Binder b) &#123;...&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">用这种方式实现的接口成员称为显式接口成员，这是因为每个成员都显式地指定要实现的接口成员。</span></span><br><span class="line"><span class="comment">显式接口成员只能通过接口来调用。例如，在 EditBox 中实现的 Paint </span></span><br><span class="line"><span class="comment">方法只能通过强制转换为 IControl 接口来调用。测试如下</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Test</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span> &#123;</span><br><span class="line">      EditBox editbox = <span class="keyword">new</span> EditBox();</span><br><span class="line">      editbox.Paint();   <span class="comment">// error: no such method</span></span><br><span class="line">      IControl control = editbox;</span><br><span class="line">      control.Paint();   <span class="comment">// calls EditBox&#x27;s Paint implementation</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="委托"><a href="#委托" class="headerlink" title="委托"></a>委托</h2><p>委托使用关键字<code>delegate</code>声明。委托适用于那种在某些其他语言中需用函数指针来解决的情况（场合）。但是，与函数指针不同，委托是面向对象和类型安全的。 委托声明定义一个类，它是从 System.Delegate 类派生的类。委托实例封装了一个调用列表，该列表列出了一个或多个方法，每个方法称为一个可调用实体。对于实例方法，可调用实体由一个实例和该实例的方法组成。对于静态方法，可调用实体仅由一个方法组成。如果用一组合适的参数来调用一个委托实例，则该委托实例所封装的每个可调用实体都会被调用，并且用的都是上述的同一组参数。<br>委托实例的一个有趣且有用的属性是：它既不知道也不关心有关它所封装的方法所属的类的种种详情；对它来说最重要的是这些方法与该委托的类型兼容。   </p>
<p>定义和使用委托分三个步骤：声明、实例化和调用。  eg:  </p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//声明一个名为SimpleDelegate的委托</span></span><br><span class="line"><span class="function"><span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">SimpleDelegate</span>()</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Test</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">F</span>()</span> &#123;</span><br><span class="line">      System.Console.WriteLine(<span class="string">&quot;Test.F&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span> &#123;</span><br><span class="line">   <span class="comment">//创建一个委托实例并调用</span></span><br><span class="line">      SimpleDelegate d = <span class="keyword">new</span> SimpleDelegate(F);</span><br><span class="line">      d();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重复调用委托委托的方法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MultiCall</span>(<span class="params">SimpleDelegate d, <span class="built_in">int</span> count</span>)</span> &#123;</span><br><span class="line">   <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">      d();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><p>与C/C++中一样，没什么可说的。枚举类型声明为一组相关的符号常数定义了一个类型名称。枚举用于“多项选择”场合，就是程序运行时从编译时已经设定的固定数目的“选择”中做出决定。使用枚举的好处使用枚举胜过使用整数常数（在没有枚举的语言中很常见），这是因为使用枚举使代码更具可读性和自归档。注意枚举其实就是多选一。  </p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">enum</span> Color </span><br><span class="line">&#123;</span><br><span class="line">   Red,</span><br><span class="line">   Blue,</span><br><span class="line">   Green</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Shape</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Fill</span>(<span class="params">Color color</span>)</span> &#123;</span><br><span class="line">      <span class="keyword">switch</span>(color) &#123;</span><br><span class="line">         <span class="keyword">case</span> Color.Red:</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">case</span> Color.Blue:</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">case</span> Color.Green:</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">         <span class="literal">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="命名空间和程序集"><a href="#命名空间和程序集" class="headerlink" title="命名空间和程序集"></a>命名空间和程序集</h2><p>命名空间和程序集有助于开发基于组件的系统。命名空间提供一个逻辑组织体系。命名空间既用作程序的“内部”组织体系，也用作“外部”组织体系（一种表示向其他程序公开程序元素的途径）。</p>
<p>程序集用于物理打包和部署。程序集可以包含类型、用于实现这些类型的可执行代码以及对其他程序集的引用。</p>
<p>有两种主要的程序集：应用程序和库。应用程序有一个主入口点，通常具有 .exe 文件扩展名；而库没有主入口点，通常具有 .dll 文件扩展名。将hello world程序分成dll和exe的实例主要分成两步：编写dll组件和编写调用dll组件的应用程序。  </p>
<ol>
<li><code>HelloLibrary.dll的源程序：</code>   <figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HelloLibrary.cs</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Microsoft.CSharp.Introduction</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">HelloMessage</span></span><br><span class="line">   &#123;</span><br><span class="line">      <span class="keyword">public</span> <span class="built_in">string</span> Message &#123;</span><br><span class="line">         <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;hello, world&quot;</span>;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>将其编译为<code>.dll</code>的方法为<code>csc /target:library HelloLibrary.cs</code>，会生成一个名为<code>HelloLibrary.dll</code>的文件。<br>关于命名空间的组织方式中   </p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">Microsoft.CSharp.Introduction</span></span><br><span class="line">&#123;...&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>等价于：    </p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">Microsoft</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">namespace</span> <span class="title">CSharp</span></span><br><span class="line">   &#123;</span><br><span class="line">      <span class="keyword">namespace</span> <span class="title">Introduction</span></span><br><span class="line">      &#123;...&#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<ol start="2">
<li>将“hello, world”组件化的下一个步骤是编写使用 HelloMessage 类的控制台应用程序。可以使用此类的完全限定名 Microsoft.CSharp.Introduction.HelloMessage，但该名称太长，使用起来不方便。一种更方便的方法是使用“using 命名空间指令”，这样，使用相应的命名空间中的所有类型时就不必加限定名称。  <figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HelloApp.cs</span></span><br><span class="line"><span class="keyword">using</span> Microsoft.CSharp.Introduction;</span><br><span class="line"><span class="keyword">class</span> <span class="title">HelloApp</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span> &#123;</span><br><span class="line">      HelloMessage m = <span class="keyword">new</span> HelloMessage();</span><br><span class="line">      System.Console.WriteLine(m.Message);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
调用<code>.dll</code>的编译方法为<code>csc /reference:HelloLibrary.dll HelloApp.cs</code>，编译后会生成一个<code>HelloApp.exe</code>的可执行文件。  </li>
</ol>
<p>C# 还允许定义和使用别名。using 别名指令定义类型的别名。当两个类库之间发生名称冲突时，或者当使用大得多的命名空间中的少数类型时，这类别名很有用。<code>using MessageSource = Microsoft.CSharp.Introduction.HelloMessage;</code>  </p>
<p>这样就可以将<code>Hello World</code>程序组件化，只有将相应的<code>.dll</code>文件和<code>.exe</code>放入同一文件夹下才能正常运行。    </p>
<h2 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a>版本控制</h2><p>版本控制是一个过程，它以兼容的方式对组件进行不断的改进。如果依赖于早期版本的代码重新编译后可以适用于新版本，则组件的新版本与早期版本源代码兼容。相反，如果依赖于早期版本的应用程序不用重新编译即可适用于新版本，则组件的新版本为二进制兼容。<br>使用<code>new</code>关键字和<code>override</code>关键字来明确对父类方法的隐藏或者重写。eg: </p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">F</span>()</span> &#123;</span><br><span class="line">   System.Console.WriteLine(<span class="string">&quot;Derived.F&quot;</span>); </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">F</span>()</span> &#123;</span><br><span class="line">   <span class="keyword">base</span>.F();</span><br><span class="line">   System.Console.WriteLine(<span class="string">&quot;Derived.F&quot;</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><h2 id="其他总结"><a href="#其他总结" class="headerlink" title="其他总结"></a>其他总结</h2><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><ol>
<li>所有<code>String</code>类方法官方链接：<a href="https://msdn.microsoft.com/zh-cn/library/system.string.aspx">https://msdn.microsoft.com/zh-cn/library/system.string.aspx</a>  </li>
</ol>
]]></content>
      <categories>
        <category>Csharp</category>
      </categories>
      <tags>
        <tag>Csharp</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Streaming MultiProcessor、Register、Shared-Memory对线程块尺寸的影响</title>
    <url>/2015/08/12/Determine-block-size/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>线程块中线程总数的大小除了受到硬件中<code>Max Threads Per block</code>的限制，同时还要受到<code>Streaming Multiprocessor、Register</code>和<code>Shared Memory</code>的影响。这些条件的共同作用下可以获得一个相对更合适的<code>block</code>尺寸。当<code>block</code>尺寸太小时，将无法充分利用所有线程；当<code>block</code>尺寸太大时，如果线程需要的资源总和过多，<code>CUDA</code>将通过强制减少<code>block</code>数量来保证资源供应，同样无法利用所有线程。而<code>grid</code>的尺寸通常越大越好，当然够用就可以了，以免浪费资源。  </p>
<span id="more"></span>

<p>本文需要通过<code>NVIDIA</code>官方提供的一个非常有用的工具<code>C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v7.0\tools\CUDA_Occupancy_Calculator.xls</code>进行辅助计算来获得合适的<code>block</code>大小。这个<code>excle</code>表中的<code>Help</code>表单有详细的使用说明，以下分析将基于这个工具。<br>可以通过在编译时添加<code>--ptxas-options=-v</code>参数在编译时输出当前程序中所使用的<code>Register</code>和<code>Shared Memory</code>大小。</p>
<h2 id="SM的限制对block尺寸的影响"><a href="#SM的限制对block尺寸的影响" class="headerlink" title="SM的限制对block尺寸的影响"></a>SM的限制对block尺寸的影响</h2><p><code>Multiprocessor</code>(以下所有的<code>Multiprocessor</code>都是指<code>Streaming Multiprocessor</code>，即SM,具体SM在GPU中的结构组织参见<a href="http://notes.maxwi.com/2015/06/11/CUDA-study-notes/">http://notes.maxwi.com/2015/06/11/CUDA-study-notes/</a>基本概念中的图示)中<code>thread</code>数量的限制主要影响工作状态的线程是否能够占满当前的整个<code>Multiprocessor</code>。为了使工作状态的线程能够占满整个<code>Multiprocessor</code>，<code>block</code>中的<code>thread</code>的总数应当不小于<code>Max Threads Per Multiprocessor / Max Thread Blocks Per Multiprocessor</code>。</p>
<p>下图所示为CUDA_Occupancy_Calculator给出的计算能力为5.0的GPU的参数。<br><img data-src="1.png" alt="Physical Limits for GPU Compute Capability">  </p>
<p>此时线程块的中线程数量应当不小于2048/32 = 64。当线程块的数量小于64时，由于每个Multiprocessor中可以含有的最大线程块只有32个，所以此时32个线程块乘以这个小于64的数字必然要小于2048，也就是无论怎样都无法使线程填满整个Multiprocessor，导致SM中会有空闲的Streaming Processor。所以根据要填满SM，则要求每个线程块中至少需要有64个线程。如果将线程块尺寸设置为1024，则此时根据SM总线程的限制2048，每个SM可以启动2个线程块。</p>
<p>注意：1). 当前计算能力5.0的设备每个线程块中线程数量上限Maximum Thread Block Size=1024、2). CUDA中线程组织单位为Wrap，此处Threads per Warp=32，所以线程块中的线程数量应为32的倍数。3). 各维都有大小限制，计算能力5.0的三维分别为1024,1024,64</p>
<h2 id="CUDA-Occupancy-Calculator的使用"><a href="#CUDA-Occupancy-Calculator的使用" class="headerlink" title="CUDA_Occupancy_Calculator的使用"></a>CUDA_Occupancy_Calculator的使用</h2><p>下图为<code>CUDA_Occupancy_Calculator</code>计算结果，由于此处只讨论了SM中线程及线程块的限制对<code>block</code>尺寸的影响，所以这里只需要使曲线的红三角在波峰即可。注意第一张图中的1.)、1.b)需要根据自己的硬件情况进行选择；2).需要自己填入的程序参数(可以通过2.2的方法获得)，3).工具计算出的GPU使用率，显示此时占用为100%，也就是SM中的活动线程束为64个，即64*32。其他各图是其对应的曲线，由第二幅图可以看出在<code>register</code>和<code>shared memory</code>固定的情况下，block尺寸设置为256, 512, 1024时都可以占满SM，因为它们都有以下特点：1). 大于64，满足不小于<code>Max Threads Per Multiprocessor / Max Thread Blocks Per Multiprocessor</code>; 2). 32的整数倍，满足线程束的最小单位Wrap; 3). 可以被2048整除，因为<code>Max Threads Per Multiprocessor=2048</code>。<br><img data-src="2.png" alt="CUDA Occupancy Calculator"><br><img data-src="3.png" alt="Impact of Varying Block Size"><br><img data-src="4.png" alt="Impact of Varying Shared Memory Usage Per Block"><br><img data-src="5.png" alt="Impact of Varying Register Count Per Thread ">  </p>
<h2 id="Register对block尺寸的影响"><a href="#Register对block尺寸的影响" class="headerlink" title="Register对block尺寸的影响"></a>Register对block尺寸的影响</h2><p>计算能力为5.0的设备<code>Registers per Multiprocessor=65536，Max Registers per Thread=256</code>。也就是说一个SM总共也就只有65536个<code>register</code>，一个<code>thread</code>最多能定义256大小的<code>register</code>，根据上图可以看出，显然当<code>Register Per Thread</code>大于32时性能就要开始降低了。因为当前情况下SM中的所有线程都被占满了(此处占满意思是所有线程都为活动线程)，也就是说在这种block参数配置下，一个SM最多可以启动2048个线程(注意是最多可以，并不是说一定要，比如我一共就1000个数据，当然就启动1000个线程就可以了)，由于SM中能使用的register最多只有65536，当SM中的资源不够用时，SM就会强制减少block，所以<code>Register Per Thread</code>应该不大于<code>Registers per Multiprocessor / Max Threads per Multiprocessor</code>，也就是65536 / 2048 = 32</p>
<h2 id="Shared-Memory对block尺寸的影响"><a href="#Shared-Memory对block尺寸的影响" class="headerlink" title="Shared Memory对block尺寸的影响"></a>Shared Memory对block尺寸的影响</h2><p>计算能力为5.0的设备<code>Shared Memory per Multiprocessor (bytes)=65536，Max Shared Memory per Block=49152</code>。也就是说block中的<code>smem(Shared Memory)</code>必须要小于49152，要想使得SM中的线程全部占满，那么整个SM中占用的smem必须小于65536。由于smem是以block为单位进行分配，所以当smem不够用时也就会以block为单位进行减少线程。所以<code>Shared Memory Per Block (bytes)</code>应该不大于<code>Shared Memory per Multiprocessor / Active Thread Blocks per Multiprocessor = Shared Memory per Multiprocessor / (Max Threads per Multiprocessor / Threads Per Block)</code>，当block尺寸设置为256时，<code>Shared Memory Per Block (bytes)</code>最大值为65536 / (2048/256) = 8192。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>block最佳尺寸应该满足：<br>1). 不小于<code>Max Threads Per Multiprocessor / Max Thread Blocks Per Multiprocessor</code>；<br>2). 32的整数倍；<br>3). 可以被<code>Max Threads Per Multiprocessor</code>整除。  </p>
<p>4). <code>Register Per Thread</code>应该不大于<code>Registers per Multiprocessor / Max Threads per Multiprocessor</code>，否则根据<code>CUDA_Occupancy_Calculator.xls</code>参考调节block尺寸以获得最佳性能。  </p>
<p>5). <code>Shared Memory Per Block (bytes)</code>最大值应该不大于<code>Shared Memory per Multiprocessor / (Max Threads per Multiprocessor / Threads Per Block)</code>，否则根据<code>CUDA_Occupancy_Calculator.xls</code>参考调节block尺寸以获得最佳性能。  </p>
<p>注意：  </p>
<ol>
<li>没有标明单位的量其单位都为个。  </li>
<li><code>CUDA_Occupancy_Calculator</code>给出了<code>register</code>和<code>shared memory</code>的分配单位，精确优化时应该非常有用。<br>Register allocation unit size        256<br>Register allocation granularity        warp<br>Shared Memory allocation unit size  256<br>Warp allocation granularity         4   </li>
</ol>
]]></content>
      <categories>
        <category>CUDA</category>
      </categories>
      <tags>
        <tag>CUDA</tag>
        <tag>Notes</tag>
      </tags>
  </entry>
  <entry>
    <title>C++学习笔记之基础</title>
    <url>/2015/06/22/cpp-study-notes/</url>
    <content><![CDATA[<h1 id="关于本文"><a href="#关于本文" class="headerlink" title="关于本文"></a>关于本文</h1><p>主要是看《C++ primer》时的总结，由于以前学习过C++，所以仅仅记录了自己忘记的以及一些之前没有弄明白的东西。本文举例全部通过gcc 5.1.2验证，使用g++编译进可以通过指定<code>-std=c++11</code>或<code>-std=c++0x</code>来启用对C++11的支持。eg: <code>g++ -o hello hello.cpp -std=c++11 -Wall</code>，<code>-Wall</code>是开启警告。<br>参考手册：<br>1.cplusplus Reference，包含了C++和C的标准库，并带有示例： <a href="http://www.cplusplus.com">http://www.cplusplus.com</a><br>2.cppreference配全上面使用，该站点有中文版本：<a href="http://www.cppreference.com">http://www.cppreference.com</a><br>其他资料：<br>1.C++中指针和引用的区别：<a href="http://stackoverflow.com/questions/57483/what-are-the-differences-between-a-pointer-variable-and-a-reference-variable-in">http://stackoverflow.com/questions/57483/what-are-the-differences-between-a-pointer-variable-and-a-reference-variable-in</a><br>2.<code>const int*</code>、<code>const int * const</code>、<code>int const *</code>的区别：<a href="http://stackoverflow.com/questions/1143262/what-is-the-difference-between-const-int-const-int-const-and-int-const">http://stackoverflow.com/questions/1143262/what-is-the-difference-between-const-int-const-int-const-and-int-const</a><br>3.什么是C++11中的<code>rvalue</code>、<code>lvalue</code>、<code>xvalue</code>、<code>glvalue</code>、<code>prvalue</code>：<a href="http://stackoverflow.com/questions/3601602/what-are-rvalues-lvalues-xvalues-glvalues-and-prvalues">http://stackoverflow.com/questions/3601602/what-are-rvalues-lvalues-xvalues-glvalues-and-prvalues</a>   </p>
<span id="more"></span>  
<p>4.使迭代器失效的规则解释：<a href="http://stackoverflow.com/questions/6438086/iterator-invalidation-rules">http://stackoverflow.com/questions/6438086/iterator-invalidation-rules</a>   </p>
<h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><p>1.注释与”交替出现时，谁在前面先匹配谁：<br><code>std::cout &lt;&lt; /* &quot;*/&quot; /* &quot;/*&quot; */;</code>输出为<code>/*</code>，因为出现<code>/*</code>时后面的第一个<code>*/</code>会自动与其匹配，然后<code>&quot;</code>出现时它会与后面的第一个<code>&quot;</code>进行匹配。注释会被编译器直接忽略掉。  </p>
<p>2.以下输出结果为2^32 - 32  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> a = <span class="number">10</span>, b = <span class="number">42</span>;</span><br><span class="line">std::cout &lt;&lt; a - b &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>

<p>3.C++支持的4种变量初始化的方法：  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">a</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="comment">//以下仅在C++11中支持，好处之一是当变量无法容纳初始值时不会进行强制类型转换</span></span><br><span class="line"><span class="type">int</span> a = &#123;<span class="number">1</span>&#125;;</span><br><span class="line"><span class="type">int</span> a&#123;<span class="number">1</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>1.通常标准库的头文件使用尖括号<code>&lt;&gt;</code>，非标准库的头文件使用双引号””。</p>
<p>2.函数体外的变量会被自动初始化为0，函数体内的变量不会被自动初始化。</p>
<p>3.extern 可用于声明该变量在其他地方有定义(extern int a;)，或者可以在函数外部定义全局变量(extern int a = 10;)。</p>
<p>4.定义const变量(常量)必须在定义时初始化。如果const变量不是用常量表达式初始化，不应该将其在头文件中定义，该const变量应该在一个源文件中定义并初始化，并在头文件中为它添加extern声明，以使其能被多个文件共享。</p>
<p>7.头文件应该用于声明而不是定义，<code>extern int ival = 10;</code>和<code>double cash;</code>都属于定义。但头文件中可以定义类、值在编译时就已经知道的const对象和inline函数。</p>
<p>8.通过定义预处理器变量来避免重复包含头文件。eg:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> HELLO_H   <span class="comment">//测试是否定义该预处理器变量，若没有定义，则后面的所有定义都执行，直到#endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HELLO_h</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Sales_item</span> &#123;</span><br><span class="line">    std::string bookNo;</span><br><span class="line">    <span class="type">unsigned</span> units_sold = <span class="number">0</span>;</span><br><span class="line">    <span class="type">double</span> revenue = <span class="number">0.0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>9.引用的定义方式为<code>int &amp;a = b;</code>表示 a是b的别名。</p>
<h1 id="string"><a href="#string" class="headerlink" title="string"></a>string</h1><p>10.string类型与字符串字面值类型不同。string有以下几种初始化方式：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">string str; str = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="function">string <span class="title">str</span><span class="params">(s1)</span></span>;str = s1;</span><br><span class="line"><span class="function">string <span class="title">str</span><span class="params">(<span class="string">&quot;hello&quot;</span>)</span></span>;str = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="function">string <span class="title">str</span><span class="params">(<span class="number">4</span>,<span class="string">&#x27;l&#x27;</span>)</span></span>;str = <span class="string">&quot;llll&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>11.string类型的输入操作符会读取并忽略有效字符前的的所有空白字符，如空格、换行符、制表符。读取字符直到再次遇到空白字符，读取终止，且该空白字符仍在输入流中。</p>
<p>12.getline(cin, line) 一次读取一行，且不忽略开头的空白字符，遇到换行符终止并丢弃换行符（此时换行符不在输入流中），返回一个istream引用。如果这个返回值作为if或者while等的bool逻辑判断，则读取成功返回true，失败返回false，所以<code>istream&amp; getline(istream&amp; in, string &amp; str, char delim = &#39;\n&#39;)</code>函数可以使用while循环进行判断。</p>
<p>13.string类的s.size()/length()返回s中英文字符个数或者字节数，返回值为string::size_type类型，该类型与unsigned类型具有相同的含义，不能将其赋给int类型。s.empty()测试s是否为空。</p>
<p>14.string对象使用+操作符与字符串字面值进行连接时左右操作数必须至少有一个是string对象，注意str1+str2返回的是一个string对象。所以这个是非法的<code>string str = &quot;Hello&quot; + &quot;world&quot; + s1;</code>，而这两种是合法的<code>string str = s1 + &quot;Hello&quot; + &quot;world&quot;;string str =  &quot;Hello&quot; +s1 + &quot;world&quot;;</code>。另外注意<code>string str = &quot;Hello&quot;;</code>是一个赋值初始化的过程，构造初始化应为<code>string str(&quot;Hello&quot;);</code>。</p>
<p>15.cctype标准库头文件中测试函数返回的是int类型值，测试失败返回0，测试为真返回非0;其中的tolower()和toupper()返回也为int，即对应字符的ASCII码，其中还包含了isalnum(),isalpha()等。</p>
<p>16.C++通过cstring头文件提供对C语言风格的字符串操作。如<code>strlen(s), strcmp(s1, s2), strcat(s1, s2), strcpy(s1, s2), strncat(s1, s2, n), strncpy(s1, s2,n)</code>。其中strn类的函数更安全，它能够控制复制字符的个数。strlen返回的是字符个数，不包括null结束符。处理C风格字符串时一定要记得字符串结束符null。尽量避免使用C风格字符串而是使用标准库类型string，其安全性和效率更高。可以使用C风格字符串初始化string，但不能使用string直接初始化C风格字符串，但string类提供的c_str()函数可以返回一个const类型的C风格字符串。</p>
<p>17.C++11中可以使用范围for，即range for来遍历给定序列中的每个元素，并对该元素进行操作，<code>for (declaration : expression)&#123;&#125;</code>。<br>注意默认情况下范围for使用的是非引用的方式访问序列中的元素，所以此时无法修改序列中的元素，如果需要修改序列中的元素，则必须使用引用。<br>eg:  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">str</span><span class="params">(<span class="string">&quot;Hello world!!!&quot;</span>)</span></span>;</span><br><span class="line"><span class="comment">//punct_cnt的类型将与str.size()类型一致，都是string:size_type  </span></span><br><span class="line"><span class="keyword">decltype</span>(str.<span class="built_in">size</span>()) punct_cnt = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//使用auto来让编译器自动判断所需类型</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> c : str) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">ispunct</span>(c))</span><br><span class="line">      ++punct_cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出标点符号的个数</span></span><br><span class="line">cout &lt;&lt; punct_cnt &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用引用c访问每个字符并将其改成大写</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;c : str) &#123;</span><br><span class="line">    c = <span class="built_in">toupper</span>(c);</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; str &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<p>18.注意char *字义的字符串与string并不一样，char *字义的字符串是常量字符串，无法修改它们的值，如<code>char *str = &quot;Hello world&quot;</code>，此时str是只读的。  </p>
<h2 id="C-11下的字符串数组"><a href="#C-11下的字符串数组" class="headerlink" title="C++11下的字符串数组"></a>C++11下的字符串数组</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *str = <span class="string">&quot;abc&quot;</span>; <span class="comment">//C++11下会出现警告，因为这相当于将一个可变的指针，绑定到一个字符面值常量  </span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *str1 = <span class="string">&quot;abc&quot;</span>; <span class="comment">//正确  </span></span><br><span class="line"><span class="type">char</span> str2[] = <span class="string">&quot;abc&quot;</span>;  <span class="comment">//声明一个数组，当然没有问题</span></span><br></pre></td></tr></table></figure>


<h1 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h1><p>16.vector是同一种类型的对象的集合，是一个类模板，可以定义任意多种数据类型，定义方法为<code>vector&lt;type&gt; variable_list;</code>，意为vector<type>类型的var。它与数组极为相似。vector能容纳绝大多数类型的对应作为其元素，但引用不是对象，所以引用不能作为其原素，vector的元素本身也可以是vector,eg: <code>vector&lt;vector&lt;string&gt;&gt; vstr;//需要C++11</code>如果编译器不支持，需要在后面尖括号中加一个空格，如<code>vector&lt;vector&lt;string&gt; &gt; vstr;</code></p>
<p>17.所有模板的实例化方法都是在模板名字后面跟一对尖括号，在括号中放入实例化信息。  </p>
<p>17.初始化vector对象的方法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;T&gt;  v1;  <span class="comment">//vector保存类型为T的对象，默认构造函数v1为空。</span></span><br><span class="line"><span class="function">vector&lt;T&gt; <span class="title">v2</span><span class="params">(v1)</span></span>;  <span class="comment">//v2是v1的一个副本。</span></span><br><span class="line">vector&lt;T&gt; v2 = v1;  <span class="comment">//等价于v2(v1);</span></span><br><span class="line"><span class="function">vector&lt;T&gt; <span class="title">v3</span><span class="params">(n, i)</span></span>;  <span class="comment">//v3包含n个值为i的元素。eg:`vector&lt;int&gt; vec(10, 2);` 10元素，每个元素都被初始化为2。</span></span><br><span class="line"><span class="function">vector&lt;T&gt; <span class="title">v4</span><span class="params">(n)</span></span>;  <span class="comment">//v4含有类型T默认的值初始化的元素的n个副本。</span></span><br><span class="line">vector&lt;T&gt; v5&#123;a,b,c...&#125;; <span class="comment">//v5包含初始值个数的元素，每个元素被赋予相应的初始值，需要C++11的支持  </span></span><br><span class="line">vector&lt;T&gt; v5 = &#123;a,b,c...&#125;; <span class="comment">//等价于v5&#123;a,b,c...&#125;</span></span><br></pre></td></tr></table></figure>

<p>18.vector初始化时应尽量使用()指定vector中的元素数量，而使用{}指定初始值,eg:   </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v1</span><span class="params">(<span class="number">10</span>, <span class="number">12</span>)</span></span>; <span class="comment">//10个元素，每个元素值都是12</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v2</span><span class="params">(<span class="number">10</span>)</span></span>; <span class="comment">//10个元素，每个元素值都是0</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v3; <span class="comment">//0个元素</span></span><br><span class="line"><span class="function">vector&lt;string&gt; <span class="title">v4</span><span class="params">(<span class="number">10</span>, <span class="string">&quot;hi&quot;</span>)</span></span>; <span class="comment">//10个元素，每个元素值都是“hi”</span></span><br><span class="line">vector&lt;string&gt; v5&#123;<span class="number">10</span>, <span class="string">&quot;hi&quot;</span>&#125;; <span class="comment">//10个元素，每个元素值都是“hi”</span></span><br><span class="line">vector&lt;string&gt; v6&#123;<span class="number">10</span>&#125;; <span class="comment">//10个元素，每个元素值都是“”</span></span><br></pre></td></tr></table></figure>

<p>17.vector对象支持的操作：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">v.<span class="built_in">empty</span>();  <span class="comment">//v为空返回true</span></span><br><span class="line">v.<span class="built_in">size</span>();  <span class="comment">//v中元素个数</span></span><br><span class="line">v.<span class="built_in">push_back</span>(t);  <span class="comment">//将t插入到v的末尾</span></span><br><span class="line">v[n];  <span class="comment">//返回v中位置为n的元素</span></span><br><span class="line">v1 =  v2;  <span class="comment">//把v1中的元素替换为v2中元素的副本。</span></span><br></pre></td></tr></table></figure>
<p>==, !=, &lt;, &lt;=, &gt;, &gt;=保持其操作符惯有的含义。</p>
<p>18.vector可以动态的增加元素。对vector中各元素的访问与对string中各字符的访问方法一样使用下标，为vector对象增加一个元素需要使用<code>v.push_back(t);</code>。v.size()的返回类型与string也类似为vector<T>::size_type。</p>
<p>19.C++由于可以使用内联函数，所以在每次的循环测试中都直接使用v.size()不会增加太多运行代价。</p>
<p>20.string和vector对象在没有定义确定元素时都无法通过下标直接增加值，string只能使用+操作符，vector只能使用v.push_back(t)。eg:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">string str1 = <span class="string">&quot;Hello world!&quot;</span>;</span><br><span class="line">string str2;</span><br><span class="line"><span class="keyword">for</span>(string::size_type ix = <span class="number">0</span>; ix != str1.<span class="built_in">size</span>(); ++ix)</span><br><span class="line">&#123;</span><br><span class="line">    str2[i++] = str1[ix];  <span class="comment">//Error,str2元素个数为0;</span></span><br><span class="line">    str2 += str1[ix];    <span class="comment">//OK</span></span><br><span class="line">&#125;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; num;</span><br><span class="line"><span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::size_type ix = <span class="number">0</span>; ix &lt; <span class="number">10</span>;++ix)</span><br><span class="line">&#123;</span><br><span class="line">    num[ix] = ix; <span class="comment">//Error,num[ix]处的元素并不存在，下标只能访问已经存在的元素</span></span><br><span class="line">    num.<span class="built_in">push_back</span>(ix);  <span class="comment">//OK</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="迭代器iterator"><a href="#迭代器iterator" class="headerlink" title="迭代器iterator"></a>迭代器iterator</h1><p>21.标准库为每一种容器类型都定义了一种迭代器iterator类型。迭代器比下标访问元素更通用化。它与指针非常相似，C++中的容器有:<br>顺序性容器:<br>vector: 从后面快速的插入与删除，直接访问任何元素<br>deque: 从前面或后面快速的插入与删除，直接访问任何元素<br>list: 双链表，从任何地方快速插入与删除<br>关联容器:<br>set: 快速查找，不允许重复值<br>multiset: 快速查找，允许重复值<br>map: 一对多映射，基于关键字快速查找，不允许重复值<br>multimap: 一对多映射，基于关键字快速查找，允许重复值<br>容器适配器:<br>stack: 后进先出<br>queue: 先进先出<br>priority_queue: 最高优先级元素总是第一个出列<br>关于容器的两个讨论：<a href="http://www.tuicool.com/articles/aiMnAz">http://www.tuicool.com/articles/aiMnAz</a>和<a href="http://www.cnblogs.com/answeryi/archive/2011/12/16/2289811.html">http://www.cnblogs.com/answeryi/archive/2011/12/16/2289811.html</a><br>注意虽然string不是迭代器，但string支持迭代器  </p>
<p>22.迭代器类型的定义方式为vector<int>::iterator iter;(以vector为例)，其定义了一个vector<int>::iterator类型的迭代器变量。  </p>
<p>23.每一种容器都定义一对命名为begin和end的函数，用于返回迭代器。如果容器中有元素则begin返回的迭代器指向第一个元素。end函数返回的是容器的最后一个元素的下一个，它指向的是一个不存在的元素。如果容器为空，则begin与end相同。<br>eg:<code>vector&lt;int&gt;::iterator iter = ivec.begin();</code>//iter初始化为由为begin的vector操作返回的值。如果ivec不为空，则iter指向元素为ivec[0],iter就像指向容器中元素的指针。如果iter指向ivec的第一个元素，则*iter与ivec[0]指向就是同一个元素，iter支持++,–操作符。</p>
<p>24.迭代器可以使用==或者!=进行比较，如果两个迭代器指向同一个元素则相等。</p>
<p>25.iter-&gt;mem 表示解引用iter并获取该元素的名为mem的成员，等价于(<em>iter).mem，例如对于string的vector中元素支持的empty()函数，(</em>.ter).empty() &lt;=&gt; ter-&gt;empty()  </p>
<p>26.由于所有标准库容器的迭代器都定义了==和!=操作符，所以可以养成使用!=和迭代器而不是<code>&lt;</code>和下标的习惯。  </p>
<p>25.每一种迭代器的const_iterator类型只能用于读取它所指向元素的值，不能写,相当于常量指针。begin和end返回值是不是常量由对象是不是常量决定。eg:  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line"><span class="type">const</span> vector&lt;<span class="type">int</span>&gt; cv;</span><br><span class="line"><span class="keyword">auto</span> it1 = v.<span class="built_in">begin</span>();  <span class="comment">//it1的类型是vector&lt;int&gt;::iterator</span></span><br><span class="line"><span class="keyword">auto</span> it2 = cv.<span class="built_in">begin</span>();  <span class="comment">//it1的类型是vector&lt;int&gt;::const_iterator</span></span><br></pre></td></tr></table></figure>

<p>26.C++11中增加了cbegin()和cend()它们始终返回const_iterator类型，不管对象是不是const。</p>
<p>26.迭代器举例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">num</span><span class="params">(<span class="number">10</span>)</span></span>;  <span class="comment">//声明含有10个int元素的vector对象。</span></span><br><span class="line">    <span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator ite = num.<span class="built_in">begin</span>(); ite != num.<span class="built_in">end</span>(); ++ite)      <span class="comment">//使用迭代器将num容器中的元素全部置为1</span></span><br><span class="line">    &#123;</span><br><span class="line">        *ite = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator ite = num.<span class="built_in">begin</span>(); ite != num.<span class="built_in">end</span>(); ++ite)</span><br><span class="line">        cout &lt;&lt; *ite &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>27.任何改变vector长度的操作都会使已存在的迭代器失效，例如在调用push_back之后，就不能再信任之前指向这个vector的迭代器的值了。所以凡是使用了迭代器的循环体，都不要向迭代器所属的容器添加元素。  </p>
<p>28.vector迭代器支持与指针类似的与常量相加、相减以及指向同一个vector的两个迭代器相减的操作，但不能相加，就像两个指针相加的未定义的一样，同时支持两个迭代器的比较，比较的是它们的位置。</p>
<p>29.string和vector都定义了带符号的difference_type类型，该类型是一个带符号的整型数，可正可负。两个迭代器相减的结果就是difference_type类型。</p>
<p>29.bitset是一种用于处理二进制位的类模板，定义时必须指定其长度值。初始化方式为：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">bitset&lt;n&gt; b;  <span class="comment">//b有n位，每位都为0</span></span><br><span class="line"><span class="function">bitset&lt;n&gt; <span class="title">b</span><span class="params">(u)</span></span>;  <span class="comment">//b是unsigned long 型u的一个副本，用u从低位向高位对b赋值，u不够时高位填充0,多余时舍掉</span></span><br><span class="line"><span class="function">bitset&lt;32&gt; <span class="title">bitvec1</span><span class="params">(<span class="number">0xffff</span>)</span></span>;    <span class="comment">//bitvec为0-15为1,16-31为0，当然这里可以放10进制，也会被自动转为2进制。</span></span><br><span class="line"><span class="function">bitset&lt;n&gt; <span class="title">b</span><span class="params">(s)</span></span>;  <span class="comment">//b是string对象s中含有的位串的副本 ,其中string直接表示为位模式。</span></span><br><span class="line"><span class="function">string <span class="title">strval</span><span class="params">(<span class="string">&quot;1100&quot;</span>)</span></span>;  <span class="comment">//注意这里只能有0和1组成。</span></span><br><span class="line"><span class="function">bitset&lt;32&gt; <span class="title">bitvec2</span><span class="params">(strval)</span></span>; <span class="comment">//bitvec2第2和3位置1,其余位都是0.注意此处不能直接放一个字符串字面值</span></span><br><span class="line"><span class="function">bitset&lt;n&gt; <span class="title">b</span><span class="params">(s, pos, n)</span></span>;  <span class="comment">//b是s中从位置pos开始的n个位的副本</span></span><br></pre></td></tr></table></figure>

<p>30.bitset对象有多种操作能够方便的处理位，参考bitset的reference。也可以使用下标操作符读写某个位。</p>
<p>31.bitset对象返回的数值类型为cstddef头文件中的size_t类型，该类型为与机器相关的unsigned类型。eg:size_t sz = bitvec.size();</p>
<p>32.函数体外定义的数组会被自动初始化为0,函数体内定义的数组不会自动初始化。数组元素为类类型时，不管在哪里定义都会自动调用默认构造函数进行初始化，所以string定义的变量不管在哪里都默认为空字符串，如果没有默认构造函数则必须显示初始化。数组大小必须要在编译时已经，非const的变量只有在运行时才赋值，所以不能使用它作为数组长度。在没有明显性能影响的情况下，能使用vector的地方尽量不要使用数组。使用字符串初始化的字符数组会在数组结尾自动添加’\0’作为结束符。注意数组不能像vector那样直接赋值以及使用另一个数组对其初始化。数组下标类型为<code>size_t</code></p>
<h1 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h1><p>33.指针进行初始化或赋值只能使用以下四种类型的值：1.0值常量表达式，只能是编译时可以获得的0值整型const对象或字面值常量0。2.类型匹配的对象的地址。3.另一对象之后的下一地址。4.同类型的另一个有效指针。eg:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> val;</span><br><span class="line"><span class="type">int</span> zero = <span class="number">0</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> c_ival = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> *pi = ival;    <span class="comment">//ERROR,pi只能指向地址，eg:int *pi = &amp;ival;</span></span><br><span class="line">pi = zero;    <span class="comment">//ERROR，zero为int型变量，只有在运行时才能获取其值</span></span><br><span class="line">pi = c_ival;    <span class="comment">//OK，const的变量在编译时已经确定其值。</span></span><br><span class="line">pi = <span class="number">0</span>;    <span class="comment">//OK，0值字面值常量 ，也可以使用cstdlib头文件中的NULL，int *pi = NULL &lt;=&gt; 0值</span></span><br></pre></td></tr></table></figure>

<p>34.空指针的三种定义方法：  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> *p1 = <span class="literal">nullptr</span>;  <span class="comment">//C++11才支持，等价于int *p1 = 0;</span></span><br><span class="line"><span class="type">int</span> *p2 = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//首选include cstdlib头文件</span></span><br><span class="line"><span class="type">int</span> *p3 = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>

<p>34.<code>void *</code> 指针。</p>
<p>35.引用与指针的区别：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> iva1 = <span class="number">1024</span>, iva2 = <span class="number">2048</span>;</span><br><span class="line"><span class="type">int</span> *p1 = &amp;iva1, *p2 = &amp;iva2;</span><br><span class="line"><span class="type">int</span> &amp;r1= ival, &amp;r2= iva2;</span><br><span class="line">p1 = p2;  <span class="comment">//p1指向P2</span></span><br><span class="line">r1= r2;  <span class="comment">//将iva2的值赋给iva1</span></span><br></pre></td></tr></table></figure>

<p>36.两个指针相减返回的数据类型为ptrdiff_t，其也在cstddef中定义，size_t是unsigned类型，而ptrdiff_t则是signed类型。</p>
<h2 id="数组与指针"><a href="#数组与指针" class="headerlink" title="数组与指针"></a>数组与指针</h2><p>1.数组名是数组元素的首地址，即&amp;a[0] == a; 使用下标访问数组时，实际上是使用下标访问指针。eg:  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> ia[] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="type">int</span> i = ia[<span class="number">2</span>]; <span class="comment">//等价于i = *(ia + 2);</span></span><br><span class="line"><span class="type">int</span> *p = &amp;ia[<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> j = p[<span class="number">-2</span>];  <span class="comment">//等价于j = *(p-2) &lt;=&gt; j = *(&amp;ia[2]-2) = 0;</span></span><br></pre></td></tr></table></figure>
<p>2.在数组与指针混合应用时应采用从数组的名字开始由内向外的方式进行解释  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> *ptr[<span class="number">10</span>];  <span class="comment">//ptr是含有10个指向int型数据的指针的数组  </span></span><br><span class="line"><span class="type">int</span> &amp;ref[<span class="number">10</span>]; <span class="comment">//错误，引用不是对象，所以不存在存放引用的数组</span></span><br><span class="line"><span class="built_in">int</span> (*parray)[<span class="number">10</span>] = &amp;arr; <span class="comment">//parray是一个指向含有10个整数数组的指针</span></span><br><span class="line"><span class="built_in">int</span> (&amp;refarr)[<span class="number">10</span>] = arr; <span class="comment">//refarr是一个引用含有10整数数组的引用  </span></span><br><span class="line"><span class="type">int</span> *(&amp;refparr)[<span class="number">10</span>] = ptr; <span class="comment">//refparr是一个引用含有10个int指针的数组的引用  </span></span><br></pre></td></tr></table></figure>

<p>38.指针相当于数组的迭代器。可以定义指向数组最后一个元素的下一个位置的指针，该指针只能用于比较，不能访问。eg:</p>
<p>39.以下定义数组的方法是非法的，因为数组长度必须是常量表达式。  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> buff_size = <span class="number">1024</span>;</span><br><span class="line"><span class="type">int</span> arr[buff_size];</span><br></pre></td></tr></table></figure>
<p>33.使用指针访问数组，C++11在头文件iterator中定义了两个函数begin()和end()用于返回指向数组的首元素和尾元素的下一个位置的指针。用法为将数组作为其参数传递。  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//非C++11的方式</span></span><br><span class="line"><span class="type">const</span> <span class="type">size_t</span> arr_sz = <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> int_arr[arr_sz] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> *pbegin = int_arr, *pend=int_arr+arr_sz; pbegin != pend; ++pbegin)</span><br><span class="line">    cout &lt;&lt; *pbegin &lt;&lt; <span class="string">&#x27; &#x27;</span>;  <span class="comment">//单引号还是双引号在些处一样，单引号表示字符，双引号表示一个字符串,以`\0`结束。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//C++11的方式</span></span><br><span class="line"><span class="type">int</span> *pbeg = <span class="built_in">begin</span>(int_arr), *pend = <span class="built_in">end</span>(int_arr);</span><br><span class="line"><span class="keyword">while</span> (pbeg != pend) </span><br><span class="line">    cout &lt;&lt; pbeg++ &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>39.const和指针：<br>指向const对象的指针：<code>const double *cptr;</code>不需要对其初始化，因为const修饰的是<code>*cptr</code>，它是一个解引用变量，而cptr是一个指向const对象的指针，其本身不是const变量，只是它指向的对象是个const的变量，不能通过它去修改所指向的值，但可以将其指向其他变量。当然此处的cptr可以指向一个非const变量。</p>
<p>const指针：<code>double *const cptr = &amp;a</code>定义了一个<code>const</code>指针cptr，定义时必须初始化。<br>因为const修饰的是cptr而不是*cptr,所以不能修改cptr的指向，cptr只能指向变量a，但可以通过cptr修改a的值，例如:<code>*cptr = 3.14;</code>  </p>
<p>1.指向const对象的const指针：<code>const double *const cptr = &amp;pi;</code>定义时必须初始化，且pi必须是const对象。既不能修改cptr的指向，也不能通过cptr修改其所指向的值。</p>
<p>2.typedef与指针一起使用时的一个例子能更好的理解const的修饰作用：  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> string *pstring;</span><br><span class="line"><span class="type">const</span> pstring cstr; </span><br><span class="line"><span class="comment">//cstr的类型为一个指向string类型的const指针。因为pstring是一个指针，它相当于由typedef定义的string *类型，typedef是别名，编译时不会简单的替换，而const修饰的是个指针，所以cstr是个const指针。而define是在预编译时进行简单替换。</span></span><br></pre></td></tr></table></figure>

<p>39.C++11中新增加了通过using来定义类型的别名，eg: <code>using SI = Sales_item;</code>这样SI就是Sales_item的别名，其作用就是把等号左侧的名字规定成等号右侧类型的别名。  </p>
<p>40.当使用非const对象初始化const对象的引用时，系统会自动将非const对象转换为const对象。但不能使用const对象对非const对象的引用初始化。eg:   </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *p = &amp;a; <span class="comment">//OK</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> *p2 = &amp;b; <span class="comment">//Error</span></span><br></pre></td></tr></table></figure>
<p>41.C++11支持constexpr变量，该类型的变量由编译器来验证变量的值是否为一个常量表达式，声明为constexpr的变量一定是一个常量，而且必须用常量表达式初始化，但初始始化时也可以使用constexpr函数作为初始值。  </p>
<p>42.C++11引入了类型指示符decltype，它的作用是选择并返回操作数的数据类型。eg: <code>decltype(f()) sum = x;</code>其中sum的类型就是函数f的返回类型。<br>decltype((variable))的结果永远是引用，而decltype(variable)结果只有当variable本身就是一个引用时才是引用。  </p>
<p>42.动态数组：C++中的new和delete实现了C语言中malloc和free相同的功能。</p>
<p>定义动态数组时只需要指定类型和数组长度，不必为数组对象命名，可以直接初始化为默认值，或者不进行初始化，new表达式返回指向新分配数组的第一个元素指针：  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">size_t</span> n = <span class="built_in">get_size</span>();</span><br><span class="line"><span class="type">int</span> *pia = <span class="keyword">new</span> <span class="type">int</span>[n]();<span class="comment">//初始化为int.</span></span><br></pre></td></tr></table></figure>
<p>使用之后需要使用delete语句显式释放分配的动态空间：<code>delete [] pia;</code><br>eg:  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span> *err = <span class="string">&quot;Error: afunction declaration must specify a function return type!&quot;</span>;</span><br><span class="line"><span class="type">int</span> dimension = <span class="built_in">strlen</span>(err) + <span class="number">1</span>;</span><br><span class="line"><span class="type">char</span> *errMsg = <span class="keyword">new</span> <span class="type">char</span>[dimension];</span><br><span class="line"><span class="built_in">strncpy</span>(errMsg, err, dimesion);</span><br><span class="line"><span class="keyword">delete</span> [] errMsg; <span class="comment">//一定要记得创建时就把释放定后，以免忘记释放</span></span><br></pre></td></tr></table></figure>

<p>43.可以使用数组直接初始化vector对象，但必须给出数组的两个位置指针，如果需要用整个数组初始化，则第二个指针必须是指向数组最后一个元素的下一位置的地址。eg:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">size_t</span> arr_size = <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> int_arr[arr_size] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ivec</span><span class="params">(int_arr, int_arr + arr_size)</span></span>;<span class="comment">//使用整个数组。</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ivec</span><span class="params">(begin(int_arr), end(int_arr))</span></span>;<span class="comment">//使用整个数组。需要C++11支持</span></span><br></pre></td></tr></table></figure>

<h2 id="多维数组与指针"><a href="#多维数组与指针" class="headerlink" title="多维数组与指针"></a>多维数组与指针</h2><p>1.C++中的多维数组指的是数组的数组，不存在真正意义上的多维数组。例如int a[3][4]意思是含有3个int型元素的数组a中，每个元素都是含有4个int型整数的数组。  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="type">int</span> b = <span class="number">4</span>;</span><br><span class="line"><span class="type">int</span> *ip[<span class="number">4</span>];  <span class="comment">//指向int类型的指针数组，也就是这个数组里面含有4个指针，每个指针都指向int型数据。</span></span><br><span class="line">ip[<span class="number">1</span>] = &amp;b;  <span class="comment">//将b的地址存放在ip[1]。</span></span><br><span class="line"><span class="built_in">int</span> (*ap)[<span class="number">4</span>]; <span class="comment">//指向4个int型元素的数组指针。  相当于指向地址的指针。</span></span><br><span class="line">ap = &amp;a;  <span class="comment">//让ap指向数组首地址的的地址。</span></span><br><span class="line">cout &lt;&lt; (*ap)[<span class="number">1</span>];  <span class="comment">//输出数组a的第2个值，等价于*(*ap + 1) &lt;=&gt; a[1] &lt;=&gt; *(a + 1)</span></span><br></pre></td></tr></table></figure>

<p>2.多维数组中的引用定义：  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> ia[<span class="number">2</span>][<span class="number">3</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="built_in">int</span> (&amp;row)[<span class="number">3</span>] = ia[<span class="number">1</span>];  <span class="comment">//定义一个引用row，将它绑定到ia的第二个含有3个元素的数组上</span></span><br></pre></td></tr></table></figure>

<p>3.多维数组中使用range for循环  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> ia[<span class="number">2</span>][<span class="number">3</span>];</span><br><span class="line"><span class="type">size_t</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//此处必须使用引用，一方面是为了修改遍历的值，另一方面防止使用auto时row被自动转换成指针，因为ia是数组</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;row : ia) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;col : row) &#123;</span><br><span class="line">        col = cnt;</span><br><span class="line">        ++cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//外层循环依然要使用引用，防止使用auto时row被自动转换成指针，因为ia是数组。为了避免修改数组，所以使用const</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp;row : ia) &#123;</span><br><span class="line"><span class="comment">//内层循环col即指向row中的每一个元素，因为C++中的多维数组就是数组的数组，row中存放的就是int类型</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> col : row) &#123;</span><br><span class="line">        cout  &lt;&lt; col &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4.C++11中使用using简化多维数组中指针的使用  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> int_arr = <span class="type">int</span>[<span class="number">3</span>];  <span class="comment">//声明int[3]的别名</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> int_arr[<span class="number">4</span>];  <span class="comment">//等价的typedef声明</span></span><br><span class="line"><span class="comment">//prow指向外层数组  </span></span><br><span class="line"><span class="keyword">for</span> (int_arr *prow = ia; prow != ia + <span class="number">2</span>; ++prow) &#123;</span><br><span class="line"><span class="comment">//*prow即内层数组，pcol指向内层数组的第一个元素，也就是每一行的开头</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> *pcol = *prow; pcol != *prow + <span class="number">3</span>; ++pcol) &#123;</span><br><span class="line">        cout  &lt;&lt; *pcol &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>45.通过指针遍历字符串：  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *cp = <span class="string">&quot;Hello world&quot;</span>;</span><br><span class="line"><span class="keyword">while</span>(cp &amp;&amp; *cp);  <span class="comment">//表示当cp为非空指针并且cp指向的字符不为空字符null(&#x27;\0&#x27;)时执行循环体。</span></span><br></pre></td></tr></table></figure>
<p>46.C++为在点操作符中使用的解引用操作定义了一个同义词：箭头操作符(-&gt;)。eg:<code>(*p).foo; &lt;=&gt; p-&gt;foo;</code></p>
<p>47.一个帮助理解指针、引用、auto、for range的例子：  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ia[<span class="number">3</span>][<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> row = <span class="number">0</span>; row &lt; <span class="number">3</span>; ++row) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> col = <span class="number">0</span>; col &lt; <span class="number">4</span>; ++col) &#123;</span><br><span class="line">            ia[row][col] = col + row * <span class="number">4</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//使用C++11中的using来简化定义指向数组的指针</span></span><br><span class="line">    <span class="keyword">using</span> int_arr = <span class="type">int</span>[<span class="number">4</span>];</span><br><span class="line">    <span class="comment">//for (const int_arr &amp;row : ia) &#123;  //类型别名控制外部循环</span></span><br><span class="line">    <span class="comment">//使用引用输出</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Reference&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="built_in">int</span> (&amp;row)[<span class="number">4</span>] : ia) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="type">int</span> col : row) &#123;</span><br><span class="line">            cout &lt;&lt; col &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl &lt;&lt; <span class="string">&quot;Subscript&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//使用下标输出</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> row = <span class="number">0</span>; row &lt; <span class="number">3</span>; ++row) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> col = <span class="number">0</span>; col &lt; <span class="number">4</span>; ++col) &#123;</span><br><span class="line">            cout &lt;&lt; ia[row][col] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl &lt;&lt; <span class="string">&quot;Pointer&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//使用指针输出</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> int_arr *row = ia; row != ia + <span class="number">3</span>; ++row) &#123;  <span class="comment">//使用类型别名，row是一个指向含有4个int型元素的指针，ia中含有3个int *型的元素，每个元素又含有4个int的整型</span></span><br><span class="line">   <span class="comment">// for (const int (*row)[4] = ia; row != ia + 3; ++row) &#123;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="type">int</span> *col = *row; col != *row + <span class="number">4</span>; ++col) &#123;</span><br><span class="line">            cout &lt;&lt; *col &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl &lt;&lt; <span class="string">&quot;auto&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//使用auto</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp;row : ia) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> col : row) &#123;</span><br><span class="line">            cout &lt;&lt; col &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="表达式和语句"><a href="#表达式和语句" class="headerlink" title="表达式和语句"></a>表达式和语句</h1><h2 id="sizeof"><a href="#sizeof" class="headerlink" title="sizeof"></a>sizeof</h2><p>47.sizeof操作符返回的是编译时常量</p>
<p>48.动态创建的对象初始化时如果不进行直接初始化，对于内置类型或者没有默认构造函数的类型不会自动进行自动初始化。而有默认构造函数的类都会自动调用默认构造函数进行初始化。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> *pi = <span class="keyword">new</span> <span class="type">int</span>;    <span class="comment">//不会自动初始化</span></span><br><span class="line"><span class="type">int</span> *pi = <span class="keyword">new</span> <span class="built_in">int</span>();  <span class="comment">//自动初始化为0</span></span><br></pre></td></tr></table></figure>

<p>48.<code>i != j &lt; k;</code> is equivalent to <code>i != (j &lt; k);</code></p>
<p>49.sizeof运算符作用的结果，部分的依赖于它的作用的类型：  </p>
<ul>
<li>对char或者类型为char的表达式执行sizeof运算，结果为1  </li>
<li>对引用类型执行sizeof运算得到被引用对象所占空间大小  </li>
<li>对指针执行sizeof运算返回指针本身所占空间的大小  </li>
<li>对解引用执行sizeof运算，返回指针所指向的对象所占的空间大小，指针不需要有效  </li>
<li>对数组执行sizeof运算返回整个数组所占空间的大小，相当对使用sizeof对数组中的每个元素运算，并将运算结果求和，注意sizeof作用于数组时，不会将数组转换为指针。   </li>
<li>对string对象或vector对象执行sizeof运算只返回该类型固定部分的大小，不会计算对象中的元素占用了多少空间。也就是说通常对一个vector或string对象执行sizeof运算得不到其占用的总空间大小。例如在我的64位win7操作系统上，<code>vector&lt;int&gt; ivec(1000); cout &lt;&lt; sizeof ivec;</code>输出为24。  </li>
<li>对一个没有声明任何成员变量与成员函数的类名执行sizeof，返回结果为1。因为为了区分该类的不同对象，编译器会在编译时插入一个char，所以结果为1。</li>
</ul>
<h2 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h2><p>49.C++风格强制类型转换操作符：static_cast、dynamic_cast、const_cast、reinterpret_cast。使用方式为:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cast-<span class="built_in">name</span>&lt;type&gt;(expression)。</span><br><span class="line"><span class="built_in">const_cast</span>&lt;<span class="type">char</span> *&gt;(pc_str);<span class="comment">//转换掉表达式的const性质。</span></span><br><span class="line"><span class="type">double</span> d = <span class="number">2.0</span>;</span><br><span class="line"><span class="built_in">static_cast</span>&lt;<span class="type">char</span>&gt;(d);  <span class="comment">//将d强制转换为char类型，所有编译器隐式执行的转换都可以通过static_cast显式完成。</span></span><br><span class="line"><span class="built_in">static_cast</span>&lt;type *&gt;(pointer);  <span class="comment">//可以强制将存放在void *中的指针值强制转换为原来的指针类型。</span></span><br></pre></td></tr></table></figure>
<p>应该尽量避免使用强制类型转换。<br>dynamic_cast支持运行时类型识别  </p>
<p>50.static_cast可用于找回存在于void*指针中的值：  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *p = &amp;d;</span><br><span class="line"><span class="type">double</span> *dp = <span class="built_in">static_cast</span>&lt;<span class="type">double</span>*&gt;(p);</span><br></pre></td></tr></table></figure>

<p>50.switch求解的表达式可以非常复杂，也可以直接定义并初始化一个变量。eg:<code>switch(int ival = get_response())</code></p>
<p>51.C++中switch语句中的case之句可以放在一行。eg: <code>case &#39;a&#39;: case &#39;e&#39; : case &#39;i&#39; : case &#39;o&#39;:</code></p>
<p>52.C++中pair类型的用法：pair类型包含在std命名空间下，是一种结构模板类型，它可以同时存储两个类型不同的值。是std::tuple类型的一种只含有两个元素的特例。它含有两个属性，分别是first表示第一个元素值，second表示第二个元素值。使用方法如下：  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">pair&lt;string, <span class="type">double</span>&gt; <span class="title">book1</span><span class="params">(<span class="string">&quot;The old man and The sea&quot;</span>, <span class="number">99.99</span>)</span></span>;</span><br><span class="line">pair&lt;string, <span class="type">double</span>&gt; book2;</span><br><span class="line">book2.first = <span class="string">&quot;Harry porter&quot;</span>;</span><br><span class="line">book2.second = <span class="number">88.88</span>;</span><br><span class="line">cout &lt;&lt; book1.first &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; book1.second &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; book2.first &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; book2.second &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p>51.C++的异常：throw表达式抛出异常，try…catch…处理异常。<br>标准异常(4个)：</p>
<ul>
<li>exception头文件定义了最常见的异常类，它的类名是exception。这个类只通知异常的产生，但不会提供更多的信息。  </li>
<li>stdexcept头文件定义了几种常见的异常类。 </li>
<li>new头文件定义了bad_alloc异常类型，提供因无法分配内存而由new抛出的异常。  </li>
<li>type_info头文件定义了bad_cast异常类型。  </li>
</ul>
<p>52.runtime_error异常抛出时必须初始化，示例：  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (item1.<span class="built_in">isbn</span>() != item2.<span class="built_in">isbn</span>())</span><br><span class="line">   <span class="keyword">throw</span> <span class="built_in">runtime_error</span>(<span class="string">&quot;Data must refer to same ISBN&quot;</span>);</span><br><span class="line">cout &lt;&lt; item1 + item2 &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<p>53.try语句块示例：<br>runtime_error类的成员函数what()返回初始化对象时所用的string对象副本，throw语句应在try块中。  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//输入两个整数，输出其相除的结果</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num1, num2; cout &lt;&lt; <span class="string">&quot;Enter two number: &quot;</span> &lt;&lt; endl, cin &gt;&gt; num1 &gt;&gt; num2;) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (num2 == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="built_in">runtime_error</span>(<span class="string">&quot;Zero is error!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            cout &lt;&lt; num1 &lt;&lt; <span class="string">&quot; / &quot;</span> &lt;&lt; num2 &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(num1) / num2 &lt;&lt; endl;</span><br><span class="line">        &#125; <span class="built_in">catch</span> (runtime_error err) &#123;</span><br><span class="line">            cout &lt;&lt; err.<span class="built_in">what</span>()  &lt;&lt; endl &lt;&lt; <span class="string">&quot;Enter \&quot;y\&quot; to continue or \&quot;n\&quot; to end&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="type">char</span> ch;</span><br><span class="line">            cin &gt;&gt; ch;</span><br><span class="line">            <span class="keyword">if</span> (!cin || ch != <span class="string">&#x27;y&#x27;</span>)</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>1.函数在调用前必须声明，定义可以在调用之后，跟C语言一样。</p>
<p>2.计算阶乘的函数  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">fact</span><span class="params">(<span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//注意这里对于0的处理非常合适啊</span></span><br><span class="line">    <span class="keyword">return</span> i &gt; <span class="number">1</span> ? i * <span class="built_in">fact</span>(i - <span class="number">1</span>) : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.含有函数声明的头文件应该被包含到定义函数的源文件中。  </p>
<p>52.使用C++中的引用形参比直接使用C类型的指针进行实参访问更安全和自然。引用相当于原变量的一个别名，所以可以直接修改原变量的值。eg:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span> &amp;v1, <span class="type">int</span> &amp;v2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="type">int</span> tmp = v1;</span><br><span class="line">   v1 = v2;</span><br><span class="line">   v2 = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>53.能用const引用的地方，多用const引用，利用const引用可以避免函数传递时的参数复制。即对于不需要修改变量的函数形参使用引用时应该增加const修饰。  </p>
<p>54.const修饰的string引用参数可以直接接受字面值字符串。  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">find1</span><span class="params">(<span class="type">const</span> string &amp;str)</span></span>;  </span><br><span class="line"><span class="built_in">find1</span>(<span class="string">&quot;Hello&quot;</span>);    <span class="comment">//OK</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find2</span><span class="params">(string &amp;str)</span></span>;</span><br><span class="line"><span class="built_in">find2</span>(<span class="string">&quot;Hello&quot;</span>);  <span class="comment">//ERROR,type error</span></span><br></pre></td></tr></table></figure>
<p>55.可以通过给函数传递数组首指针begin(arr)和尾指针end(arr)的方式来限定数组的大小，并遍历数组。  </p>
<p>56.<code>int &amp;arr[10]</code>是引用的数组，而<code>int (&amp;arr)[10]</code>却是数组的引用。即声明一个引用，该引用绑定到某个数组。  </p>
<p>57.向函数传递多维数组时，第二维的维度不能省略。<code>int *matrix[10]</code>定义10个指针构成的数组。<code>int (*matrix)[10]</code>定义指向含有10个整数的数组的指针。  </p>
<p>58.C++的main函数传递参数时，定义方法为<code>int main(int argc, char *argv[])</code>或者<code>int main(int argc, char **argv)</code>其中第二个数组中存放的是C风格字符串的指针，所以后一种形式中的argv指向<code>char*</code>。当实参传递给main函数之后，argv的第一个元素指向程序的名字或者一个空字符串，接下来的元素依次为命令行提供的实参，最后一个指针之后的元素值保存为0。eg:<code>prog -d -o ofile data0</code>中argc为5，argv元素分别为”prog”,”-d”,”-o”,”ofile”,”data0”,0。</p>
<p>59.C++11可以使用initializer_list类型的形参来实现多个不同数量相同类型的参数传递。initializer_list是一种标准库类型，用于表示某种特定类型的值的数组。</p>
<p>60.没有返回值的return语句只能用在返回类型是void的函数中，可以用于提前结束程序的运行。返回void的函数，函数在执行到最后一句时会隐式地执行return语句。</p>
<p>61.C++11中可以返回花括号包围的值的列表。类似于其他返回结果，此处的列表也用来对表示函数返回的临时量进行初始化。eg:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;string&gt; <span class="title">process</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (expected.<span class="built_in">empty</span>()) </span><br><span class="line">      <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (expected == actual)</span><br><span class="line">      <span class="keyword">return</span> &#123;<span class="string">&quot;functionx&quot;</span>, <span class="string">&quot;okay&quot;</span>&#125;;</span><br><span class="line">   <span class="keyword">else</span> </span><br><span class="line">      <span class="keyword">return</span> &#123;<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;edu&quot;</span>, actual&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>47.主函数main如果结尾没有返回值，当程序达到了main函数结尾处而且没有return语句，编译器将隐式地插入一条的返回0的return语句。为了使返回值与机器无关，cstdlib头文件中定义了两个预处理变量表达程序执行成功或者失败。eg:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (<span class="literal">true</span>)</span><br><span class="line">      <span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>59.声明一个返回数组指针的函数，形式为: <code>Type (*function(parameter_list))[dimesion]</code>。其中Type是元素的类型，dimension表示数组的大小。eg:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> (*<span class="built_in">func</span>(<span class="type">int</span> i))[<span class="number">10</span>];</span><br></pre></td></tr></table></figure>
<ul>
<li><code>func(int i)</code> 表示调用func函数时需要一个int类型的实参。  </li>
<li><code>(*func(int i))</code> 意味着我们可以对函数调用的结果执行解引用操作。  </li>
<li><code>(*func(int i))[10]</code> 表示解引用func的调用将得到一个大小是10的数组。  </li>
<li><code>int (*func(int i))[10]</code> 表示数组中的元素是int类型。  </li>
</ul>
<p>60.C++11可以通过尾置返回类型(trailing return type)来简化上述声明。声明方式为<code>auto func(int i) -&gt; int(*)[10];</code>。  </p>
<p>61.编写一个函数声明，该函数返回数组的引用并且该数组包含10个string对象：  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> (&amp;<span class="built_in">func</span>(<span class="built_in">string</span> (&amp;strarr)[<span class="number">10</span>]))[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">using</span> ArrT = string[<span class="number">10</span>];</span><br><span class="line"><span class="function">ArrT <span class="title">func1</span><span class="params">(ArrT&amp; arr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">func2</span><span class="params">(ArrT&amp; arr)</span> -&gt; <span class="title">string</span><span class="params">(&amp;)</span>[10]</span>;</span><br><span class="line">string arrS[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">decltype</span>(arrS)&amp; <span class="built_in">func3</span>(ArrT&amp; arr);</span><br></pre></td></tr></table></figure>

<p>62.C++中一旦某个形参被赋予了默认值，它后面的所有形参都必须有默认值。通常应尽量让不怎么使用默认值的形参出现在前面，而让那些经常使用默认值的形参出现在后面。    </p>
<p>55.标准库都在命名空间std下，例如vector,string,iterator</p>
<p>56.函数中不应该传递vector等容器类形参，可以通过向函数传递对应容器对象的迭代器来访问容器元素。</p>
<p>57.内联函数会在调用点处内联地展开，内联函数通常应该是比较短小的函数，最好定义在头文件中，方便修改和调用。eg  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">const</span> string &amp;<span class="title">shorterString</span><span class="params">(<span class="type">const</span> string &amp;s1, <span class="type">const</span> string &amp;s2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s1.<span class="built_in">size</span>() &lt; s2.<span class="built_in">size</span>() ? s1:s2 &lt;&lt; endl;;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="built_in">shorterString</span>(s1, s2) &lt;&lt; endl;  <span class="comment">//该调用在编译时将展开为</span></span><br><span class="line">cout &lt;&lt; (s1.<span class="built_in">size</span>() &lt; s2.<span class="built_in">size</span>() ? s1: s2) &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<p>63.C++11中新增加了constexpr函数(constexpr function)，是指能用于常量表达式的函数，定义constexpr函数的方法与其他函数类似，但要求函数的返回类型及所有形参的类型都是字面值类型，而且函数体中必须有且只有一条return语句，eg:  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">new_sz</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> <span class="number">42</span>;&#125;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> foo = <span class="built_in">new_sz</span>();  <span class="comment">//foo是一个常量表达式，将可以做为数组大小。  </span></span><br></pre></td></tr></table></figure>
<p>为了能在编译过程中随时展开，constexpr函数被隐式指定为内联函数。  </p>
<p>63.和其他函数一样，内联函数和constexpr函数可以在程序中定义多次，所以为了保证定义完全一致，内联函数和constexpr函数通常定义在头文件中。  </p>
<h2 id="C-调试帮助头文件cassert"><a href="#C-调试帮助头文件cassert" class="headerlink" title="C++调试帮助头文件cassert"></a>C++调试帮助头文件cassert</h2><p>64.C++中帮助调式的两个关键字assert(预处理宏)和NDEBUG(预处理变量):  </p>
<ul>
<li><p><code>assert</code>定义在头文件<code>cassert</code>中，用法为<code>assert(expr);</code>，该语句会首先对expr求值，如果表达式为假(即0),assert输出信息并终止程序的执行，如果表达式为真(即非0),assert什么也不做。 assert宏常用于检查“不能发生”的条件。例如一个对输入文本操作的程序可能要求所有给定单词的长度都大于某个阈值，因此，可以这样定义<code>assert(word.size() &gt; threshold);</code>  </p>
</li>
<li><p><code>NDEBUG</code>的作用是限制assert的行为,即assert的行为依赖于NDEBUG的预处理变量的状态，如果定义了NDEBUG，则assert什么也不做，默认状态下没有定义NDEBUG，此时assert将执行运行时检查。可以使用一个<code>#define</code>  语句定义NDEBUG，从而关闭调试状态，如<code>#define NDEBUG</code>，很多编译器也提供一个命令行选项用于定义预处理变量：  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">CC -D NDEBUG main.c</span><br></pre></td></tr></table></figure>
<p>该命令等价于在main.c文件的开始写一行<code>#define NDEBUG</code>  </p>
</li>
</ul>
<p>65.除了将NDEBUG用于assert外，也可以使用NDEBUG编写自己的条件调试代码。如果NDEBUG未定义，则执行#ifndef和#endif之间的代码，如果定义了NDEBUG，这些代码将被忽略掉。eg:  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> <span class="type">int</span> ia[], <span class="type">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> NDEBUG</span></span><br><span class="line">   cerr &lt;&lt; __func__ &lt;&lt; <span class="string">&quot;: array size is &quot;</span>  &lt;&lt; size &lt;&lt; endl; <span class="comment">//__func__是编译器定义的一个局部静态变量，用于存放函数的名字 </span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>67.编译器定义的可用于调试的名字有：  </p>
<ul>
<li><code>__func__</code>  存放当前调试的函数的名字，它是const char的一个静态数组。  </li>
<li><code>__FILE__</code>  存放文件名的字符串字面值。 </li>
<li><code>__LINE__</code>  存放当前行号的整型字面值。  </li>
<li><code>__TIME__</code>  存放文件编译时间的字符串字面值。  </li>
<li><code>__DATE__</code>  存放文件编译日期的字符串字面值。  </li>
</ul>
<p>68.调试举例：  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NDEBUG</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;vec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> NDEBUG</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;vector size: &quot;</span>  &lt;&lt; vec.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">if</span> (!vec.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> temp = vec.<span class="built_in">back</span>();</span><br><span class="line">        vec.<span class="built_in">pop_back</span>();</span><br><span class="line">        <span class="built_in">print</span>(vec);</span><br><span class="line">        cout &lt;&lt; temp &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; veci;</span><br><span class="line">    <span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::size_type i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        veci.<span class="built_in">push_back</span>(i + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">print</span>(veci);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>70.实参赋给形参时有可能会出现类型转换。  </p>
<p>64.出现在相同作用域中的两个函数，如果具有相同的名字而形参表不同，则称其为重载函数。局部声明的函数将屏蔽全局声明的函数而不是重载，重载函数必须作用域相同。调用重载函数时尽量避免使用强制类型转换，如果一定要使用强制类型转换，则说明重载函数设计不合理。  </p>
<h2 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h2><p>65.指向函数的指针定义： bool (<em>pf) (const string &amp;, const string &amp;);  //定义了一个指向含有两个const string &amp;类型形参，返回bool类型的函数指针pf。使用typedef可以简化定义，typedef bool (</em>tdpf) (const string &amp;, const string &amp;);</p>
<p>66.函数指针只能通过同类型的函数或函数指针或0值常量表达式进行初始化或赋值。函数指针初始化时，直接引用函数名等效于在函数名上应用取地址操作符：<code>tdpf pf1 = getnum;</code> &lt;=&gt; <code>tdpf pf1 = &amp;getnum;</code></p>
<p>67.通过函数指针调用函数时不需要对其解引用。eg: pf(“Hello”, “world”);</p>
<p>68.当指向函数的指针作为形参时可能使用如下两种方式编写：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">useBigger</span><span class="params">(<span class="type">const</span> string &amp;, <span class="type">const</span> string &amp;, <span class="type">bool</span> (<span class="type">const</span> string &amp;, <span class="type">const</span> string &amp;))</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">useBigger</span><span class="params">(<span class="type">const</span> string &amp;, <span class="type">const</span> string &amp;, <span class="type">bool</span> (*)(<span class="type">const</span> string &amp;, <span class="type">const</span> string &amp;))</span></span>;   <span class="comment">//就像普通类型的定义类似，不需要指名函数名。</span></span><br></pre></td></tr></table></figure>

<p>69.返回指向函数的指针，可能从函数名开始由里向外分析。eg:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span>  (*<span class="built_in">ff</span>(<span class="type">int</span>))(<span class="type">int</span> *, <span class="type">int</span>);  <span class="comment">//它表示ff声明为一个函数，它带有一个int型的形参，并返回`int (*)(int *, int);`，它是一个指向函数的指针，该函数返回int型并带有两个分别为`int *`和`int`的形参。其等价的typedef定义为：</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*PF)</span><span class="params">(<span class="type">int</span> *, <span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="function">PF <span class="title">ff</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p>70.函数无法返回函数，只能返回指向函数的指针。而当形参为指向函数的指针时，具有函数类型的对应的实参会被自动转换为指向相应函数类型的指针。eg:   </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">int</span> *, <span class="type">int</span>)</span></span>;  <span class="comment">//func为函数类型</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">(func)</span></span>;  <span class="comment">//OK,f1含有一个函数类型的形参</span></span><br><span class="line"><span class="function">func <span class="title">f2</span><span class="params">(<span class="type">int</span>)</span></span>;  <span class="comment">//ERROR，f2返回的是个函数</span></span><br><span class="line"><span class="function">func *<span class="title">f3</span><span class="params">(<span class="type">int</span>)</span></span>;  <span class="comment">//OK，f3返回类型为指向函数的指针。</span></span><br></pre></td></tr></table></figure>

<p>71.C++允许使用函数指针指向重载的函数。定义该指针时其类型必须与重载函数精确匹配。</p>
<h1 id="类"><a href="#类" class="headerlink" title="类"></a>类</h1><p>1.类的声明和定义可以在一起，即声明一个类类型时，同时定义它的成员。也可以暂时只声明而不定义。eg: <code>class Sales_data;</code>。这种声明被称作前面声明（forward declaration），在它声明之后定义之前是一个不完全类型（incomplete type）。不完全类型只能在非常有限的情况下使用：可以定义指向这种类型的指针或引用，也可以声明（但不能定义）以不完全类型作为参数或者返回类型的函数。  </p>
<p>58.类的所有成员必须在定义类的花括号中声明，成员函数的定义可以放在类的定义内定义，也可以放在类的定义外定义。放在类的定义内定义的成员函数会被编译器隐式地当作内联(inline)函数。当成员函数在类外进行定义时，记得命名空间，在类外定义时也可以使用inline进行修饰，通常应该加上inline以便于阅读。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">Sales_item::avg_price</span><span class="params">()</span> <span class="type">const</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>59.每个类成员函数都隐含的包含一个形参this,在调用成员函数时，形参this初始化为调用函数的对象的地址。在成员函数中，不必显示的使用this指针来访问被调用函数所属对象的成员。对这个类的成员的任何没有前缀的引用，都被假定为通过指针this实现的引用,此规则只是针对对象的成员函数的调用，在定义成员函数时必须使用this。eg:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Sales_item::add_price</span><span class="params">(<span class="type">double</span> price)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;price = price;  <span class="comment">//其中this-&gt;price为类成员属性price，必须使用this-&gt;price</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>60.如果在成员函数名后面,花括号前面加上修鉓符const，则this将成为指向调用对象的const的指针,该成员函数称为常量成员函数。可以有效保护对象不被成员函数修改。eg:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//该函数将无法修改this.isbn及this所指对象的常量成员。</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">same_isbn</span><span class="params">(<span class="type">const</span> Sales_item &amp;rhs)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="keyword">return</span> isbn == rhs.isbn;&#125;  <span class="comment">//等价于&#123;this-&gt;isbn == rhs.isbn;&#125;</span></span><br></pre></td></tr></table></figure>

<p>61.函数可以直接返回整个对象，或者返回一个对象的引用，也可以返回this对象。 eg:  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Sales_item&amp; <span class="title">Sales_item::combine</span><span class="params">(<span class="type">const</span> Sales_item &amp;rhs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">//combine this and rhs</span></span><br><span class="line">   <span class="keyword">return</span> *<span class="keyword">this</span>; <span class="comment">//</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>62.IO类属于不能被拷贝的类型，所以函数在传递IO类时需要以引用的方式传递。  </p>
<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>61.构造函数与类同名，且没有返回类型。每个类可以有多个构造函数，每个构造函数的形参表必须不同。构造函数应该放在public部分，用于初始化对象。</p>
<p>62.当类中没有构造函数时，编译器会自动生成默认构造函数。但不能依赖于默认构造函数，通常应该为类定义默认构造函数，原因为：  </p>
<ul>
<li>当我们定义了其他构造函数时，编译器将不会再生成默认构造函数，除非再定义一个默认构造函数，否则类将没有默认构造函数。  </li>
<li>如果类包含内置类型或者复合类型的成员，只有当这些成员都有类内初始值时，这个类才能合适地使用默认构造函数。  </li>
<li>有些情况下编译器也无法为某些类合成默认构造函数。例如，如果类中包含一个其他类类型的成员且这个成员的类型没有默认构造函数时。  </li>
</ul>
<p>63.C++11中允许使用 <code>= default</code>的方式来要求编译器生成默认构造函数。eg: <code>Sales_data() = default;</code>  </p>
<p>62.构造函数的定义：”类名(形参表)：构造函数的初始化列表 {函数体}”eg:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Sales_data</span>(): <span class="built_in">units_sold</span>(<span class="number">0</span>), <span class="built_in">revenue</span>(<span class="number">0.0</span>) &#123;&#125;  <span class="comment">//成员名后面的圆括号中为成员初值</span></span><br></pre></td></tr></table></figure>
<p>构造函数也可以只在类内声明，然后在类外面进行定义，在类外面定义时，必须通过类名指定该构造函数属于哪个类。<br>构造函数的初始化列表可以为空，函数体也可以为空。  </p>
<p>63.类的定义为 class 类名 {}; 记得后面要有个分号。</p>
<p>63.类内的变量的初始值不能使用圆括号初始化。  </p>
<p>5.struct和class的唯一区别是默认访问级别，struct默认访问级别为public，class默认访问级别是private。</p>
<p>6.类中public部分定义的成员在程序的任何部分都可以访问，通常在public部分放置操作，以便在程序的其他部分可以执行这些操作。类中private部分定义的成员只能被作为类的组成部分的代码（以及该类的友元）访问。通常在private部分放置数据，以对对象的内部数据进行隐藏。</p>
<h2 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h2><p>7.类可以通过友元来允许其他类或者函数访问它的非公有成员，方法是在类内部使用关键字friend声明相应的函数。eg:  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">friend</span> std::istream &amp;<span class="title">read</span><span class="params">(std::istream&amp;, Sales_data&amp;)</span></span>;</span><br></pre></td></tr></table></figure>
<p>友元的声明只能出现在类定义的内部，但在类内出现的位置不限，友元不是类的成员，所以也不受它所在区域访问控制级别的约束。一般，最好在类定义开始或结束前的位置集中声明友元。  </p>
<p>8.由于友元的声明仅仅指定了访问的权限，并非一个通常意义上的函数声明。所以如果我们希望类的用户能够调用某个友元函数，那么我们就必须在友元声明之外再专门对函数进行一次声明。  </p>
<p>9.可以通过在类中定义某种类型的别名来隐藏类的具体实现，在类中定义的类型名字同样存在访问限制，可以是public或者private中的一种。eg:  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Screen</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="keyword">typedef</span> std::string::size_type pos; <span class="comment">//等价于using pos = std::string::size_type;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">   pos cursor = <span class="number">0</span>;</span><br><span class="line">   pos height = <span class="number">0</span>, width = <span class="number">0</span>;</span><br><span class="line">   std::string contents;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>10.类的成员函数也可以被重载。  </p>
<p>11.可以通过关键字mutable将类的数据成员声明为可变数据成员(mutable data member)，可变数据成员永远不会是const，即使它是const对象的成员，const成员函数依然可以改变它的值。eg:  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Screen</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">some_member</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">   <span class="keyword">mutable</span> <span class="type">size_t</span> access_ctr;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Screen::some_member</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   ++access_ctr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>8.类内初始值必须使用=的初始化形式或者花括号括起来的直接初始化形式。  </p>
<p>9.成员函数返回<code>*this</code>时，如果该函数需要修改对象的成员，应让其返回对象的引用，这样即可以避免只能改变对象的临时副本，又能避免数据拷贝。  </p>
<p>10.一个const成员函数如果以引用的形式返回*this，那么它的返回类型将是常量引用。  </p>
<p>11.即使两个类的成员列表完全一致，它们也是不同的类型。  </p>
<p>12.默认初始化类的方式：  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">以下两个声明等价</span><br><span class="line">Sales_data item1;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sales_data</span> item1;  <span class="comment">//C语言中通常使用这种方式  </span></span><br></pre></td></tr></table></figure>

<p>13.类可以把其他的类定义成友元，也可以把其他类的成员函数定义成友元，友元函数能定义在类的内部，这样的函数是隐式内联的。友元关系不存在传递性，每个类负责控制自己的友元类或友元函数。eg:    </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//A是B的友元类，所以A的成员函数将可以访问B中包括非公有成员在内的所有成员。  </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">do</span><span class="params">(B&amp;)</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line"><span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">A</span>;</span><br><span class="line"><span class="comment">//指定类A中的某个成员函数成为B的友元。  </span></span><br><span class="line"><span class="function">free <span class="type">void</span> <span class="title">A::do</span><span class="params">(B&amp;)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">A::<span class="built_in">do</span>(B&amp; b) &#123;<span class="keyword">return</span> *<span class="keyword">this</span>&#125;</span><br></pre></td></tr></table></figure>
<p>要想令某个成员函数作为友元，必须仔细组织程序的结构以满足声明和定义的彼此依赖关系，必须按照如下方式设计程序：  </p>
<ul>
<li>首先定义A类，其中声明do函数，但此时不能定义，在do使用B的成员之前必须先声明B。  </li>
<li>接下来定义B，包括对于do的友元声明。  </li>
<li>最后定义do函数的实际内容，此时它才可以使用B的成员。</li>
</ul>
<p>14.类和非成员函数的声明不是必须在它们的友元声明之前，此时隐匿地假定该名字在当前作用域是可见的。即使在类的内部定义友元时定义该函数，也必须在类的外部提供相应的声明从而使得函数可见。eg:    </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">X</span> &#123;</span><br><span class="line">   <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; &#125; <span class="comment">//友元可以定义在类的内部</span></span><br><span class="line">   <span class="built_in">X</span>() &#123;<span class="built_in">f</span>();&#125;  <span class="comment">//错误：f还没有被声明</span></span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">h</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">X::g</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">f</span>(); &#125;  <span class="comment">//错误：f还没有被声明</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">X::h</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">f</span>(); &#125; <span class="comment">//正确：现在f的声明在作用域中了</span></span><br></pre></td></tr></table></figure>

<p>14.一旦遇到类名，定义的剩余部分就在类的作用域之内了，这里的剩余部分包括参数列表和函数体，也就是此时可以直接使用类的成员，而无需再次指明类名。但类名之前的成员必须通过<code>::</code>来指明其所属类（例如成员函数的返回类型），包括在类中定义的类型别名。  </p>
<p>15.编译器在处理类的定义时分两步：首先编译成员的声明，然后直到类全部可见后才编译函数体。所以定义在类内的成员函数中可以使用在其后定义的成员。而声明中使用的名字，包括返回类型及参数列表则必须在使用前确保可见。    </p>
<p>16.通常内层作用域中可以重新定义外层作用域中的名字，即使该名字已经在内层作用域中使用过，然后在类中，如果成员使用外层作用域中的某个名字，而该名字代表一种类型，则类不能在之后重新定义该名字。  </p>
<p>17.三种情况下类成员必须在默认构造函数中显示初始化：成员是const或者是引用，或者当成员属于某种类类型且该类型没有定义默认构造函数时。  </p>
<p>18.由于构造函数初始化列表的顺序与成员声明的顺序一致，所有最好令构造函数初始值的顺序与成员声明的顺序保持一致。且如果有可能，应尽量避免使用某些成员初始化其他成员，这样就可以不必考虑成员的初始化顺序。  </p>
<p>19.如果一个构造函数为所有参数都提供了默认实参，则它实际上也定义了默认构造函数。  </p>
<p>20.C++11中新增加了委托构造函数。一个委托构造函数使用它所属类的其他构造函数执行它自己的初始化过程，或者说它把它自己的一些职责委托给其他构造函数。委托构造函数的声明也有一个成员初始值的列表和一个函数体，其成员初始值列表只有一个唯一的入口，就是类名本身，类名后面紧跟圆括号括起来的参数列表，参数列表必须与类中的另一个构造函数匹配。eg:  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Sales_data</span> &#123;</span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line"><span class="comment">//非委托构造函数使用对应的实参初始化成员</span></span><br><span class="line">   <span class="built_in">Sales_data</span>(std::string s, <span class="type">unsigned</span> cnt, <span class="type">double</span> price): <span class="built_in">bookNo</span>(s), <span class="built_in">units_sold</span>(cnt), <span class="built_in">revenue</span>(cnt*price) &#123; &#125;</span><br><span class="line"><span class="comment">//下面的构造函数全都委托给另一个构造函数</span></span><br><span class="line">   <span class="built_in">Sales_data</span>(): <span class="built_in">Sales_data</span>(<span class="string">&quot;&quot;</span>, <span class="number">0</span>, <span class="number">0</span>) &#123; &#125;</span><br><span class="line">   <span class="built_in">Sales_data</span>(std::string s): <span class="built_in">Sales_data</span>(s, <span class="number">0</span>, <span class="number">0</span>) &#123; &#125;</span><br><span class="line">   <span class="built_in">Sales_data</span>(std::istream &amp;is): <span class="built_in">Sales_data</span>() &#123; <span class="built_in">read</span>(is, *<span class="keyword">this</span>); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>21.如果构造函数只接受一个实参，则它实际上定义了将该实参转换为此类类型的隐式转换机制，有时我们把这种构造函数称作转换构造函数，即这种构造函数的参数可以初始隐式的转换为该类的类类型。例如当类A中的某个构造函数只含有一个string类型的实参作为其参数列表时，当调用函数中的参数需要使用A时，则可以使用string直接替代，此时编译器会用给定的string自动创建一个A对象，并将这个（临时）的A对象传递给调用函数，这里的调用函数的参数应该是一个常量引用。编译器只会执行一步类型转换，也就是说当你使用一个字符串字面值直接给这个调用函数时，将无法编译通过，因为它不能被自动转换为string然后再转换为A对象，必须强制将其先转换为string。  </p>
<p>22.可以通过将构造函数声明为explicit以阻止构造函数的隐式转换，这样构造函数A将不能再成为转换构造函数。eg:  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">   <span class="function"><span class="keyword">explicit</span> <span class="title">A</span><span class="params">(<span class="type">const</span> std::string &amp;s)</span>: bookNo(s) &#123;</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当构造函数被声明为explicit时，它将只能以直接初始化的形式使用（即圆括号），而不能使用赋值初始化（即通过=号进行的拷贝初始化）  </p>
<p>13.类类型当然也支持显式的强制类型转换，例如：  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">   std::string bookNo;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">   <span class="built_in">A</span>(std::string s): <span class="built_in">bookNo</span>(s) &#123;&#125;</span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">combin</span><span class="params">(A)</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">A itemA;</span><br><span class="line">itemA.<span class="built_in">combin</span>(<span class="built_in">A</span>(<span class="string">&quot;Hello&quot;</span>));</span><br><span class="line">itemA.<span class="built_in">combin</span>(<span class="built_in">static_cast</span>&lt;A&gt;(<span class="string">&quot;Hello&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>19.聚合类使得用户可以直接访问其成员，并且具体特殊的初始化语法形式。当满足以下条件时，才是聚合类：  </p>
<ul>
<li>所有成员都是public的  </li>
<li>没有定义任何构造函数  </li>
<li>没有类内初始值  </li>
<li>没有基类，也没有virtual函数。<br>这种类在初始化时使用花括号括起来的成员初始值列表进行初始化，初始值的顺序必须与声明的顺序一致。<br>eg:  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Data</span> &#123;</span><br><span class="line">   <span class="type">int</span> ival;</span><br><span class="line">   string s;</span><br><span class="line">&#125;;</span><br><span class="line">Data val = &#123;<span class="number">0</span>, <span class="string">&quot;test&quot;</span>&#125;;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>21.数据成员都是字面值类型的聚合类是字面值常量类。如果一个类不是聚合类，但它符合以下要求，也可以是一个字面值常量类：  </p>
<ul>
<li>数据成员都必须是字面值类型  </li>
<li>类必须至少含有一个constexpr构造函数  </li>
<li>如果一个数据成员含有类内初始值，则内置类型成员的初始值必须是一条常量表达式；或者如果成员属于某种类类型，则初始值必须使用成员自己的constexpr构造函数。  </li>
<li>类必须使用析构函数的默认定义，该成员负责销毁类的对象。  </li>
</ul>
<p>22.通过static声明类的静态成员（可以是数据或者函数），类的静态成员直接与类本身关联，而不是与类的各个对象保持关联。静态成员也可以是public或private，静态数据成员的类型可以是常量、引用、指针、类类型等。类的静态成员被该类的所有对象所共享。静态成员函数不能声明成const的，而且也不能在static函数体内使用this指针。<br>由于非静态成员需要实例化后才会分配内存，而静态成员属于类，一直存在于内存中，所以静态成员不能访问非静态成员。但非静态成员可以访问类的静态成员</p>
<p>21.静态成员函数即可以定义在类的内部也可以定义在类的外部，但定义在类的外部时不能重复static关键字，static关键字只出现在类内部的声明语句中。  </p>
<p>23.使用静态成员的方式：</p>
<ul>
<li>直接使用作用域运算符通过类名来访问静态成员，eg:<code>double r = Account::rate();</code>  </li>
<li>使用类的对象、引用或指针来访问静态成员，eg:  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Account ac1;</span><br><span class="line">Account *ac2 = &amp;ac1;</span><br><span class="line"><span class="comment">//以下两种方式等价</span></span><br><span class="line"><span class="type">double</span> r = ac1.<span class="built_in">rate</span>();</span><br><span class="line"><span class="type">double</span> ac2-&gt;<span class="built_in">rate</span>();</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="标准IO库"><a href="#标准IO库" class="headerlink" title="标准IO库"></a>标准IO库</h1><ul>
<li>iostream  对流进行读写  从istream和ostream派生而来  含istream和ostream</li>
<li>fstream  读写文件，由iostream派生而来  含ifstream和ofstream</li>
<li>sstream  对string对象进行读写，由iostream派生而来  含istringstream和ostringstream</li>
</ul>
<p>73.标准IO为了对国际字符的支持，有一组带”w”前缀的IO库。如wostream、wistream、wiostream等对应的char类型为wchar_t类型。对应的标准输入输出对象为wcin、wcout，还有wcerr.</p>
<p>74.IO对象不可复制或复制，而只有支持复制的元素类型可以存储在容器类型中，所以IO对象不支持容器。形参或返回类型也不能为流类型，如果需要传递或者返回IO对象，则必须传递或返回指向该对象的指针或引用。</p>
<p>75.标准IO库的条件状态标志，适用于普通流、文件流以及string流。注意，这些只是状态标准，例如s.clear()只是将流的标志重置为有效状态，但并不会清空流的缓冲区。清空缓冲区需要使用cin.sync()。</p>
<p>failbit通常是可以修正，例如需要int却输入了字符串则为s.fail()返回true，此时可能通过s.clear()进行重置流状态为有效。而badbit是系统级的故障，出现这类错误时的流将无法再使用。</p>
<p>76.输出缓冲区的管理。每个IO对象管理一个缓冲区用于存储程序读写的数据。输出缓冲区的内容被刷新的方式有：<br>1).程序正常结束。作为main返回工作的一部分，将清空所有输出缓冲区。<br>2).在一些不确定的时候，缓冲区已经满了，此时缓冲区将会在下一个值写入之前刷新。<br>3).用操纵符显式地刷新缓冲区，例如结束符endl用于输出一个换行符并刷新缓冲区，flush用于刷新流但不在输出中添加任何字符，ends在缓冲区中插入字符null然后再刷新它。<br>4).在每次输出操作执行完成后，用unitbuf操纵符设置流的内部状态，从而清空缓冲区。<br>如果需要刷新所有输出，最好使用unitbuf，它每次执行完写操作后都刷新流：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cout &lt;&lt; unitbuf &lt;&lt; <span class="string">&quot;first&quot;</span> &lt;&lt; <span class="string">&quot; second&quot;</span> &lt;&lt; nounitbuf;</span><br></pre></td></tr></table></figure>
<p>等价于：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cout &lt;&lt; <span class="string">&quot;first&quot;</span> &lt;&lt; flush &lt;&lt; <span class="string">&quot; second&quot;</span> &lt;&lt; flush;</span><br></pre></td></tr></table></figure>
<p>nounitbuf 操纵符将流恢复为使用正常的、由系统管理的缓冲区刷新方式。<br>5).可将输出流与输入流关联(使用tie函数)起来，这样，在读输入流时将刷新其关联的输出缓冲区。<br>当输入流与输出流绑在一起时，任何读输入流的尝试都将首先刷新其输出流关联的缓冲区。标准库将cout与cin绑在一起。eg:<br>cin.tie(&amp;cout);</p>
<p>77.程序在崩溃时不会自动刷新输出缓冲区</p>
<p>78.从标准输入一直读取直到遇到文件结束符，不管读到时是否发生了错误都进入循环，可有效检测错误原因，记得使用逗号。eg:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (cin &gt;&gt; ival, !cin.<span class="built_in">eof</span>())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (cin.<span class="built_in">bad</span>())    <span class="comment">//检测流是否为不可恢复的的badbit</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">runtime_error</span>(<span class="string">&quot;IO stream corrupted&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (cin.<span class="built_in">fail</span>())    <span class="comment">//检测流是否为还可以再使用的failbit错误，如果是则重置failbit标志并重新使用该流</span></span><br><span class="line">    &#123;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;bad data, try again&quot;</span>;</span><br><span class="line">        cin.<span class="built_in">clear</span>(istream::failbit);   <span class="comment">//重置流的状态标志，但不会清空输入缓冲区。</span></span><br><span class="line">        cin.<span class="built_in">sync</span>();  <span class="comment">//清空输入缓冲区中的所有内容。</span></span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>79.当需要处理多种状态时可以使用按位或操作符在一次调用中生成“两个或更多状态位”。eg：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">is.<span class="built_in">setstate</span>(ifstream::badbit | ifstream::failbit);  <span class="comment">//同时设置badbit和failbit位为真</span></span><br></pre></td></tr></table></figure>

<p>80.cin.clear()重置cin的状态标志为有效，cin.sync()清空输入缓冲区中的内容，cin.ignor()可用于清空输入流中的部分内容。</p>
<h2 id="文件的输入和输出"><a href="#文件的输入和输出" class="headerlink" title="文件的输入和输出"></a>文件的输入和输出</h2><p>fstream头文件定义了三种支持文件IO的类型：</p>
<ul>
<li>ifstream，由istream派生，提供读文件的功能。</li>
<li>ofstream，由ostream派生，提供写文件的功能。</li>
<li>fstream，由iostream派生，提供读写同一个文件的功能。<br>eg:  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ifstream <span class="title">infile</span><span class="params">(ifile.c_str())</span></span>;  <span class="comment">//定义并初始化输入文件流infile，并将其与将要读取的文件ifile绑定。 &lt;=&gt;`ifstream infile; infile.open(&quot;in&quot;);`//假设文件名为in并在当前文件夹</span></span><br><span class="line"><span class="function">ofstream <span class="title">outfile</span><span class="params">(ofile.c_str())</span></span>;  <span class="comment">//定义并初始化输出文件流outfile，并将其与将要写入的文件ofile绑定。 &lt;=&gt;`ofstream outfile; outfile.open(&quot;out&quot;);`//假设文件名为out并在当前文件夹</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>82.检查文件是否已成功打开<code>if (!infile)</code>。如果要将文件流与新文件重新捆绑必须先将其关闭<code>infile.close();</code></p>
<p>83.关于文件的读写实例：  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//    string file = &quot;out.txt&quot;;</span></span><br><span class="line"><span class="comment">//    cin &gt;&gt; file;</span></span><br><span class="line"><span class="comment">//    ofstream outfile(file.c_str());  //定义并打开一个用于写入的文件流outfile，记得转成c风格字符串</span></span><br><span class="line"><span class="comment">//    cin.clear();  //重置输入流标志防止cin有可能出现的错误</span></span><br><span class="line"><span class="comment">//    cin.sync();  //清空输入流缓冲区的内容</span></span><br><span class="line"><span class="comment">//    if (!outfile)  //判断写文件流是否有效</span></span><br><span class="line"><span class="comment">//    &#123;</span></span><br><span class="line"><span class="comment">//        cout &lt;&lt; &quot;Error to open the file &quot; &lt;&lt; file &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//    else</span></span><br><span class="line"><span class="comment">//    &#123;</span></span><br><span class="line"><span class="comment">//        cout &lt;&lt; &quot;Enter some words:&quot; &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//        string str;</span></span><br><span class="line"><span class="comment">//        getline(cin, str);  //一次读到一行</span></span><br><span class="line"><span class="comment">//        outfile &lt;&lt; str;  //将str写到文件输出流outfile中</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//    outfile.close();  //关闭文件流</span></span><br><span class="line">    string file = <span class="string">&quot;sales_item.h&quot;</span>;</span><br><span class="line">    <span class="function">ifstream <span class="title">infile</span><span class="params">(file.c_str())</span></span>;  <span class="comment">//定义并初始化文件输入流 </span></span><br><span class="line">    <span class="keyword">if</span> (!infile)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Error to open infile &quot;</span> &lt;&lt; file &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; file &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="comment">//        string str;</span></span><br><span class="line"><span class="comment">//        getline(infile, str);</span></span><br><span class="line"><span class="comment">//        cout &lt;&lt; str &lt;&lt; endl;</span></span><br><span class="line">        string str;</span><br><span class="line">        vector&lt;string&gt; sales;</span><br><span class="line">        <span class="keyword">while</span> (!infile.<span class="built_in">eof</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">getline</span>(infile, str);</span><br><span class="line">            sales.<span class="built_in">push_back</span>(str);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (vector&lt;string&gt;::const_iterator ite = sales.<span class="built_in">begin</span>(); ite != sales.<span class="built_in">end</span>(); ++ite)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; *ite &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    infile.<span class="built_in">close</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>84.文件的打开模式，注意这些模式指的是文件的模式而不是流的模式。<br>其中out、trunc和app模式只能用于ofstream或者fstream，in模式只能用于ifstream或fstream。所有的文件都可以使用ate或binary模式。<br>eg:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ofstream <span class="title">outfile</span><span class="params">(<span class="string">&quot;filename&quot;</span>, ofstream::out | ofstream::trunc)</span></span>;  <span class="comment">//使用按位或操作符同时以out和trunc模式打开文件。</span></span><br></pre></td></tr></table></figure>
<p>默认时ifstream流对象关联的文件将以in模式打开，ofstream默认以out模式打开。以out模式打开的文件内容会被清空，效果上等同于同时指定了out和trunc模式。</p>
<p>85.fstream既可以读也可以写它所关联的文件，如何处理它的文件取决于它打开的模式。eg:<br>fstream inout(“filename”, fstream::in | fstream::out);  //同时以输入和输出模式打开文件</p>
<p>86.打开模式的有效组合：</p>
<p>87.打开文件前若未知原文件流的状态，一定记得首先使用in.close();in.clear();重置原来的流。</p>
<h2 id="字符串流"><a href="#字符串流" class="headerlink" title="字符串流"></a>字符串流</h2><p>88.字符串流的操作包含在头文件sstream头文件中。类似于文件流它包含对应的三种类型：istringstream、ostringstream和stringstream。像fstream一样，iostream的操作也都适用于sstream相关对象。</p>
<p>89.stringstream的特定操作strm.str();strm.str(s);  </p>
<p>90.字符串流的用处：<br>1)可以同时对一行以及一行中的单词进行处理。eg:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">string line, word;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">getline</span>(cin, line))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">istringstream <span class="title">stream</span><span class="params">(line)</span></span>;  <span class="comment">//定义并初始化stringstream对象</span></span><br><span class="line">    <span class="keyword">while</span> (stream &gt;&gt; word)    <span class="comment">//从一行中读取单词</span></span><br><span class="line">    &#123;</span><br><span class="line">        processing;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2)stringstream可用于转换或格式化字符串。eg:<br>将数字转化为字符串：<br>int val1 = 512, val2 = 1024;<br>ostringstream format_message;<br>format_message &lt;&lt; “val1: “ &lt;&lt; val1 &lt;&lt; “\n” &lt;&lt; “val2: “ &lt;&lt; val2 &lt;&lt; “\n”;  //format_message内容将为val1: 512\nval2: 1024</p>
<p>将字符串转化为数字：<br>istringstream input_istring(format_message.str());<br>string dump;<br>input_istring &gt;&gt; dump &gt;&gt; val1 &gt;&gt; dum &gt;&gt; val2;  //非数字将被输入到dump而数字512和1024将分别被输入val1和val2。程序会自动忽略换行符。</p>
<h1 id="顺序容器"><a href="#顺序容器" class="headerlink" title="顺序容器"></a>顺序容器</h1><p>元素在顺序容器中的顺序与其加入容器时的位置相对应。<br>关联容器中元素的位置由元素相关联的关键字值决定。<br>1.顺序容器类型：  </p>
<ul>
<li>vector 相当于可变大小的数组。支持快速随机访问，在尾部之外的位置插入或删除元素可能很慢。  </li>
<li>deque 双端队列。支持快速随机访问。在头尾位置插入/删除速度很快。  </li>
<li>list 双向链表。只支持双向顺序访问。在list中任何位置进行插入或删除操作速度都很快。  </li>
<li>forward_list(C++11) 单向链表。只支持单向顺序访问。在链表任何位置进行插入或删除都很快。  </li>
<li>array(C++11) 固定大小的数组。支持快速随机访问，不能添加或删除元素。  </li>
<li>string 与vector相似的容器，但专门用于保存字符。随机访问快，在尾部插入或删除速度快。<br>除了固定大小的array外，其他容器都提供高效、灵活的内存管理。<br>string和vector的元素保存的连续的内存空间中，所以对其使用下标访问元素速度依然很快，但在中间位置插入元素由于需要移动大量元素，所以会非常慢。<br>list和forward_list可以方便地在任何位置添加或删除元素，速度都会很快，但不支持随机访问。而且与vector、deque和array相比，这两个容器的额外内存开销也很大。<br>deque是一个更为复杂的数据结构，与string和vector类似，其支持随机访问，同样在中间位置添加或删除元素代价可能会很高。但在deque的两端添加或删除元素都很快，可以与list或forward_list添加删除元素的速度相当。<br>与内置的数组相比，C++11新增加的array是一种更安全、更容易使用的数组类型，当然其大小也是固定的。C++11中的forward_list设计的目标是达到与最好的手写单向链表数据结构相当的性能，所以forward_list没有size操作。  </li>
</ul>
<p>2.通常，使用vector是最好的选择，除非你有很好的理由选择其他容器。  </p>
<p>3.每个容器都定义在其相应的头文件中，容器均定义为模板类。  </p>
<p>4.可以定义元素类型为容器的容器，如<code>vector&lt;vector&lt;string&gt;&gt; lines</code>，C++11之前的版本需要在后面两个尖括号之前加一个空格。  </p>
<p>5.每种容器都支持迭代器及对应的操作，其他forward_list的迭代器不支持<code>--</code>运算符。  </p>
<p>6.容器的迭代器所描述的元素范围称为左闭合区间[begin, end)，因为end指向的是容器最后一个元素的下一个位置。  </p>
<p>7.在不需要修改容器元素的情况下记得使用const_iterator迭代器。  </p>
<p>8.每个容器的迭代器也都有其对应的反向迭代器reverse_iterator，反向迭代器++会获取其前一个元素。  </p>
<p>9.容器的索引类型为container<type>::size_type，例如int的vector的索引类型为<code>vector&lt;int&gt;::size_type</code>   </p>
<p>10.<code>begin</code>和<code>end</code>返回的迭代器有多个版本，以r开头的版本返回反向迭代器，以c开头的版本返回const迭代器。例如:    </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">list&lt;string&gt; a;</span><br><span class="line"><span class="keyword">auto</span> it1 = a.<span class="built_in">begin</span>();  <span class="comment">//list&lt;string&gt;::iterator</span></span><br><span class="line"><span class="keyword">auto</span> it2 = a.<span class="built_in">rbegin</span>();  <span class="comment">//list&lt;string&gt;::reverse_iterator</span></span><br><span class="line"><span class="keyword">auto</span> it3 = a.<span class="built_in">cbegin</span>();  <span class="comment">//list&lt;string&gt;::const_iterator</span></span><br><span class="line"><span class="keyword">auto</span> it4 = a.<span class="built_in">crbegin</span>();  <span class="comment">//list&lt;string&gt;::const_reverse_iterator</span></span><br></pre></td></tr></table></figure>
<p>所以当不需要写访问时，应使用cbegin和cend  </p>
<p>11.除了array之外，其他容器的默认构造函数都会创建一个指定类型的空容器，且顺序容器都可以接受指定容器大小和元素初始值的参数。使用方法与vector一样。    </p>
<p>12.与内置数组一样，标准库array的大小也是类型的一部分，当定义一个array时，除了指定元素类型，还要指定容器大小：  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">array&lt;<span class="type">int</span>, 42&gt; a1; <span class="comment">//定义一个保存42个int的数组</span></span><br><span class="line">array&lt;<span class="type">int</span>, 10&gt;::size_type i;  <span class="comment">//定义类型为array&lt;int, 10&gt;::size_type的数组下标</span></span><br></pre></td></tr></table></figure>

<p>13.array支持拷贝或对象赋值操作，由于类型必须一样(元素类型和大小都是类型的一部分)：  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">array&lt;<span class="type">int</span>, 10&gt; digits = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">array&lt;<span class="type">int</span>, 10&gt; copy = digits;</span><br></pre></td></tr></table></figure>

<p>14.vector的6种创建和初始化方式及初始值：  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; vec;    <span class="comment">// 0</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">vec</span><span class="params">(<span class="number">10</span>)</span></span>;    <span class="comment">// 0</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">vec</span><span class="params">(<span class="number">10</span>, <span class="number">1</span>)</span></span>;  <span class="comment">// 1</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; vec&#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;; <span class="comment">// 1, 2, 3, 4, 5</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">vec</span><span class="params">(other_vec)</span></span>; <span class="comment">// same as other_vec</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">vec</span><span class="params">(other_vec.begin(), other_vec.end())</span></span>; <span class="comment">// same as other_vec</span></span><br></pre></td></tr></table></figure>

<p>15.用于容器的swap和assign函数：  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">swap</span>(c1, c2); <span class="comment">//交换c1和c2中的元素。c1和c2必须具有相同的类型</span></span><br><span class="line">c1.<span class="built_in">swap</span>(c2); <span class="comment">//swap通常比从c2向c1拷贝元素快得多  </span></span><br><span class="line"><span class="comment">//assign操作不适用于关联容器和array</span></span><br><span class="line">seq.<span class="built_in">assign</span>(b, e);  <span class="comment">//将seq中的元素替换为迭代器b和e所表示的范围中的元素。迭代器b和e不能指向seq中的元素  </span></span><br><span class="line">seq.<span class="built_in">assign</span>(il);  <span class="comment">//将seq中的元素替换为初始化列表il中的元素</span></span><br><span class="line">seq.<span class="built_in">assign</span>(n, t); <span class="comment">//将seq中的元素替换为n个值为t的元素</span></span><br></pre></td></tr></table></figure>

<p>16.可变大小的容器都有三个与大小相关的操作：size()返回容器中的元素数目；empty()判断容器是否为空；max_size()返回一个大于或等于该类型容器所能容纳的最大元素数的值。  </p>
<p>17.每个容器都支持相等运算符(==和!=)，除了无序关联容器外的所有容器都支持关系运算符（<code>&gt;、&gt;=、&lt;、&lt;=</code>）。</p>
<p>18.顺序容器都有其相应的添加和删除元素的操作（push_back、insert、emplace等），其中emplace系列的成员函数是C++11中引入的，它们执行的操作是构造而不是拷贝元素，所以速度会快一些，因为拷贝元素时会创建一个临时变量。  </p>
<p>19.支持下标访问的容器有string、vector、deque、array，它们同时支持通过at来较安全的访问。下标越界的结果是未定义的，而at访问越界时会抛出out_of_range异常，用法为<code>c.at(n)</code>。   </p>
<p>20.访问元素的成员函数（即front、back、下标和at）返回的都是引用，即可以作为左值使用，如<code>c.front() = 42;</code>  </p>
<p>21.容器操作可能会使迭代器失效，特别是在改变了容器的大小时要特别留意是否在改变容器之后依然使用了改变之前的迭代器。  </p>
<p>22.容器大小管理操作：  </p>
<ul>
<li>shrink_to_fit 只适用于vector、string和deque。  </li>
<li>capacity和reserve只适用于vector和string。  </li>
<li>c.shrink_to_fit()  将capacity()减少为与size()相同大小  </li>
<li>c.reserve(n)  分配至少能容纳n个元素的内存空间<br>reserve并不改变容器中元素的数量，它仅影响vector预先分配多大的内存空间。只有当需要的内存空间超过当前容量时，reserve调用才会改变vector的容量。<br>capacity和size：容器的size是指它已经保存的元素的数目；而capacity则是在不分配新的内存空间的前提下它最多可以保存多少元素。  </li>
</ul>
<p>22.string还支持另外三个构造函数：  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//n、len2、pos2都是无符号值</span></span><br><span class="line"><span class="function">string <span class="title">s</span><span class="params">(cp, n)</span></span>; <span class="comment">//s是cp指向的数组中前n个字符的拷贝，此数组至少应该包含n个字符。  </span></span><br><span class="line"><span class="function">string <span class="title">s</span><span class="params">(s2, pos2)</span></span>;  <span class="comment">//s是string s2从下标pos2开始的字符的拷贝，若pos2&gt;s2.size(),构造函数的行为未定义  </span></span><br><span class="line"><span class="function">string <span class="title">s</span><span class="params">(s2, pos2, len2)</span></span>;  <span class="comment">//s是string s2从下标pos2开始len2个字符的拷贝。若pos2&gt;s2.size(),构造函数的行为未定义。不管len2的值是多少，构造函数至多拷贝s2.size()-pos2个字符  </span></span><br></pre></td></tr></table></figure>

<p>22.string有着丰富的成员函数，可以支持修改、查找、搜索、比较、数值转换等功能。  </p>
<h2 id="容器适配器"><a href="#容器适配器" class="headerlink" title="容器适配器"></a>容器适配器</h2><p>1.标准库中有三个顺序容器适配器：stack、queue和priority_queue，stack在stack头文件中，其他两个都在queue头文件中。容器、迭代器和函数都有适配器，容器适配器即一个容器适配器接受一种已有的容器类型，使其行为看起来像一种不同的类型。所有容器适配器都支持empty、size和swap函数。  </p>
<p>2.每个适配器都定义两个构造函数：默认构造函数创建一个空对象，接受一个容器的构造函数拷贝该容器来初始化适配器。eg:  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">deque&lt;<span class="type">int</span>&gt; deq;</span><br><span class="line"><span class="function">stack&lt;<span class="type">int</span>&gt; <span class="title">stk</span><span class="params">(deq)</span></span>; <span class="comment">//从deq拷贝元素到stk，假设deq中已经有初始值 </span></span><br><span class="line"><span class="comment">//在vector上实现的string类型的空栈</span></span><br><span class="line">stack&lt;string, vector&lt;string&gt;&gt; str_stk;</span><br><span class="line"><span class="comment">//str_stk2在vector上实现，初始化时保存svec的拷贝</span></span><br><span class="line">stack&lt;string, vector&lt;string&gt;&gt;  <span class="built_in">str_stk2</span>(svec);</span><br></pre></td></tr></table></figure>
<p>默认情况下，stack和queue是基于deque实现的，priority_queue是在vector之上实现的。  </p>
<p>3.所有适配器都要求容器具有添加、删除元素的能力，每一种容器适配器都有其对应的构造容器的限制。  </p>
<p>4.栈适配器stack在标准库头文件stack中，stack默认基于deque实现，也可以在list或者vector之上实现，其支持的其他特有操作：  </p>
<ul>
<li>s.pop()  删除栈顶元素，但不返回该元素值    </li>
<li>s.push(item)  创建一个新元素压入栈顶，该元素通过拷贝或移动item而来  </li>
<li>s.emplace(args)  同上，只是其由args构造  </li>
<li>s.top()  返回栈顶元素，但不将元素弹出栈<br>虽然适配器基于容器，但不能直接使用容器的操作。  </li>
</ul>
<p>5.队列适配器queue和priority_queue定义在queue头文件中，其中queue默认基于deque实现，priority_queue默认基于vector实现，queue也可以用list或vector实现，priority_queue也可以用deque实现。其支持的其他操作：    </p>
<ul>
<li>q.pop()    </li>
<li>q.front()  </li>
<li>q.back()  </li>
<li>q.top()  </li>
<li>q.push(item)  </li>
<li>q.emplace(args)<br>标准库queue使用一种先进先出（first-in，first-out，FIFO）的存储和访问策略。  </li>
</ul>
<h1 id="泛型算法"><a href="#泛型算法" class="headerlink" title="泛型算法"></a>泛型算法</h1><p>由于标准库容器定义的操作集合很小，所以标准库为这些容器定义了一组通用（generic，或称泛型的）算法：它们可以用于不同类型的容器和不同类型的元素。通常这些算法并不直接操作容器，而是遍历由两个迭代器指定的一个元素范围来进行操作。<br>1.大多数算法都定义在头文件algorithm中，头文件numeric中定义了一组数值泛型算法。<br>algorithm所有算法: <a href="http://www.cplusplus.com/reference/algorithm/">http://www.cplusplus.com/reference/algorithm/</a>  </p>
<p>2.泛型算法本身不会执行容器的操作，它们只会运行于迭代器之上，执行迭代器的操作。所以算法永远不会改变底层容器的大小。算法可能改变容器中保存元素的值，也可能在容器内移动元素，但永远不会直接添加或删除元素。算法可以通过操作标准库定义的一类特殊的迭代器——插入器（inserter）来完成容器添加元素的效果。  </p>
<p>3.除了少数例外，标准库算法都对一个范围内的元素进行操作，我们将此元素范围称为“输入范围”，接受输入范围的算法总是使用前两个参数来表示此范围，两个参数分别是指向要处理的第一个元素和尾元素之后位置的迭代器。   </p>
<p>4.那些只接受一个单一迭代器来表示第二个序列的算法，都假定第二个序列至少与第一个序列一样长。  </p>
<p>5.向目的位置迭代器写入数据的算法假定目的位置足够大，能容纳要写入的元素。注意vector等容器默认声明时如果不指定大小，是不分配初始空间大小的。  </p>
<p>6.插入迭代器可以通过容器算法向容器中赋值，back_inserter是一个定义在头文件iterator中的函数，可以用其生成插入迭代器。back_inserter接受一个指向容器的引用，返回一个与该容器绑定的插入迭代器，当我们通过此迭代器赋值时，赋值运算符会调用push_back将一个具有给定值的元素添加到容器中。eg:  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line"><span class="keyword">auto</span> it = <span class="built_in">back_inserter</span>(vec);</span><br><span class="line">*it = <span class="number">42</span>; <span class="comment">//向vec中添加一个元素，值为42</span></span><br><span class="line"><span class="built_in">fill_n</span>(vec, <span class="number">10</span>, <span class="number">0</span>); <span class="comment">//错误，fill_n无法向不存在的容器空间中写入数据。</span></span><br><span class="line"><span class="built_in">fill_n</span>(<span class="built_in">back_inserter</span>(vec), <span class="number">10</span>, <span class="number">0</span>); <span class="comment">//添加10个值为0的元素到vec中</span></span><br></pre></td></tr></table></figure>

<p>7.拷贝算法copy接受三个迭代器，前两个指定输入范围，第三个表示目的序列的起始位置，返回目的位置迭代器（递增后）的值。</p>
<p>8.replace算法可以将给定范围内的某个值替换为另一个值。  </p>
<p>9.重排容器元素的算法：sort()接受两个迭代器指定范围按字典序排序；unique()接受两个迭代器指定范围，将输入范围中重复值放在序列的后面，并返回指向不重复区域之后一个位置的迭代器；  </p>
<p>10.sort函数的默认排序是通过<code>&lt;</code>进行比较，可能通过向其传递第三个参数来指定比较方式，函数会对其每一个参数调用第三个参数代指的函数，通常第三个参数被称为谓词，谓词分为一元谓词（unary predicate）和二元谓词（binary predicate）。stable_sort可以维持相等元素的原有顺序。eg:  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isShorter</span><span class="params">(<span class="type">const</span> std::string &amp;a, <span class="type">const</span> std::string &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">return</span> a.<span class="built_in">size</span>() &lt; b.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用方法</span></span><br><span class="line"><span class="built_in">stable_sort</span>(words.<span class="built_in">begin</span>(), words.<span class="built_in">end</span>(), isShorter);</span><br></pre></td></tr></table></figure>

<h2 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h2><p>C++11新增的lambda表达式相当于未命名的内联函数，可以定义在函数内部。表达式形式如下：  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[capture list] (parameter list) -&gt; <span class="keyword">return</span> type &#123;function body&#125;;</span><br></pre></td></tr></table></figure>
<p>其中capture list（捕获列表）是一个lambda所在函数中定义的局部变量的列表（通常为空）；return type、parameter list和function body分别表示返回类型、参数列表和函数体，lambda必须使用尾置返回来指定返回类型。可以忽略参数列表和返回类型，但必须包含捕获列表和函数体。  </p>
<p>1.函数名加小括号即表示调用运算符，如<code>f()</code>。</p>
<p>2.使用lambda表达式的例子：  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">stable_sort</span>(words.<span class="built_in">begin</span>(), words.<span class="built_in">end</span>(), [](<span class="type">const</span> string &amp;a, <span class="type">const</span> string &amp;b) &#123;<span class="keyword">return</span> a.<span class="built_in">size</span>() &lt; b.<span class="built_in">size</span>();&#125;);</span><br></pre></td></tr></table></figure>
<p>实现上例的功能，空捕获列表表示此lambda不使用它所在函数中的任何局部变量。一个lambda只有在其捕获列表中捕获一个它所在函数中的局部变量，才能在函数体中使用该变量。但lambda可以直接使用局部static变量和在它所有函数之外声明的名字。    </p>
<p>3.使用for_each函数配合lambda表达式输出容器中的元素，每个元素后面接一个空格。eg:  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">for_each(words.<span class="built_in">begin</span>(), words.<span class="built_in">end</span>(), [](<span class="type">const</span> string &amp;s)&#123;cout &lt;&lt; s &lt;&lt; <span class="string">&quot; &quot;</span>;&#125;);</span><br></pre></td></tr></table></figure>

<p>4.当定义一个lambda时，编译器生成一个与lambda对应的新的（未命名的）类类型。  </p>
<p>5.与参数不同，lambda表达式中被捕获的变量的值是在lambda创建时拷贝，而不是调用时拷贝。  </p>
<p>6.可以通过给lambda的捕获列表传递=或&amp;告诉编译器隐匿地采用值捕获方式或引用捕获方式，当然也支持混合使用显示捕获与隐式捕获。eg:  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">for_each(words.<span class="built_in">begin</span>(), words.<span class="built_in">end</span>(), [&amp;, c](<span class="type">const</span> string &amp;s) &#123; os &lt;&lt; s &lt;&lt; c;&#125;);</span><br></pre></td></tr></table></figure>
<p>当混合使用隐式捕获与显示捕获时，捕获列表的第一个元素必须是一个&amp;或=，此符号即指定了默认捕获方式为引用或值，且显示捕获的变量必须采用与隐式捕获不同的方式。  </p>
<p>7.默认情况下，对于一个值被拷贝的局部变量，传递给lambda时为只读变量，lambda不会改变其值。可能通过在参数列表首加上关键字mutable来使用lambda可以改变局部变量的值。eg:  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">fcn3</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="type">size_t</span> v1 = <span class="number">42</span>;</span><br><span class="line">   <span class="comment">//如果没有mutable，编译将报错，因为v1是只读的</span></span><br><span class="line">   <span class="keyword">auto</span> f = [v1]() <span class="keyword">mutable</span> &#123;<span class="keyword">return</span> ++v1;&#125;;</span><br><span class="line">   v1 = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">auto</span> j = <span class="built_in">f</span>(); <span class="comment">//j为43</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>8.默认情况下，如果一个lambda体包含return之外的任何语句，则编译器假定此lambda返回void。  </p>
<p>9.当需要手动指定lambda的返回类型时，需要使用尾置返回类型：  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//transform算法可以遍历修改序列中的值</span></span><br><span class="line"><span class="built_in">transform</span>(vi.<span class="built_in">begin</span>(), vi.<span class="built_in">end</span>(), vi.<span class="built_in">begin</span>(), [](<span class="type">int</span> i) -&gt; <span class="type">int</span>  &#123;<span class="keyword">if</span> (i &lt; <span class="number">0</span>) <span class="keyword">return</span> -i; <span class="keyword">else</span> <span class="keyword">return</span> i;&#125;);</span><br></pre></td></tr></table></figure>

<p>10.标准库头文件functional中的bind函数可以将函数生成为一个新的可调用对象来“适应”原对象的参数列表。  </p>
<h2 id="iterator"><a href="#iterator" class="headerlink" title="iterator"></a>iterator</h2><p>11.标准库在头文件iterator中还定义了以下几种迭代器：  </p>
<ul>
<li>插入迭代器（insert iterator）：用于与一个容器绑定并向容器中插入元素。  <ul>
<li>back_inserter  </li>
<li>front_inserter  </li>
<li>inserter  </li>
</ul>
</li>
<li>流迭代器（stream iterator）：这些迭代器被绑定到输入或输出流上，可用来遍历所关联的IO流。通过使用流迭代器，我们可以用泛型算法从流对象读取数据以及向其写入数据。    <ul>
<li>istream_iterator 读取输入流。    </li>
<li>ostream_iterator 向一个流写入数据。   </li>
</ul>
</li>
<li>反向迭代器（reverse iterator）：即在容器中从尾元素向首元素反向移动的迭代器。  </li>
<li>移动迭代器（move iterator）：这种迭代器不拷贝其中的元素，而是移动它们。  </li>
</ul>
<p>1.插入迭代器用法：<code>std::unique_copy(lstr.begin(), lstr.end(), back_inserter(l_unique));</code>  </p>
<p>2.istream_iterator用法：  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">istream_iterator&lt;T&gt; <span class="title">in</span><span class="params">(is)</span></span>;  <span class="comment">//in从流is读取类型为T的值</span></span><br><span class="line">istream_iterator&lt;T&gt; end;  <span class="comment">//读取类型为T的值的istream_iterator迭代器，表示尾后位置。  </span></span><br><span class="line"><span class="comment">//下面从标准输入读取数据存入vector</span></span><br><span class="line"><span class="function">istream_iterator&lt;<span class="type">int</span>&gt; <span class="title">in_ter</span><span class="params">(cin)</span></span>;  <span class="comment">//从cin读取int</span></span><br><span class="line">istream_iterator&lt;<span class="type">int</span>&gt; eof;  <span class="comment">//istream尾后迭代器</span></span><br><span class="line"><span class="keyword">while</span> (in_ter != eof)  <span class="comment">//当有数据可供读取时</span></span><br><span class="line">   vec.<span class="built_in">push_back</span>(*in_ter++);</span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line"><span class="function">istream_iterator&lt;<span class="type">int</span>&gt; <span class="title">in_ter</span><span class="params">(cin)</span>, eof</span>; <span class="comment">//从cin读取int</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">vec</span><span class="params">(in_ter, eof)</span></span>; <span class="comment">//从迭代器范围构造vec</span></span><br></pre></td></tr></table></figure>

<p>2.ostream_iterator用法：  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ostream_iterator&lt;T&gt; <span class="title">out</span><span class="params">(os)</span></span>;  <span class="comment">//out将类型为T的值写到输出流os中</span></span><br><span class="line"><span class="function">ostream_iterator&lt;T&gt; <span class="title">out</span><span class="params">(os, d)</span></span>;  <span class="comment">//out将类型为T的值写到输出流os中，每个值后面都输出一个d。d指向一个空字符结尾的字符数组，例如字符串字面值。</span></span><br><span class="line"><span class="comment">//以下利用ostream_iterator输出vector的元素</span></span><br><span class="line"><span class="function">ostream_iterator&lt;<span class="type">int</span>&gt; <span class="title">out_iter</span><span class="params">(cout, <span class="string">&quot; &quot;</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> e : vec)</span><br><span class="line">   *out_iter++ = e; <span class="comment">//等价于out_iter = e;</span></span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="comment">//以上等价于使用copy的如下实现</span></span><br><span class="line"><span class="built_in">copy</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), out_iter);</span><br><span class="line">cout &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<p>3.iostream的迭代器举例：  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//实现功能为使用istream_iterator从文件读取string到vector中，然后使用ostream_iterator将vector中的元素输出到标准输出cout中</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">//定义文件流</span></span><br><span class="line">    <span class="function">std::ifstream <span class="title">in</span><span class="params">(<span class="string">&quot;test.cpp&quot;</span>)</span></span>;</span><br><span class="line">    <span class="comment">//使用文件流创建istream_iterator及文件结尾eof</span></span><br><span class="line">    <span class="function">std::istream_iterator&lt;std::string&gt; <span class="title">in_ter</span><span class="params">(in)</span>, eof</span>;</span><br><span class="line">   <span class="comment">//使用文件迭代器创建一个存放string的vector</span></span><br><span class="line">    <span class="function">std::vector&lt;std::string&gt; <span class="title">vecstr</span><span class="params">(in_ter, eof)</span></span>;</span><br><span class="line">    <span class="comment">//创建标准输出迭代器</span></span><br><span class="line">    <span class="function">std::ostream_iterator&lt;std::string&gt; <span class="title">out</span><span class="params">(std::cout, <span class="string">&quot; &quot;</span>)</span></span>;</span><br><span class="line">    <span class="comment">//使用copy函数将vector中的内容拷贝的含有标准输出的迭代器</span></span><br><span class="line">    std::<span class="built_in">copy</span>(vecstr.<span class="built_in">begin</span>(), vecstr.<span class="built_in">end</span>(), out);</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5.除了forward_list之外，其他容器都支持反向迭代器。</p>
<p>6.每个算法都会对它的每个迭代器参数指明须提供哪类迭代器。按算法要求可分为以下5类迭代器：  </p>
<ul>
<li>输入迭代器  只读，不写；单遍扫描，只能递增；find和accumulate要求输入迭代器，istream_iterator是一种输入迭代器。  </li>
<li>输出迭代器  只写，不读；单遍扫描，只能递增；ostream_iterator类型是输出迭代器    </li>
<li>前向迭代器  可读写；多遍扫描，只能递增；forward_list上的迭代器是前向迭代器    </li>
<li>双向迭代器  可读写；多遍扫描，可递增递减；除了forward_list之外，其他标准库都提供双向迭代器    </li>
<li>随机访问迭代器  可读写；多遍扫描，支持全部迭代器运算；array、deque、string和vector的迭代器都是随机访问迭代器       </li>
</ul>
<p>7.算法命名规范：  </p>
<ul>
<li>_if版本的算法接受一个谓词代替元素值，适用于lambda表达式。eg:    <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">find</span>(beg, end, val);  <span class="comment">//查找输入范围中val第一次出现的位置</span></span><br><span class="line"><span class="built_in">find_if</span>(beg, end, pred); <span class="comment">//查找第一个令pred为真的元素  </span></span><br></pre></td></tr></table></figure></li>
<li>_copy版本的算法会将元素拷贝到目的位置eg:  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">reverse</span>(beg, end);  <span class="comment">//反转元素</span></span><br><span class="line"><span class="built_in">reverse_copy</span>(beg, end, dest);  <span class="comment">//反转元素并拷贝到dest</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>8.list和forward_list定义了它们自己的sort, merge, remove, reverse和unique算法。  </p>
<h1 id="关联容器"><a href="#关联容器" class="headerlink" title="关联容器"></a>关联容器</h1><p>1.关联容器支持高效的关键字查找和访问。两个主要的关联容器类型是map和set。map使用关键字进行索引，set中每个元素只包含一个关键字，它支持高效的关键字查询操作——检查一个给定的关键字是否在set中。  </p>
<p>2.对于关联容器来说，第一个元素就相当于数组下标，第二个元素是对应下标下存储的值。    </p>
<p>2.标准库中一共定义了8个关联容器其中map和multimap定义在头文件map中；set和multiset定义在头文件set中；无序容器则定义在头文件unordered_map和unordered_set中。  </p>
<ul>
<li>按关键字有序保存元素的容器:  <ul>
<li>map   关联数组；保存关键字-值对</li>
<li>set   关键字即值，即只保存关键字的容器  </li>
<li>multimap  关键字可重复出现的map  </li>
<li>multiset  关键字可重复出现的set  </li>
</ul>
</li>
<li>无序集合:  <ul>
<li>unordered_map  用哈希函数组织的map  </li>
<li>unordered_set  用哈希函数组织的set  </li>
<li>unordered_multimap  用哈希函数组织的map；关键字可以重复出现  </li>
<li>unordered_multiset  用哈希函数组织的set；关键字可以重复出现  </li>
</ul>
</li>
</ul>
<p>3.关联容器使用举例：  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * testmap.cpp</span></span><br><span class="line"><span class="comment"> * 从test.cpp文件中读取单词，并统计单词出现的次数，不统计排除列表中的单词，能够将大小写单词，以及结尾有符号的单词识别为同一个单词，例如&quot;Expam&quot;，&quot;expam.&quot;，&quot;expam,&quot;为同一个单词</span></span><br><span class="line"><span class="comment"> * Copyright (C) 2015  &lt;@BLUEYI-PC&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Distributed under terms of the MIT license.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//声明文件流并初始化</span></span><br><span class="line">    <span class="function">std::ifstream <span class="title">in</span><span class="params">(<span class="string">&quot;test.cpp&quot;</span>)</span></span>;</span><br><span class="line">    <span class="comment">//使用文件流初始化流迭代器</span></span><br><span class="line">    <span class="function">std::istream_iterator&lt;std::string&gt; <span class="title">in_ite</span><span class="params">(in)</span>, eof</span>;</span><br><span class="line">    <span class="comment">//声明map，用于存放单词与其个数</span></span><br><span class="line">    std::map&lt;std::string, <span class="type">size_t</span>&gt; word_count;</span><br><span class="line">    <span class="comment">//声明set，存放排除列表</span></span><br><span class="line">    std::set&lt;std::string&gt; exclude = &#123;<span class="string">&quot;&#123;&quot;</span>, <span class="string">&quot;&#125;&quot;</span>, <span class="string">&quot;the&quot;</span>, <span class="string">&quot;and&quot;</span>&#125;;</span><br><span class="line">    std::string word;</span><br><span class="line">    <span class="keyword">while</span> (in_ite != eof) &#123;</span><br><span class="line">        word = *in_ite;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;ch : word) ch = std::<span class="built_in">tolower</span>(ch);</span><br><span class="line">        word.<span class="built_in">erase</span>(std::<span class="built_in">remove_if</span>(word.<span class="built_in">begin</span>(), word.<span class="built_in">end</span>(), ispunct), word.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">if</span> (exclude.<span class="built_in">find</span>(word) == exclude.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            ++word_count[word];</span><br><span class="line">        &#125;</span><br><span class="line">        in_ite++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span> &amp;w : word_count) &#123;</span><br><span class="line">        std::cout &lt;&lt; w.first &lt;&lt; <span class="string">&quot; occurs &quot;</span> &lt;&lt; w.second &lt;&lt; ((w.second &gt; <span class="number">1</span>) ? <span class="string">&quot; times&quot;</span> : <span class="string">&quot; time&quot;</span>) &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4.list、vector、deque、map以及set的使用场景：  </p>
<ul>
<li>list : anytime when a doubly-linked list is required.</li>
<li>vector : anytime when a dynamic array is required.</li>
<li>deque : An answer from Stackoverflow.</li>
<li>map : dictionary.</li>
<li>set : when to keep elements sorted and unique.<br>deque: </li>
</ul>
<blockquote>
<p>When modeling any kind of real-world waiting line: entities (bits, people, cars, words, particles, whatever) arrive with a certain frequency to the end of the line and are serviced at a different frequency at the beginning of the line. While waiting some entities may decide to leave the line…. etc. The point is that you need “fast access” to insert/deletes at both ends of the line, hence a deque.</p>
</blockquote>
<blockquote>
<p>I’m not sure how realistic this is. Consider that you can’t use a deque to model a real world line unless in that line only the last person can leave. Also in this hypothetical line if the third guy from the end wants to leave then everyone behind him better share his opinion because they’ll need to leave too. </p>
</blockquote>
<blockquote>
<p>I working on this right now: I have one program that displays images with 60Hz using OpenGL. Another program decides what should be drawn in the images. Unfortunately this other program occasionally stops for the garbage collection. I use a deque in the display program as a cache for future images. This way I can ensure that there will always be images available even when the garbage collector stops the producer occasionally. </p>
</blockquote>
<p>6.关联容器的迭代器都是双向的  </p>
<p>7.set和map都可以在声明时进行初始化，初始化时提供对应的值或值对即可。  </p>
<p>8.pair类型定义在头文件utility中，一个pair保存两个不同类型的数据成员，分别通过pair.first和pair.second来访问。map的元素即是pair，所以map有点类似于成员为pair是vector,pair的定义方式如下：   </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义一个pair，两个类型分别为T1,T2并使用v1,v2对其进行值初始化。当然也可以使用=号进行初始化或者只定义，但定义时会调用默认初始化  </span></span><br><span class="line"><span class="function">pair&lt;T1, T2&gt; <span class="title">p</span><span class="params">(v1, v2)</span></span>;  </span><br><span class="line"></span><br><span class="line"><span class="comment">//返回一个用v1和v2初始化的pair，pair的类型从v1和v2的类型推断出来  </span></span><br><span class="line"><span class="built_in">make_pair</span>(v1, v2); </span><br></pre></td></tr></table></figure>
<p>C++11中可以让函数直接返回一个pair，即可以使函数一次返回两个值。  </p>
<p>9.关联容器定义了以下额外的类型别名：  </p>
<ul>
<li>key_type 表示容器类型的关键字类型  </li>
<li>mapped_type 表示每个关键字关联的类型，只适用于map</li>
<li>value_type 对于set，与key_type相同，对于map，为pair&lt;const key_type, mapped_type&gt;<br>例如：  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">set&lt;string&gt;::value_type v1;  <span class="comment">//v1是一个string</span></span><br><span class="line">set&lt;string&gt;::key_type v2;  <span class="comment">//v2是一个string</span></span><br><span class="line">map&lt;string, <span class="type">int</span>&gt;::value_type v3;  <span class="comment">//v3是一个pair&lt;const string, int&gt;</span></span><br><span class="line">map&lt;string, <span class="type">int</span>&gt;::key_type v4;  <span class="comment">//v4是一个string</span></span><br><span class="line">map&lt;string, <span class="type">int</span>&gt;::mapped_type v5;  <span class="comment">//v5是一个int</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>10.对一个关联容器迭代器解引用时，会得到一个类型为容器的value_type的值的引用，对于map而言，value_type是一个pair类型，其first成员保存const的关键字，second成员保存值，所以只能通过map迭代器修改pair的值，但不能修改其关键字的值。记得可以使用<code>-&gt;</code>来直接访问引用之后的对象的成员。     </p>
<p>11.set的迭代器虽然定义了iterator和const_iterator，但两种类型都只允许只读访问set中的元素，而不能修改其值。  </p>
<p>12.当使用一个迭代器遍历一个map、multimap、set或multiset时，迭代器按关键字升序遍历元素。   </p>
<p>13.由于关联容器的关键字总是会有const属性，而泛型算法一般需要向元素写入值，所以通常不对关联容器使用泛型算法。  </p>
<p>14.向关联容器中插入元素使用insert和emplace成员函数，删除元素使用erase。向map中添加元素的4种方式，假定word_count存储的是单词和它出现的次数：  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">word_count.<span class="built_in">insert</span>(&#123;word, <span class="number">1</span>&#125;); <span class="comment">//C++11中支持的花括号直接初始化</span></span><br><span class="line">word_count.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(word, <span class="number">1</span>));  <span class="comment">//调用make_pair来返回一个pair</span></span><br><span class="line">word_count.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;string, <span class="type">size_t</span>&gt;(word, <span class="number">1</span>));  <span class="comment">//显式构造一个pair</span></span><br><span class="line">word_count.<span class="built_in">insert</span>(map&lt;string, <span class="type">size_t</span>&gt;::<span class="built_in">value_type</span>(word, <span class="number">1</span>));  <span class="comment">//构造一个恰当的pair类型，并构造该类型的一个新对象</span></span><br></pre></td></tr></table></figure>

<p>15.关联容器的insert（或emplace）返回的值依赖与容器类型和参数，对于不包含重复关键字的容器，添加单一元素的insert和emplace版本返回一个pair，该pair的first成员是一个迭代器，指向具有给定关键字的元素；second成员是一个bool值，指出元素是插入成功还是已经存在于容器中。如果关键字已在容器中，则insert什么事情也不做，且返回值中的bool部分为false。如果关键字不存在，元素被插入容器中，且bool值为true。    </p>
<p>15.map和unordered_map容器提供了下标运算符和一个对应的at函数。它们的区别如下：  </p>
<ul>
<li>c[k]  返回关键字为k的元素；如果k不在c中，添加一个关键字为k的元素，对其进行值初始化。  </li>
<li>c.at(k)  访问关键字为k的元素，带参数检查；若k不在c中，抛出一个out_of_range异常。  </li>
</ul>
<p>16.map下标运算符与解引用一个map迭代器所返回的类型是不一样的。当对一个map进行下标操作时，会获得一个mapped_type对象；但当解引用一个map迭代器时，会得到一个value_type对象。     </p>
<p>17.关联容器支持多种元素访问方式，如find成员函数和count成员函数。  </p>
<p>18.map下标操作的作用是：若key存在，则返回相应的value；若key不存在，则对该key对应的value赋一个对应于value类型数据的默认值并返回。例如对于类型为<code>map&lt;string,string&gt;</code>的变量m,如果m中不存在”str”，则当使用m[“str”]时，相当于向m中插入了一个(“str”, “”)  </p>
<p>19.记得使用find进行查找某个值是否在map变量中。  </p>
<p>18.map使用示例:    </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">//搜索input文件中的内容，根据map_file中的文件规则相应简写单词进行替换</span></span><br><span class="line"><span class="comment">//例如input中的某行为ho a y，map_file中的规则有</span></span><br><span class="line"><span class="comment">//ho how</span></span><br><span class="line"><span class="comment">//a are</span></span><br><span class="line"><span class="comment">//y you</span></span><br><span class="line"><span class="comment">//则该行输出应为how are you, 假定规则文件内容都是有效的</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span></span></span><br><span class="line"><span class="comment">//根据文件建立相应map</span></span><br><span class="line"><span class="function">std::map&lt;std::string, std::string&gt; <span class="title">buildMap</span><span class="params">(std::ifstream &amp;mapfile)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::map&lt;std::string, std::string&gt; trans_map;</span><br><span class="line">    std::string key;</span><br><span class="line">    std::string value;</span><br><span class="line">    <span class="keyword">while</span> (mapfile &gt;&gt; key &amp;&amp; <span class="built_in">getline</span>(mapfile, value)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (value.<span class="built_in">size</span>() &gt; <span class="number">1</span>)</span><br><span class="line">            trans_map[key] = value.<span class="built_in">substr</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;no rule for &quot;</span> + key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> trans_map;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据map搜索单词</span></span><br><span class="line"><span class="function"><span class="type">const</span> std::string &amp; <span class="title">transword</span><span class="params">(<span class="type">const</span> std::string &amp;str, <span class="type">const</span> std::map&lt;std::string, std::string&gt; &amp;trans_map)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::map&lt;std::string, std::string&gt;::const_iterator it = trans_map.<span class="built_in">find</span>(str);</span><br><span class="line">    <span class="keyword">if</span> (it != trans_map.<span class="built_in">cend</span>())</span><br><span class="line">        <span class="keyword">return</span> it-&gt;second;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">transform</span><span class="params">(std::ifstream &amp;infile, std::ifstream &amp;mapfile)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> trans_map = <span class="built_in">buildMap</span>(mapfile);</span><br><span class="line">    std::string line;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">getline</span>(infile, line)) &#123;</span><br><span class="line">        <span class="function">std::istringstream <span class="title">is</span><span class="params">(line)</span></span>;</span><br><span class="line">        std::string str;</span><br><span class="line">        <span class="keyword">while</span> (is &gt;&gt; str) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="built_in">transword</span>(str, trans_map) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::ifstream <span class="title">infile</span><span class="params">(<span class="string">&quot;words.txt&quot;</span>)</span>, <span class="title">mapfile</span><span class="params">(<span class="string">&quot;trans_map.txt&quot;</span>)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (infile &amp;&amp; mapfile)</span><br><span class="line">        <span class="built_in">transform</span>(infile, mapfile);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Error, Can&#x27;t open the file&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>9.C++11中定义了4个无序关联容器（unordered associative container）。这些容器不是使用比较运算符来组织元素，而是使用一个哈希函数和关键字类型的==运算符。有序与无序关联容器的对比如下：  </p>
<ul>
<li>Ordered Associative Container<ul>
<li>Standard Traversal encounters elements in sorted order</li>
<li>Order predicate may be specified</li>
<li>Default order predicate is “less than”, defined using operator<code>&lt;</code> for the element type</li>
<li>Popular implementations: OrderedVector, BinarySearchTree</li>
<li>Search operations required to have O(log n) runtime</li>
<li>Insert, Remove operations should either be seldom used or have O(log n) runtime</li>
</ul>
</li>
<li>Unordered Associative Container<ul>
<li>Standard Traversal encounters elements in unspecified order</li>
<li>Search, Insert, Remove operations should have average-case constant runtime</li>
<li>Popular implementations use hashing</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>Notes</tag>
        <tag>CPP</tag>
      </tags>
  </entry>
  <entry>
    <title>Python学习笔记</title>
    <url>/2015/05/03/Python-study-notes/</url>
    <content><![CDATA[<p>自己学习python 3.x的笔记，主要内容来源于<a href="https://github.com/swaroopch/byte_of_python">A byte of python</a>(已看完)和python官网文档<a href="https://docs.python.org/3/">Python 3.4.3 documentation</a>(其中的Tutorial已看完)。  </p>
<span id="more"></span>

<h2 id="To-Do"><a href="#To-Do" class="headerlink" title="To-Do:"></a>To-Do:</h2><p><del>1.配置好Hexo及VIM在windows下的环境。</del><br><del>2.在windows下编辑完本文其他内容。</del><br><del>3.回顾markdown语法，排版本文。</del><br><del>4.完成python官网Tutorial</del><br>5.使用python实现一个采集系统<br>6.使用pyton实现一个图像处理功能</p>
<h2 id="一、python的基本知识"><a href="#一、python的基本知识" class="headerlink" title="一、python的基本知识"></a>一、python的基本知识</h2><p>1.helloworld字符串的输出格式为<code>print(&#39;Hello world!&#39;)</code></p>
<p>2.python可以以多数模式运行.eg:<code>python -c command [arg]</code> #以命令行模式运行等，如果手动指定其运行模式则<code>sys.argv[0]</code>中存储的将是相应的参数<em>-c</em>,<em>-m</em>等否则是<em>sourcename</em>，即<code>sys.argv[0]</code>存储python命令后面的第一个参数。</p>
<p>3.python默认的源码文件为UTF-8格式，可以通过将语句<code># -*- coding: encoding -*-</code>放在源码第一行或者第二行来手动指定源文件格式。或者直接写成<code># encoding=utf-8</code></p>
<p>4.python注释以#开头，物理行结束，可以放在整行，空格或者代码后。</p>
<p>5.python的变量必须先赋值再使用，赋值相当于同时定义了变量，支持并列赋值和表达式中赋值。eg: <code>a,b = 1,2</code>  </p>
<p>6.交互模式下最后一次被打印的表达式存储在变量”_”中，这个变量对用户是只读的，但可以创建同名变量覆盖它。  </p>
<p>7.python内建支持<code>int,float,decimal,fraction,complex number</code>，使用”J”或“j”指定虚数位。</p>
<p>8.单引号与双引号的功能一样，类似于C里面的<code>printf()</code>中的双引号，三引号可以打印多行字符,也就是可以在程序中字符串的地方直接输入回车。反斜杠表示转义字符与C中一样，行尾的反斜杠”&quot;表示下一行是上一行的继续。在字符串引号前加R/r表示自然语言，也就是说里面的所有字符就只是单纯的字符，无法使用格式化输出，可以用于正则表达式。单引号内的双引号和双引号内的单引号不需要转义。</p>
<p>9.format为格式化输出，即使用参变量的值代替格式符{n}中的内容，<code>format()</code>可以有多个参数，例如：</p>
<p><code>&#39;&#123;0:.3&#125;&#39;.format(1/3)</code>输出为1/3保留3位小数<code>0.333</code>  </p>
<p><code>&#39;&#123;0:*^10&#125;&#39;.format(&#39;blueyi&#39;)</code> 以”*“在两边填充占用11位的”blueyi” 输出为 <code>**blueyi***</code>  </p>
<p><code>&#39;&#123;name&#125; &#123;age&#125;&#39;.format(name = &quot;blueyi&quot;,age = 3+2)</code> 输出为 <code>blueyi5</code> “{}”中的数字或者说内容是可选的  </p>
<p>print()函数打印时会自动在字符串结尾加上”\n”，可以手动指定结尾内容，如<code>print(&quot;he&quot;, end = &quot;&quot;)</code>不会换行，<code>name = &quot;blueyi&quot;;print(&quot;I&#39;m&quot;,name);</code>会打印<code>I&#39;m blueyi</code>  </p>
<p><code>input()</code>获取输入，eg: <code>age = int(input(&quot;Enter your age:&quot;))</code></p>
<p>10.操作符和表达式<br>大部分操作符与C语言一样，数学运算时<code>a ^ b</code>表示异或，即有且仅有一个真时为真。<code>a ** b</code>表示a的b次方，<code>a // b</code>表示取a对b取整，<code>a &lt;&lt; b</code>和<code>a &gt;&gt; b</code>表示a对应的二进制左移或者右移b位,C语言里面的位运算也能用，<code>～a</code>表示对a取反，<code>～a == -(a + 1)</code>，and、or、not对应逻辑中的与或非<br>可以使用<code>a += b</code>，不过没有“a++”类型的操作符。</p>
<p>11.可以使用分号;让两个逻辑行放在一个物理行里面，例如:<code>i = 1;print(i);</code></p>
<p>12.字符串是序列的一种，所有序列都可以通过“+”操作符连接，“*”操作符重复，都支持索引、切片以及使用len返回长度等。两个或者多个字符串紧挨在一起会被自动连接。eg: <code>&#39;max&#39; + &#39;wi&#39; == &#39;maxwi&#39; == &#39;max&#39;&#39;wi&#39;</code>  </p>
<p>13.字符串可以通过下标索引，索引可以为负数，但不能越界，str[-1]为最后一个最符，<code>str[-0] == str[0]</code>。  </p>
<p>14.字符串支持所有序列都支持的切片操作，切片操作<code>str[n1:n2]</code>返回n1到n2之间的字符串，含头不含尾。切片越界不会报错，会返回到字符串结尾。如果n1已经越界则返回空字符串。<code>s[:i] + s[i:] == s</code>  </p>
<p>15.字符串是不可变的，也就是不能对单一某一位上的字符进行修改。eg:<code>str[0] = &#39;a&#39;</code>会返回<code>TypeError</code>  </p>
<p>16.python中所有非0值为true，非空序列为true，空序列为false。</p>
<p>17.一般以双下划线开头和结尾的变量都是python内建或者程序中自己定义的具有特殊意义的变量。</p>
<h2 id="二、控制流"><a href="#二、控制流" class="headerlink" title="二、控制流"></a>二、控制流</h2><p>1、if-elif-else记得加:，eg：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Yes,it&#x27;s true&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>2、while语句与C类似，可选else，else语句将在循环结束后执行一次</p>
<p>3、<code>for...in...</code>语句in后面可以跟任何序列，也有一个与while类似的可选else。for语句和list()函数相当于一个遍历器。list()可以从可遍历序列创建一个列表。eg:<code>list(rang(5)) =&gt; [0,1,2,3,4]</code>   </p>
<p>3.1 for循环可用于遍历任何序列中的元素，遍历时若在循环内修改序列，则for循环的条件序列也会立即改变。所以for循环不会默认以副本形式的序列作为条件，最好以序列的拷贝进行遍历。eg:<code>for w in words[:];</code>该切片返回的是列表的拷贝。 </p>
<p>3.2 遍历数字序列时，可以使用内建的<code>range()</code>函数。eg:<code>for i in range(1, 5): pass;</code></p>
<p>3.3 <code>range(n)</code>为从0到n遍历数字，含头不含尾。<code>range(start, end, step)</code>表示以步长step从start遍历到end，step可以为负数。索引序列时可以混合使用<code>range()</code>和<code>len()</code>。eg:  </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = [<span class="string">&#x27;I&#x27;</span>, <span class="string">&#x27;am&#x27;</span>, <span class="string">&#x27;blueyi&#x27;</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(a)):</span><br><span class="line">    <span class="built_in">print</span>(i, a[i])</span><br></pre></td></tr></table></figure>

<p>也可以使用枚举实现上述例子。eg:<code>list(enumerate(a));</code>  </p>
<p>3.4 <code>range()</code>为了节省空间，只在遍历时才返回连续的元素。实际上不会在内存中生成一个元素列表，所以<code>print(range(10)) =&gt;range(0,10)</code>   </p>
<p>3.5 <code>enumerate(iterable, start = 0)</code>表示默认从0开始遍历可遍历的序列对象。</p>
<p>4、continue和break在循环中与C中用法类似，分别表示继续下一次循环和跳出最近的for或while循环，pass表示空语句。</p>
<p>5、语句块以关键字加冒号再配合缩进组成，包括if,while,for,def</p>
<p>6、关键字in可用于测试序列中是否包含一个确定的值。eg:  </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="number">5</span> <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<h2 id="三、函数"><a href="#三、函数" class="headerlink" title="三、函数"></a>三、函数</h2><ol>
<li><p>使用def定义函数,函数中的变量有全局，局部和非局部三种作用域。</p>
</li>
<li><p>函数中的所有变量都存储在一个局部列表中，引用变量时首先会查找局部列表，然后查找外部函数的局部列表，再然后是全局列表，最后是内建名称。</p>
</li>
<li><p>在函数体内部可以使用global关键字修饰全局变量，以便能在函数体内修改函数体外的变量。在函数体内定义的函数体中，可以使用关键字nonlocal修饰局部变量，使其成为非局部变量，以便可以在嵌套的内部函数中修改。一个关于作用域的例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">scope_test</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">do_local</span>():</span><br><span class="line">        spam = <span class="string">&quot;local spam&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">do_nonlocal</span>():</span><br><span class="line">        <span class="keyword">nonlocal</span> spam</span><br><span class="line">        spam = <span class="string">&quot;nonlocal spam&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">do_global</span>():</span><br><span class="line">        <span class="keyword">global</span> spam</span><br><span class="line">        spam = <span class="string">&quot;global spam&quot;</span></span><br><span class="line">    spam = <span class="string">&quot;test spam&quot;</span></span><br><span class="line">    do_local()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;After local assignment:&quot;</span>, spam)</span><br><span class="line">    do_nonlocal()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;After nonlocal assignment:&quot;</span>, spam)</span><br><span class="line">    do_global()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;After global assignment:&quot;</span>, spam)</span><br><span class="line"></span><br><span class="line">scope_test()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;In global scope:&quot;</span>, spam)</span><br></pre></td></tr></table></figure>
</li>
<li><p>定义形参时可以给形参赋值，为形参指定一个默认参数，只有参数表末尾的参数可以有默认值。当然也可以是这样<code>def func(a=5):</code></p>
</li>
<li><p><code>print(string * n)</code>表示打印n次string，其中n为整数，string为字符串</p>
</li>
</ol>
<p>6.为函数形参赋值时，实参按顺序赋给形参，也可以通过赋值语句而不考虑顺序，eg:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">a, b=<span class="number">5</span>, c=<span class="number">6</span></span>):</span><br><span class="line">    <span class="keyword">pass</span>  <span class="comment"># 表示空语句</span></span><br></pre></td></tr></table></figure>
<p><code>func(1, 2, 3)</code>则a=1, b=2, c=3</p>
<p><code>func(3, c=2)</code>则a=3, b=5, c=2</p>
<p><code>func(c=3, a=2)</code>则a=2, b=5, c=3</p>
<p>注意：未指定默认值的参数必须赋值</p>
<p>6.形参所赋的默认值只会被计算一次，当拥有默认值的形参默认值是个可变列表时，要特别注意。eg:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">a, <span class="built_in">list</span>=[]</span>):</span><br><span class="line">\<span class="comment">#调用时只会被调用一次，每次调用都会将a添加到list形参</span></span><br><span class="line">    <span class="built_in">list</span>.append(a)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span></span><br></pre></td></tr></table></figure>
<p><code>l1 = func(1)</code> =&gt; l1 = [1]</p>
<p><code>l2 = func(2)</code> =&gt; l2 = [1,2]</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func2</span>(<span class="params">a, <span class="built_in">list</span>=<span class="literal">None</span></span>):</span><br><span class="line">\<span class="comment">#调用时会首先检测是否list为None,如果是则将其清空</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">list</span> <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="built_in">list</span> = []</span><br><span class="line">    <span class="built_in">list</span>.append(a)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span></span><br></pre></td></tr></table></figure>
<p><code>l3 = func2(1)</code> =&gt; l3 = [1]<br><code>l4 = func2(2)</code> =&gt; l4 = [2]</p>
<p>7.可以使用列表和字典来定义一个能获取任意个数参数的函数。eg:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">a=<span class="number">5</span>, *numbers, **keywords</span>):</span><br><span class="line">    total = a</span><br><span class="line">    <span class="keyword">for</span> number <span class="keyword">in</span> numbers:</span><br><span class="line">        total += number</span><br><span class="line">    <span class="keyword">for</span> key <span class="keyword">in</span> keywords:</span><br><span class="line">        total += keywords[key]</span><br><span class="line">    <span class="keyword">return</span> total</span><br><span class="line">func(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, a=<span class="number">4</span>, b=<span class="number">5</span>, c=<span class="number">6</span>)</span><br></pre></td></tr></table></figure>
<p>8.可以在带*的参数后面声明keyword-only参数.eg:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">a=<span class="number">5</span>, *b, c</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>调用func时c必须赋值，eg:<code>func(1, 2, 3, 4, c=8)</code></p>
<p>9.return返回函数值，无需指定函数的返回类型，没有return的函数默认返回None</p>
<p>10.Docstring文档字符串位于函数的第一个逻辑行，放在6个双引号”之间。可以使用<code>__doc__</code>(双下划线)引用eg:<code>print(func.__doc__)</code>  </p>
<p>11.lambda关键字可用于创建匿名函数，形式为<code>lambda parameters : expression</code>。也可以利用它创建返回函数的嵌套函数。eg:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">make_func</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">lambda</span> x : x+n</span><br><span class="line">f = make_func(<span class="number">42</span>)</span><br></pre></td></tr></table></figure>
<p><code>f(0)</code> =&gt; 42<br><code>f(1)</code> =&gt; 43</p>
<p>12.程序的元数据以字典形式存储在<code>__annotations__</code>变量中。可通过<code>func.__annotations__</code>读取。  </p>
<h2 id="四-数据结构"><a href="#四-数据结构" class="headerlink" title="四.数据结构"></a>四.数据结构</h2><p>列表，元组，字典，集合都属于结构化数据，有可变和不可变之分。<br>1.1列表：可变的序列，类方法操作后直接修改而不返回。可使用<code>for element in list:</code>遍历，使用[]定义。eg:<code>list = [&#39;I&#39;,&#39;am&#39;,&#39;blueyi&#39;]</code>,可以通过<code>list[n]</code>来访问第n个元素，<code>list.append(&#39;rice&#39;)</code>在列表尾添加一个元素，通过<code>del list[n]</code>删除第n个无素，<code>list.sort()</code>排序，<code>len(list)</code>查看其长度。</p>
<p>1.2 列表支持层叠.eg: <code>a = str1;b = str2;c = [a,b];</code></p>
<p>1.3 常的list类方法。</p>
<p><code>list.append(x)</code> 列表尾添加一个元素。&lt;=&gt; <code>a[len(a):] = [x]</code></p>
<p><code>list.extend(L)</code> 将列表L添加到list &lt;=&gt; <code>a[len(a):] = L</code></p>
<p><code>list.insert(i, x)</code> 在i位置前插入元素x。<code>a.insert(len(a), x)</code>  &lt;=&gt; <code>a.append(x)</code></p>
<p><code>list.remove(x)</code> 移除值为x的元素</p>
<p><code>list.pop([i])</code> 移除并返回位置i处的元素。[]表示可选项。<code>list.pop()</code>为移除最后一个元素</p>
<p><code>list.clear()</code> 删除list中所有元素 &lt;=&gt; <code>del a[:]</code></p>
<p><code>list.index(x)</code> 返回列表中第一个值为x的元素索引,若无x则报错。</p>
<p><code>list.count(x)</code> 返回列表中x出现的次数</p>
<p><code>list.sort()</code> 直接对当前列表进行排序</p>
<p><code>list.reverse()</code> 颠倒列表中的元素</p>
<p><code>list.copy()</code> 返回一个列表的浅拷贝 &lt;=&gt; <code>a[:]</code>。关于深浅拷贝<a href="http://www.01happy.com/python-shallow-copy-and-deep-copy/">http://www.01happy.com/python-shallow-copy-and-deep-copy/</a></p>
<p>list的pop和append可以方便地将其当作堆栈来使用。利用<code>collections.deque()</code>可将列表当队列使用。</p>
<p>2.元组：不可变序列，可以将多样的对象集合到一起。使用<code>for element in tuple:</code>遍历，使用()定义，使用<code>tuple[n]</code>访问。eg:<code>tuple = (&#39;python&#39;,&#39;perl&#39;,&#39;ruby&#39;,&#39;php&#39;);tuple_plus = (&#39;C&#39;, &#39;C++&#39;, tuple);</code>则<code>tuple_plus[2][1][1] = +</code></p>
<p>2.1 声明含有0个元素的元组可以直接<code>tuple = ()</code>，仅含一个元素时后面必须要有个逗号，eg:<code>tuple = (&#39;blueyi&#39;,)</code></p>
<p>3.字典：就是键值对的集合，且没有顺序，其中键必须是惟一且不可变的，值是可变或者不可变的。可以使用<code>for key, value in dict.items():</code>遍历，声明方式为<code>dict = &#123;key1 : value1, key2 : value2&#125;</code> <code>del dict[key1]</code>删除键值对，<code>if key2 in dict</code>检验键值对是否存在。定义一个空字典：<code>dic = &#123;&#125;</code></p>
<p>4.列表，元组，字符串都属于序列，有着许多共同之处，他们者支持索引操作符”[ ]”，也支持切片操作。eg:<code>list[1:3]</code>返回<code>list[1],list[2]</code>，切片操作返回值包含首不包含尾，<code>list[:]</code>返回整个序列，<code>list[1:]</code>返回第一个到最后一个,<code>list[1:4:2]</code>以部长n返回，即<code>list[1],list[3],list[5]....</code>  </p>
<p>5.集合：没有顺序的，简单对象的聚类。声明方式为<code>sets = set([&#39;Pear&#39;, &#39;Apple&#39;, &#39;Orange&#39;])</code>，支持一些集合上的逻辑运算。</p>
<p>6.切片操作获得的是拷贝，而赋值操作获得的只是引用</p>
<p>7.记得使用help，查看更多相应类方法</p>
<p>8.一些常见的序列遍历方法</p>
<p>9.1 <code>items()</code>方法可以同时遍历字典中的key和value。eg:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> k,v <span class="keyword">in</span> <span class="built_in">dict</span>.items():</span><br><span class="line">    <span class="built_in">print</span>(k, v)</span><br></pre></td></tr></table></figure>
<p>9.2 <code>enumerate()</code>函数可同时遍历序列中的index和value。eg:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i,v <span class="keyword">in</span> <span class="built_in">enumerate</span>(<span class="built_in">list</span>):</span><br><span class="line">    <span class="built_in">print</span>(i,v)</span><br></pre></td></tr></table></figure>
<p>9.3 reversed()函数以相反的方向遍历序列。eg:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">reversed</span>(<span class="built_in">range</span>(<span class="number">1</span>,<span class="number">10</span>,<span class="number">2</span>)):</span><br><span class="line">    <span class="built_in">print</span>(i, end=<span class="string">&#x27; &#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>=&gt;9 7 5 3 1</p>
<p>9.4 <code>zip()</code>函数可同时遍历多个序列。eg:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">questions = [<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;quest&#x27;</span>, <span class="string">&#x27;favorite color&#x27;</span>]</span><br><span class="line">answers = [<span class="string">&#x27;lancelot&#x27;</span>, <span class="string">&#x27;the holy grail&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>]</span><br><span class="line"><span class="keyword">for</span> q, a <span class="keyword">in</span> <span class="built_in">zip</span>(questions, answers):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;What is your &#123;0&#125;?  It is &#123;1&#125;.&#x27;</span>.<span class="built_in">format</span>(q, a))</span><br></pre></td></tr></table></figure>
<p>What is your name?  It is lancelot.<br>What is your quest?  It is the holy grail.<br>What is your favorite color?  It is blue.  </p>
<p>9.5 <code>sorted()</code>函数返回一个已排序的序列而不改变原序列。eg:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">sorted</span>(<span class="built_in">set</span>(<span class="built_in">list</span>)):</span><br><span class="line">    <span class="built_in">print</span>(i)  </span><br></pre></td></tr></table></figure>

<p>10.条件检查和比较</p>
<p>10.1 操作符”in”和”not in” 检查值是否出现在某个序列中</p>
<p>10.2 “is”和”is not” 检验两对象是否是同一对象，它们仅用于可变对象,如list.</p>
<p>10.3 所有的比较操作符优先级一样</p>
<p>10.4 比较可以级联。eg: <code>a &lt; b == c &lt;=&gt; a &lt; b and b == c</code></p>
<p>10.5 比较时可以混合使用布尔操作符and,or,not.它们的优先级比比较操作符低。其中not优先级最高，or优先级最低</p>
<p>10.6 布尔操作符中的and,or遵循短路原则</p>
<p>10.7 相同类型的序列对象之间可相互比较，遵照字典顺序。如果某一序列是另一序列的子序列，则较短的较小。序列元素为数字比较时，如果类型不一样，则近似比较。eg:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>) &lt; (<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>)</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] &lt; [<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>]</span><br><span class="line"><span class="string">&#x27;ABC&#x27;</span> &lt; <span class="string">&#x27;C&#x27;</span> &lt; <span class="string">&#x27;Pascal&#x27;</span> &lt; <span class="string">&#x27;Python&#x27;</span></span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>) &lt; (<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>)</span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>) &lt; (<span class="number">1</span>, <span class="number">2</span>, -<span class="number">1</span>)</span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>) == (<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>)</span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, (<span class="string">&#x27;aa&#x27;</span>, <span class="string">&#x27;ab&#x27;</span>)) &lt; (<span class="number">1</span>, <span class="number">2</span>, (<span class="string">&#x27;abc&#x27;</span>, <span class="string">&#x27;a&#x27;</span>), <span class="number">4</span>)</span><br></pre></td></tr></table></figure>

<h2 id="五-模块"><a href="#五-模块" class="headerlink" title="五.模块"></a>五.模块</h2><p>1.每一个’.py’文件的python都是一个模块，模块中可以包含函数，变量等</p>
<p>2.使用关键字import导入模块，eg:<code>import A</code>表示导入A到当前程序，引用时需要使用点操作符’.’来确定命名空间。<code>from A import B</code>表示导入A中的B到当前程序，<code>from A import *</code>导入A中的所有变量或者函数到当前程序(双下划线开始的变量除外)，这种导入方式引用时不需要”.”操作符，但容易与当前同名变量冲突，所以不推荐使用</p>
<p>3.模块的<code>__name__</code>可以控制主块的运行。这样模块就可以像脚本一样运行。eg:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;run by itself&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">     <span class="built_in">print</span>(<span class="string">&#x27;imported from another module&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>4.<code>sys.argv</code>中存储的是传递参数列表，<code>sys.argv[0]</code>是程序名，<code>sys.path</code>为sys的路径，<code>os.getcwd()</code>可以获取当前程序所在路径</p>
<p>5.<code>dir()</code>可用于显示模块的所有名称列表.eg:<code>dir(sys)</code>显示sys模块中的所有名称列表，<code>dir()</code>则显示当前模块中的名称列表。dir()不会列出内建程序名和变量名，要列出它们需要使用内建模块builtins。eg:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> builtins</span><br><span class="line"><span class="built_in">dir</span>(builtins)</span><br></pre></td></tr></table></figure>

<p>6.<code>del a</code>语句用于删除变量/名称a</p>
<p>7.包可用于组织模块，是模块的文件夹，使用<code>__init__.py</code>文件来在模块文件夹根目录标明当前文件夹为包。包包含模块，模块包含函数和全局变量，函数中又包含变量 </p>
<ol start="8">
<li>一个模块在一次程序进程期间只会导入一次，修改模块后需要重启解释器，如果只是为了交互式的测试可使用imp.<code>reload()</code>重新载入模块。eg:<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> imp;</span><br><span class="line">imp.reload(modulename)</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>9.编译模块为.pyc文件或者.pyo(通过-o参数，pyo为优化后的pyc文件，通常更小)。pyc文件通常为<code>__pycache__</code>目录下的<code>module.version.pyc</code>。这些文件有平台依赖性。</p>
<p>10..pyc或.pyo文件并不会使python程序运行更快，只是加快了载入速度。</p>
<p>11.python标准库就是python的标准模块,部分标准库依赖操作系统平台。eg:winreg模块仅在windows下有</p>
<ol start="12">
<li><code>sys.ps1</code>存储的是交互模式下的提示符’&gt;&gt;&gt;’，<code>sys.path.append(&#39;string&#39;)</code>可追加<code>PYTHONPATH</code>  </li>
</ol>
<p>13.使用包管理模块时可嵌套目录，使用点操作符引用。eg: <code>import item.subitem.subsubitem</code>最后一个元素可以是个模块或者包，但不能是类、函数或变量。</p>
<h2 id="六、类"><a href="#六、类" class="headerlink" title="六、类"></a>六、类</h2><p>1.类使用关键字class创建，eg:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">blueyi = Person()</span><br><span class="line"><span class="built_in">print</span>(blueyi)</span><br></pre></td></tr></table></figure>
<p>属于一个类或者对象的变量称为域，域又可称为属于实例的实例变量，和属于对象或者类本身的类变量。</p>
<p>2.类对象支持2种操作，一种是属性引用。eg:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Myclass</span>:</span><br><span class="line">    i = <span class="number">1</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;Hi&#x27;</span></span><br><span class="line"></span><br><span class="line">Myclass.i    <span class="comment">#引用类变量</span></span><br><span class="line">Myclass.f()  <span class="comment">#引用类函数</span></span><br></pre></td></tr></table></figure>
<p>另一种是实例引用,即创建一个Myclass的实例。eg:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = Myclass()</span><br><span class="line"></span><br><span class="line">x.i    <span class="comment">#引用实例变量</span></span><br><span class="line">x.f()  <span class="comment">#引用实例方法 &lt;=&gt; Myclass.f(x)</span></span><br></pre></td></tr></table></figure>

<p>3.类方法与普通函数的区别是类方法必须有第一个参数且指向对象本身，通常称为self.注意不是指定类，而是指定类创建的对象本身。eg:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sayHi</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Hi!&#x27;</span>)</span><br><span class="line">p = Person()</span><br><span class="line">p.sayHi()</span><br></pre></td></tr></table></figure>
<p>4.类可以通过<code>__init__()</code>方法初始化，<code>__init__</code>函数会在类对象创建时立即运行，相当于C++的构造函数。<code>__del__()</code>方法用于在对象被删除时运行，例如使用del语句删除对象。它们也必须要有self参数。</p>
<p>5.与类变量名字相同的实例变量会隐藏类变量。类变量在所有实例之间共享，可以被它们修改，而实例变量是由各个实例所私有。eg:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>:</span><br><span class="line">    kind = <span class="string">&#x27;Canine&#x27;</span>    <span class="comment">#类变量</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        self.name = name    <span class="comment">#实例变量</span></span><br></pre></td></tr></table></figure>
<p>6.同名的数据属性会覆盖掉方法属性。</p>
<p>7.以双下划线开头的变量都是私有变量。如果某个变量想只在对象和类中使用，最好以单下划线开关。pep8规范</p>
<p>8.类继承是通过元组在定义子类时将父类作为元组元素来实现继承。eg:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Company</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dell</span>(<span class="title class_ inherited__">Company</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>9.python支持多重继承，继承的属性从第一个父类开始从左至右搜索到为止。</p>
<p>10.所有类都继承自object。</p>
<p>11.一些常用的特殊类方法</p>
<p><code>object.__init__(self,[...])</code> 新创建的对象返回之前调用，用于初始化对象</p>
<p><code>object.__del__(self)</code> 对象被销毁前调用</p>
<p><code>object.__str__(self)</code> 当使用print函数或者<code>str()</code>函数时调用</p>
<p><code>object.__lt__(self,other)</code> 当使用&lt;操作符时调用，对应的有<code>object.__eq__(self, other) object.__ne__(self, other) object.__gt__(self, other)object.__ge__(self, other)</code>  </p>
<p><code>object.__getitem__(self, key)</code> 使用索引操作符<code>x[index]</code>时调用</p>
<p><code>object.__len__(self)</code> 当内建的<code>len()</code>函数对序列对象使用时调用  </p>
<p>12.检查类的两个方法：</p>
<p><code>isinstance(obj, class)</code> 检查实例类型</p>
<p><code>issubclass(class1, class2)</code> 检查class是否继承自class2</p>
<h2 id="七、输入输出"><a href="#七、输入输出" class="headerlink" title="七、输入输出"></a>七、输入输出</h2><p>1.字符串的输入输出是通过<code>input(prompt)</code>和<code>print(string)</code>.eg: </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">text = <span class="built_in">input</span>(<span class="string">&#x27;Enter your string:&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(text)</span><br></pre></td></tr></table></figure>

<p>2.<code>repr()</code>和<code>str()</code>都会强制将任何值强制转换为一个字符串并返回，其中<code>repr()</code>返回一个解释器易于处理的形式，而<code>str()</code>会返回一个人易读的形式。</p>
<p>3.<code>str.rjust(width[ ,filechar])</code>右对齐并以fillchar填充，相应的有<code>ljust()</code>,<code>center()</code>。这些方法不会修改原str，只是返回一个新的str。<code>str.format()</code>可对字符串进行格式化转化。</p>
<p>4.对于文件的读写使用<code>open(filename, mode),close(),write(),read(),readline()</code>等方法，以UTF-8格式打开文件，打开方式可选且多数与C类似，默认为以文本方式读或者写，默认mode为<code>r</code>。<br><strong>默认的这些文件读写方法由os包提供，是较低级的文件读写接口，尽量使得io包提供的文件读写接口：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># encoding=utf-8</span></span><br><span class="line"><span class="keyword">import</span> io</span><br><span class="line">f = io.<span class="built_in">open</span>(<span class="string">&quot;abc.txt&quot;</span>, <span class="string">&quot;wt&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">f.write(<span class="string">u&quot;Imagine non-English language here&quot;</span>)</span><br><span class="line">f.close()</span><br><span class="line">text = io.<span class="built_in">open</span>(<span class="string">&quot;abc.txt&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>).read()</span><br><span class="line"><span class="built_in">print</span>(text)</span><br></pre></td></tr></table></figure>

<p>5.文件读写的文本模式下，默认读取时会自动转换换行符(<code>\n on unix,\r\n on windows</code>)为<code>\n</code>,写会进行相反的操作。</p>
<p>6.File的常用类方法(假定已经创建了名为f的file对象)：</p>
<p>6.1 <code>f.read([size])</code>读取size bytes大小的数据，返回一个字符串或字节对象，若省略size则返回整个文件内容，若文件过大则会出错，达到文件尾会返回空字符串。</p>
<p>6.2 <code>f.readline()</code>读取单独的一行，包含<code>\n</code>。返回空字符串时表示到达文件尾。可使用更高效的循环代替。eg:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">    <span class="built_in">print</span>(line, end=<span class="string">&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>6.3 <code>f.readlines()</code> 读取文件中的所有行到列表。也可使用list(f)</p>
<p>6.4 <code>f.write(string)</code> 将string写入文件并返回写入的字符数。若写入的内容不是字符串则需要手动转换。eg:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">value = (<span class="string">&#x27;the answer&#x27;</span>, <span class="number">42</span>)</span><br><span class="line">s = <span class="built_in">str</span>(value)</span><br><span class="line">f.write(s)</span><br></pre></td></tr></table></figure>

<p>6.5 <code>f.tell()</code> 返回一个标示当前文件对象所指向文件位置的整数，二进制模式表示从文件头到当前位置的字节数。文本模式下为一个opaque number。</p>
<p>6.6 <code>f.seek(offset[, from_what])</code> 以frome_what为参考位置修改f的指向位置。from_what可取0、1、2分别表示文件开头、当前位置、文件结尾，默认为0。</p>
<p>6.7 <code>f.close()</code> 关闭文件并释放资源。</p>
<p>6.8 <code>f.closed()</code> 查看当前文件是否已被关闭。</p>
<p>7.建议使用<code>with...as...</code>语句读写文件  eg:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;temp.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">        <span class="built_in">print</span>(line, end=<span class="string">&#x27;_&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>with 获取open返回的对象，以f引用，在执行它后的语句块之前会先执行返回对象的<strong>enter</strong>方法。执行完语句块之后会执行返回对象的<strong>exit</strong>方法。无需手动关闭文件。   </p>
<p>8.<code>open()</code>方法默认以utf-8格式打开文件，也可以手动指定编码格式。eg: <code>f = open(&#39;temp.txt&#39;, &#39;wt&#39;, encoding=&#39;utf-8&#39;)</code>  </p>
<p>9.利用pickle模块的dump()和load()方法可以将对象存储到文件中然后在需要的时候读取,存取时要以二进制模式读写,且存储的文件仅能用于python中。eg:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line">listfile = <span class="string">&#x27;list.data&#x27;</span></span><br><span class="line"><span class="built_in">list</span> = [<span class="string">&#x27;China&#x27;</span>, <span class="string">&#x27;Japan&#x27;</span>, <span class="string">&#x27;America&#x27;</span>]</span><br><span class="line">f = <span class="built_in">open</span>(listfile, <span class="string">&#x27;wb&#x27;</span>)</span><br><span class="line">pickle.dump(<span class="built_in">list</span>, f)</span><br><span class="line">f.close()</span><br><span class="line"><span class="keyword">del</span> <span class="built_in">list</span></span><br><span class="line">f = <span class="built_in">open</span>(listfile, <span class="string">&#x27;rb&#x27;</span>)</span><br><span class="line"><span class="built_in">list</span> = pickle.load(f)</span><br><span class="line">f.close()</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>)</span><br></pre></td></tr></table></figure>

<p>10.json模块与pickle相反，它可将结构化的数据存储到可交换的数据文件格式json中，使用<code>json.dump(x, f)</code>将x写入f，<code>x = json.load(f)</code>,将f内容读入到x。  </p>
<h2 id="八-异常"><a href="#八-异常" class="headerlink" title="八.异常"></a>八.异常</h2><p>1.通过<code>try...except...else</code>语句处理异常，功能语句放在try块中，错误处理语句放在except块中，没有任何异常则运行else中的语句，else语句可选。<br>如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    text = <span class="built_in">input</span>(<span class="string">&#x27;Enter something --&gt; &#x27;</span>)</span><br><span class="line"><span class="keyword">except</span> EOFError:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Why did you do an EOF on me?&#x27;</span>)</span><br><span class="line"><span class="keyword">except</span> KeyboardInterrupt:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;You cancelled the operation.&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;You entered &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(text))</span><br></pre></td></tr></table></figure>

<p>2.except中可加入多个异常。eg:<code>except(RuntimeError, TypeError, NameError):</code>,最后一个异常名可以使用通配符。</p>
<p>3.自己可以创建继承至Error或者Exception类的异常，使用raise可以引发错误或者异常，用户定义的异常应该直接或者间接地继承自Exception。</p>
<p>4.使用<code>try...finally...</code>可以在无论异常发生与否的情况下都执行finally语句块中的内容</p>
<p>5.可选的finally语句在实际应用中可用于释放外部资源，如关闭文件或网络连接。</p>
<p>6.有些对象预定义了清理动作，如file，可通过<code>with...as...</code>语句体现。with语句处理完文件后，无论哪种情况下都会关闭文件。</p>
<h2 id="九-其他"><a href="#九-其他" class="headerlink" title="九.其他"></a>九.其他</h2><p>1.利用元组可以获得函数一次返回的两个值。eg:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">getStudent</span>():</span><br><span class="line">    <span class="keyword">return</span> (<span class="string">&#x27;blueyi&#x27;</span>, <span class="number">23</span>)</span><br><span class="line">name, age = getstudent()</span><br></pre></td></tr></table></figure>
<p><code>a, *b = [1,2,3,4]</code> 则<code>a = 1,b = [2,3,4]</code></p>
<p>2.Python中的迭代器。<br>2.1迭代器遍布于python之中，最常见是for循环通过调用可迭代对象的<code>iter()</code>方法来进行循环迭代。其中<code>iter()</code>方法相当于一个对象容器，每次返回一个迭代器对象，迭代器对象中定义的<code>__next__()</code>方法用来在每次迭代时返回<code>iter()</code>中的下一个元素，当没有任何元素时，<code>__next__()</code>将引发<code>StopIteration</code>异常。可以使用内置函数<code>next()</code>来调用<code>__next__()</code>方法。eg:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> element <span class="keyword">in</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]:</span><br><span class="line">    <span class="built_in">print</span>(element)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = <span class="string">&#x27;abc&#x27;</span></span><br><span class="line">it = <span class="built_in">iter</span>(s)</span><br><span class="line"><span class="built_in">next</span>(it)   <span class="comment">#输出a</span></span><br><span class="line"><span class="built_in">next</span>(it)   <span class="comment">#输出b</span></span><br><span class="line"><span class="meta">... </span>       <span class="comment">#直到迭代完成引发`StopIteration`异常。</span></span><br></pre></td></tr></table></figure>

<p>2.2 可通过在类中增加<code>__iter()__</code>方法返回对象本身给<code>__next__()</code>方法来为自己的类增加迭代功能。eg:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Reverse</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Iterator for looping over a sequence backwards.&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, data</span>):</span><br><span class="line">        self.data = data</span><br><span class="line">        self.index = <span class="built_in">len</span>(data)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__next__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> self.index == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">raise</span> StopIteration</span><br><span class="line">        self.index = self.index - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> self.data[self.index]</span><br><span class="line"></span><br><span class="line">rev = Reverse(<span class="string">&#x27;blueyi&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> char <span class="keyword">in</span> rev:</span><br><span class="line">    <span class="built_in">print</span>(char, end=<span class="string">&#x27; &#x27;</span>)    <span class="comment">#输出为i y e u l b</span></span><br></pre></td></tr></table></figure>

<p>3.Python中的生成器。</p>
<p><code>yield</code>语句可以用于创建迭代器，能够实现通过<code>__iter__()</code>和<code>__next__()</code>实现的功能。每次 next() 被调用时, 生成器会从它上次离开的地方继续执行，它会记住所有的数据值和最后一次执行的语句。eg:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">reverse</span>(<span class="params">data</span>):</span><br><span class="line">    <span class="keyword">for</span> index <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(data)-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">yield</span> data[index]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> char <span class="keyword">in</span> reverse(<span class="string">&#x27;blueyi&#x27;</span>):</span><br><span class="line">    <span class="built_in">print</span>(char, end=<span class="string">&#x27; &#x27;</span>)    <span class="comment">#输出为i y e u l b</span></span><br></pre></td></tr></table></figure>

<p>4.Generator表达式比列表实现的相同功能更省内存。</p>
<p><code>sum(i*i for i in range(10))</code>   #计算平方和，输出为285</p>
<h2 id="十-标准库"><a href="#十-标准库" class="headerlink" title="十.标准库"></a>十.标准库</h2><p>1.sys包含系统指定的函数功能</p>
<p>2.os用来和系统交互</p>
<p>3.plantform用来获得平台信息</p>
<p>4.logging用来记录信息</p>
<p>5.urllib网络相关  </p>
<h2 id="拾遗"><a href="#拾遗" class="headerlink" title="拾遗"></a>拾遗</h2><h3 id="函数装饰器：-classmethod-staticmethod-property"><a href="#函数装饰器：-classmethod-staticmethod-property" class="headerlink" title="函数装饰器：@classmethod, @staticmethod, @property"></a>函数装饰器：@classmethod, @staticmethod, @property</h3><p>函数装饰器通常用于放在类方法前面修饰类内部定义的函数。<br>类的成员函数可以通过上述提到的3个装饰器来修饰，区别主要如下：</p>
<ul>
<li>普通成员函数，即不使用任何装饰器来修饰的成员函数即为方法，它属于类的实例化对象，且只能通过实例化之后的类对象调用，而不能通过类本身来直接调用（当然可以通过显示传递实例的方式调用），即普通成员函数与类的实例绑定。普通成员函数的第一个参数默认为当前类的实例，即通常用的self。</li>
<li>@classmethod修饰的方法属于类方法，类方法属于类本身，且被所有类的实例共有，该方法的第一个参数默认为类本身，而不是类的实例，通常使用cls来表示第一个形参。该方法可以通过类名来直接调用，或者通过类的实例来调用，即该方法与类本身绑定。它可以访问数据成员及成员函数</li>
<li>@staticmethod修饰的方法为静态方法，类似C++中的静态方法，该方法不与类及类对象绑定，它的第一个参数也不要求必须是谁，可以没有第一个参数（其他类方法第一个参数都默认为类本身或实例本身）。该方法即可以直接通过类来调用，也可以通过类的实例调用。它不能访问实例的属性（数据成员或成员函数）</li>
<li>@property装饰器可以将方法设置为对象的属性，当一个函数被@property修饰时，python默认会为该类增加一个相应函数的getter, setter和deleter属性，默认的@property修饰的方法就是getter方法，如下面的官方示例：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self._x = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">x</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;I&#x27;m the &#x27;x&#x27; property.&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> self._x</span><br><span class="line"></span><br><span class="line"><span class="meta">    @x.setter</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">x</span>(<span class="params">self, value</span>):</span><br><span class="line">        self._x = value</span><br><span class="line"></span><br><span class="line"><span class="meta">    @x.deleter</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">x</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">del</span> self._x</span><br><span class="line"></span><br><span class="line"><span class="comment">#使用</span></span><br><span class="line">c = C()</span><br><span class="line">c.x = <span class="number">5</span></span><br><span class="line"><span class="built_in">print</span>(c.x)</span><br></pre></td></tr></table></figure>

<p>一个针对性举例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#! /usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;普通函数&quot;&quot;&quot;</span></span><br><span class="line">        self._x = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">com_fun</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;普通函数&quot;&quot;&quot;</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;I am common function&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">class_method</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;类方法，可以通过类名直接调用&quot;&quot;&quot;</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;I am class method: &#x27;</span> + <span class="built_in">str</span>(self.x))</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">st_method</span>():</span><br><span class="line">        <span class="string">&quot;&quot;&quot;静态方法，可以通过类名或实例直接调用，可以没有参数&quot;&quot;&quot;</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;I am static method&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">x</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;I&#x27;m the &#x27;x&#x27; property.&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> self._x</span><br><span class="line"></span><br><span class="line"><span class="meta">    @x.setter</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">x</span>(<span class="params">self, value</span>):</span><br><span class="line">        self._x = value</span><br><span class="line"></span><br><span class="line"><span class="meta">    @x.deleter</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">x</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">del</span> self._x</span><br><span class="line"></span><br><span class="line">c = C()</span><br><span class="line">c.com_fun()  <span class="comment">#通过实例调用普通函数，实际上该函数有第一个参数self，self即实例本身</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;c.com_fun: &#x27;</span> + <span class="built_in">str</span>(c.com_fun))  <span class="comment">#查看函数绑定情况</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># C.com_fun()  #通过类用普通函数将出错</span></span><br><span class="line">C.com_fun(c)  <span class="comment">#可以通过显式传递实例名的方式通过类名调用普通成员函数</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;C.com_fun(c): &#x27;</span> + <span class="built_in">str</span>(C.com_fun))  <span class="comment">#查看函数绑定情况</span></span><br><span class="line"></span><br><span class="line">c.class_method() <span class="comment">#通过实例调用类方法，实际上该方法的第一个参数cls为类本身</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;c.class_method: &#x27;</span> + <span class="built_in">str</span>(c.class_method))</span><br><span class="line"></span><br><span class="line">C.class_method() <span class="comment">#通过类调用类方法</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;C.class_method: &#x27;</span>+ <span class="built_in">str</span>(C.class_method))</span><br><span class="line"></span><br><span class="line">c.st_method()  <span class="comment">#通过实例调用静态方法，该函数参数列表为空，不存在第一个参数</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;c.st_method: &#x27;</span> + <span class="built_in">str</span>(c.st_method))</span><br><span class="line">C.st_method()  <span class="comment">#通过实例调用静态方法</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;C.st_method: &#x27;</span> + <span class="built_in">str</span>(C.st_method))</span><br><span class="line"></span><br><span class="line">c.x = <span class="number">5</span> <span class="comment">#通过setter属性为实例成员变量赋值</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;c.x: &#x27;</span> + <span class="built_in">str</span>(c.x))  <span class="comment">#通过getter属性获取实例变量的值</span></span><br><span class="line"><span class="keyword">del</span> c.x  <span class="comment">#通过deleter属性删除实例变量</span></span><br><span class="line"><span class="comment"># print(c.x)  #加上这句将运行出错，因为已经通过属性删除了c._x</span></span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">I am common function</span><br><span class="line">c.com_fun: &lt;bound method C.com_fun of &lt;__main__.C object at 0x0000000002A64E10&gt;&gt;</span><br><span class="line">I am common function</span><br><span class="line">C.com_fun(c): &lt;unbound method C.com_fun&gt;</span><br><span class="line">I am class method: &lt;property object at 0x0000000002A790E8&gt;</span><br><span class="line">c.class_method: &lt;bound method type.class_method of &lt;class &#x27;__main__.C&#x27;&gt;&gt;</span><br><span class="line">I am class method: &lt;property object at 0x0000000002A790E8&gt;</span><br><span class="line">C.class_method: &lt;bound method type.class_method of &lt;class &#x27;__main__.C&#x27;&gt;&gt;</span><br><span class="line">I am static method</span><br><span class="line">c.st_method: &lt;function st_method at 0x0000000002A77748&gt;</span><br><span class="line">I am static method</span><br><span class="line">C.st_method: &lt;function st_method at 0x0000000002A77748&gt;</span><br><span class="line">c.x: 5</span><br></pre></td></tr></table></figure>
<p>从结果中可以看到com_method绑定到了C的对象，class_method与类本身绑定，st_method没有绑定</p>
<h3 id="requirements-txt"><a href="#requirements-txt" class="headerlink" title="requirements.txt"></a>requirements.txt</h3><p><code>pip freeze &gt; requirements.txt</code> 生成依赖<br><code>pip install -r requirements.txt</code> 安装依赖</p>
<p>参考：<br><a href="http://stackoverflow.com/questions/136097/what-is-the-difference-between-staticmethod-and-classmethod-in-python">http://stackoverflow.com/questions/136097/what-is-the-difference-between-staticmethod-and-classmethod-in-python</a><br><a href="http://stackoverflow.com/questions/12179271/meaning-of-classmethod-and-staticmethod-for-beginner">http://stackoverflow.com/questions/12179271/meaning-of-classmethod-and-staticmethod-for-beginner</a><br><a href="http://blog.csdn.net/slvher/article/details/42497781">http://blog.csdn.net/slvher/article/details/42497781</a><br><a href="https://docs.python.org/2/library/functions.html#property">https://docs.python.org/2/library/functions.html#property</a></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Notes</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Git学习笔记</title>
    <url>/2015/04/09/git-study-notes/</url>
    <content><![CDATA[<h2 id="git常用配置命令"><a href="#git常用配置命令" class="headerlink" title="git常用配置命令:"></a>git常用配置命令:</h2><p><code>git config --global user.name &quot;Your Name&quot;</code> 相当于设置你将来的仓库所有人  </p>
<p><code>git config --global user.email &quot;you@example.com&quot;</code> 仓库所有人的邮箱  </p>
<p><code>git config --global color.ui true</code> 让git显示颜色  </p>
<p>在仓库目录下新建<code>.gitignore</code>，编辑需要忽略掉的文件，支持通配符，并把它提交到仓库即可。可以访问<a href="https://github.com/github/gitignore">https://github.com/github/gitignore</a> 寻找常用的<code>.gitignore</code>文件  </p>
<p><code>git config --global alias.[alias_name] [git_command]</code> 为git命令配置别名，跟bash里面的别名配置类似</p>
<span id="more"></span>

<p>例如: </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global alias.lg &quot;log --color --graph --pretty=format:&#x27;%Cred%h%Creset  </span><br><span class="line">-%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&#x27; --abbrev-commit&quot;</span><br></pre></td></tr></table></figure>
<p>配置之后执行<code>git lg</code>就等价于执行上面双引号中的一大堆。</p>
<p>git的全局配置文件在<code>/home/username/.gitconfig</code></p>
<p>git的各个仓库配置文件在仓库目录下的<code>.git/config</code></p>
<h2 id="git本地维护常用命令"><a href="#git本地维护常用命令" class="headerlink" title="git本地维护常用命令"></a>git本地维护常用命令</h2><p><code>git init</code> 初始化当前目录为git的版本控制仓库</p>
<p><code>git add [FILES..]</code> 把文件添加到仓库的暂存区，方便一并提交</p>
<p><code>git commit -m &quot;STRING&quot;</code> 提交刚才添加到仓库暂存区的文件，相当于是对文件建了一个快照，所以提交的只相当于是修改，STRING可以设置成方便自己以后查看的快照备注</p>
<p><code>git status</code> 查看当前的仓库状态，例如都添加了哪些文件，哪些没有被添加，哪些做了修改还没有提交</p>
<p><code>git diff [FILENAME]</code> 查看当前名为FILENAME的文件与上次commit的文件有哪些不同</p>
<p><code>git diff [HEAD[N个^]] -- [FILENAME]</code>查看FILENAME当前文件内容与之前某个版本内容的差异</p>
<p><code>git log (--pretty=oneline)</code> 查看当前的提交历史 (<code>--graph</code>) 查看分支合并图</p>
<p><code>git reflog</code> 查看命令历史，可以显示对文件操作过的所有命令历史，包含SHA1码的一部分，可以方便的回退到任何一个版本</p>
<p><code>git reset --hard  [commit_id/HEAD[^]]</code> 回退版本,它会撤销某次提交，但是此次提交之后的修改都会被退回到暂存区。其中commit_id即为SHA1码的一部分，HEAD后面有几个^就表示回退几个版本，或者使用<code>HEAD~[n]</code>，其中<code>n</code>即是通过<code>git reflog</code>查看到的序号。  </p>
<p><code>git reset HEAD -- [FILENAME]</code> 将添加到暂存区的文件撤消到工作区  </p>
<p><code>git reset HEAD</code> 撤销当前add的所有文件，相当于撤销add操作</p>
<p><code>git revert [commit_id/HEAD[^]/HEAD[n]]</code> 撤销某次操作，此次操作之后的<code>commit</code>都会被保留，例如有1,2,3个<code>commit</code>,<code>git revert 2</code>之后通过<code>git log</code>查看时会发现，只有1,3。  </p>
<p><code>git checkout -- [FILENAME]</code> 丢弃工作区中对应文件的修改 相当于使用版本库中的相应文件替换工作区中的文件</p>
<p><code>git rm [FILENAME]</code> 删除文件</p>
<h2 id="git分支相关命令"><a href="#git分支相关命令" class="headerlink" title="git分支相关命令"></a>git分支相关命令</h2><p> <code>git branch</code> 查看分支  </p>
<p> <code>git branch [branch_name]</code> 创建名为branchname的分支</p>
<p> <code>git checkout [branch_name]</code> 切换分支</p>
<p> <code>git checkout -b [branch_name]</code> 创建并切换分支</p>
<p> <code>git merge [branch_name]</code> 将分支branch_name合并到当前分支,使用的是快速合并模式(fast forward)，删除分支后会丢失分支信息，以后将无法查看到分支合并记录</p>
<p> <code>git merge --no-ff -m &quot;string&quot; [branch_name]</code> 普通合并模式，可以使用<code>git log --graph</code>查看分支合并情况</p>
<p> <code>git branch -d [branch_name]</code> 删除已经合并的分支。 “-d”参数改为”-D”后可以强制删除未合并的分支</p>
<p><code>git stash</code> 暂存当前分支的工作现场</p>
<p><code>git stash apply ([stash@&#123;n&#125;])</code> 恢复当前分支到暂存n或者直接恢复最近一个stash，参数可选,这里的暂存跟<code>git add</code>到的暂存区不是同一个意思，这个相当于工作状态收藏夹</p>
<p><code>git stash drop ([stash@&#123;n&#125;])</code> 删除某个暂存，参数可选</p>
<p><code>git stash pop ([stash@&#123;n&#125;])</code> 恢复并删除某个暂存，参数可选</p>
<h2 id="git远程操作命令"><a href="#git远程操作命令" class="headerlink" title="git远程操作命令"></a>git远程操作命令</h2><h3 id="远程操作相关命令"><a href="#远程操作相关命令" class="headerlink" title="远程操作相关命令"></a>远程操作相关命令</h3><p>下面以github上的远程仓库为便演示，当然该远程仓库地址为本地裸版本库也是一样的。<br><code>ssh-keygen -t rsa -b 4096 -C &quot;YOUREMAIL@YOUREMAIL.COM&quot;</code> 生成新的SSH密钥，以便使用远程仓库时使用SSH加密传输,生成SSH key之后复试<code>.ssh/id_rsa.pub</code> 中的内容添加到github，详情可以查看github帮助</p>
<p><code>ssh -T git@github.com</code> 测试GITHUB上的密钥是否设置正确</p>
<p><code>git remote add  origin &#39;git@github.com:yourusername/projectname.git&#39;</code><br>或<br><code>git remote add  origin &#39;https://github.com/yourname/projectname.git&#39;</code><br>将本地仓库添加到远程仓库，远程仓库的名字为<code>origin</code>，远程仓库的项目名字即为<code>projectname</code><br>如果出现403错误，可以考虑将<code>.git/config</code>中的url修改为<code>ssh://git@github.com/FanChael/Hash.git</code></p>
<p><code>git push -u origin master</code> 第一次将本地仓库的master分支推送到远程 并关联本地和远程的master分支</p>
<p><code>git push origin master</code> 把本地master分支的最新修改推送至GitHub</p>
<p><code>git push origin dev:dev</code> 提交本地创建的<code>dev</code>分支为远程的<code>dev</code>分支   </p>
<p><code>git push origin :dev</code> 删除刚提交到远程的<code>dev</code>分支   </p>
<p><code>git push [origin branch-name]</code> 推送某个分支到远程，如果不加参数则推送push.default设置的默认推送内容，如果未设置push.default则推送当前分支，如果当前分支与远程分支没有关联，则使用以下命令关联即可</p>
<p><code>git branch --set-upstream origin remote_branch_name</code> 关联本地当前分支与远程分支以便使用不带参数的git push命令进行推送</p>
<p><code>git remote (-v)</code> 查看远程名称，加上”-v”参数可以查看更详细的内容</p>
<p><code>git branch -r</code> 查看远程跟踪的分支，即所有的远程分支</p>
<p><code>git clone [URL]</code> 将远程仓库克隆到本地</p>
<p><code>git pull [origin branch_name]</code> 拉取远程仓库中branch_name分支的最新内容到本地，并直接与当前本地分支merge,以更新本地分支内容</p>
<p><code>git fetch [origin branch_name]</code> 获取远程分支到origin/branch_name分支，不会自动合并。 </p>
<p><code>git diff branch_name..origin/branch_name</code> 查看本地与刚fetch回来的数据差异  </p>
<p><code>git fetch origin</code> 即获取远程仓库到本地  </p>
<p><code>git checkout -b local_branch_name origin/remote_branch_name</code> 在本地创建并切换到与远程分支对应的分支，最好两个分支名字一样，常应用于先有远程分支时。</p>
<p><code>git diff local_branch_name remote_branch_name FILENAME</code> 比较本地某个文件与远程分支上的区别</p>
<p><code>git tag [tag_name]  ([commit id])</code> 将当前分支的最后一次提交加上标签名tab_name,或者指定某个commit id，例如标签即为版本号</p>
<p><code>git tag -d [tag_name]</code> 删除某个标签</p>
<p><code>git tag -a [tag_name] -m &quot;string&quot;</code> 添加标签并附带描述</p>
<p><code>git tag -s [tag_name] -m &quot;string&quot;</code> 添加带PGP签名的的标签及描述</p>
<p><code>git tag</code> 显示所有标签</p>
<p><code>git show [tag_name]</code> 显示标签的详细信息</p>
<p><code>git push origin [tag_name]</code> 推送本地标签到远程</p>
<p><code>git push origin --tags</code> 推送本地所有未被推送到远程的标签</p>
<p><code>git push origin :refs/tags/tag_name</code> 删除远程上某个的标签  </p>
<h3 id="创建本地的祼版本库"><a href="#创建本地的祼版本库" class="headerlink" title="创建本地的祼版本库"></a>创建本地的祼版本库</h3><p>祼版本库是指仅用于存放仓库版本信息，不含有工作区的git源库。例如我们在github上存储的仓库，实际并不与我们的本地仓库目录结构一致，它只是保存了我们的仓库版本信息，以便需要时将其克隆到本地，成为带工作区的git版本控制仓库，以及推送时将本地库推送后自动被转换为远程的裸版本库。为了方便我们在本地操作或者以本地硬盘存储git仓库，可以采用本地裸版本库。祼版本库通常以后缀<code>.git</code>结尾。有两种方式为一个项目创建本地的祼版本库，实际上当这个仓库有个绝对地址时，也就类似于github上的了。</p>
<h4 id="克隆生成祼版本库"><a href="#克隆生成祼版本库" class="headerlink" title="克隆生成祼版本库"></a>克隆生成祼版本库</h4><p>假如已经在本地初始化一个git的工作目录，现在想为其创建一个相应的祼版本库，以便向其中推送我们的版本控制。命令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone --bare /path/to/my/workspace/demo /path/to/repos/demo.git</span><br></pre></td></tr></table></figure>
<p>查看裸库目录结构：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ls -a</span><br><span class="line">./  ../  config  description  HEAD  hooks/  info/  objects/  refs/</span><br></pre></td></tr></table></figure>
<p>现在可以将我们的工作目录推送到该库了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git remote add origin /path/to/repos/demo.git</span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure>
<p>或者直接推送：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git push /path/to/repos/demo.git</span><br><span class="line"># 可能需要以下命令</span><br><span class="line">git push --set-upstream /path/to/repos/demo.git master</span><br></pre></td></tr></table></figure>
<h4 id="创建生成裸版本库"><a href="#创建生成裸版本库" class="headerlink" title="创建生成裸版本库"></a>创建生成裸版本库</h4><p>命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git init --bare /path/to/repos/demo.git</span><br></pre></td></tr></table></figure>
<p>有了裸版本库地址<code>/path/to/repos/demo.git</code>，后面的操作就都一样了，可以直接从其克隆来创建本地库工作目录，也可以将其添加为本地工作目录的一个远程存储仓库</p>
<h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="将master分支整个替换为dev分支"><a href="#将master分支整个替换为dev分支" class="headerlink" title="将master分支整个替换为dev分支"></a>将master分支整个替换为dev分支</h3><p>场景：假如使用<code>dev</code>分支已经工作了一段时间，<code>master</code>分支已经落后数个版本，现在想将当前的<code>dev</code>分支设为新的<code>master</code>。方法如下：<br>方法一：<br><code>git checkout dev</code>  切换到<code>dev</code>分支<br><code>git merge --strategy=ours master</code>  保留<code>dev</code>分支的全部内容，并记录合并<br><code>git checkout master</code>  切换回<code>master</code><br><code>git merge dev</code>  使用快速合并将<code>dev</code>合并到<code>master</code>分支，不会有冲突问题<br><code>git push -f origin master</code>  防止推送冲突，强制推送  </p>
<p>方法二(不推荐)：<br><code>git branch -m master old_master</code>  修改当前<code>master</code>分支名字为<code>old_master</code><br><code>git branch -m dev master</code>  将<code>dev</code>修改为<code>master</code><br><code>git push -f origin master</code>  强制推送   </p>
<h3 id="如何撤销合并"><a href="#如何撤销合并" class="headerlink" title="如何撤销合并"></a>如何撤销合并</h3><p>场景：在<code>master</code>分支上将<code>dev</code>合并到<code>master</code>分支后，发现合并错了分支，或者觉得暂时不应该合并，可以使用以下方法撤消合并。这是官方的教程<a href="http://git-scm.com/blog/2010/03/02/undoing-merges.html">http://git-scm.com/blog/2010/03/02/undoing-merges.html</a><br>方法一：<code>reset</code>到<code>merge</code>前的版本即可，要求每个合作者都将本在的<code>HEAD</code>回滚回去<br><code>git checkout master</code>  切换到进行合并操作时的分支<br><code>git reset --hard [merge前的版本号]</code>  回滚到<code>merge</code>前的版本号，例如<code>HEAD^</code>  </p>
<h3 id="gitignore排除总结"><a href="#gitignore排除总结" class="headerlink" title=".gitignore排除总结"></a>.gitignore排除总结</h3><ul>
<li>忽略一个特定的文件：/filename.extension</li>
<li>忽略所有同名的文件：filename.extension</li>
<li>忽略一个特定的目录：folder/ （这会连同其下所有子目录及文件都被忽略）</li>
<li>但是排除一个特定的模式：（在 3 的基础上）!folder/some/important/filename.extension</li>
<li>忽略指定目录下所有子目录下的特定文件：folder/**/filename.extension</li>
<li>同上，但是只匹配文件扩展名：folder/<em>*/</em>.extension</li>
<li>同上，但是只匹配特定的目录：folder/**/tmp/<br>参考：<a href="https://ruby-china.org/topics/23561">https://ruby-china.org/topics/23561</a></li>
</ul>
<h3 id="git-fetch-与-git-pull的区别"><a href="#git-fetch-与-git-pull的区别" class="headerlink" title="git fetch 与 git pull的区别"></a>git fetch 与 git pull的区别</h3><ol>
<li><p><code>git fetch</code>: 相当于是从远程获取最新版本到本地，不会自动<code>merge</code><br>常用使用场景：获取远程分支到origin/master，然后与本地master分支比较之后，再合并  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git fetch origin master</span><br><span class="line">git log -p master..origin/master</span><br><span class="line">git merge origin/master</span><br></pre></td></tr></table></figure>
<p>类似的实现方式如下  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git fetch origin master:temp</span><br><span class="line">git diff temp</span><br><span class="line">git merge temp</span><br></pre></td></tr></table></figure>
<p>即：首先获取远程master分支到temp分支，比较之后再合并</p>
</li>
<li><p><code>git pull</code>:相当于从远程获取分支的最新版本并与本地对应分支进行<code>merge</code>。eg:<br><code>git pull [origin branch_name]</code> 即从远程获取branch_name分支并与本地的branch_name分支合并，如果去除可选参数则表示获取当前本地分支的远程分支并合并。相当于<code>git fetch</code>与<code>git merge</code>两个命令，但会隐藏掉过程细节，所以通常建议使用fetch而不是pull。  </p>
</li>
</ol>
<h3 id="GitHub上与他人合作个人项目"><a href="#GitHub上与他人合作个人项目" class="headerlink" title="GitHub上与他人合作个人项目"></a>GitHub上与他人合作个人项目</h3><p>仅限于个人建立的项目，不包括组织项目。<br>GitHub官方对应的相关链接如下：  </p>
<ol>
<li><code>Fork A Repo</code>: <a href="https://help.github.com/articles/fork-a-repo/">https://help.github.com/articles/fork-a-repo/</a>    </li>
<li><code>Syncing a fork</code>: <a href="https://help.github.com/articles/syncing-a-fork/">https://help.github.com/articles/syncing-a-fork/</a>   </li>
<li><code>Using pull requests</code>: <a href="https://help.github.com/articles/using-pull-requests/">https://help.github.com/articles/using-pull-requests/</a>  </li>
<li><code>Merging a pull request</code>: <a href="https://help.github.com/articles/merging-a-pull-request/">https://help.github.com/articles/merging-a-pull-request/</a>  </li>
<li><code>Closing a pull request</code>: <a href="https://help.github.com/articles/closing-a-pull-request/">https://help.github.com/articles/closing-a-pull-request/</a>  </li>
</ol>
<p>一、如果对方将你添加为合作者，也就是将你添加到<code>Collaborators</code>列表，那么，你将自动拥有对该项目的几乎所有的修改权限，所有此时只需要新建分支就可以直接开写代码了。当然，如果项目为私有项目，必须添加队友为合作者时，队友才能看见你的代码仓库。  </p>
<p>二、如果不是合作者，则需要通过<code>fork</code>别人的代码仓库，然后修改之后再通过创建<code>pull request</code>申请将代码合并。如果<code>fork</code>之后原仓库代码又有了更新，则可以通过同步这个fork来更新你当前的代码。具体操作如下：  </p>
<ol>
<li><p>首先通过github网站上项目右上角的Fork按钮来Fork一份想要协作的项目仓库。Fork结束后就会在你的账号下拷贝一份该项目的副本。  </p>
</li>
<li><p>通过<code>git clone https://github.com/YOUR_USERNAME/YOUR_FORK.git</code>克隆你账号下Fork的项目到本地。通过<code>git remote -v</code>命令可以查看该仓库所配置的远程仓库详情。然后通过命令<code>git remote add upstream https://github.com/ORIGINAL_OWNER/ORIGINAL_REPOSITORY.git</code>将你的仓库与原仓库的远程地址相关联，以便接收原仓库的更新，通过<code>git remote -v</code>来查看当前配置。  </p>
</li>
<li><p>通过<code>git fetch upstream</code>将原仓库的更新接收到本地的<code>upstream</code>中，<code>master</code>中commit将会存储在本地的<code>upstream/master</code>。本地切换到master分支后通过<code>git merge upstream/master</code>将fork的master分支与upstream同步。  </p>
</li>
<li><p>本地修改过fork的仓库代码后，先提交到自己账号下的相应仓库，然后通过GitHub网站上分支旁边的<code>compare,review,create a pull request</code>按钮来查看代码更新并创建<code>pull request</code>。当确定你的代码可以提交给原仓库主合并时，点击<code>Create pull request</code>即可创建一个pull request提示原仓库主及其合作者可以考虑将你的修改与当前仓库相应分支进行合并。  </p>
</li>
</ol>
<h3 id="解决部分网络无法使用SSH连接的问题"><a href="#解决部分网络无法使用SSH连接的问题" class="headerlink" title="解决部分网络无法使用SSH连接的问题"></a>解决部分网络无法使用SSH连接的问题</h3><p>使用ssh连接最大的好处是可以不需要每次进行远程操作都输入密码，但github官方比较推荐使用https连接，应该是考虑更安全。<br>有些网络禁用了部分SSH连接，导致使用命令<code>ssh -T git@github.com</code>测试连接时提示连接超时，此时可以通过以下方式测试是否可以让SSH使用HTTPS的443端口连通<code>ssh -T -p 443 git@ssh.github.com</code>，如果测试通过，则说明可以让ssh通过HTTPS的端口来通信。此时需要创建以下文件<code>~/.ssh/config</code>，如果是windows，则在用户目录下面的<code>.ssh</code>文件夹中创建config文件，内容如下：  </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Host github.com</span><br><span class="line">  Hostname ssh.github.com</span><br><span class="line">  Port 443</span><br></pre></td></tr></table></figure>
<p>保存后应该就可以正常使用<code>ssh -T git@github.com</code>测试通过了。<br>官网链接在此： <a href="https://help.github.com/articles/using-ssh-over-the-https-port/">Using SSH over the HTTPS port</a>    </p>
<h3 id="如何让github上fork的项目保持更新"><a href="#如何让github上fork的项目保持更新" class="headerlink" title="如何让github上fork的项目保持更新"></a>如何让github上fork的项目保持更新</h3><p>应用场景为：当你看到某一个好的项目，觉得很不错，以后有可以自己会使用到，然后你可能会考虑到先<code>fork</code>到自己的账号下。<code>fork</code>的作用就是在你的账号下建立一份该仓库的关联副本，你可能通过修改你账号下的该副本然后提交后给原仓库发一个<code>pull request</code>来请求原仓库作者合并你的提交。当你<code>fork</code>过原仓库一段时间后，发现原仓库又更新了很多提交，你现在希望自己账号下的该仓库副本与原仓库保持同步，当然你可以删除你的这个副本然后重新<code>fork</code>一次，或者你的副本已经有了自己的修改需要保留，那么你可以采用以下两种方法：  </p>
<ul>
<li>直接在<code>github</code>网页上操作，即利用<code>github</code>上的<code>pull request</code>功能，所以这个<code>pull request</code>不仅仅可以向原仓主发出合并请求，还可以更新你的副本仓库。操作截图如下：  <ul>
<li>1.首先打开你的副本仓库，点击<code>Pull request</code>或<code>Compare</code>按钮<br><img data-src="1.jpg" alt="">  </li>
<li>2.点击<code>switching the base</code>，或者手动切换<code>base fork</code>为你的副本仓库以及<code>head fork</code>为原仓库<br><img data-src="2.jpg" alt="">  </li>
<li>3.切换完成之后点击<code>Create pull request</code>，并填写<code>Title</code>（就是你想备注的信息）之后即可<code>Create pull request</code><br><img data-src="3.jpg" alt="">  </li>
<li>4.滚动窗口到最下面后点击<code>Merge pull request</code>即可（同样可能需要填写你想要的备注信息），然后<code>Confirm merge</code>。<br><img data-src="4.jpg" alt="">  </li>
</ul>
</li>
<li>通过在本地仓库中增加原仓库地址为一个<code>remote</code>仓库，然后<code>fetch</code>后切换到相应的分支或者将更新分支合并到希望更新的分支，在更新本地仓库后，再提交即可。具体操作过程如下：  <ul>
<li>1.增加原分支为远程分支，命名为<code>upstream</code>：<code>git remote add upstream https://github.com/whoever/whatever.git</code>  </li>
<li>2.<code>fetch</code>该远程仓库下的所有分支到<code>remote-tracking</code>分支：<code>git fetch upstream</code>  </li>
<li>3.确保你当前在<code>master</code>分支：<code>git checkout master</code>  </li>
<li>4.如果你已经对当前自己的副本做过更改，并且想要保留，则将更新合并到主分支：<code>git merge upstream/master</code>，如果想要保留所有原仓库的历史更新则使用<code>rebase</code>复写当前分支：<code>git rebase upstream/master</code>  </li>
<li>5.然后正常推送即可，如果推送有冲突，可以直接强制推送：<code>git push -f origin master</code>  </li>
</ul>
</li>
</ul>
<h3 id="如何提交时忽略所有删除的文件"><a href="#如何提交时忽略所有删除的文件" class="headerlink" title="如何提交时忽略所有删除的文件"></a>如何提交时忽略所有删除的文件</h3><p>应用场景：当使用git一段时间之后，如果对文件做过较多的删除操作之后，使用<code>git add .</code>之后会提示手动使用<code>git rm</code>来删除那些已经被删除的文件，此时如果想一条命令来忽略掉所以这些需要使用<code>git rm</code>来删除的操作，那就使用<code>git add -A</code>。然后就不会再有那一堆的红色提示了。  </p>
<h3 id="git如何永久性地从历史提交中删除某个文件"><a href="#git如何永久性地从历史提交中删除某个文件" class="headerlink" title="git如何永久性地从历史提交中删除某个文件"></a>git如何永久性地从历史提交中删除某个文件</h3><p>应用场景：某次不小心将含有密码等重要数据的文件提交到了仓库中，后来又commit多次之后才发现，曾经提交了一个不该提交的文件，需要将其从所有历史中删除。可以如下操作：<br><strong>删除文件历史</strong><br>进入你的仓库根目录，进行以下操作，其中PATH-TO-YOUR-FILE-WITH-SENSITIVE-DATA是你需要删除的文件的相对路径</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git filter-branch --force --index-filter \</span></span><br><span class="line"><span class="language-bash"><span class="string">&#x27;git rm --cached --ignore-unmatch PATH-TO-YOUR-FILE-WITH-SENSITIVE-DATA&#x27;</span> \</span></span><br><span class="line"><span class="language-bash">--prune-empty --tag-name-filter <span class="built_in">cat</span> -- --all</span></span><br></pre></td></tr></table></figure>
<p><em>如果该文件曾经在其他路径，并被重新命名后移到了现在的路径，同样需要对原文件执行相同的操作</em></p>
<p><strong>确认已经完成删除</strong><br>确认你的文件以及相应的历史是否已经完全移除，可以通过以下命令查看相应文件的commit id:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">log</span> --pretty=oneline &lt;PATH-TO-YOUR-FILE-WITH-SENSITIVE-DATA&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后根据commit id查看文件修改历史：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git show &lt;commit-id&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>强制更新远程仓库</strong><br>确认后可以将你的敏感文件加入.gitignore，然后后进行强制更新远程仓库即可：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git push origin --force --all</span></span><br></pre></td></tr></table></figure>

<p><strong>更新tags</strong><br>如果有相应的tags，也应该更新tags</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git push origin --force --tags</span></span><br></pre></td></tr></table></figure>

<p>还有其他多种方法，可以参考：<br>1.<a href="https://help.github.com/articles/removing-sensitive-data-from-a-repository/">https://help.github.com/articles/removing-sensitive-data-from-a-repository/</a><br>2.<a href="http://stackoverflow.com/questions/307828/completely-remove-file-from-all-git-repository-commit-history">http://stackoverflow.com/questions/307828/completely-remove-file-from-all-git-repository-commit-history</a></p>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Notes</tag>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>5分钟掌握Markdown基本语法</title>
    <url>/2014/03/20/learn-mardown-in-5-minutes/</url>
    <content><![CDATA[<p>本文非原创，基于原创内容增加了一些常用内容，原创网址貌似被墙了，所以转来分享  </p>
<span id="more"></span>
<hr>
<h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><p><code>#</code>+<code>空格</code>+<code>标题</code>。<br>通过 1 到 6 个 <code>#</code> 可以指定不同字号的标题，1 个 <code>#</code> 代表一级标题（最大），6 个 <code>#</code> 代表六级标题（最小）。</p>
<img data-src="/images/20140320/learnMarkdown1.png" class="">
<!-- more -->

<p>标题还有一种比较少用的语法是：输入标题后换行，在第二行写三个以上 <code>=</code> 或 <code>-</code>，如：</p>
<img data-src="/images/20140320/learnMarkdown8.png" class="">

<h2 id="加粗和倾斜"><a href="#加粗和倾斜" class="headerlink" title="加粗和倾斜"></a>加粗和倾斜</h2><p>倾斜：<code>*要倾斜的文字*</code> 或 <code>_要倾斜的文字_</code>；<br>加粗：<code>**要加粗的文字**</code> 或 <code>__要加粗的文字__</code>。`   </p>
<p>在文字的两端各添加一个 <code>*</code> 或 <code>_</code> 表示这段文字倾斜，各添加两个 <code>*</code> 或 <code>_</code> 表示这段文字加粗。</p>
<img data-src="/images/20140320/learnMarkdown2.png" class="">

<h2 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h2><p><code>~~文字~~</code>。下面效果的代码是 <code>~~删除线~~</code><br><del>删除线</del>。</p>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><code>[文字](点击文字后链接到的 URL &quot;标题&quot;)</code>。<br>如 <a href="www.google.com">Google</a> 的代码是：<code>[Google](www.google.com)</code> 我省略掉了标题。<br>自动链接可以使用<code>&lt;http://notes.maxwi.com&gt;</code> 当然中间的网址为邮箱时自动处理为mailto   </p>
<h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><p><code>![文字](点击文字后链接到的 URL &quot;标题&quot;)</code></p>
<p>图片和链接和像，只是在链接的语法前面加上一个 <code>!</code>。图片的 <strong>文字</strong> 和 <strong>标题</strong> 都可以省略掉。<br>如下面的图片代码就是 <code>![](https://www.google.com/images/srpr/logo4w.png)</code>。</p>
<p><img data-src="https://www.google.com/images/srpr/logo4w.png" alt=""></p>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p><code>&gt; 引用的文字</code></p>
<p>引用只需要在引用的文字前面加上 <code>&gt;</code>+<code>空格</code> 即可。如果是多层引用就多个 <code>&gt;</code>。<br>如下面的引用代码是 <code>&gt; Hello Markdown!</code>。</p>
<blockquote>
<p>Hello Markdown!.</p>
</blockquote>
<h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p><code>序号. 文字</code> 或 <code>* 文字</code>。注意 <code>序号.</code> 或 <code>*</code> 与文字之间都需要加一个 <code>空格</code>。支持嵌套。</p>
<ol>
<li>列表 A</li>
<li>列表 A</li>
<li><ul>
<li>嵌套 A</li>
<li>嵌套 A</li>
<li>嵌套 A</li>
</ul>
</li>
</ol>
<p>或</p>
<ul>
<li>列表 B</li>
<li>列表 B</li>
<li><ol>
<li>嵌套 B</li>
<li>嵌套 B</li>
<li>嵌套 B</li>
</ol>
</li>
</ul>
<p>上面效果的代码是：</p>
<img data-src="/images/20140320/learnMarkdown3.png" class="">

<h2 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h2><p><code>___</code> 或 <code>***</code> 或 <code>- - - -</code>， 效果都是一样的：</p>
<hr>
<h2 id="强制换行"><a href="#强制换行" class="headerlink" title="强制换行"></a>强制换行</h2><p><code>文字后加两个或两个以上空格</code>。下面是对比效果图：<br>回车但未强制换行：</p>
<img data-src="/images/20140320/learnMarkdown4.png" class="">

<img data-src="/images/20140320/learnMarkdown5.png" class="">

<p>回车并强制换行：</p>
<img data-src="/images/20140320/learnMarkdown6.png" class="">

<img data-src="/images/20140320/learnMarkdown7.png" class="">

<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>一行的情况：首尾加上<code>`</code> 即可，如：<br><code>#include &lt;stdlib.h&gt;</code><br>的代码是 <code>`#include &lt;stdlib.h&gt;`</code>。<br>多行的情况：每行缩进 4 个 <code>空格</code> 或一个 <code>Tab</code>，如</p>
<pre><code>#include &lt;stdlib.h&gt;   
#include &lt;stdio.h&gt;   
#include &lt;conio.h&gt;   </code></pre><p>代码是:</p>
<img data-src="/images/20140320/learnMarkdown9.png" class="">
<p>或者放在两行三个<code>`</code>之间，上面代码的多行表示形式可以是：</p>
<img data-src="/images/20140320/learnMarkdown10.png" class="">
<p>或者第一个标识后面可以接上特定的语言，以支持高亮：（假如markdown解析系统支持的话）</p>
<img data-src="/images/20140320/learnMarkdown11.png" class="">


<h2 id="页内跳转"><a href="#页内跳转" class="headerlink" title="页内跳转"></a>页内跳转</h2><ol>
<li><p>先定义一个锚(id)<br><code>&lt;span id=&quot;jump&quot;&gt;Hello World&lt;/span&gt;</code></p>
</li>
<li><p>然后使用markdown的语法:<br><code>[jump to Hello World](#jump)</code></p>
</li>
</ol>
<h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><p>注意表格的开始和结束位置都需要有个空行<br>Markdown可以使用以下方式生成表格：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">| 一个普通标题 | 一个普通标题 | 一个普通标题 |</span><br><span class="line">| ------| ------ | ------ |</span><br><span class="line">| 短文本 | 中等文本 | 稍微长一点的文本 |</span><br><span class="line">| 稍微长一点的文本 | 短文本 | 中等文本 |</span><br></pre></td></tr></table></figure>
<p>效果为：   </p>
<table>
<thead>
<tr>
<th>一个普通标题</th>
<th>一个普通标题</th>
<th>一个普通标题</th>
</tr>
</thead>
<tbody><tr>
<td>短文本</td>
<td>中等文本</td>
<td>稍微长一点的文本</td>
</tr>
<tr>
<td>稍微长一点的文本</td>
<td>短文本</td>
<td>中等文本</td>
</tr>
</tbody></table>
<p>或者这样：   </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">| 左对齐标题 | 右对齐标题 | 居中对齐标题 |</span><br><span class="line">| :------| ------: | :------: |</span><br><span class="line">| 短文本 | 中等文本 | 稍微长一点的文本 |</span><br><span class="line">| 稍微长一点的文本 | 短文本 | 中等文本 |</span><br></pre></td></tr></table></figure>
<p>效果为：   </p>
<table>
<thead>
<tr>
<th align="left">左对齐标题</th>
<th align="right">右对齐标题</th>
<th align="center">居中对齐标题</th>
</tr>
</thead>
<tbody><tr>
<td align="left">短文本</td>
<td align="right">中等文本</td>
<td align="center">稍微长一点的文本</td>
</tr>
<tr>
<td align="left">稍微长一点的文本</td>
<td align="right">短文本</td>
<td align="center">中等文本</td>
</tr>
</tbody></table>
<p>或者使用html标签的方式：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span>&gt;</span>设备<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span>&gt;</span>设备文件名<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span>&gt;</span>文件描述符<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span>&gt;</span>类型<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span>&gt;</span>键盘<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span>&gt;</span>/dev/stdin<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span>&gt;</span>0<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span>&gt;</span>标准输入<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span>&gt;</span>显示器<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span>&gt;</span>/dev/stdout<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span>&gt;</span>1<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span>&gt;</span>标准输出<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span>&gt;</span>显示器<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span>&gt;</span>/dev/stderr<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span>&gt;</span>2<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span>&gt;</span>标准错误输出<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>效果为：</p>
<table>
    <tr>
        <th>设备</th>
        <th>设备文件名</th>
        <th>文件描述符</th>
        <th>类型</th>
    </tr>
    <tr>
        <th>键盘</th>
        <th>/dev/stdin</th>
        <th>0</th>
        <th>标准输入</th>
    </tr>
    <tr>
        <th>显示器</th>
        <th>/dev/stdout</th>
        <th>1</th>
        <th>标准输出</th>
    </tr>
    <tr>
        <th>显示器</th>
        <th>/dev/stderr</th>
        <th>2</th>
        <th>标准错误输出</th>
    </tr>
</table>

]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
        <tag>5分钟掌握Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo相关陷阱</title>
    <url>/2014/03/20/hexo-trap/</url>
    <content><![CDATA[<p>Hexo使用过程中遇到的一些陷阱，往往只是一个很小的问题，但可能需要花费很多时间才能查到问题所在，特别是当笔记比较多的时候，并且问题又出在对笔记的markdown文件解析上的时候。</p>
<h3 id="enerate-Error-expected-end-of-comment-got-end-of-file"><a href="#enerate-Error-expected-end-of-comment-got-end-of-file" class="headerlink" title="enerate Error: expected end of comment, got end of file"></a>enerate Error: expected end of comment, got end of file</h3><p>由于某一个markdown文件中有这样一句:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">`echo $&#123;#arr[@]&#125;`</span><br></pre></td></tr></table></figure>
<p>而出现了错误，经查是由于上述大括号后面跟了#号导致，根本原因是由于Nunjuck parse error 要找出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% raw %&#125;/&#123;% endraw %&#125; block</span><br></pre></td></tr></table></figure>
<p>解决方法是将上述这句去掉，或者使用一对三个</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">`</span><br></pre></td></tr></table></figure>
<p>包裹的方式而不是采用一对该符号包裹的方式进行代码高亮。</p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown学习教程收藏</title>
    <url>/2014/03/20/introduction-markdown/</url>
    <content><![CDATA[<p>  现在很多技术网站一般都支持markdown语法，当然几乎所有的轻量级博客也都是使用markdown语法来写博客的。用了一点markdown的基本语法，虽然说东西不是很多，不过觉得还是不太好记，这里就记录下来收藏的markdown相关学习网站以方便以深入学习。具体什么是markdown及简单用法就直接看一下<a href="http://zh.wikipedia.org/wiki/Markdown">Markdown维基百科</a>吧。  </p>
<span id="more"></span>
<p>以下为我在网上看到的还不错的Markdown相关网站。  </p>
<h2 id="Markdown教程"><a href="#Markdown教程" class="headerlink" title="Markdown教程"></a>Markdown教程</h2><p>1.<a href="http://notes.maxwi.com/2014/03/20/learn-mardown-in-5-minutes/">5分钟掌握Markdown常用语法:图文并茂</a><br>2.<a href="http://www.jianshu.com/p/q81RER">简书:献给写作者的 Markdown 新手指南</a><br>4.<a href="http://wowubuntu.com/markdown/">wowubuntu:Markdown语法说明</a><br>5.<a href="https://github.com/github/linguist/blob/master/lib/linguist/languages.yml">Github:Markdown语法高亮说明</a><br>6.<a href="http://daringfireball.net/projects/markdown/">Markdown详细的英文教程</a>  </p>
<h2 id="Markdown在线编辑器"><a href="#Markdown在线编辑器" class="headerlink" title="Markdown在线编辑器"></a>Markdown在线编辑器</h2><p>1.<a href="http://mahua.jser.me/">MaHua</a><br>2.<a href="https://chrome.google.com/webstore/detail/made/oknndfeeopgpibecfjljjfanledpbkog">MaDe(Chrome插件)</a><br>3.<a href="http://dillinger.io/">Dillinger</a><br>4.<a href="http://www.zybuluo.com/mdeditor">CMD</a><br>5.<a href="https://stackedit.io/">Stackedit</a>  </p>
<p>多写多练习就可以了。其中好多教程没有提到删除线，删除线直接在需要的地方前后加上<code>~~</code>即可。如下所示：<br><del>删除线效果</del>  </p>
]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
      <tags>
        <tag>markdown教程</tag>
      </tags>
  </entry>
  <entry>
    <title>如何将托管在github上的hexo博客转到gitcafe</title>
    <url>/2014/03/19/hexo-github-to-gitcafe/</url>
    <content><![CDATA[<p>github虽然非常好用，而且也已经相当成熟，但由于国内网络原因，导致访问速度很慢，还经常被墙，于是动手将其同步托管到gitcafe上，这样既可以解决国内访问慢的问题，同时也算在github上做了个备份。以下说明是建立在已经在github上搭建过基于hexo的博客，如果还没有在github上搭建或者想直接将博客托管在gitcafe上的也可以参考。关于如何github上搭建，请参考<a href="http://notes.maxwi.com/2014/02/22/first-post/">这里</a>。  </p>
<span id="more"></span>
<p><strong>gitcafe邀请注册地址:</strong><a href="http://gitcafe.com/signup?invited_by=blueyiniu">gitcafe</a>  </p>
<hr>
<ul>
<li>首先必须注意git全局变量中的user.name与user.email在两个网站的注册信息中必须都是一样的。使用以下代码设置。  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git config --global user.name &#x27;blueyi&#x27;</span><br><span class="line">git config --global user.email &#x27;blueyiniu@qq.com&#x27;</span><br></pre></td></tr></table></figure></li>
<li>参考gitcafe官网说明创建一个用户名相同的项目并初始化，本地目录任意，链接在<a href="http://blog.gitcafe.com/116.html">这里</a>  </li>
<li>进入你的hexo博客目录下面的’.deploy’目录，创建gitcafe-pages分支，并切换到该分支  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git checkout -b gitcafe-pages</span><br></pre></td></tr></table></figure></li>
<li>添加到gitcafe的远程仓库  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git remote add origin &#x27;git@gitcafe.com:yourname/yourname.git&#x27;</span><br></pre></td></tr></table></figure></li>
<li>push到gitcafe仓库(以后使用hexo g生成之后到.deploy目录执行即可)  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git push -u origin gitcafe-pages</span><br></pre></td></tr></table></figure></li>
<li><em>完成，下面根据官方以下说明绑定域名即可*</em><br>如果你想绑定 www 子域名, 你需要将此 www 子域名添加到自定义域名里, 然后在你的域名管理页面增加一条 A 记录, 将它指向 GitCafe 服务器的 IP 地址 117.79.146.98  </li>
</ul>
<p><strong>想以后直接使用<code>hexo d</code>就可以直接提交到gitcafe请修改<code>_config.yml</code></strong>  </p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">github</span></span><br><span class="line">  <span class="attr">repository:</span> <span class="string">git@gitcafe.com:yourname/yourname.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">gitcafe-pages</span></span><br></pre></td></tr></table></figure>

<p><strong>想同时同步到github请执行以下命令(注意这里的git操作需要在.deploy目录)</strong><br>首先切换git工作分支为master  </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git checkout master</span><br></pre></td></tr></table></figure>
<p>然后就直接像之前使用hexo一样即可,’hexo d’可以直接提交到github。<br>如果再想提交到gitcafe直接再切换回gitcafe-pages分支即可。可以使用以下命令查看当前工作分支。  </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git branch</span><br></pre></td></tr></table></figure>
<p>如果觉得每次提交需要输入这么多命令，可以写个复合命令别名添加到<code>.bashrc</code>文件然后在你的博客目录执行  </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">alias upblog=&#x27;cd .deploy/ &amp;&amp; git checkout gitcafe-pages &amp;&amp; git push -u origin gitcafe-pages &amp;&amp; git checkout master &amp;&amp; cd .. &amp;&amp; hexo d&#x27;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>github</tag>
        <tag>gitcafe</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>C/C++语言的二分查找法及举例</title>
    <url>/2014/03/18/bin-search/</url>
    <content><![CDATA[<p>  忘了这是在哪里看到的一个练习题，也许对于好多人来说太简单了，自己写的时候修改了很多次才满意，感觉二分查找好像就是二叉树最早的原型吧，记录之  </p>
<span id="more"></span>
<p><strong>二分搜索算法</strong><br>二分搜索算法用于针对已排序的集合进行搜索。<br>搜索结果需要满足以下要求：<br>1.如果有多个可匹配的值，则返回最大的那个索引。<br>2.如果没有找到，则返回失败的位置</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//该算法无法在匹配之后提前退出</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function">std::<span class="type">size_t</span> <span class="title">binSearch</span><span class="params">(<span class="type">const</span> std::vector&lt;T&gt; &amp;vec, <span class="type">const</span> T &amp;e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::<span class="type">size_t</span> lo = <span class="number">0</span>, hi = vec.<span class="built_in">size</span>(), mid = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (lo &lt; hi) &#123;</span><br><span class="line">        mid = (lo + hi) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        e &lt; vec[mid] ? hi = mid : lo = mid + <span class="number">1</span>;     <span class="comment">//让lo最终定位在比所需匹配元素大一个索引的位置</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> --lo;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">10</span>, <span class="number">11</span>&#125;;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Original array:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;  Num: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> v : vec) </span><br><span class="line">        std::cout &lt;&lt; v &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; std::endl &lt;&lt; <span class="string">&quot;Index: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; vec.<span class="built_in">size</span>(); ++i) </span><br><span class="line">        std::cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="type">int</span> e, res;</span><br><span class="line">    std::cout &lt;&lt; std::endl &lt;&lt; <span class="string">&quot;Enter your number: &quot;</span>; </span><br><span class="line">    <span class="keyword">while</span> (std::cin &gt;&gt; e) &#123;</span><br><span class="line">        res = <span class="built_in">binSearch</span>&lt;<span class="type">int</span>&gt;(vec, e);</span><br><span class="line">        <span class="keyword">if</span> (vec[res] == e) </span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Ok: &quot;</span> &lt;&lt; res &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;NO: &quot;</span> &lt;&lt; res &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; std::endl &lt;&lt; <span class="string">&quot;Enter your number: &quot;</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithms</category>
      </categories>
      <tags>
        <tag>CPP</tag>
        <tag>二分查找法</tag>
      </tags>
  </entry>
  <entry>
    <title>替换任意长度字符串中的两个字符为指定的一个</title>
    <url>/2014/03/18/Replace-two-character-with-one/</url>
    <content><![CDATA[<p>替换任意长度字符串中的两个字符为指定的一个字符,不知道写的对不对，就没有做太多异常判断,当做个记录吧，这里可以高亮语法，方便查看一些，这里举例只使用大写字符，如果要能处理大小写使用<code>ctype.h</code>做个判断就好。  </p>
<span id="more"></span>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX 1000</span></span><br><span class="line"><span class="type">char</span> * <span class="title function_">replace</span><span class="params">(<span class="type">char</span> * result,<span class="type">char</span> <span class="type">const</span> * source)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> input[MAX];</span><br><span class="line">	<span class="type">char</span> output[MAX];</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Enter your strings(empty line to quit!):\n&quot;</span>);</span><br><span class="line">	<span class="keyword">while</span> (fgets(input,MAX - <span class="number">1</span>,<span class="built_in">stdin</span>) != <span class="literal">NULL</span> &amp;&amp; input[<span class="number">0</span>] != <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Your string: %s\n&quot;</span>,input);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Replace str: %s\n&quot;</span>,replace(output,input));</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Enter your strings(empty line to quit!):\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span> * <span class="title function_">replace</span><span class="params">(<span class="type">char</span> * result,<span class="type">char</span> <span class="type">const</span> * source)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> * temp = result;</span><br><span class="line">	<span class="keyword">while</span> (*source != <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		*(result++) = *(source++); </span><br><span class="line">		<span class="keyword">if</span> (*source == <span class="string">&#x27;B&#x27;</span> &amp;&amp; *(source - <span class="number">1</span>) == <span class="string">&#x27;A&#x27;</span>)</span><br><span class="line">		&#123;</span><br><span class="line">		  *(result - <span class="number">1</span>) = <span class="string">&#x27;C&#x27;</span>;</span><br><span class="line">		  source++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	*result = <span class="string">&#x27;\0&#x27;</span>;	</span><br><span class="line">	<span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Algorithms</category>
      </categories>
      <tags>
        <tag>Algorithms</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo+github搭建个人博客环境及hexo配置</title>
    <url>/2014/02/22/first-post/</url>
    <content><![CDATA[<p>之所以编写本文一方面是为了练习使用这个全新的博客系统，另一方面也为记录在搭建本站时遇到的问题。虽然很多问题网上都有相关的解决的方法，但由于hexo版本的更新以及问题的修复，网上很多方法都已经不在试用，特别是默认模板由最初的light改为了landscape等一个大块代码的更新导致网上的好多修改方法都不再试用。这里有些地方也没有做到完整请谅解，如果有更好的方法，记得提醒我哈。我只是对linux及嵌入式和互联网感兴趣，没有学过任何一门的网页语言，所以问题及解决方法的拙劣之处还请谅解。<br>有时候折腾的时候遇到问题一直解决不了很想放弃，总是中放弃之后又不甘心，又来重试，如此反复，直到解决完问题后心里非常舒服，感觉如释重负一般，其实有时候回过头来一看，或者让身边人一看也许他会觉得-那么长时间就整个这？这其中的感觉恐怕很多时候只有自己才会理解了！  </p>
<span id="more"></span>

<h2 id="什么是hexo"><a href="#什么是hexo" class="headerlink" title="什么是hexo"></a>什么是hexo</h2><p>Hexo 是一款基于node 的静态博客网站生成器<br>作者 ：tommy351是一个台湾的在校大学生。。。<br>相比其他的静态网页生成器而言有着，生成静态网页最快，插件丰富（已经移植了大量Octopress插件）。同其他很多轻量级博客如jekyll、octopress、jekyllbootstrap等一样，也是<br>使用Markdown语法进行编辑博文，关于Markdown不用怕，推荐搜索维基上面的语法示例，有中文版本<a href="http://zh.wikipedia.org/wiki/Markdown">http://zh.wikipedia.org/wiki/Markdown</a>，只需要会非常简单的常用语法就可以了。关于以上这些轻量仍博客系统哪一个更好，各有各的优缺点，其中jekyll是它们的基础，不过配置要麻烦一些。octopress的中文资料好像是最全的，不过generate速度太慢了点。</p>
<p><strong>hexo的github主页地址：</strong><br><a href="https://github.com/tommy351/hexo">https://github.com/tommy351/hexo</a><br><strong>hexo的官方文档首页：</strong><br><a href="http://zespia.tw/hexo/docs/index.html">http://zespia.tw/hexo/docs/index.html</a>  </p>
<hr>
<h2 id="什么是github"><a href="#什么是github" class="headerlink" title="什么是github"></a>什么是github</h2><p><img data-src="/images/github-logo.png" alt="github-logo"><br><strong>github官方网站：</strong><a href="https://github.com">https://github.com</a><br><strong>github官方帮助网站：</strong><a href="https://help.github.com/">https://help.github.com/</a><br>    当然官方帮助文档都是英文，不过配合词典应该也都不是问题，如果看了官方后依然是一头雾水，觉得挺复杂，那暂时可以先不管，就把它理解为基于git版本控制的代码仓库就可以了。关于git是什么可以自行<a href="http://www.google.com">google</a>,如果暂时先不想看那就把它理解为一个分布式版本控制/软件配置管理软件，也就是一个控制代码版本的，就当成github是在线版本的吧。<br><strong>git官方文档:</strong><a href="http://git-scm.com/documentation">http://git-scm.com/documentation</a><br><strong>git常用命令：</strong>请点击<a href="">git常用命令记录</a>  </p>
<hr>
<h2 id="搭建过程如下："><a href="#搭建过程如下：" class="headerlink" title="搭建过程如下："></a>搭建过程如下：</h2><h3 id="注册github"><a href="#注册github" class="headerlink" title="注册github"></a>注册github</h3><p>注册github账号并验证邮箱,登录后了解主页面各选项基本内容<br>这里需要特别注意的是邮箱一定要验证通过，点击github首页右上角设置图标如截图所示，Email(will be public)以及Emails栏目下的邮箱都不能有“！”号出现，不然你等一下就算建立了github pages也是无法打开的，会显示404错误。<br><img data-src="/images/20140225/01.png" alt="git注册1">  </p>
<hr>
<h3 id="创建repository"><a href="#创建repository" class="headerlink" title="创建repository"></a>创建repository</h3><p>创建repository,并填写你的个人信息以创建你自己的github pages<br>这是需要特别注意的就是Repository name必须是您的usename(也就是你可以用于登录github官网的名字)或者是你建立的组织的名字。否则你建立的仓库是不能作为pages被github解析的。其他选项默认即可，这里是github pages的官方链接<a href="http://pages.github.com/">http://pages.github.com/</a>，可以自行查看一下说明。<br><img data-src="/images/20140225/02.png" alt="repository">  </p>
<hr>
<h3 id="ubuntu上安装本地环境"><a href="#ubuntu上安装本地环境" class="headerlink" title="ubuntu上安装本地环境"></a>ubuntu上安装本地环境</h3><p> hexo 依赖于<code>Node.js</code>和<code>Git</code>所以下面分别开始安装这两个软件  </p>
<h4 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h4><p>ubuntu安装git直接apt-get就可以了  </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo apt-get install git-core</span>  </span><br></pre></td></tr></table></figure>
<h4 id="安装Node-js"><a href="#安装Node-js" class="headerlink" title="安装Node.js"></a>安装Node.js</h4><p>hexo官方推荐的安装方法是使用nvm，这里我们也使用nvm进行安装，当然你也可以使用直接安装，不过貌似nvm安装之后会直接在个人目录下产生<code>.nvm</code>目录并且通过<code>.bashrc</code>或者<code>.bash_profile</code>进行开机加载，然后其他的nvm操作都会保存在&gt;.nvm目录，这样方便以后升级或者重装系统，相当于绿色软件了。<br>nvm的github主页<a href="https://github.com/creationix/nvm">https://github.com/creationix/nvm</a><br>安装nvm可以使用以下两个命令中的任意一个都可以<br>cURL:  </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">curl https://raw.github.com/creationix/nvm/master/install.sh | sh</span>  </span><br></pre></td></tr></table></figure>
<p>或者Wget:  </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"> wget -qO- https://raw.github.com/creationix/nvm/master/install.sh | sh</span></span><br></pre></td></tr></table></figure>
<p>等待nvm安装完成之后重新启动你的终端然后运行以下命令安装Node.js  </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">nvm install 0.10</span> </span><br></pre></td></tr></table></figure>
<p>我这里安装的node.js版本是0.10.26可用使用<code>nvm ls</code>命令查看<br>至此本地环境安装完成</p>
<hr>
<h3 id="安装并初始化Hexo"><a href="#安装并初始化Hexo" class="headerlink" title="安装并初始化Hexo"></a>安装并初始化Hexo</h3><p>使用npm命令安装hexo  </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">npm install -g hexo</span></span><br></pre></td></tr></table></figure>
<p>这里有两点需要提醒一下：  </p>
<ul>
<li>1、如果提示command not found，请检查是否已经重新启动终端或者使用<code>nvm ls</code>检查当前使用的node.js的版本，如果没有则使用以下命令来使用刚安装的版本。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">nvm use 0.10.26</span>  </span><br></pre></td></tr></table></figure>
<p>或者使用以下命令直接设置全局的默认node.js版本  </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">nvm <span class="built_in">alias</span> default 0.10.26</span>  </span><br></pre></td></tr></table></figure>
<ul>
<li>2、如果npm  安装hexo是速度太慢，或者包安装失败，应该是您的网络无法连接到官方服务器，或者是GFW的问题，请使用以下方法更改npm镜像源:  </li>
</ul>
<p>1.通过config命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">npm config <span class="built_in">set</span> registry http://registry.cnpmjs.org</span>  </span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">npm info underscore (如果上面配置成功，使用这个命令会有以下提示)</span>  </span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">npm http GET http://registry.cnpmjs.org/underscore</span>  </span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">npm http 200 http://registry.cnpmjs.org/underscore</span>  </span><br></pre></td></tr></table></figure>
<p>2.命令行指定  </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">npm --registry http://registry.cnpmjs.org info underscore</span>  </span><br></pre></td></tr></table></figure>
<p>3.编辑 ~/.npmrc 加入以下内容可以使配置永久生效，就不用每次npm安装时都要运行指定源命令了  </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">registry = http://registry.cnpmjs.org</span>  </span><br></pre></td></tr></table></figure>
<p>使用以下命令对hexo进行初始化（这里我位于<del>目录，而且我想把我的个人博客放在</del>/hexo目录，需要放在其他目录直接改一下自己需要的目录就可以了）  </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">hexo init hexo</span>  </span><br></pre></td></tr></table></figure>
<p>现在本地版本的hexo已经配置完成了，可以使用以下命令来生成静态文件  </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">hexo generate</span>  </span><br></pre></td></tr></table></figure>
<p>或者  </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">hexo g</span>  </span><br></pre></td></tr></table></figure>
<p>使用以下命令启动本地服务器进行预览  </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">hexo server</span>  </span><br></pre></td></tr></table></figure>
<p>或者  </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">hexo s</span>  </span><br></pre></td></tr></table></figure>
<p>然后通过<a href="http://localhost:4000/">http://localhost:4000/</a>进行访问，如果页面正常打开，那么恭喜你，你的本地博客已经搭建完成，还差一点点就可以进行发布了。  </p>
<hr>
<h3 id="配置git并发布"><a href="#配置git并发布" class="headerlink" title="配置git并发布"></a>配置git并发布</h3><p>配置git并发布基于hexo和github的个人博客<br>首先编辑你hexo安装目录下的<code>_config.yml</code>文件，找到以下内容并修改为github</p>
<blockquote>
<p>deploy:<br>   type: github<br>   repository: <a href="https://github.com/username/username.github.io.git">https://github.com/username/username.github.io.git</a><br>   branch: master  </p>
</blockquote>
<p>运行以下命令设置你的git全局变量,即设置你的用户名和邮箱  </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git config --global user.name <span class="string">&quot;Your Name Here&quot;</span></span>  </span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git config --global user.email <span class="string">&quot;your_email@example.com&quot;</span></span></span><br></pre></td></tr></table></figure>
<p>好了，现在已经可以使用以下命令将你的博客发布到github上了，当然需要根据提示输入你的用户名和密码  </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">hexo deploy</span>  </span><br></pre></td></tr></table></figure>
<p>或者   </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">hexo d</span>  </span><br></pre></td></tr></table></figure>
<p>记得每次运行hexo deploy之前先运行hexo generate生成你本地博客的最新版本<br>如果需要将博客页面中的个人信息修改成你自己的信息，请编辑并认真查看~/hexo目录下的<code>_config.yml</code>文件，强烈推荐多查看官方帮助文档中的说明。关于主题的修改及配置，还有添加其他RSS插件、多说插件等，请参见其他文章。<br><strong>* 关于绑定个人域名 *</strong> </p>
<p>github在这方面非常方便，直接在source目录下创建CNAME文件，内容为你需要绑定的域名，例如本博客就是<a href="http://notes.maxwi.com">notes.maxwi.com</a>，然后在你的域名管理处添加一项CNAME记录，记录值为你的github page的地址，例如：<code>username.github.io.</code>然后重新<code>hexo g</code>和<code>hexo d</code>即可，根据github官方说明大概需要10分钟生效。如果你需要绑定的是一级域名需要创建一个A记录，记录值为<code>207.97.227.245</code>   </p>
<p><strong>至此你在github上的个人博客就搭建完成了，如果有任何问题请留言或者查询本博客的其它博文说明。</strong>   </p>
<h2 id="常见问题记录"><a href="#常见问题记录" class="headerlink" title="常见问题记录"></a>常见问题记录</h2><p><strong>1、为什么我的hexo上的文章目录一闪而过</strong><br>这个问题找了好久才发现，刚开始以为是因为文件头部没有<code>toc: ture</code>引起的，后来添加上了，问题依然有，经过无数次尝试才发现是因为这些文章里面的标题都是从三级标题开始的。所以要想让标题显示正常至少应该从二级标题开始，也就是要有<code>##</code>。这应该是pacman主题的一个bug吧。</p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>ubuntu</tag>
      </tags>
  </entry>
</search>
