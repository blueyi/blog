<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/avatar.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/avatar.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/avatar.png">
  <link rel="mask-icon" href="/images/avatar.png" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"notes.maxwi.com","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":true,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="本文不会像其他笔记那样详细讲解每一个步骤和问题，最近太忙，没有太多时间，突击学习一下，记录下遇到的一些问题，但依然会像其他笔记一样授之以渔。仅针对C++，OpenCV2，假如你没学习过官方提供详细支持的编程语言，例如C&#x2F;C++&#x2F;python，建议还是先学一门编程语言再来学习OpenCV吧。看到网上有教程竟然讲OpenCV时还讲起了C语言。强烈推荐参考官方手册，官方的doc简直太棒了：http:&#x2F;&#x2F;">
<meta property="og:type" content="article">
<meta property="og:title" content="OpenCV学习小记">
<meta property="og:url" content="http://notes.maxwi.com/2016/12/06/opencv-study-notes/index.html">
<meta property="og:site_name" content="blueyi&#39;s notes">
<meta property="og:description" content="本文不会像其他笔记那样详细讲解每一个步骤和问题，最近太忙，没有太多时间，突击学习一下，记录下遇到的一些问题，但依然会像其他笔记一样授之以渔。仅针对C++，OpenCV2，假如你没学习过官方提供详细支持的编程语言，例如C&#x2F;C++&#x2F;python，建议还是先学一门编程语言再来学习OpenCV吧。看到网上有教程竟然讲OpenCV时还讲起了C语言。强烈推荐参考官方手册，官方的doc简直太棒了：http:&#x2F;&#x2F;">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://notes.maxwi.com/2016/12/06/opencv-study-notes/mask-filter2D.png">
<meta property="article:published_time" content="2016-12-06T13:47:16.000Z">
<meta property="article:modified_time" content="2016-12-06T13:47:16.000Z">
<meta property="article:author" content="blueyi">
<meta property="article:tag" content="OpenCV">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://notes.maxwi.com/2016/12/06/opencv-study-notes/mask-filter2D.png">

<link rel="canonical" href="http://notes.maxwi.com/2016/12/06/opencv-study-notes/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>OpenCV学习小记 | blueyi's notes</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="blueyi's notes" type="application/atom+xml">
<link rel="alternate" href="/rss2.xml" title="blueyi's notes" type="application/rss+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">blueyi's notes</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Follow Excellence,Success will chase you!</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://notes.maxwi.com/2016/12/06/opencv-study-notes/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/default_avatar.jpg">
      <meta itemprop="name" content="blueyi">
      <meta itemprop="description" content="心怀善意，虛怀若谷！">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="blueyi's notes">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          OpenCV学习小记
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2016-12-06 21:47:16" itemprop="dateCreated datePublished" datetime="2016-12-06T21:47:16+08:00">2016-12-06</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/OpenCV/" itemprop="url" rel="index"><span itemprop="name">OpenCV</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>28k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>25 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>本文不会像其他笔记那样详细讲解每一个步骤和问题，最近太忙，没有太多时间，突击学习一下，记录下遇到的一些问题，但依然会像其他笔记一样授之以渔。仅针对C++，OpenCV2，假如你没学习过官方提供详细支持的编程语言，例如C/C++/python，建议还是先学一门编程语言再来学习OpenCV吧。看到网上有教程竟然讲OpenCV时还讲起了C语言。<br>强烈推荐参考官方手册，官方的doc简直太棒了：<a target="_blank" rel="noopener" href="http://opencv.org/documentation.html">http://opencv.org/documentation.html</a>，即能下载PDF，又能在线查看，还有详细的tutorial，以下多数问题的解决来源于查看官方的Reference Manual：<a target="_blank" rel="noopener" href="http://docs.opencv.org/2.4/opencv2refman.pdf">http://docs.opencv.org/2.4/opencv2refman.pdf</a></p>
<span id="more"></span>

<h2 id="关于环境配置"><a href="#关于环境配置" class="headerlink" title="关于环境配置"></a>关于环境配置</h2><p>环境配置参见这里<a href="/2016/12/05/opencv-windows-env/" title="Windows下OpenCV与VS开发环境配置">Windows下OpenCV与VS开发环境配置</a></p>
<h2 id="一些入门常用函数"><a href="#一些入门常用函数" class="headerlink" title="一些入门常用函数"></a>一些入门常用函数</h2><p>2.图像操作及用户界面的几个函数原型及作用（highgui.hpp）：<br><strong>imread：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Mat <span class="title">imread</span><span class="params">(<span class="type">const</span> string&amp; filename, <span class="type">int</span> flags=<span class="number">1</span> )</span></span></span><br></pre></td></tr></table></figure>
<p>用于从文件filename读取图像并在内存中存储为Mat类型，flags用于指宝载入图像使用的色彩类型，如rgb、灰度等</p>
<p><strong>imshow：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">imshow</span><span class="params">(<span class="type">const</span> string&amp; winname, InputArray mat)</span></span></span><br></pre></td></tr></table></figure>
<p>在指定的窗口中显示图像mat，由winname指定窗口名称（即窗口标题），如果没有使用namedWindow创建窗口，则新建一个。InputArray类型是一个接口类，可以是Mat、Mat_<T>、Mat_&lt;T, m, n&gt;、vector<T>、vector&lt;vector<T>&gt;、vector<Mat>类型</p>
<p><strong>imwrite：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">imwrite</span><span class="params">(<span class="type">const</span> string&amp; filename, InputArray img, <span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; params=vector&lt;<span class="type">int</span>&gt;() )</span></span></span><br></pre></td></tr></table></figure>
<p>将图像img保存于指定的文件filname中，最后一个参数于用指定保存的图片格式，如jPEG、PNG等，当不指定最后一个参数时，函数会自动根据finlname中的文件后缀来确定存储格式</p>
<p><strong>createTrackbar：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">createTrackbar</span><span class="params">(<span class="type">const</span> string&amp; trackbarname, <span class="type">const</span> string&amp; winname, <span class="type">int</span>* value, <span class="type">int</span> count, TrackbarCallback onChange=<span class="number">0</span>, <span class="type">void</span>* userdata=<span class="number">0</span>)</span></span></span><br></pre></td></tr></table></figure>
<p>创建一个名为trackbarname的滑动条，并将其依附到指定的名为winname的窗口上。第三个参数value用于指定滑动指针的位置，需要是个整型指针变量（因为这个变量会在调节滑动条是发生变化，所以需要是个指针变量）；第四个参数count就用来指定滑动条最大可以滑动到多少，例如int value = 50,count = 100，则表示程序运行时滑动指针指向50的位置，最大可以滑动的位置是100。第五个可选参数onChange是一个形如<code>void Foo(int,void*);</code>的回调函数，即当滑动条的value变化时就调用该函数，该回调函数中的第一个参数是滑动条的当前值，即value，第二个参数与createTrackbar的最后一个参数userdata一样，可用于在不使用全局变量的情况下向回调函数传递数据来处理滑动条事件，暂时没有使用过。官方提供的一个使用示例在：opencv_source_code/samples/cpp/connected_components.cpp<br>注意：该函数创建的滑动条在窗口的顶端，水平放置，且无法改变，如果想改变它的位置，可以通过Qt的GUI来实现</p>
<p><strong>getTrackbarPos：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">getTrackbarPos</span><span class="params">(<span class="type">const</span> string&amp; trackbarname, <span class="type">const</span> string&amp; winname)</span></span></span><br></pre></td></tr></table></figure>
<p>返回滑动条的当前位置，其实也就是上面那个函数的value的当前值。</p>
<p><strong>moveWindow</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">moveWindow</span><span class="params">(<span class="type">const</span> string&amp; winname, <span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br></pre></td></tr></table></figure>
<p>移动名为winname的窗口</p>
<p><strong>destroyWindow：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">destroyWindow</span><span class="params">(<span class="type">const</span> string&amp; winname)</span></span></span><br></pre></td></tr></table></figure>
<p>销毁给定名称的窗体，释放内存</p>
<p><strong>destroyAllWindows：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">destroyAllWindows</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
<p>销毁所有打开着的HighGUI窗体，并释放内存<br>这两个函数在小程序时可以省略，因为程序结束运行时会自动被操作系统回收。但对于大程序，应该手动去释放不需要的窗体内存，特别是需要长期运行的程序，以防止内存泄露。</p>
<p><strong>waitKey：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">waitKey</span><span class="params">(<span class="type">int</span> delay=<span class="number">0</span>)</span></span></span><br></pre></td></tr></table></figure>
<p>等待按键按下，当延时delay毫秒后依然没有按下，停止等待。如果delay为0或负数时表示一直等待，直到键被按下并返回键值，如果delay时间结束时依然没有键被按下返回-1，该函数可用于函数窗口被关闭，类似C中的getchar()</p>
<p><strong>如何使imshow的显示窗口能够调整大小？</strong><br>对于高分辨率的图像，很容易显示太大，导致不方便查看，其实只需要在调用imshow之前使用namedWindow创建一个WINDOW_NORMAL的窗体即可，该窗体（官方称为placeholder）可用于放image和trackbar，如果已经有了一个同名的窗体，则该函数调用什么也不干。如果在调用imshow之前已经创建了一个同名window，则imshow会将显示内容置于该window中，如果没有，则imshow会默认创建一个参数为WINDOW_AUTOSIZE的窗体，结合上面的其他图像存取函数举例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/core/core.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/highgui/highgui.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"></span><br><span class="line">Mat img;</span><br><span class="line"></span><br><span class="line"><span class="comment">//滑动条的回调函数，用于根据滑动条的当前值修改窗口大小</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">resizeWin</span><span class="params">(<span class="type">int</span> size, <span class="type">void</span>*)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">resizeWindow</span>(<span class="string">&quot;rCat&quot;</span>, size, size);   <span class="comment">//将名为rCat的窗口的宽和高都调整为size的值</span></span><br><span class="line">    <span class="built_in">imshow</span>(<span class="string">&quot;rCat&quot;</span>, img);   <span class="comment">//在名为rCat的窗口中显示img中的图像</span></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">getTrackbarPos</span>(<span class="string">&quot;TrackBar&quot;</span>, <span class="string">&quot;rCat&quot;</span>) &lt;&lt; std::endl;   <span class="comment">//输出名为rCat窗口中的TrackBar滑动条指针所指向的当前值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> winSize = <span class="number">80</span>;  <span class="comment">//定义滑动条指针变量及初始值</span></span><br><span class="line">    img = <span class="built_in">imread</span>(<span class="string">&quot;F:\\cat.jpg&quot;</span>, <span class="number">2</span> | <span class="number">4</span>);  <span class="comment">//cat.jpg是一张高清图像</span></span><br><span class="line">    <span class="keyword">if</span>(img.<span class="built_in">empty</span>())                      <span class="comment">//确保图像打开成功</span></span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt;  <span class="string">&quot;Could not open or find the image&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">namedWindow</span>(<span class="string">&quot;Cat&quot;</span>, WINDOW_NORMAL);  <span class="comment">//创建一个名为Cat的窗体，窗口模式设置为NORMAL</span></span><br><span class="line">    <span class="built_in">imshow</span>(<span class="string">&quot;Cat&quot;</span>, img); <span class="comment">//已经有了名为Cat的窗体，imshow将直接在其中显示img的内容，且是普通窗体，所以imshow显示的内容可以通过鼠标调整大小</span></span><br><span class="line"> </span><br><span class="line">    <span class="built_in">namedWindow</span>(<span class="string">&quot;rCat&quot;</span>, WINDOW_NORMAL);  <span class="comment">//再创建一个名为rCat的窗体，窗口模式设置为NORMAL</span></span><br><span class="line">    <span class="built_in">createTrackbar</span>(<span class="string">&quot;TrackBar&quot;</span>, <span class="string">&quot;rCat&quot;</span>, &amp;winSize, <span class="number">1024</span>, resizeWin);  <span class="comment">//在名为rCat的窗口上创建一个名为TrackBar的滑动条，滑动条的初始大小为</span></span><br><span class="line">                                                                    <span class="comment">//为winSize的初始值80，最大值为1024，当winSize改变时，调用回调函数resizeWin</span></span><br><span class="line">    <span class="built_in">resizeWin</span>(winSize, <span class="number">0</span>);  <span class="comment">//回调函数显示结果，如果没有这句，将在程序刚启动时窗口不显示任何内容，但调节滑动条之后就会有了，因为回调函数中设置了显示函数</span></span><br><span class="line">    <span class="built_in">imwrite</span>(<span class="string">&quot;hcat-copy.png&quot;</span>, img);  <span class="comment">//将img中的图像内容写入文件hcat-copy.png，存储格式为png</span></span><br><span class="line">    <span class="built_in">waitKey</span>(<span class="number">0</span>);  <span class="comment">//等待键被按下</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>播放一个视频</strong><br>播放视频其实就是读取视频中一帧帧的图像，并将其显示出来，同时将处理后的视频保存，直接看代码吧：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">cv::VideoCapture <span class="title">vcap</span><span class="params">(<span class="string">&quot;F:\\bunny.avi&quot;</span>)</span></span>;  <span class="comment">//创建一个视频对象，可以来源于视频、图像序列或像机</span></span><br><span class="line"><span class="comment">//    cv::VideoCapture vcap(0);  //表示从默认相机创建一个视频对象vcap</span></span><br><span class="line">    <span class="keyword">if</span> (!vcap.<span class="built_in">isOpened</span>()) &#123; <span class="comment">//确定文件正常打开</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Video or camera open failed!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">        cv::VideoWriter outputVideo;</span><br><span class="line">        <span class="type">int</span> ex = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(vcap.<span class="built_in">get</span>(CV_CAP_PROP_FOURCC));     <span class="comment">// Get Codec Type- Int form</span></span><br><span class="line">        cv::Size S = cv::<span class="built_in">Size</span>((<span class="type">int</span>)vcap.<span class="built_in">get</span>(CV_CAP_PROP_FRAME_WIDTH),    <span class="comment">// Acquire input size</span></span><br><span class="line">        (<span class="type">int</span>)vcap.<span class="built_in">get</span>(CV_CAP_PROP_FRAME_HEIGHT));</span><br><span class="line">        outputVideo.<span class="built_in">open</span>(<span class="string">&quot;F:\\bunny_edge.avi&quot;</span>, ex, vcap.<span class="built_in">get</span>(CV_CAP_PROP_FPS), S, <span class="literal">false</span>);</span><br><span class="line">    cv::Mat edges;  <span class="comment">//创建一个Mat对象存储图像</span></span><br><span class="line">    cv::<span class="built_in">namedWindow</span>(<span class="string">&quot;Edges&quot;</span>, <span class="number">1</span>);  <span class="comment">//创建一个名为Edges的窗口</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        cv::Mat frame;</span><br><span class="line">        vcap &gt;&gt; frame;   <span class="comment">//将视频中的一帧读入到frame中</span></span><br><span class="line">        cv::<span class="built_in">cvtColor</span>(frame, edges, CV_BGR2GRAY);  <span class="comment">//调用灰度化函数处理图像，并存储到edges中</span></span><br><span class="line">        cv::<span class="built_in">GaussianBlur</span>(edges, edges, cv::<span class="built_in">Size</span>(<span class="number">7</span>, <span class="number">7</span>), <span class="number">1.5</span>, <span class="number">1.5</span>);  <span class="comment">//调用高斯模糊函数处理edges中的图像信息</span></span><br><span class="line">        cv::<span class="built_in">Canny</span>(edges, edges, <span class="number">0</span>, <span class="number">30</span>, <span class="number">3</span>);  <span class="comment">//调用边缘检测函数来处理edges中图像</span></span><br><span class="line">                cv::<span class="built_in">imshow</span>(<span class="string">&quot;Edges&quot;</span>, edges);  <span class="comment">//将edges中的图像显示到名为Edges的窗口中</span></span><br><span class="line">                outputVideo &lt;&lt; edges;</span><br><span class="line">        <span class="keyword">if</span> (cv::<span class="built_in">waitKey</span>(<span class="number">30</span>) &gt;= <span class="number">0</span>) <span class="keyword">break</span>;  <span class="comment">//延迟30秒后进行一下一帧图像的处理</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>D:\opencv\sources\samples</code>目录下有很多好玩的实例</p>
<h2 id="核心模块"><a href="#核心模块" class="headerlink" title="核心模块"></a>核心模块</h2><p>库的使用，基本的像素操作方法</p>
<h3 id="常用的数据类型和函数"><a href="#常用的数据类型和函数" class="headerlink" title="常用的数据类型和函数"></a>常用的数据类型和函数</h3><p>OpenCV中的所有数据类型可以在这里查看：<a target="_blank" rel="noopener" href="http://docs.opencv.org/2.4.13/modules/core/doc/core.html">http://docs.opencv.org/2.4.13/modules/core/doc/core.html</a><br>1.Mat是Opencv中非常重要的数据类型，它是个很复杂的类型，即可以用于操作二维的图像方阵，又可以作为普通的矩阵类来使用，并且具有自动管理内存的功能，通过上面将视频数据写入到Mat类对象可以看出它应该是被重载了很多的操作符的。所以实际上可以通过一个VideoCapture对象对它进行<code>&gt;&gt;</code>操作，也可以通过cout对它<code>&lt;&lt;</code>操作。<br>Mat类共有24个构造函数，可见其功能的丰富程度，下面几个常用的构造方式：<br><strong>直接构造</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Mat <span class="title">img</span><span class="params">(<span class="number">300</span>, <span class="number">400</span>, CV_8UC3, Scalar(<span class="number">122</span>, <span class="number">33</span>, <span class="number">104</span>))</span></span>;  <span class="comment">//构造一个300行400列的Mat对象</span></span><br><span class="line">    <span class="built_in">imshow</span>(<span class="string">&quot;Picture&quot;</span>, img);</span><br><span class="line"></span><br><span class="line">    <span class="function">Mat <span class="title">img1</span><span class="params">(<span class="number">3</span>, <span class="number">4</span>, CV_8UC3, Scalar(<span class="number">122</span>, <span class="number">33</span>, <span class="number">104</span>))</span></span>;</span><br><span class="line">    std::cout &lt;&lt; img1 &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">destroyWindow</span>(<span class="string">&quot;Picture&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Mat img1(3, 4, CV_8UC3, Scalar(122, 33, 104));</code><br>表示构造一个名为img1的二维矩阵对象，该对象由3行4列的Scalar对象构成，可以把这里的Scalar当成是一个vector，其中的三个值分别对应BGR的三个值122,33,104。这三个值构成的颜色刚好是VS2013的LOG颜色。上面第三个参数CV_8UC3是定义好的宏，用于指定RGB的存储属性，意义分别是CV_[The number of bits per item][Signed or Unsigned][Type Prefix]C[The channel number]，例子中的意思就是每个像素点使用3通道的8位无符号数字表示（由后面的Scalar来填充）。所以上面的程序运行会输出一个高300像素，宽400像素VS2013的LOGO颜色的纯色框。并且会在命令行中输出3行4列的122,33,104：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[122, 33, 104, 122, 33, 104, 122, 33, 104, 122, 33, 104;</span><br><span class="line">  122, 33, 104, 122, 33, 104, 122, 33, 104, 122, 33, 104;</span><br><span class="line">  122, 33, 104, 122, 33, 104, 122, 33, 104, 122, 33, 104]</span><br></pre></td></tr></table></figure>

<p>虽然Mat也可以构造为多维的矩阵，但由于imshow和<code>&lt;&lt;</code>运算符只能用于2维或2维以下的Mat对象，所以这里不做解释，可以自行查看这里<a target="_blank" rel="noopener" href="http://docs.opencv.org/3.0-last-rst/doc/tutorials/core/mat_the_basic_image_container/mat_the_basic_image_container.html#matthebasicimagecontainer">http://docs.opencv.org/3.0-last-rst/doc/tutorials/core/mat_the_basic_image_container/mat_the_basic_image_container.html#matthebasicimagecontainer</a></p>
<p>2.通过randu可以使用随机颜色填充Mat对象：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Mat img = <span class="built_in">Mat</span>(<span class="number">300</span>, <span class="number">400</span>, CV_8UC3);</span><br><span class="line"><span class="built_in">randu</span>(img, Scalar::<span class="built_in">all</span>(<span class="number">0</span>), Scalar::<span class="built_in">all</span>(<span class="number">255</span>));  <span class="comment">//表示填充值从0到255</span></span><br><span class="line"><span class="built_in">imshow</span>(<span class="string">&quot;Picture&quot;</span>, img);</span><br></pre></td></tr></table></figure>

<p><strong>通过create函数构造</strong><br>3.可以通过调用create(nrows, ncols, type)来进行构造指定size和类型的Mat对象：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Mat <span class="title">M</span><span class="params">(<span class="number">7</span>, <span class="number">7</span>, CV_32FC2, Scalar(<span class="number">1</span>, <span class="number">3</span>))</span></span>;  <span class="comment">//创建一个7x7的矩阵</span></span><br><span class="line">M.<span class="built_in">create</span>(<span class="number">100</span>, <span class="number">50</span>, <span class="built_in">CV8UC</span>(<span class="number">15</span>));  <span class="comment">//改变其大小和类型，源矩阵会被释放</span></span><br><span class="line">Mat N;</span><br><span class="line">N.<span class="built_in">create</span>(M.<span class="built_in">size</span>(), M.<span class="built_in">type</span>());  <span class="comment">//将N改变为与M一样的大小和类型</span></span><br></pre></td></tr></table></figure>

<p><strong>创建一个多维矩阵</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个100x100x100的8-bit矩阵</span></span><br><span class="line"><span class="type">int</span> sz[] = &#123;<span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>&#125;; </span><br><span class="line"><span class="function">Mat <span class="title">cube</span><span class="params">(<span class="number">3</span>, sz, CV_8U, Scalar::all(<span class="number">0</span>))</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>通过copy函数从一个Mat对象的指定行或列构造另一个对象</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// add the 5-th row, multiplied by 3 to the 3rd row</span></span><br><span class="line">M.<span class="built_in">row</span>(<span class="number">3</span>) = M.<span class="built_in">row</span>(<span class="number">3</span>) + M.<span class="built_in">row</span>(<span class="number">5</span>)*<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// now copy the 7-th column to the 1-st column</span></span><br><span class="line"><span class="comment">// M.col(1) = M.col(7); // this will not work</span></span><br><span class="line">Mat M1 = M.<span class="built_in">col</span>(<span class="number">1</span>);</span><br><span class="line">M.<span class="built_in">col</span>(<span class="number">7</span>).<span class="built_in">copyTo</span>(M1);</span><br><span class="line"></span><br><span class="line"><span class="comment">// create a new 320x240 image</span></span><br><span class="line"><span class="function">Mat <span class="title">img</span><span class="params">(Size(<span class="number">320</span>,<span class="number">240</span>),CV_8UC3)</span></span>;</span><br><span class="line"><span class="comment">// select a ROI</span></span><br><span class="line"><span class="function">Mat <span class="title">roi</span><span class="params">(img, Rect(<span class="number">10</span>,<span class="number">10</span>,<span class="number">100</span>,<span class="number">100</span>))</span></span>;</span><br><span class="line"><span class="comment">// fill the ROI with (0,255,0) (which is green in RGB space);</span></span><br><span class="line"><span class="comment">// the original 320x240 image will be modified</span></span><br><span class="line">roi = <span class="built_in">Scalar</span>(<span class="number">0</span>,<span class="number">255</span>,<span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p><strong>通过数组创建</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//两种情况</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">process_video_frame</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span>* pixels,</span></span></span><br><span class="line"><span class="params"><span class="function">                         <span class="type">int</span> width, <span class="type">int</span> height, <span class="type">int</span> step)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Mat <span class="title">img</span><span class="params">(height, width, CV_8UC3, pixels, step)</span></span>;</span><br><span class="line">    <span class="built_in">GaussianBlur</span>(img, img, <span class="built_in">Size</span>(<span class="number">7</span>,<span class="number">7</span>), <span class="number">1.5</span>, <span class="number">1.5</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//另一种情况</span></span><br><span class="line"><span class="type">double</span> m[<span class="number">3</span>][<span class="number">3</span>] = &#123;&#123;a, b, c&#125;, &#123;d, e, f&#125;, &#123;g, h, i&#125;&#125;;</span><br><span class="line">Mat M = <span class="built_in">Mat</span>(<span class="number">3</span>, <span class="number">3</span>, CV_64F, m).<span class="built_in">inv</span>();</span><br></pre></td></tr></table></figure>

<p><strong>通过一个逗号分隔的初始化列表创建</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// create a 3x3 double-precision identity matrix</span></span><br><span class="line">Mat M = (<span class="built_in">Mat_</span>&lt;<span class="type">double</span>&gt;(<span class="number">3</span>,<span class="number">3</span>) &lt;&lt; <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, </span><br><span class="line">                  <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, </span><br><span class="line">                  <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p><strong>MATLAB风格的zeros(),ones(), eye()函数来初始化</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// create a double-precision identity martix and add it to M.</span></span><br><span class="line">M += Mat::<span class="built_in">eye</span>(M.rows, M.cols, CV_64F);</span><br></pre></td></tr></table></figure>

<p>3.opencv内建了多种Mat对象的输出格式，还内建了其他一些支持<code>&lt;&lt;</code>输出的数据类型，官方下面这个例子很全，可以运行查看效果：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  For description look into the help() function. */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;opencv2/core/core.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">help</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout</span><br><span class="line">        &lt;&lt; <span class="string">&quot;\n--------------------------------------------------------------------------&quot;</span> &lt;&lt; std::endl</span><br><span class="line">        &lt;&lt; <span class="string">&quot;This program shows how to create matrices(cv::Mat) in OpenCV and its serial&quot;</span></span><br><span class="line">        &lt;&lt; <span class="string">&quot; out capabilities&quot;</span> &lt;&lt; std::endl</span><br><span class="line">        &lt;&lt; <span class="string">&quot;That is, cv::Mat M(...); M.create and std::cout &lt;&lt; M. &quot;</span> &lt;&lt; std::endl</span><br><span class="line">        &lt;&lt; <span class="string">&quot;Shows how output can be formated to OpenCV, python, numpy, csv and C styles.&quot;</span> &lt;&lt; std::endl</span><br><span class="line">        &lt;&lt; <span class="string">&quot;Usage:&quot;</span> &lt;&lt; std::endl</span><br><span class="line">        &lt;&lt; <span class="string">&quot;./cvout_sample&quot;</span> &lt;&lt; std::endl</span><br><span class="line">        &lt;&lt; <span class="string">&quot;--------------------------------------------------------------------------&quot;</span> &lt;&lt; std::endl</span><br><span class="line">        &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span>, <span class="type">char</span>**)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">help</span>();</span><br><span class="line">    <span class="comment">// create by using the constructor</span></span><br><span class="line">    <span class="function">Mat <span class="title">M</span><span class="params">(<span class="number">2</span>, <span class="number">2</span>, CV_8UC3, Scalar(<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>))</span></span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;M = &quot;</span> &lt;&lt; std::endl &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; M &lt;&lt; std::endl &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// create by using the create function()</span></span><br><span class="line">    M.<span class="built_in">create</span>(<span class="number">4</span>, <span class="number">4</span>, <span class="built_in">CV_8UC</span>(<span class="number">2</span>));</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;M = &quot;</span> &lt;&lt; std::endl &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; M &lt;&lt; std::endl &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// create multidimensional matrices</span></span><br><span class="line">    <span class="type">int</span> sz[<span class="number">3</span>] = &#123; <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span> &#125;;</span><br><span class="line">    <span class="function">Mat <span class="title">L</span><span class="params">(<span class="number">3</span>, sz, CV_8UC(<span class="number">1</span>), Scalar::all(<span class="number">0</span>))</span></span>;</span><br><span class="line">    <span class="comment">// Cannot print via operator &lt;&lt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create using MATLAB style eye, ones or zero matrix</span></span><br><span class="line">    Mat E = Mat::<span class="built_in">eye</span>(<span class="number">4</span>, <span class="number">4</span>, CV_64F);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;E = &quot;</span> &lt;&lt; std::endl &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; E &lt;&lt; std::endl &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    Mat O = Mat::<span class="built_in">ones</span>(<span class="number">2</span>, <span class="number">2</span>, CV_32F);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;O = &quot;</span> &lt;&lt; std::endl &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; O &lt;&lt; std::endl &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    Mat Z = Mat::<span class="built_in">zeros</span>(<span class="number">3</span>, <span class="number">3</span>, CV_8UC1);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Z = &quot;</span> &lt;&lt; std::endl &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; Z &lt;&lt; std::endl &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// create a 3x3 double-precision identity matrix</span></span><br><span class="line">    Mat C = (<span class="built_in">Mat_</span>&lt;<span class="type">double</span>&gt;(<span class="number">3</span>, <span class="number">3</span>) &lt;&lt; <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">5</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;C = &quot;</span> &lt;&lt; std::endl &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; C &lt;&lt; std::endl &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    Mat RowClone = C.<span class="built_in">row</span>(<span class="number">1</span>).<span class="built_in">clone</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;RowClone = &quot;</span> &lt;&lt; std::endl &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; RowClone &lt;&lt; std::endl &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Fill a matrix with random values</span></span><br><span class="line">    Mat R = <span class="built_in">Mat</span>(<span class="number">3</span>, <span class="number">2</span>, CV_8UC3);</span><br><span class="line">    <span class="built_in">randu</span>(R, Scalar::<span class="built_in">all</span>(<span class="number">0</span>), Scalar::<span class="built_in">all</span>(<span class="number">255</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Demonstrate the output formating options</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;R (default) = &quot;</span> &lt;&lt; std::endl &lt;&lt; R &lt;&lt; std::endl &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;R (python)  = &quot;</span> &lt;&lt; std::endl &lt;&lt; format(R, <span class="string">&quot;python&quot;</span>) &lt;&lt; std::endl &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;R (numpy)   = &quot;</span> &lt;&lt; std::endl &lt;&lt; format(R, <span class="string">&quot;numpy&quot;</span>) &lt;&lt; std::endl &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;R (csv)     = &quot;</span> &lt;&lt; std::endl &lt;&lt; format(R, <span class="string">&quot;csv&quot;</span>) &lt;&lt; std::endl &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;R (c)       = &quot;</span> &lt;&lt; std::endl &lt;&lt; format(R, <span class="string">&quot;c&quot;</span>) &lt;&lt; std::endl &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="function">Point2f <span class="title">P</span><span class="params">(<span class="number">5</span>, <span class="number">1</span>)</span></span>;  <span class="comment">//2维点，每一维度由float类型表示</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Point (2D) = &quot;</span> &lt;&lt; P &lt;&lt; std::endl &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="function">Point3f <span class="title">P3f</span><span class="params">(<span class="number">2</span>, <span class="number">6</span>, <span class="number">7</span>)</span></span>;  <span class="comment">//3维点</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Point (3D) = &quot;</span> &lt;&lt; P3f &lt;&lt; std::endl &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">float</span>&gt; v;</span><br><span class="line">    v.<span class="built_in">push_back</span>((<span class="type">float</span>)CV_PI);   v.<span class="built_in">push_back</span>(<span class="number">2</span>);    v.<span class="built_in">push_back</span>(<span class="number">3.01f</span>);</span><br><span class="line">  <span class="comment">//下面使用一个包含3个元素的vector构造Mat对象并输出</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Vector of floats via Mat = &quot;</span> &lt;&lt; <span class="built_in">Mat</span>(v) &lt;&lt; std::endl &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//输出以二维点为元素的vector</span></span><br><span class="line">    <span class="function">vector&lt;Point2f&gt; <span class="title">vPoints</span><span class="params">(<span class="number">20</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; vPoints.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        vPoints[i] = <span class="built_in">Point2f</span>((<span class="type">float</span>)(i * <span class="number">5</span>), (<span class="type">float</span>)(i % <span class="number">7</span>));</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;A vector of 2D Points = &quot;</span> &lt;&lt; vPoints &lt;&lt; std::endl &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4.Point类用于表示点，<code>Point_&lt;int&gt;</code>、<code>Point2i</code>、<code>Point</code>三个一样都表示以int为基础元素类型的点，而<code>Point_&lt;float&gt;</code>和<code>Point2f</code>表示以float为基础数据类型的二维上的点：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Point <span class="title">p</span><span class="params">(<span class="number">3</span>, <span class="number">4</span>)</span></span>;</span><br><span class="line"><span class="function">Point2f <span class="title">pf</span><span class="params">(<span class="number">3.14</span>, <span class="number">4.13</span>)</span></span>;</span><br><span class="line">p.x = <span class="number">5</span>;</span><br><span class="line">p.y = <span class="number">6</span>;</span><br></pre></td></tr></table></figure>

<p>5.Scalar类可用于表示颜色，它是一个含有4个元素的vector，当用于表示RGB时最后一个元素可以省略，RGB在Scalar中的顺序实际是BGR，即三个元素分量分别对应蓝、绿、红。与.NET中的颜色表示一样。上面的例子中已经使用过了</p>
<p>6.尺寸类Size，有2个参数分别可用于表示二维矩阵的宽、高尺寸，同样具有Size2d，表示以double为基础数据类型，感觉跟Point很像，源码定义也确实在一起。：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Size <span class="title">si</span><span class="params">(<span class="number">3</span>, <span class="number">4</span>)</span></span>;</span><br><span class="line"><span class="function">Size2d <span class="title">sd</span><span class="params">(<span class="number">3.14</span>, <span class="number">4.13</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p>7.矩形类Rect，Rect类有4个成员变量用于表示一个矩形的起点坐标(x, y)和尺寸(width, height)，还包括了一些很有用的成员函数，如rec.size()返回Size、area()返回面积、contains(Point)判断点是否在矩形内、inside(Rect)判断另一个矩形是否在该矩形内、tl()返回左上角点坐标、br()返回右下角点坐标。<br>还被重载了一些非常有用的操作符：</p>
<ul>
<li>rect = rect + point  //平移矩形</li>
<li>rect = rect - point</li>
<li>rect = rect + size  //缩放矩形</li>
<li>rect = rect - size</li>
<li>rect += point, rect -= point, rect += size, rect -= size (简化版操作符)</li>
<li>rect = rect1 &amp; rect2 求2个矩形的交集</li>
<li>rect = rect1 | rect2 返回包含两个矩形的最小矩形</li>
<li>rect &amp;= rect1, rect |= rect1  //简化版操作符</li>
<li>rect == rect1, rect != rect1 比较两个矩形</li>
</ul>
<p>8.颜色空间转换函数cvtColor()，前面已经用过它来转RGB到灰度图。它还可以实现HSV、HSI等色彩模式的转换，函数原型为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">cvtColor</span><span class="params">(InputArray src, OutputArray dst, <span class="type">int</span> code, <span class="type">int</span> dstCn=<span class="number">0</span>)</span></span></span><br></pre></td></tr></table></figure>
<p>第三个参数是颜色空间转换标识符、第四个参数为目标图像的通道数，0表示取源图像的通道数。</p>
<h3 id="图像表示"><a href="#图像表示" class="headerlink" title="图像表示"></a>图像表示</h3><p>1.opencv中的Mat图像以二维矩阵的形式存储，为了效率，有时候会将整个图像在内存中以连续的一行存储，可以通过Mat的成员函数isContinuous()为判断是否为连接存储，如果是，则所有数据在内存中将只以一行的形式存储。<br>内存中像素在每行中的存储与通道数相关，例如如果是3通道8位无符号，则每个像素应由3个8位无符号组成，即每行中的数字列数实际应该为图像像素列数乘以3。<br>Mat的一些成员变量或函数：</p>
<ul>
<li>mat.rows 获取总行数，即图片以像素为单位的高度</li>
<li>mat.cols 获取总列数，即图片以像素为单位的宽度</li>
<li>mat.channels() 获取图像的通道数</li>
<li>mat.data 获取图像矩阵的第一行且为第一列的指针，如果返回为空，则表示输入的图像有问题，可以用来判断输入图像是否生效</li>
<li>mat.ptr<uchar>(i) 获取图像第i行的uchar类型的元素指针</li>
<li>mat.clone()  返回对象副本</li>
</ul>
<p>Mat类实现由两部分数据组成：矩阵头（包含矩阵尺寸、存储方法、存储地址等信息）和一个指向存储所有像素值的矩阵的指针。Mat的拷贝构造函数只是拷贝Mat对象的信息头和矩阵指针，而不复制矩阵本身，因为矩阵本身存储的数量量太大。当需要Mat副本时，应该使得cone函数获得副本。</p>
<p><strong>2.缩减像素数</strong><br>图像当以8位来表示一个单通道的像素点时，可以有2^8=256种色彩值，为了提高处理效率，实际上不需要那么丰富的色彩。此时可以将图像映射为较少色彩值的图像，一般的映射方法为，如果以10为一个颜色值步长的话，可以将0-9全部用0来表示，10-19用10来表示，20-29用20来表示，依次类推。这个步长越大，图像中的颜色值将越少。<br>可以利用除法的自动截余特性来方便的实现，例如原的来颜色值为old，新值<code>new = (old / step ) * step</code>，step为颜色值的跨度步长。然后遍历所有像素，全部这样转换一遍就获得了缩减之后的图像，转换后由于色彩较少，会有点水彩画的感觉。<br>但为了提高效率，由于8位一共也就256个值，可以提前建个表，然后当需要转换时从这个表里面读即可，例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> step = <span class="number">10</span>;</span><br><span class="line">uchar table[<span class="number">256</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">256</span>; ++i)</span><br><span class="line">  table[i] = (i / step) * step;</span><br></pre></td></tr></table></figure>
<p>这样table里面将是一个缩减后的表，1-9的位置都是0，10-19的位置都是1，依次。。。<br>当我有个数字26想知道转换后的值是多少时，直接读table[26]的值即可，这样就不用所有图像的每个像素都要进行一次计算了。</p>
<p>而opencv中提供了一个名为LUT的函数，可以直接根据表来实现将一个Mat对象转换为缩减后的Mat对象的功能<br>LUT的函数原型为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">cv::LUT</span><span class="params">( cv::InputArray src, cv::InputArray lut, cv::OutputArray dst)</span></span>;</span><br></pre></td></tr></table></figure>
<p>下面分别使用普通方式和LUT方式实现图像缩减，推荐使用LUT函数，效率更高</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">scanImageAndReduce</span><span class="params">(Mat &amp;src, uchar *tab)</span></span>;  <span class="comment">//手动进行缩减</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Mat img = <span class="built_in">imread</span>(<span class="string">&quot;F:\\cat.jpg&quot;</span>);</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> divideWidth = <span class="number">60</span>;  <span class="comment">//设定缩减位宽</span></span><br><span class="line">    uchar table[<span class="number">256</span>];  <span class="comment">//用于创建一个缩减后的表，以后的颜色取值可以直接从这个表里面取</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">256</span>; ++i) &#123;</span><br><span class="line">        table[i] = (uchar)divideWidth * (i / divideWidth);  <span class="comment">//利用除法的截余特性，即(61/60)*60=1，而(59/60)*60=0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Mat img_reduce;  <span class="comment">//用于存放缩减后的图像</span></span><br><span class="line">    <span class="function">Mat <span class="title">lookUpTable</span><span class="params">(<span class="number">1</span>, <span class="number">256</span>, CV_8U)</span></span>;  <span class="comment">//创建一个1行，256列的Mat对象，其中每个像素用1个通道的8位无符号类型表示</span></span><br><span class="line"></span><br><span class="line">    uchar *p = lookUpTable.<span class="built_in">ptr</span>();   <span class="comment">//将原来的table复制到lookUpTable中</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">256</span>; ++i)</span><br><span class="line">        p[i] = table[i];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">LUT</span>(img, lookUpTable, img_reduce);  <span class="comment">//LUT函数用于将源图像img，按表lookUpTable转换为缩减后的图像img_reduce</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">imshow</span>(<span class="string">&quot;Original image&quot;</span>, img);</span><br><span class="line">    <span class="built_in">imshow</span>(<span class="string">&quot;Reduced image by LUT&quot;</span>, img_reduce);  <span class="comment">//显示用LUT缩减后的图像</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//LUT函数实现的功能与如下函数类似</span></span><br><span class="line">    Mat img_reduce2 = img.<span class="built_in">clone</span>();  <span class="comment">//复制源图像</span></span><br><span class="line">    <span class="built_in">scanImageAndReduce</span>(img_reduce2, table);</span><br><span class="line">    <span class="built_in">imshow</span>(<span class="string">&quot;Reduced image by manual&quot;</span>, img_reduce2);  <span class="comment">//显示手动缩减后的图像</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">scanImageAndReduce</span><span class="params">(Mat &amp;src, uchar *tab)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> channel = src.<span class="built_in">channels</span>();  <span class="comment">//获取源图像的通道数</span></span><br><span class="line">    <span class="type">int</span> nRow = src.rows;  <span class="comment">//获取源图像的行数和列数，即图像的实际像素高和宽</span></span><br><span class="line">    <span class="type">int</span> nCol = src.cols * channel;  <span class="comment">//通道数乘以图像的列数即为矩阵中每行的总元素数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (src.<span class="built_in">isContinuous</span>()) &#123;   <span class="comment">//判断图像是否为连续存储的，即所有元素是否都在一行上，为遍历估准备</span></span><br><span class="line">        nCol *= nRow;</span><br><span class="line">        nRow = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    uchar *p;  //用于存放从Mat对象中获取的行指针</span></span><br><span class="line"><span class="comment">    for (int i = 0; i &lt; nRow; ++i) &#123;</span></span><br><span class="line"><span class="comment">        p = src.ptr&lt;uchar&gt;(i);</span></span><br><span class="line"><span class="comment">        for (int j = 0; j &lt; nCol; ++j)   //遍历各列数值，并将其替换为tab表中指定的值</span></span><br><span class="line"><span class="comment">            p[j] = tab[p[j]];</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//或者直接使用Mat对象的data，data会返回指向矩阵的第一行、第一列的指针。</span></span><br><span class="line">    <span class="comment">//如果该指针为空，则表示输入对象无效</span></span><br><span class="line">    uchar *p2 = src.data;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nCol * nRow; ++i)</span><br><span class="line">        *p2++ = tab[*p2];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>3.统计时间的两个函数，当然C++自带的也可以，举例说明：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> t = <span class="built_in">getTickCount</span>();  <span class="comment">//获取当前CPU走过的时钟周期数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// some method</span></span><br><span class="line"></span><br><span class="line"><span class="type">double</span> time0 = ((<span class="type">double</span>)<span class="built_in">getTickCount</span>() - t) / <span class="built_in">getTickFrequency</span>();  <span class="comment">//两个时间周期数之差再除以一秒钟CPU所走的时钟周期数，得到时差</span></span><br><span class="line">std::cout &lt;&lt; time0 * <span class="number">1000</span> &lt;&lt; <span class="string">&quot; ms&quot;</span> &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>

<p><strong>根据每个像素的邻居像素值来修改当前像素实现锐化</strong><br>原理如下图：<br><img data-src="mask-filter2D.png" alt=""></p>
<p>官方示例代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/core/core.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/highgui/highgui.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/imgproc/imgproc.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"></span><br><span class="line"><span class="comment">//手动增加掩膜的锐化函数，其实就是将图像中的每一个像素根据他的邻居像素值来进行计算，从而得到一个新的像素</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Sharpen</span><span class="params">(<span class="type">const</span> Mat&amp; myImage, Mat&amp; Result)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* filename = <span class="string">&quot;F:\\cat.jpg&quot;</span>;</span><br><span class="line"></span><br><span class="line">    Mat I, J, K;  <span class="comment">//创建三个Mat对象，I用于存储源图像，J用于存储手动处理的图像，K存储通过内置函数filter2D处理的图像</span></span><br><span class="line"></span><br><span class="line">    I = <span class="built_in">imread</span>(filename);</span><br><span class="line">    <span class="keyword">if</span> (!I.data) &#123;  <span class="comment">//确保图像载入成功</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Error load image&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">namedWindow</span>(<span class="string">&quot;Input&quot;</span>, WINDOW_AUTOSIZE);</span><br><span class="line">    <span class="built_in">namedWindow</span>(<span class="string">&quot;Output by Sharpen&quot;</span>, WINDOW_AUTOSIZE);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">imshow</span>(<span class="string">&quot;Input&quot;</span>, I);</span><br><span class="line">    <span class="type">double</span> t = (<span class="type">double</span>)<span class="built_in">getTickCount</span>();  <span class="comment">//通过2次计时来看看手动写的函数跟使用内置的filter2D哪个速度更快</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">Sharpen</span>(I, J);</span><br><span class="line"></span><br><span class="line">    t = ((<span class="type">double</span>)<span class="built_in">getTickCount</span>() - t) / <span class="built_in">getTickFrequency</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Hand written function times passed in seconds: &quot;</span> &lt;&lt; t &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">imshow</span>(<span class="string">&quot;Output by Sharpen&quot;</span>, J);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过Mat_构造函数来从一个逗号分隔的数字创建一个3x3的Mat对象</span></span><br><span class="line">    Mat kern = (<span class="built_in">Mat_</span>&lt;<span class="type">char</span>&gt;(<span class="number">3</span>, <span class="number">3</span>) &lt;&lt; <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>,    </span><br><span class="line">                                    <span class="number">-1</span>, <span class="number">5</span>, <span class="number">-1</span>,</span><br><span class="line">                                    <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    t = (<span class="type">double</span>)<span class="built_in">getTickCount</span>();</span><br><span class="line">    <span class="built_in">filter2D</span>(I, K, I.<span class="built_in">depth</span>(), kern);  <span class="comment">//调用filter2D，将I中的每个像素与kern相乘，并将结果存放在K中</span></span><br><span class="line">    t = ((<span class="type">double</span>)<span class="built_in">getTickCount</span>() - t) / <span class="built_in">getTickFrequency</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Built-in filter2D time passed in seconds:      &quot;</span> &lt;&lt; t &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">namedWindow</span>(<span class="string">&quot;Output by fliter2D&quot;</span>, WINDOW_AUTOSIZE);</span><br><span class="line">    <span class="built_in">imshow</span>(<span class="string">&quot;Output by fliter2D&quot;</span>, K);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Sharpen</span><span class="params">(<span class="type">const</span> Mat&amp; myImage, Mat&amp; Result)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">CV_Assert</span>(myImage.<span class="built_in">depth</span>() == CV_8U);  <span class="comment">// accept only uchar images</span></span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> nChannels = myImage.<span class="built_in">channels</span>();  <span class="comment">//读取通道数</span></span><br><span class="line">    Result.<span class="built_in">create</span>(myImage.<span class="built_in">size</span>(), myImage.<span class="built_in">type</span>());  <span class="comment">//通过Mat的create将Result调整与源图像同样大小的类型</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; myImage.rows - <span class="number">1</span>; ++j)    <span class="comment">//对除了边缘行和列之外的所有像素进行处理</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">const</span> uchar* previous = myImage.<span class="built_in">ptr</span>&lt;uchar&gt;(j - <span class="number">1</span>);  <span class="comment">//源图像的当前行的上一行</span></span><br><span class="line">        <span class="type">const</span> uchar* current = myImage.<span class="built_in">ptr</span>&lt;uchar&gt;(j);</span><br><span class="line">        <span class="type">const</span> uchar* next = myImage.<span class="built_in">ptr</span>&lt;uchar&gt;(j + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        uchar* output = Result.<span class="built_in">ptr</span>&lt;uchar&gt;(j);  <span class="comment">//指向结果图像的当前行</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = nChannels; i &lt; nChannels*(myImage.cols - <span class="number">1</span>); ++i)  <span class="comment">//修改当前行中的每一列，注意多通道时需要通过channel来定位邻居像素位置</span></span><br><span class="line">        &#123;</span><br><span class="line">            *output++ = <span class="built_in">saturate_cast</span>&lt;uchar&gt;(<span class="number">5</span> * current[i]</span><br><span class="line">                - current[i - nChannels] - current[i + nChannels] - previous[i] - next[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置边缘像素为黑色</span></span><br><span class="line">    Result.<span class="built_in">row</span>(<span class="number">0</span>).<span class="built_in">setTo</span>(<span class="built_in">Scalar</span>(<span class="number">0</span>));</span><br><span class="line">    Result.<span class="built_in">row</span>(Result.rows - <span class="number">1</span>).<span class="built_in">setTo</span>(<span class="built_in">Scalar</span>(<span class="number">0</span>));</span><br><span class="line">    Result.<span class="built_in">col</span>(<span class="number">0</span>).<span class="built_in">setTo</span>(<span class="built_in">Scalar</span>(<span class="number">0</span>));</span><br><span class="line">    Result.<span class="built_in">col</span>(Result.cols - <span class="number">1</span>).<span class="built_in">setTo</span>(<span class="built_in">Scalar</span>(<span class="number">0</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过上面的运行结果，明显内建函数速度要快很多</p>
<p>其中<code>int Mat::depth() cont</code>返回对象的位深度，例如16-bit signed的图像返回的就是CV_16S。所有位深度的对应信息如下：</p>
<ul>
<li>CV_8U - 8-bit unsigned integers ( 0..255 )</li>
<li>CV_8S - 8-bit signed integers ( -128..127 )</li>
<li>CV_16U - 16-bit unsigned integers ( 0..65535 )</li>
<li>CV_16S - 16-bit signed integers ( -32768..32767 )</li>
<li>CV_32S - 32-bit signed integers ( -2147483648..2147483647 )</li>
<li>CV_32F - 32-bit floating-point numbers ( -FLT_MAX..FLT_MAX, INF, NAN )</li>
<li>CV_64F - 64-bit floating-point numbers ( -DBL_MAX..DBL_MAX, INF, NAN )</li>
</ul>
<p><strong>4.读写感兴趣区域ROI</strong><br>ROI也即是Region of interest，即针对一副图像中的感兴趣区域进行操作。<br>由于Mat对象的拷贝构造函数实际上拷贝的是指针，所以可以很方便地从源图像获取感兴趣获取的矩阵到新的Mat对象，而该新的Mat对象实际上关联的是源图像的像素矩阵。有2种方法获取ROI区域，其实就是Mat的两个构造函数：<br>原型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Mat::<span class="built_in">Mat</span>(<span class="type">const</span> Mat&amp; m, <span class="type">const</span> Range&amp; rowRange, <span class="type">const</span> Range&amp; colRange=Range::<span class="built_in">all</span>() )</span><br><span class="line">Mat::<span class="built_in">Mat</span>(<span class="type">const</span> Mat&amp; m, <span class="type">const</span> Rect&amp; roi)</span><br></pre></td></tr></table></figure>

<p>举例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Mat srcImg;  <span class="comment">//认为源图像srcImg已经载入了图像</span></span><br><span class="line"></span><br><span class="line">Mat imgROI = <span class="built_in">srcImg</span>(<span class="built_in">Rect</span>(<span class="number">100</span>, <span class="number">80</span>, ncols, nrows));  <span class="comment">//ROI区域为以(80, 100)为起点的ncols x nrows大小的矩阵</span></span><br><span class="line"></span><br><span class="line">Mat imgROI2 = <span class="built_in">srcImg</span>(<span class="built_in">Range</span>(<span class="number">100</span>, <span class="number">100</span> + nrows), <span class="built_in">Range</span>(<span class="number">80</span>, <span class="number">80</span> + ncols));  <span class="comment">//通过提供行和列的范围来指定</span></span><br></pre></td></tr></table></figure>

<p>使用举例，通过copyTo()函数将一个图像拷贝到另一个图像，copyTo()有一个重载可以附加一个mask来实现隐现效果：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/core/core.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/highgui/highgui.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* srcFileName = <span class="string">&quot;F:\\cat.jpg&quot;</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* logoFileName = <span class="string">&quot;F:\\mini.jpg&quot;</span>;</span><br><span class="line"></span><br><span class="line">    Mat srcImg = <span class="built_in">imread</span>(srcFileName);</span><br><span class="line">    Mat logoImg = <span class="built_in">imread</span>(logoFileName);  </span><br><span class="line">    <span class="keyword">if</span> (!srcImg.data || !logoImg.data)    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;File load error \n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建感兴趣区域，实现上像素矩阵依然是srcImg中的像素值</span></span><br><span class="line">    Mat roiImg = <span class="built_in">srcImg</span>(<span class="built_in">Rect</span>(srcImg.rows / <span class="number">2</span>, srcImg.cols / <span class="number">2</span>, logoImg.cols, logoImg.rows));  </span><br><span class="line"></span><br><span class="line">    <span class="comment">//copyTo的第二个可选参数mask必须为CV_8U类型的图像，并非只能是单通道的灰度图</span></span><br><span class="line">    logoImg.<span class="built_in">copyTo</span>(roiImg, logoImg);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">imshow</span>(<span class="string">&quot;ROI mask picture&quot;</span>, srcImg);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>5.addWeighted线性混合两张图像</strong><br>官方示例：<a target="_blank" rel="noopener" href="http://docs.opencv.org/3.0-last-rst/doc/tutorials/core/adding_images/adding_images.html">http://docs.opencv.org/3.0-last-rst/doc/tutorials/core/adding_images/adding_images.html</a><br>split()和merge()函数可以实现通道的与合并 </p>
<p><strong>6.调整图像对比度与亮度</strong><br>可以用如下方法初始化一个新Mat对象的所有像素内存为0：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Mat new_image = Mat::<span class="built_in">zeros</span>( image.<span class="built_in">size</span>(), image.<span class="built_in">type</span>() );  <span class="comment">//image为源图像</span></span><br></pre></td></tr></table></figure>

<p>官方示例：<a target="_blank" rel="noopener" href="http://docs.opencv.org/3.0-last-rst/doc/tutorials/core/basic_linear_transform/basic_linear_transform.html">http://docs.opencv.org/3.0-last-rst/doc/tutorials/core/basic_linear_transform/basic_linear_transform.html</a><br>注意其中访问每个像素用的语法：<code>new_image.at&lt;Vec3b&gt;(y, x)[c]</code>，其中y是行，x是列，Vec3b就是一个含有3个uchar的vector：<code>typedef Vec&lt;uchar, 3&gt; Vec3b</code>，c表示R、G或B，取值0、1或2。<br>opencv内建了<code>saturate_cast&lt;type&gt;(value)</code>将value强制转换为有效的type类型的值</p>
<p><strong>7.离散傅里叶变换DFT</strong><br>DFT即Discrete Fourier Transform，该变换在图像处理中的应用可以做到图像增强与图像去噪、图像分割中的边缘检测、图像特征提取以及图像压缩等。<br>OpenCV中提供了dft()函数，可以对一维或二维浮点数数组进行正向或反向离散傅里叶变换，可以用于计算两个二维实矩阵的卷积。<br><a target="_blank" rel="noopener" href="http://docs.opencv.org/3.0-last-rst/doc/tutorials/core/discrete_fourier_transform/discrete_fourier_transform.html">http://docs.opencv.org/3.0-last-rst/doc/tutorials/core/discrete_fourier_transform/discrete_fourier_transform.html</a></p>
<p><strong>8.OpenCV内建对xml和yaml的解析</strong><br>还是官方文档：<br><a target="_blank" rel="noopener" href="http://docs.opencv.org/3.0-last-rst/doc/tutorials/core/file_input_output_with_xml_yml/file_input_output_with_xml_yml.html">http://docs.opencv.org/3.0-last-rst/doc/tutorials/core/file_input_output_with_xml_yml/file_input_output_with_xml_yml.html</a><br><a target="_blank" rel="noopener" href="http://docs.opencv.org/2.4.13/modules/core/doc/xml_yaml_persistence.html">http://docs.opencv.org/2.4.13/modules/core/doc/xml_yaml_persistence.html</a></p>
<p><strong>9.内建多种图形绘制</strong><br><a target="_blank" rel="noopener" href="http://docs.opencv.org/3.0-last-rst/doc/tutorials/core/basic_geometric_drawing/basic_geometric_drawing.html">http://docs.opencv.org/3.0-last-rst/doc/tutorials/core/basic_geometric_drawing/basic_geometric_drawing.html</a><br><strong>直线函数line</strong><br>函数原型如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">line</span><span class="params">(Mat&amp; img, Point pt1, Point pt2, <span class="type">const</span> Scalar&amp; color, <span class="type">int</span> thickness=<span class="number">1</span>, <span class="type">int</span> lineType=<span class="number">8</span>, <span class="type">int</span> shift=<span class="number">0</span>)</span></span></span><br></pre></td></tr></table></figure>
<p>thickness就是线宽，lineType就是线的结构，8表示当斜线时两个像素角相连就认为其已经相连了，如果是4则是两个像素有一整条边相连时才算相连。<br>画箭头可以用<code>arrowedLine</code></p>
<p><strong>圆circle</strong><br>函数原型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">circle</span><span class="params">(Mat&amp; img, Point center, <span class="type">int</span> radius, <span class="type">const</span> Scalar&amp; color, <span class="type">int</span> thickness=<span class="number">1</span>, <span class="type">int</span> lineType=<span class="number">8</span>, <span class="type">int</span> shift=<span class="number">0</span>)</span></span></span><br></pre></td></tr></table></figure>

<p><strong>椭圆函数elipse</strong><br>函数原型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ellipse</span><span class="params">(Mat&amp; img, Point center, Size axes, <span class="type">double</span> angle, <span class="type">double</span> startAngle, <span class="type">double</span> endAngle, <span class="type">const</span> Scalar&amp; color, <span class="type">int</span> thickness=<span class="number">1</span>, <span class="type">int</span> lineType=<span class="number">8</span>, <span class="type">int</span> shift=<span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ellipse</span><span class="params">(Mat&amp; img, <span class="type">const</span> RotatedRect&amp; box, <span class="type">const</span> Scalar&amp; color, <span class="type">int</span> thickness=<span class="number">1</span>, <span class="type">int</span> line- Type=<span class="number">8</span>)</span></span></span><br></pre></td></tr></table></figure>

<p><strong>矩形函数rectangle</strong><br>函数原型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">rectangle</span><span class="params">(Mat&amp; img, Point pt1, Point pt2, <span class="type">const</span> Scalar&amp; color, <span class="type">int</span> thickness=<span class="number">1</span>, <span class="type">int</span> lineType=<span class="number">8</span>, <span class="type">int</span> shift=<span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">rectangle</span><span class="params">(Mat&amp; img, Rect rec, <span class="type">const</span> Scalar&amp; color, <span class="type">int</span> thickness=<span class="number">1</span>, <span class="type">int</span> lineType=<span class="number">8</span>, <span class="type">int</span> shift=<span class="number">0</span>)</span></span></span><br></pre></td></tr></table></figure>
<p>画填充的多边形用fillPoly</p>
<p>举例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/core.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/highgui.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> backWidth = <span class="number">400</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//定义一个基本图像作为绘图背景</span></span><br><span class="line">    Mat backImg = Mat::<span class="built_in">zeros</span>(backWidth, backWidth, CV_8UC3);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设定所绘线的宽度和类型</span></span><br><span class="line">    <span class="type">int</span> thickness = <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> lineType = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> radius = <span class="number">100</span>;  <span class="comment">//圆半径</span></span><br><span class="line">    Point start = <span class="built_in">Point</span>(backWidth / <span class="number">2</span> - radius, backWidth / <span class="number">2</span> - radius); <span class="comment">//矩形起点</span></span><br><span class="line">    Point end = <span class="built_in">Point</span>(backWidth / <span class="number">2</span> + radius, backWidth / <span class="number">2</span> + radius); <span class="comment">//矩形终点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//画矩形</span></span><br><span class="line">    <span class="built_in">rectangle</span>(backImg, start, end, <span class="built_in">Scalar</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>), thickness, lineType);</span><br><span class="line">    <span class="comment">//画内接圆</span></span><br><span class="line">    <span class="built_in">circle</span>(backImg, <span class="built_in">Point</span>(backWidth / <span class="number">2</span>, backWidth / <span class="number">2</span>), radius, <span class="built_in">Scalar</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>), thickness);</span><br><span class="line">    <span class="comment">//画两条直径</span></span><br><span class="line">    <span class="built_in">line</span>(backImg, start + <span class="built_in">Point</span>(<span class="number">0</span>, radius), end - <span class="built_in">Point</span>(<span class="number">0</span>, radius), <span class="built_in">Scalar</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>), thickness);</span><br><span class="line">    <span class="built_in">line</span>(backImg, start + <span class="built_in">Point</span>(radius, <span class="number">0</span>), end - <span class="built_in">Point</span>(radius, <span class="number">0</span>), <span class="built_in">Scalar</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>), thickness);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">imshow</span>(<span class="string">&quot;Draw&quot;</span>, backImg);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>RNG可以实现产生随机数，putText将窗口中显示文字</strong><br><a target="_blank" rel="noopener" href="http://docs.opencv.org/3.0-last-rst/doc/tutorials/core/random_generator_and_text/random_generator_and_text.html">http://docs.opencv.org/3.0-last-rst/doc/tutorials/core/random_generator_and_text/random_generator_and_text.html</a><br>RNG就是个随机数生成器类，与C++11中的随机数生成器类类似，下面给出这个比较常用的RNG::uniform函数的原型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">RNG::uniform</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">RNG::uniform</span><span class="params">(<span class="type">float</span> a, <span class="type">float</span> b)</span></span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">RNG::uniform</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> b)</span></span></span><br></pre></td></tr></table></figure>

<p><strong>putText显示文字</strong><br>原型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">putText</span><span class="params">(Mat&amp; img, <span class="type">const</span> string&amp; text, Point org, <span class="type">int</span> fontFace, <span class="type">double</span> fontScale, Scalar color, <span class="type">int</span> thickness=<span class="number">1</span>, <span class="type">int</span> lineType=<span class="number">8</span>, <span class="type">bool</span> bottomLeftOrigin=<span class="literal">false</span> )</span></span></span><br></pre></td></tr></table></figure>
<p>getTextSize可以返回字符串的大小：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Size <span class="title">getTextSize</span><span class="params">(<span class="type">const</span> string&amp; text, <span class="type">int</span> fontFace, <span class="type">double</span> fontScale, <span class="type">int</span> thickness, <span class="type">int</span>* baseLine)</span></span></span><br></pre></td></tr></table></figure>

<p>举例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将上例中的图像线条变成彩色并显示文字</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/core.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;opencv2/highgui.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> backWidth = <span class="number">400</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回随机的颜色</span></span><br><span class="line"><span class="function"><span class="type">static</span> Scalar <span class="title">randomColor</span><span class="params">(RNG&amp; rng)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> icolor = (<span class="type">unsigned</span>)rng;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Scalar</span>(icolor &amp; <span class="number">255</span>, (icolor &gt;&gt; <span class="number">8</span>) &amp; <span class="number">255</span>, (icolor &gt;&gt; <span class="number">16</span>) &amp; <span class="number">255</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//定义一个基本图像作为绘图背景</span></span><br><span class="line">    Mat backImg = Mat::<span class="built_in">zeros</span>(backWidth, backWidth, CV_8UC3);</span><br><span class="line"></span><br><span class="line">    <span class="function">RNG <span class="title">rng</span><span class="params">(<span class="number">0xFFFFFFFF</span>)</span></span>;  <span class="comment">//创建一个RNG对象</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//设定所绘线的宽度和类型</span></span><br><span class="line">    <span class="type">int</span> thickness = <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> lineType = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> radius = <span class="number">100</span>;  <span class="comment">//圆半径</span></span><br><span class="line">    Point start = <span class="built_in">Point</span>(backWidth / <span class="number">2</span> - radius, backWidth / <span class="number">2</span> - radius); <span class="comment">//矩形起点</span></span><br><span class="line">    Point end = <span class="built_in">Point</span>(backWidth / <span class="number">2</span> + radius, backWidth / <span class="number">2</span> + radius); <span class="comment">//矩形终点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//画矩形</span></span><br><span class="line">    <span class="built_in">rectangle</span>(backImg, start, end, <span class="built_in">randomColor</span>(rng), thickness, lineType);</span><br><span class="line">    <span class="comment">//画内接圆</span></span><br><span class="line">    <span class="built_in">circle</span>(backImg, <span class="built_in">Point</span>(backWidth / <span class="number">2</span>, backWidth / <span class="number">2</span>), radius, <span class="built_in">randomColor</span>(rng), thickness);</span><br><span class="line">    <span class="comment">//画两条直径</span></span><br><span class="line">    <span class="built_in">line</span>(backImg, start + <span class="built_in">Point</span>(<span class="number">0</span>, radius), end - <span class="built_in">Point</span>(<span class="number">0</span>, radius), <span class="built_in">randomColor</span>(rng), thickness);</span><br><span class="line">    <span class="built_in">line</span>(backImg, start + <span class="built_in">Point</span>(radius, <span class="number">0</span>), end - <span class="built_in">Point</span>(radius, <span class="number">0</span>), <span class="built_in">randomColor</span>(rng), thickness);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义随机文字的位置</span></span><br><span class="line">    Point org;</span><br><span class="line">    org.x = rng.<span class="built_in">uniform</span>(<span class="number">10</span>, backWidth / <span class="number">2</span>);</span><br><span class="line">    org.y = rng.<span class="built_in">uniform</span>(backWidth / <span class="number">2</span>, backWidth - <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//画字体</span></span><br><span class="line">    <span class="built_in">putText</span>(backImg, <span class="string">&quot;Maxwi.com&quot;</span>, org, rng.<span class="built_in">uniform</span>(<span class="number">0</span>, <span class="number">8</span>), rng.<span class="built_in">uniform</span>(<span class="number">0</span>, <span class="number">100</span>) * <span class="number">0.05</span> + <span class="number">0.1</span>, <span class="built_in">randomColor</span>(rng), rng.<span class="built_in">uniform</span>(<span class="number">1</span>, <span class="number">10</span>), lineType);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">imshow</span>(<span class="string">&quot;Draw&quot;</span>, backImg);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="imgproc组件"><a href="#imgproc组件" class="headerlink" title="imgproc组件"></a>imgproc组件</h2><p>手动图像处理功能。包括图像的基本处理、变换、轮廓提取、图像分割与修复、直方图与匹配<br><a target="_blank" rel="noopener" href="http://docs.opencv.org/3.0-last-rst/doc/tutorials/imgproc/table_of_content_imgproc/table_of_content_imgproc.html">http://docs.opencv.org/3.0-last-rst/doc/tutorials/imgproc/table_of_content_imgproc/table_of_content_imgproc.html</a><br><strong>平滑处理(smoothing)</strong><br>可以用来对图像降噪，当然也可以模糊图像，是一批带有blur的函数，常用的有以下几个：</p>
<ul>
<li>方框滤波：boxFilter()</li>
<li>均值滤波（领域平均滤波）：blur()，其实是基本的方框滤波</li>
<li>高斯滤波：GaussianBlur()</li>
<li>中值滤波：medianBlur()</li>
<li>双边滤波：bilateraFilter()</li>
</ul>
<p>举例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;opencv2/imgproc/imgproc.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;opencv2/highgui/highgui.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;opencv2/features2d/features2d.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Global Variables</span></span><br><span class="line"><span class="type">int</span> DELAY_BLUR = <span class="number">500</span>;</span><br><span class="line"><span class="type">int</span> MAX_KERNEL_LENGTH = <span class="number">31</span>;</span><br><span class="line"></span><br><span class="line">Mat src;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Function headers</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">display_dst</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* winname, <span class="type">const</span> Mat&amp; img, <span class="type">int</span> delay, <span class="type">int</span> i)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* function main</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Mat dst_blur, dst_ga, dst_me, dst_bi;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Load the source image</span></span><br><span class="line">    src = <span class="built_in">imread</span>(<span class="string">&quot;F:\\lena.jpg&quot;</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">imshow</span>(<span class="string">&quot;Original&quot;</span>, src);</span><br><span class="line"></span><br><span class="line">    dst_blur = src.<span class="built_in">clone</span>();</span><br><span class="line">    dst_ga = src.<span class="built_in">clone</span>();</span><br><span class="line">    dst_me = src.<span class="built_in">clone</span>();</span><br><span class="line">    dst_bi = src.<span class="built_in">clone</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; MAX_KERNEL_LENGTH; i = i + <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">blur</span>(src, dst_blur, <span class="built_in">Size</span>(i, i), <span class="built_in">Point</span>(<span class="number">-1</span>, <span class="number">-1</span>));</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">display_dst</span>(<span class="string">&quot;blur&quot;</span>, dst_blur, DELAY_BLUR, i) != <span class="number">0</span>) &#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; MAX_KERNEL_LENGTH; i = i + <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">GaussianBlur</span>(src, dst_ga, <span class="built_in">Size</span>(i, i), <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">display_dst</span>(<span class="string">&quot;GaussianBlur&quot;</span>, dst_ga, DELAY_BLUR, i) != <span class="number">0</span>) &#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; MAX_KERNEL_LENGTH; i = i + <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">medianBlur</span>(src, dst_me, i);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">display_dst</span>(<span class="string">&quot;medianBlur&quot;</span>, dst_me, DELAY_BLUR, i) != <span class="number">0</span>) &#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; MAX_KERNEL_LENGTH; i = i + <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">bilateralFilter</span>(src, dst_bi, i, i * <span class="number">2</span>, i / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">display_dst</span>(<span class="string">&quot;bilateralFilter&quot;</span>, dst_bi, DELAY_BLUR, i) != <span class="number">0</span>) &#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* @function display_dst</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">display_dst</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* winname, <span class="type">const</span> Mat&amp; img, <span class="type">int</span> delay, <span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">imshow</span>(winname, img);</span><br><span class="line">    <span class="keyword">if</span> (i &lt; MAX_KERNEL_LENGTH)</span><br><span class="line">        <span class="built_in">waitKey</span>(delay);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">waitKey</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h2 id="highgui组件"><a href="#highgui组件" class="headerlink" title="highgui组件"></a>highgui组件</h2><p>读写图像及视频文件、如何使用内建的用户界面库<br><a target="_blank" rel="noopener" href="http://docs.opencv.org/3.0-last-rst/doc/tutorials/highgui/table_of_content_highgui/table_of_content_highgui.html">http://docs.opencv.org/3.0-last-rst/doc/tutorials/highgui/table_of_content_highgui/table_of_content_highgui.html</a></p>
<h2 id="calib3d组件"><a href="#calib3d组件" class="headerlink" title="calib3d组件"></a>calib3d组件</h2><p>相机校正及三维信息重建<br><a target="_blank" rel="noopener" href="http://docs.opencv.org/3.0-last-rst/doc/tutorials/calib3d/table_of_content_calib3d/table_of_content_calib3d.html">http://docs.opencv.org/3.0-last-rst/doc/tutorials/calib3d/table_of_content_calib3d/table_of_content_calib3d.html</a></p>
<h2 id="feature2d组件"><a href="#feature2d组件" class="headerlink" title="feature2d组件"></a>feature2d组件</h2><p>主要用于触点检测，边缘检测等<br><a target="_blank" rel="noopener" href="http://docs.opencv.org/3.0-last-rst/doc/tutorials/features2d/table_of_content_features2d/table_of_content_features2d.html">http://docs.opencv.org/3.0-last-rst/doc/tutorials/features2d/table_of_content_features2d/table_of_content_features2d.html</a></p>
<h2 id="video组件"><a href="#video组件" class="headerlink" title="video组件"></a>video组件</h2><p>主要用于对视频流的处理算法，可以进行运动提取、目标跟踪等<br><a target="_blank" rel="noopener" href="http://docs.opencv.org/3.0-last-rst/doc/tutorials/video/table_of_content_video/table_of_content_video.html">http://docs.opencv.org/3.0-last-rst/doc/tutorials/video/table_of_content_video/table_of_content_video.html</a></p>
<h2 id="objdetect组件"><a href="#objdetect组件" class="headerlink" title="objdetect组件"></a>objdetect组件</h2><p>进行目标检测<br><a target="_blank" rel="noopener" href="http://docs.opencv.org/3.0-last-rst/doc/tutorials/objdetect/table_of_content_objdetect/table_of_content_objdetect.html">http://docs.opencv.org/3.0-last-rst/doc/tutorials/objdetect/table_of_content_objdetect/table_of_content_objdetect.html</a></p>
<h2 id="ml组件：Machine-Learning"><a href="#ml组件：Machine-Learning" class="headerlink" title="ml组件：Machine Learning"></a>ml组件：Machine Learning</h2><p>opencv在机器学习中的使用<br><a target="_blank" rel="noopener" href="http://docs.opencv.org/3.0-last-rst/doc/tutorials/ml/table_of_content_ml/table_of_content_ml.html">http://docs.opencv.org/3.0-last-rst/doc/tutorials/ml/table_of_content_ml/table_of_content_ml.html</a></p>
<h2 id="photo组件"><a href="#photo组件" class="headerlink" title="photo组件"></a>photo组件</h2><p>使用opencv进行高级图像处理<br><a target="_blank" rel="noopener" href="http://docs.opencv.org/3.0-last-rst/doc/tutorials/photo/table_of_content_photo/table_of_content_photo.html">http://docs.opencv.org/3.0-last-rst/doc/tutorials/photo/table_of_content_photo/table_of_content_photo.html</a></p>
<h2 id="gpu模块"><a href="#gpu模块" class="headerlink" title="gpu模块"></a>gpu模块</h2><p>使用GPU加速计算机视觉<br><a target="_blank" rel="noopener" href="http://docs.opencv.org/3.0-last-rst/doc/tutorials/gpu/table_of_content_gpu/table_of_content_gpu.html">http://docs.opencv.org/3.0-last-rst/doc/tutorials/gpu/table_of_content_gpu/table_of_content_gpu.html</a></p>
<h2 id="opencv在iOS中的应用"><a href="#opencv在iOS中的应用" class="headerlink" title="opencv在iOS中的应用"></a>opencv在iOS中的应用</h2><p><a target="_blank" rel="noopener" href="http://docs.opencv.org/3.0-last-rst/doc/tutorials/ios/table_of_content_ios/table_of_content_ios.html">http://docs.opencv.org/3.0-last-rst/doc/tutorials/ios/table_of_content_ios/table_of_content_ios.html</a></p>
<h2 id="OpenCV-Viz模块"><a href="#OpenCV-Viz模块" class="headerlink" title="OpenCV Viz模块"></a>OpenCV Viz模块</h2><p>3D虚拟空间模块<br><a target="_blank" rel="noopener" href="http://docs.opencv.org/3.0-last-rst/doc/tutorials/viz/table_of_content_viz/table_of_content_viz.html">http://docs.opencv.org/3.0-last-rst/doc/tutorials/viz/table_of_content_viz/table_of_content_viz.html</a></p>

    </div>

    
    
    
        

  <div class="followme">
    <p>Welcome to my other publishing channels</p>

    <div class="social-list">

        <div class="social-item">
          <a target="_blank" class="social-link" href="/atom.xml">
            <span class="icon">
              <i class="fa fa-rss"></i>
            </span>

            <span class="label">RSS</span>
          </a>
        </div>
    </div>
  </div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/OpenCV/" rel="tag"># OpenCV</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2016/12/05/opencv-windows-env/" rel="prev" title="Windows下OpenCV与VS开发环境配置">
      <i class="fa fa-chevron-left"></i> Windows下OpenCV与VS开发环境配置
    </a></div>
      <div class="post-nav-item">
    <a href="/2016/12/23/cmake-tutorial/" rel="next" title="CMake简单教程">
      CMake简单教程 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="gitalk-container"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B3%E4%BA%8E%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE"><span class="nav-number">1.</span> <span class="nav-text">关于环境配置</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80%E4%BA%9B%E5%85%A5%E9%97%A8%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0"><span class="nav-number">2.</span> <span class="nav-text">一些入门常用函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97"><span class="nav-number">3.</span> <span class="nav-text">核心模块</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%87%BD%E6%95%B0"><span class="nav-number">3.1.</span> <span class="nav-text">常用的数据类型和函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%BE%E5%83%8F%E8%A1%A8%E7%A4%BA"><span class="nav-number">3.2.</span> <span class="nav-text">图像表示</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#imgproc%E7%BB%84%E4%BB%B6"><span class="nav-number">4.</span> <span class="nav-text">imgproc组件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#highgui%E7%BB%84%E4%BB%B6"><span class="nav-number">5.</span> <span class="nav-text">highgui组件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#calib3d%E7%BB%84%E4%BB%B6"><span class="nav-number">6.</span> <span class="nav-text">calib3d组件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#feature2d%E7%BB%84%E4%BB%B6"><span class="nav-number">7.</span> <span class="nav-text">feature2d组件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#video%E7%BB%84%E4%BB%B6"><span class="nav-number">8.</span> <span class="nav-text">video组件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#objdetect%E7%BB%84%E4%BB%B6"><span class="nav-number">9.</span> <span class="nav-text">objdetect组件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ml%E7%BB%84%E4%BB%B6%EF%BC%9AMachine-Learning"><span class="nav-number">10.</span> <span class="nav-text">ml组件：Machine Learning</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#photo%E7%BB%84%E4%BB%B6"><span class="nav-number">11.</span> <span class="nav-text">photo组件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#gpu%E6%A8%A1%E5%9D%97"><span class="nav-number">12.</span> <span class="nav-text">gpu模块</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#opencv%E5%9C%A8iOS%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8"><span class="nav-number">13.</span> <span class="nav-text">opencv在iOS中的应用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#OpenCV-Viz%E6%A8%A1%E5%9D%97"><span class="nav-number">14.</span> <span class="nav-text">OpenCV Viz模块</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="blueyi"
      src="/images/default_avatar.jpg">
  <p class="site-author-name" itemprop="name">blueyi</p>
  <div class="site-description" itemprop="description">心怀善意，虛怀若谷！</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">104</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">26</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">68</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/blueyi" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;blueyi" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="http://maxwi.com/" title="http:&#x2F;&#x2F;maxwi.com" rel="noopener" target="_blank">Maxwi</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2014 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">blueyi</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="Symbols count total">750k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="Reading time total">11:22</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/pjax/pjax.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/lozad@1/dist/lozad.min.js"></script>

<script src="/js/utils.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>

  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  
  <script data-pjax>
    (function(){
      var canonicalURL, curProtocol;
      //Get the <link> tag
      var x=document.getElementsByTagName("link");
		//Find the last canonical URL
		if(x.length > 0){
			for (i=0;i<x.length;i++){
				if(x[i].rel.toLowerCase() == 'canonical' && x[i].href){
					canonicalURL=x[i].href;
				}
			}
		}
    //Get protocol
	    if (!canonicalURL){
	    	curProtocol = window.location.protocol.split(':')[0];
	    }
	    else{
	    	curProtocol = canonicalURL.split(':')[0];
	    }
      //Get current URL if the canonical URL does not exist
	    if (!canonicalURL) canonicalURL = window.location.href;
	    //Assign script content. Replace current URL with the canonical URL
      !function(){var e=/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi,r=canonicalURL,t=document.referrer;if(!e.test(r)){var n=(String(curProtocol).toLowerCase() === 'https')?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif";t?(n+="?r="+encodeURIComponent(document.referrer),r&&(n+="&l="+r)):r&&(n+="?l="+r);var i=new Image;i.src=n}}(window);})();
  </script>




  
<script src="/js/local-search.js"></script>













    <div id="pjax">
  

  

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css">

<script>
NexT.utils.loadComments(document.querySelector('#gitalk-container'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID    : '0f8243eb2c8b2207980f',
      clientSecret: 'd159633a33519d3b7a48b0ca729032f7d1f38a41',
      repo        : 'notes',
      owner       : 'blueyi',
      admin       : ['blueyi'],
      id          : '8ca259f1e0c57cd40f8577e31fa9fdd9',
        language: '',
      distractionFreeMode: true
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
});
</script>

    </div>
</body>
</html>
